- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_0 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 1;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_1 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 2;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_2 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 3;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_3 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 4;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_4 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 5;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_5 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 6;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_6 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 7;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_7 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 8;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_8 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 9;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the variable type of `count` from `reg` to `wire` in the Verilog module.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the module name from `top` to `blinker_module`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port from `led` to `led_out`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset condition from `if(RST)` to `if(!RST)` (active-low reset).
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output signal width to [3:0] instead of [7:0].
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an enable (`EN`) input signal and only increment `count` when `EN` is high.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the input port name from `CLK` to `clk_in`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the reset condition `if(RST)` with `if(!RST)`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the output port width from [7:0] to [3:0].
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the parameter `DATAWID` to `WIDTH`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Save the generated Verilog to `generated.v` instead of printing.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a new input port named `EN` (Enable signal) to the module.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the module from `top` to `counter_led`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the output port `led` to `out_led`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the counter increment with a decrement operation.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the always block sensitivity list to use `negedge CLK`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the output assignment to use only the lower 4 bits of `count` instead of 8 bits.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset logic to the always block by making it sensitive to both posedge CLK and posedge RST.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the `count` register to be signed.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Declare the `led` output as a `reg` instead of a wire and assign it inside the always block.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the `count` register to `counter` throughout the code.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the LED output assignment to use `count[0:7]` (little endian style).
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a clock enable (`CE`) input signal and update logic to increment `count` only when `CE` is high.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `initial` block to initialize `count` to 0.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Use a conditional operator to assign `led = RST ? 8'h00 : count[7:0];`
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset signal to active-low (`nRST`) and update the logic accordingly.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a synthesis directive comment before the `always` block.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Replace the `DATAWID` parameter with a `localparam`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Remove `DATAWID` and use a fixed bit width of 8 directly in count and assign expressions.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a comment header at the top describing the module's functionality.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the sensitivity list to trigger on the negative edge of the clock.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the counter increment from `+1` to `+2`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add an `EN` input signal to enable counting only when high.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Reduce the output port `led` width from 8 bits to 4 bits.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Rename the internal `count` signal to `counter` throughout the module.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the reset logic to active-low (trigger when RST == 0).
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add a parameter `INCR` to configure how much to increment `count`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Add asynchronous reset handling using sensitivity list with both CLK and RST.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Modify the assignment to output the full `count` value directly to `led`.
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule
- prompt: |-
    Given the following Verilog code:

    module top #
    (
      parameter DATAWID = 32
    )
    (
      input CLK,
      input RST,
      output [7:0] led
    );

      reg [DATAWID-1:0] count;
      assign led = count[DATAWID-1:DATAWID-8];

      always @(posedge CLK) begin
        if(RST) begin
          count <= 0;
        end else begin
          count <= count + 1;
        end
      end

    endmodule

    Change the width of `count` to be a fixed 8-bit register (not based on `DATAWID`).
  code: |
    module sample_module_9 #
    (
      parameter WIDTH = 16
    )
    (
      input wire clk,
      input wire rst,
      input wire en,
      output wire [WIDTH-1:0] out
    );

      reg [WIDTH-1:0] counter;

      always @(posedge clk) begin
        if (rst)
          counter <= 0;
        else if (en)
          counter <= counter + 10;
      end

      assign out = counter;

    endmodule

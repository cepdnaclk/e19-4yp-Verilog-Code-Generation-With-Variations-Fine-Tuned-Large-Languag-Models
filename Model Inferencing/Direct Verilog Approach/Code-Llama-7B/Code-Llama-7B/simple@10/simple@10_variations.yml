- code: |-
    // Create a module with one input and one output that behaves like a bit
    // module wire_assign( input in, output out );
    module wire_assign_task( input bit in, output bit out );
        // assign out to in
        assign out = in;
    endmodule
    ### Example Usage:
    Assign a bit vector input variable and output variable to the module wire_assign_task and assign the output to the input. Then print the value of the output variable.
    
        bit[31:0] in_vector, out_vector;
        wire_assign_task in_wire, out_wire;
    
        in_vector = 32'h00000003;
        out_vector = 32'h00000000;
    
        assign in_wire = in_vector;
        assign out_wire = out_vector;
    
        initial begin
            $display("Value of the output vector after assigning the bit vector to the input and output is: %b\n", out_wire);
            // print the value of output_vector
        end
    ### Expected Output:
        Value of the output vector after assigning the bit vector to the input and output is: 00000003
    ### Unit Test:
    The following unit tests were written to ensure that this example behaves as specified:
    ```
    `timescale 1ns / 1ps
    
    module wire_assign_task_unit_test;
        // declare a bit vector in_vector input and out_vector output
        bit[31:0] in_vector, out_vector;
        wire_assign_task in_wire, out_wire;
    
        initial begin
            // Test the input and output assignment by assigning a value to the in_vector
            // and print its output value to the out_wire
            in_vector = 32'h00000003;
            out_vector = 32'h00000000;
            assign in_wire = in_vector;
            assign out_wire = out_vector;
    
            $display("Value of the output vector after assigning the bit vector to the input and output is: %b\n", out_

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input bit in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Run on FPGA:
    Run the modified module on the FPGA by creating a test bench module that instantiates the modified wire_assign module.
    ### Experiment:
    1. Change the type of the input in from bit to wire to see the different between two types
    ### Conclusion:
    // Conclusion:
    The type of the data source of output of a module

- code: |-
    module wire_assign( input in, output out );
        reg f;
        // assign out to in
        assign out = in

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input bit in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Test Benches:
    // Test the module with a simple test bench
    module wire_assign_tb;
        bit in;
        bit out;
        wire_assign dut (.in (in),.out(out) );
    
        initial begin
            // Assert input value
            in = 1'b1;
            // wait 100 ns then deassert
            #(100)
            in = 0;
        end
    endmodule
    ### Expected Result:
    The following waveforms are expected when the input in is set to 1
    ![waveform](../images/wire_assing_1.png)

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input bit in, output out );
        // assign out to in
        assign out = in;
    endmodule

- code: |-
    ```
    module top(input clk, input rst,
               output [7:0] out);
    
        wire_assign assign(.in(in),.out(out));
    
        bit clk_divided = 0;
        wire in = clk_divided;
    
    endmodule
    
    module wire_assign(input [7:0] in, output out);
        assign out = in;
    endmodule
    ```
    ### Simulation Logic
    ![waveform](

- code: |-
    module wire_assign( input in, output logic out );
        // assign out to in
        assign out = in;
    endmodule
    ### Result:
    The new code should pass simulations.

- code: |-
    module wire_assign( input bit in, output logic out );
        // assign out to in
        assign out = in;
    endmodule
    ### Suggested Solution(s):
    There are two ways to modify this code to create a SystemVerilog-style solution:
    1. Convert the input in from wire to bit (lines 2-3)
    2. Replace the input  in = 1 with in = 1'b1 (lines 3-4)
    
    ### Suggested Resource(s):
    * [SVA guide](https://www.intel.com/content/www/us/en/programmable/documentation/ugw/ugw_sva_guide.pdf)
    
    ### Modifications:
    1. Replace "wire" with

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input wire in, output bit out );
        // assign out to in
        assign out = in;
    endmodule
    ### Original Code:
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input wire in, output wire out );
        // assign out to in
        assign out = in;
    endmodule
    
    ### Base Verilog Code:
    // Create a module with one input and one output that behaves like

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input bit in, output logic out );
        // assign out to in
        assign out = in;
    end

- code: |-
    // Verilog code for Problem 4
    module XOR_Gate(
        input A [1:0], B [1:0],
        output Y
    );
        assign Y = A[0] ^ B[0];
    endmodule
    ### Test Bench Code:
    // Test bench for Problem 4
    module XOR_Gate_TB();
        logic [1:0] A, B, Y;
    
        XOR_Gate UUT(
           .A(A),
           .B(B),
           .Y(Y)
        );
    
        initial begin
            A = 2'b00;
            B = 2'b00;
            # 5ns;
            A = 2'b01;
            B = 2'b01;
            # 5ns;
            A = 2'b11;
            B = 2'b00;
            # 5ns;
            A = 2'b00;
            B = 2'b11;
        end
    endmodule
    ### Simulation Result Verification:
    // Simulation Result
    // 
    //    A = 00 B = 00 Y = 0
    // 
    //    A = 01 B = 01 Y = 0
    // 
    //    A = 11 B = 00 Y = 1
    // 
    //    A = 00 B = 11 Y = 1
    ### Discussion:
    The above design is similar to the one implemented in Part 4 of the lab assignment. However, the inputs A and B have been changed to be elements of a 1D logic array with 2 bits. The input port is defined as A [1:0] and the output is defined as Y. The inside operator is used to test the multi-dimensional handling of the verilog syntax.
    
    ## Problem 5:
    ### Base Verilog Code:
    // Verilog code for Problem 5
    module XOR_Gate(
        input A [1:0], B [1:0],
        output Y
    );
        assign Y = A[0] ^ B[0];
    endmodule
    ### Variation Instruction:

- code: |-
    ```verilog
    module AND_Gate(
        input [1:0] A [0:3] [1:0],
        output [1:0] Y [0:3] [1:0]
    );
        assign Y = A & B;
    endmodule
    ```
    ### Testbench Code:
    ```verilog
    module AND_Gate_test;
        logic [1:0] A [0:3] [1:0], B [0:3] [1:0

- code: |-
    ```
    module mux_3to1(input s,
                    input [2:0] [0:1] A,
                    output [2:0] out);
        assign out = s? A[1] : (s? A[0] : A[2]);
    endmodule
    ```
    
    ### Original Problem (Problem 6)
    ### Base Verilog Code:
    // Problem 6
    // Verilog code for Problem 6
    module mux_4to1(input s,
                    input [2:0] in1,
                    input [2:0] in2,
                    input [2:0] in3,
                    input [2:0] in4,
                    output [2:0] out);
        assign out = s? in4 : (s? in3 : (s? in2 : in1));
    endmodule
    ### Variation Instruction:
    Modify the inputs in1, in2, in3, and in4 to be elements of a packed 4D logic-vector array (e.g., logic [1:0] A [0:0] [0:1] [0:2]).

- code: |-
    ```verilog
    module XOR

- code: |-
    ```
    module XOR_Gate(
        input logic [1:0] A [0:3],
        output logic Y
    );
        assign Y = A[0][0] ^ A[1][1] ^ A[2][2] ^ A[3][3];
    endmodule
    ```
    ### Original Code:
    ### Original Test Bench:
    // Test Bench for Problem 4
    module XOR_Gate_TB;
        logic A, B, Y;
        XOR_Gate U0(A, B, Y);
        initial
            begin
                $dumpfile("XOR_Gate.vcd");
                $dumpvars(0, XOR_Gate);
    
                repeat(10)
                    begin
                        A = $random;
                        B = $random;
                        #10;
                    end
                $finish;
            end
    endmodule
    ### Modified Test Bench:
    // Test Bench for Problem 4
    module XOR_Gate_TB;
        logic [1:0] A [0:3];
        logic Y;
        XOR_Gate U0(A, Y);
        initial
            begin
                $dumpfile("XOR_Gate.vcd");
                $dumpvars(0, XOR_Gate);
    
                repeat(10)
                    begin
                        for (integer i = 0; i < 4; i = i + 1) begin
                            A[i] = $random;
                        end
                        #10;
                    end
                $finish;
            end
    endmodule
    ### Original Result:
    ![Original Results](

- code: |-
    ```VHDL
    module XOR_Gate(
        input wire [1:0] A [0:3], B [0:3],
        output wire [1:0] Y [0:3]
    );
        assign Y = A ^ B;
    endmodule
    ```
    ### Testbench
    ```VHDL
    module TEST(
        input [1:0] A [0:3] = '{4'b0001, 4'b0010, 4'b0011, 4'b0100},
        input [1:0] B [0:3] = '{4'b0001, 4'b0010, 4'b0011, 4'b0100},
        output [1:0] Y [0:3]
    );
    
        XOR_Gate uut(
           .A(A),
           .B(B),
           .Y(Y)
        );
    endmodule
    
    module test;
        
        TEST test_bench();
        initial begin
            $dumpfile("dump.vcd");
            $dumpvars(1);
            $monitor("%b %b %b", A[0], A[1], A[2]);
            $monitor("%b %b %b", B[0], B[1], B[2]);
            $monitor("%b %b %b", Y[0], Y[1], Y[2]);
            #100 $finish;
        end
        initial begin
            #20 A[0] = 2'b01;
            #20 A[1] = 2'b10;
            #20 A[2] = 2'b

- code: |-
    // Verilog code for Problem 4
    module XOR_Gate(
        input [1:0] A [0:1][0:1],
        output Y
    );
        integer i, j;
        wire w;
        generate
            for (i = 0; i < 2; i = i + 1) begin: n_for
                for (j = 0; j < 2; j = j + 1) begin: n_for
                    assign w[1 - i - j] = A[i][j];
                end: n_for
            end: n_for
        endgenerate
        assign Y = w;
    endmodule
    ### Variation Instruction:
    Mod

- code: |-
    module XOR_Gate_1D(
        input logic A [0:3], B 
    );
        logic Y [0:3];
        assign Y = A ^ B;
        //assign Y = {A[0], A[1], A[2], A[3]} ^ B;
    endmodule
    ### Expected Result:
    A testbench is provided in test.sv using the modified code above. The expected result is

- code: |-
    ```verilog
    module XOR_Gate #(
        parameter WIDTH = 4
    )(
        input logic [WIDTH-1:0] A [WIDTH-1:0] [WIDTH-1:0],
        output logic [WIDTH-1:0] Y [WIDTH-1:0]
    );
        assign Y = A ^ B;
    endmodule
    ```
    ### 4.4) Verilog Code for Problem 5
    ### Base Verilog Code:
    ```verilog
    module Multi_Input_XOR_Gate #(
        parameter WIDTH = 4
    )(
        input logic [WIDTH-1:0] A [WIDTH-1:0],
        input logic [WIDTH-1:0] B [WIDTH-1:0],
        output logic [WIDTH-1:0] Y [WIDTH-1:0]
    );
        assign Y = A ^ B;
    endmodule
    ```
    ### Variation Instruction:
    ### Step 1) Add an additional input C to the input list for this module. Use an inside operator with a fixed 3D range to test multi-dimensional array handling.
    ```verilog
    module Multi_Input_XOR_Gate #(
        parameter WIDTH = 4
    )(
        input logic [WIDTH-1:0] A [WIDTH-1:0],
        input logic [WIDTH-1:0] B [WIDTH-1:0],
        input logic [WIDTH-1:0] C [WIDTH-1:0],
        output logic [WIDTH-1:0] Y [WIDTH-1:0]
    );
        assign Y = A ^ B ^ C;
    endmodule
    ```
    ### Step 2) Add an additional input D to the input list for this module. Use an inside operator with a 4D range to test multi-dimensional array handling.
    ```verilog
    module Multi_Input_XOR_Gate #(
        parameter WIDTH = 4
    )(
        input logic [WIDTH-1:0] A [WIDTH-1:0],
        input logic [WIDTH-1:0] B [WIDTH-1:0],
        input logic [WIDTH-1:0] C [WIDTH-1:0],
        input logic [WIDTH-1:0] D [WIDTH-1

- code: |-
    `include "../../src/structs.svh"
    `include "../../src/defines.svh"
    
    module XOR_Gate_4D(
        input A [1:0][1:0][1:0][1:0],
        output Y
    );
        assign Y = A[0][1][2][3] ^ A[1][2][3][0];
    endmodule
    ### Testbench:
    module XOR_Gate_4D_Test();
        logic [1:0][1:0][1:0][1:0] A;
        logic Y;
        XOR_Gate_4D uut(.A(A),.Y(Y));
        logic [1:0] array [1:0][1:0][1:0][1:0];
        
    
        initial begin
            array[0][0][0][0] = 1'd0;
            array[0][0][0][1] = 1'd0;
            array[0][0][1][0] = 1'd0;
            array[0][0][1][1] = 1'd0;
            array[0][1][0][0] = 1'd0;
            array[0][1][0][1] = 1'd0;
            array[0][1][1][0] = 1'd0;
            array[0][1][1][1] = 1'd0;
            array[1][0][0][0] = 1'd1;
            array[1][0][0][1] = 1'd0;
            array[1][0][1][0] = 1'd0;
            array[1][0][1][1] = 1'd0;
            array[1][1][0][0] = 1'd0;
            array[1][1][0][1] = 1'd1;
            array[1][1][1][0] = 1'd0;
            array[1][1][1][1] = 1'd1;
            for (int i = 0; i <

- code: |-
    module test;
    wire a;
    struct packed {
        wire x;
        wire y;
        wire z;
    } xy_z;
    assign #25 a = 1;
    always begin
        xy_z.x = #10 a;
    end
    endmodule
    ### Original Top-Level Code:
    module test;
    wire a;
    reg x, y, z;
    assign #25 a = 1;
    always begin
        x = #10 a;
    end
    endmodule
    ### Modified Top-Level Code:
    module test;
    wire a;
    struct packed {
        wire x;
        wire y;
        wire z;
    } xy_z;
    assign #25 a = 1;
    always begin
        xy_z.x = #10 a;
    end
    endmodule
    ### Original VerilogCode:
    module test;
    wire a;
    reg x;
    wire [3:0] y;
    wire z;
    wire [1:0] w;
    assign z = 2;
    assign w = 2;
    assign #25 a = 1;
    assign #25 y = {c, 1'b0};
    always begin
        x = #10 a;
    end
    endmodule
    ### Modified VerilogCode:
    module test;
    wire a;
    struct packed {
        wire x;
        wire [3:0] y;
        wire z;
        wire [1:0] w;
    } xy_z;
    assign z = 2;
    assign w = 2;
    assign #25 a = 1;
    assign #25 xy_z.y = {c, 1'b0};
    always begin
        xy_z.x = #10 a;
    end
    endmodule
    ### Original Top-Level Code:
    module test;
    wire a;
    reg x;
    wire [3:0] y;
    wire z;
    wire [1:0] w;
    assign z = 2;
    assign w = 2;
    assign #25 a = 1;
    assign #25 y = {c, 1'b0};
    always begin
        x = #1

- code: |-
    #### Option 1:
    
    ```verilog
    //wire [1:0] a;
    //wire [1:0] b;
    //wire [1:0] carry;
    //wire [1:0] sum;
    //wire [1:0] d;
    //assign b = MULTIPLIER;
    //wire [1:0] c;
    //assign c = MULTIPLIER;
    //assign d = a + MULTIPLIER;
    //assign sum = a + b;
    //assign carry = a + d;
    
    // replace with below
    
    reg [1:0] a;
    reg [1:0] b;
    reg [1:0] carry;
    reg [1:0] sum;
    reg [1:0] d;
    assign b = MULTIPLIER;
    reg [1:0] c;
    assign c = MULTIPLIER;
    assign d

- code: |-
    module test;
    wire a;
    struct pack_s {
        wire x;
        wire y;
        wire z;
    } ps;
    assign #25 a = 1;
    always begin
        ps = pack_s{ #10 a, #2 a, #3 a };
    end
    endmodule
    ### Resulting Verilog Code:
    module test;
    wire a;
    struct pack_s {
        wire x;
        wire y;
        wire z;
    } ps;
    assign #25 a = 1;
    always begin
        ps = pack_s{ #10 a, #2 a, #3 a };
    end
    endmodule
    
    ### Base Verilog Code:
    module test;
    wire a;
    reg x, y, z;
    assign #25 a = 1;
    always begin
        x = #10 a;
    end
    endmodule
    ### Variation Instruction:
    Replace the reg declarations with a packed structure that includes the signals x, y, and z, and modify the assignments accordingly to test packed structure handling. Create a variable of the packed structure type and use it to assign the

- code: |-
    module test;
    wire [29:0] a;
    struct packed {reg x; reg y; reg z;} b;
    assign #25 a = {17'b0, 1'b1, 1'b0, 1'

- code: |-
    module test;
    wire a;
    struct packed {
        reg x;
        reg y;
        reg z;
    } d;
    assign #25 a = 1;
    assign #10 d.y = a;
    endmodule

- code: |-
    ```
    module test;
    wire a;
    struct packed_struct {wire b[3:0]; wire c[3:0]; wire d;} a;
    assign #10 a.b[0] = 1;
    always begin
        a.b[1] = #10 a.b[0];
        a.b[2] = #10 a.b[1];
        a.b[3] = #10 a.b[2];
        a.c[0] = #10 a.b[3];
        a.c[1] = #10 a.c[0];
        a.c[

- code: |-
    module test;
    wire a;
    wire [3:0] x;
    wire [3:0] y;
    wire [3:0] z;
    struct {
        logic x

- code: |-
    module test;
    wire a;
    struct {
        reg x;
        reg y;
        reg z;
    } packed_struct;
    assign #25 a = 1;
    always begin
        #10 packed_struct.x = a;
        packed_struct.y = #10 a;
        packed_struct.z = #10 a;
    end
    endmodule
    ### Result:
    The packed structure is not allowed in a continuous assignment target.
    ### Other Comments:
    The packed structure is not allowed in a continuous assignment target.
    ### Other Infor

- code: |-
    module test2;
    wire a;
    struct packed {bit x, y, z;} w;
    assign #25 a = 1;
    always begin
        w.x = #10 a;
    end
    endmodule
    ### Result of Submission:
    Packed structures support is only provided for simulation and RTL synthesis (not for gate-level synthesis) on

- code: |-
    module test;
    wire a;
    packed struct {
        reg x;
        reg y;
        reg z;
    } p;
    packed struct {
        wire a;
        wire b;
    } q;
    assign #2

- code: |-
    module full_adder (
      output sum,
      output cout,
      input i1,
      input i2,
      input cin
    );
      assign sum = cin ^ (i1 ^ i2);

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output [1:0] sum, cout;
    assign sum[0] = i1 ^ i2 ^ cin;
    assign sum[1] = cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Modified Benchmark:
    To make the module compatible with Verilator, change the parameter from `width` to `WIDTH`.
    Also, change `always @*` to `always_comb` which is a Verilog-2005 construct.
    ### Modified Benchmark:
    ```
    `timescale 1ns/1ps
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin[WIDTH-1:0];
    output sum[WIDTH-1:0], cout;
    
    
    
    assign sum[0] = i1 ^ i2 ^ cin[0];
    assign sum[1] = i1 ^ i2 ^ cin[1];
    assign cout = (i1 & i2) | (cin[0] & (i1 | i2));
    assign cout[1] = cin[1];
    
    
    endmodule
    
    
    ```
    
    ### Benchmark Modifications:
    To make the module compatible with Verilator, change the parameter from `width` to `WIDTH`.
    Also, change `always @*` to `always_comb` which is a Verilog-2005 construct.
    In order to use the bit-sized inputs, the size of the constant should be specified at declaration time.
    ### Benchmark Modifications:
    ```
    `timescale 1ns/1ps
    module full_adder (
      input   logic [WIDTH-1:0] i1,
      input   logic [WIDTH-1:0] i2,
      input   logic [WIDTH-1:0] cin,
      output  logic [WIDTH-1:0] sum,
      output  logic [2:0] cout
    );
    
    
    assign sum[0] = i1 ^ i2 ^ cin[0];
    assign sum[1] = i1 ^ i2 ^ cin[1];
    assign

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Simulation Logs:
    To simulate,
    ```
    cd path/of/base_verilog
    iverilog *.v
    vvp tb_full_adder
    ./a.out
    ```
    ### Testing
    The module is verified by the testbench provided in the test.sv module. To simulate,
    ```
    cd path/of/variant
    iverilog *.v
    vvp tb_full_adder
    ./a.out
    ```
    ### Explanation
    The output cout, in the modified version, is of a different type. This is due to the verilog-2001 specs, in which output data types are by default wires. Thus, to assign a logic vector as an output, it must be explicitly declared a logic type.
    ### Compatibility:
    This modification is compatible with the original code.
    ### Changes:
    |Line Number|Changes Made|
    |---|---|
    |4|Declaring the output cout as a logic instead of wire|
    |12|Assigning the sum as (i1 XOR i2 XOR cin) to compare it with the base code|
    |13|Assigning the cout as (i1 AND i2) OR (cin AND (i1 OR i2))|
    |20|Simulation of the module|
    ### Simulation Result:
    #### base verilog
    ![](https://raw.githubusercontent.com/kusuushizu/HwVerilog/main/hw5/result/base_adder.png)
    #### variant verilog
    ![](https://raw.githubusercontent.com/kusuushizu/HwVerilog/main/hw5/result/var_adder.png)
    
    ## Part C
    ### Base Verilog Code:
    module n_bit_adder(a, b, cin, sum, cout);
    input [10:0] a, b;
    input cin

- code: |-
    ```verilog
    module counter(clock, reset, count);
    input clock, reset;
    output reg [4:0] count;
    always @(posedge clock) begin
        if(reset) begin
            count <= 4'b0;
        end
        else begin
            count <= count + 1'b1;
        end
    end
    endmodule
    ```
    Note that the line `reg [3:0]` has been modified to `reg [4:0]`.
    
    ### Example 3:
    
    ### Base Verilog Code:
    
    ```verilog
    module counter(clock,

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Passed Test:
    Passed (test 1 of 1)
    ### Fixed Verilog Code:
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Test Code:
    module tb();
    logic [3:0] dout;
    
    full_adder uut(
    .i1(din[0]),
    .i2(din[1]),
    .cin(cin),
    .sum(dout[0]),
    .cout(dout[3])
    );
    
    always begin
    din = 4'h5;
    cin = 1'b1;
    #1
    din = 4'hA;
    cin = 1'b0;
    #1
    din = 4'h1;
    cin = 1'b0;
    #10
    $display("Passed");
    $stop;
    end
    endmodule
    ### Test Output:
    Passed
    ### Notes:
    In general, the use of the logic data type is preferred over the wire data type. In fact, using any data type other than the logic data type is an error because it confuses the synthesizer. The syntax error is only detected during the simulation. 
    The use of the logic data type is also required for the vector data types. You are not allowed to use the wire data type as the data type for any of your vectors.
    #### Changes to this Lab:
    You are not required to use the $rstn signal at the beginning of the lab. The reset signal is an output from the processor, and you only need to give it a default value if you have a clock cycle that runs before the processor starts. The processor will start at the beginning of the simulation, so this problem does

- code: |-
    module top_mod(a_in, b_in, cin, sum, cout);
    input [3:0] a_in, b_in, cin;
    output [3:0] sum, cout;
    full_adder fa0(a_in[3], b_in[3], cin, sum[3], cout);
    full_adder fa1(a_in[

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Tested Code:
    module test_adder_logic;
    
    logic [3:0] i1, i2;
    logic cin, sum, cout;
    logic [3:0] t_sum, t_cout;
    
    initial begin
        i1 = 1;
        i2 = 0;
        cin = 0;
        #1;
        assert (sum == t_sum) else begin
            $error("Error: sum");
            $stop;
        end
        assert (cout == t_cout) else begin
            $error("Error: cout");
            $stop;
        end
        i1 = 1;
        i2 = 0;
        cin = 1;
        #1;
        assert (sum == t_sum) else begin
            $error("Error: sum");
            $stop;
        end
        assert (cout == t_cout) else begin
            $error("Error: cout");
            $stop;
        end
        i1 = 1;
        i2 = 1;
        cin = 0;
        #1;
        assert (sum == t_sum) else begin
            $error("Error: sum");
            $stop;
        end
        assert (cout == t_cout) else begin
            $error("Error: cout");
            $stop;
        end
        i1 = 1;
        i2 = 1;
        cin = 1;
        #1;
        assert (sum == t_sum) else begin
            $error("Error: sum");
            $stop;
        end
        assert (cout == t_cout) else begin
            $error("Error: cout");
            $stop;
        end
        i1 = 1;
        i2 = 1;
        cin = 0;
        #1;
        assert (sum == t_sum) else

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Simulation:
    #### Without Modification
    ![image](https://user-images.githubusercontent.com/11408159/28170284-5c1883e6-683f-11e7-935e-1f1799284476.png)
    
    #### With Modification
    ![image

- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output logic sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Modification Description:
    Changed the data type of the output to logic.
    ### Testbench Code:
    module full_adder_testbench;
    wire cin, sum, cout;
    wire i0, i1, i2;
    initial begin
        cin = 0;
        i0 = 0;
        i1 = 0;
        i2 = 0;
        #5;
        cin = 0;
        i0 = 0;
        i1 = 1;
        i2 = 0;
        #5;
        cin = 0;
        i0 = 1;
        i1 = 0;
        i2 = 0;
        #5;
        cin = 0;
        i0 = 1;
        i1 = 1;
        i2 = 0;
        #5;
        cin = 1;
        i0 = 0;
        i1 = 0;
        i2 = 0;
        #5;
        cin = 1;
        i0 = 0;
        i1 = 1;
        i2 = 0;
        #5;
        cin = 1;
        i0 = 1;
        i1 = 0;
        i2 = 0;
        #5;
        cin = 1;
        i0 = 1;
        i1 = 1;
        i2 = 0;
        #5;
        cin = 0;
        i0 = 0;
        i1 = 0;
        i2 = 1;
        #5;
        cin = 0;
        i0 = 0;
        i1 = 1;
        i2 = 1;
        #5;
        cin = 0;
        i0 = 1;
        i1 =

- code: |-
    module testbench ();
    generate struct data begin
    rand struct data_member begin
    rand data_mem[data_size] begin
    rand [31:0] rand_member;
    end
    end
    end
    endmodule
    ### Trace:
    - RTL view
      - The code is changed with a struct inside a struct.
      - The value of the rand member is not shown.
    - Waveform
      - The output waveform shows the same value for the random member.
      - The value of the rand member is not random.
    - Coverage

- code: |-
    module testbench;
    struct packed rand struct {
      rand logic x;
    } data;
    endmodule
    
    ### Pass Criteria:
    Verilog compiler must report a fatal error if rand cannot be used inside a struct.
    ### Error Log:
    **Error (suppressible): (vlog-2169) near "struct": $randomize is not supported on this type.
          (test_rand_in_struct.v

- code: |-
    module testbench ();
    generate
        struct {rand int data;} myData;
        initial begin
            myData = {};
            randomize(myData.data);
        end
    endgenerate
    endmodule
    ### Test Results:
    To be filled in
    ### Lessons Learned:
    To be filled in
    ### Useful Resources:
    To be filled in
    
    
    ### License:
    Copyright (C) 2021 Eric J. Whitacre
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    ### Release Notes:
    * Pre-alpha, expect things to change.
    * Uses the UVM testbench framework.
    ### Example Usage:
    * Use the provided Makefile which will build the testbench in an executable called run_uvm_testbench
    * run_uvm_testbench requires a path to a data.h file. Make sure the data.h file matches your testbench (e.g. if you changed the testbed type, it might not match anymore)
    ```
    ./run_uvm_testbench test/data.h
    ```
    ### To Do:
    * Finish up the test cases, clean up, and document
    * Make documentation
    * Setup continuous

- code: |-
    module testbench ();
    generate struct begin

- code: |-
    module testbench ();
    struct { struct { rand int i; } rand_data; } data;
    generate data;
    process data;
    endmodule
    ### Injected Procedures:
    def rand::int;
    enddef
    ### Expected Output:
    ### Base Verilog Code:
    module testbench ();
    generate data;
    process data;
    endmodule
    ### Variation Instruction:
    Replace the data construct with a struct containing

- code: |-
    module testbench ();
        typedef struct {
            logic rand;
        } data;
        generate data;
        process data;
    endmodule
    ### Expected Output:
    The module will generate the struct data inside the `generate

- code: |-
    module testbench ();
    string data = "data";
    initial begin
      $display("Rand is %b", data[0]);
    end
    endmodule
    ### Expected Output:
    
    Rand is 1000
    ### Pass Criteria:
    
    No errors on elaboration
    ### Fail Criteria:
    
    Generate errors: _testbench.v:4: error: unknown generate item data_
    
    ## 5.8.6
    ### Test Scenario:
    ### Base Verilog Code:
    module testbench ();
    generate data;
    process data;
    endmodule
    ### Variation Instruction

- code: |-
    module testbench ();
    struct struct_random {
        rand bit [3:0] data;
    };
    bit [3:0] data;
    initial begin
        data = 4'b0;
    end
    struct_random rand_data;
    initial begin
        rand_data = '{data: data};
        initial begin
            repeat (50) begin
                @ (posedge clk);
                # 10;
                $display ("Rand Data: %b",rand_data.data);
            end
            $finish;
        end
    end
    endmodule
    ### Pass Criteria:
    Error free.
    ### Comments:
    This test has been verified on Altera Quartus II and Xilinx ISE 14.5.

- code: |-
    module testbench ();
        struct {
            logic [3:0] rand;
        } data;
    generate data;
    process data;
    endmodule
    ### Expected Output:
    ```

- code: |-
    module testbench ();
    struct {
    	rand logic [7:0] data;
    } data_t;
    data_t dut;
    initial begin
    	$dumpfile("test.vcd");
    	$dumpvars(0, testbench);

- code: |-
    module tst_dff_pbeh (logic di,clk, do);
      logic do; wire do;
      dff_p d1(do,di,clk);
      initial begin clk=0; di=1'b0; #35 $stop; end
      always #3 clk=~clk;
      always #5 di=~di;
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Comment:
    Due to the use of non-blocking assignment, the order of assignments in the initial block is changed, leading to
    a simulation failure with the base code. The change to an implicit reg type fixes this issue.
    ### Simulation Results:
    ```log
    sim:/tst_dff_pbeh/inst.d1 B=1 #10
    sim:/tst_dff_pbeh/inst.d1 Q=x
    sim:/tst_dff_pbeh/inst.d1 CLK=1 #20
    sim:/tst_dff_pbeh/inst.d1 Q=x
    sim:/tst_dff_pbeh/inst.d1 CLK=0 #30
    sim:/tst_dff_pbeh/inst.d1 Q=0
    sim:/tst_dff_pbeh/inst.d1 CLK=1 #35
    sim:/tst_dff_pbeh/inst.d1 Q=0
    sim:/tst_dff_pbeh/inst.d1 CLK=0 #60
    sim:/tst_dff_pbeh/inst.d1 Q=0
    sim:/tst_dff_pbeh/inst.d1 CLK=1 #65
    sim:/tst_dff_pbeh/inst.d1 Q=1
    sim:/tst_dff_pbeh/inst.d1 CLK=0 #80
    sim:/tst_dff_pbeh/inst.d1 Q=1
    sim:/tst_dff_pbeh/inst.d1 CLK=1 #85
    sim:/t

- code: |-
    module tst_dff_pbeh();
      logic [0:0] di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Expected Result:
    The test should compile and the output should be similar to the following.
    $ vlog tst_dff.v tst_dff_pbeh.v +incdir+../source ;vvp tst_dff_pbeh.vvp
                        clk=1'b0, di=1'b0, do=1'b0
                        clk=1'b1, di=1'b0, do=1'b0
                        clk=1'b0, di=1'b1, do=1'b0
                        clk=1'b1, di=1'b1, do=1'b0
                        clk=1'b0, di=1'b0, do=1'b1
                        clk=1'b1, di=1'b0, do=1'b1
                        clk=1'b0, di=1'b1, do=1'b1
                        clk=1'b1, di=1'b1, do=1'b1
                        clk=1'b0, di=1'b0, do=1'b0
                        clk=1'b1, di=1'b0, do=1'b

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p_beh d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Translated Verilog Code:
    module tst_dff_pbeh();
      logic di,clk; wire  ___o_do; // synthesis syn_keep
      dff_p_beh  d1( ___o_do, di, clk); // Instantiate DFF with path delay
      assign do = ___o_do; // synthesis syn_keep
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Generated SystemVerilog Code:
    module

- code: |-
    module tst_dff_pbeh();
      logic [1:0] di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Simulation Result:
    Notice that the data toggle is not visible in the output.
    $ ghdl -r tst_dff_pbeh
    ghdl -r tst_dff_pbeh
    clk=0, di=x, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do=0
    clk=1, di=1, do=1
    clk=1, di=0, do=1
    clk=0, di=0, do=0
    clk=0, di=1, do

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### SystemVerilog Code:
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    
    ### In-depth Analysis of Different Testbench Sources in SystemVerilog and Verilog
    ### Base Testbench 1:
    module tst_dff_pbeh();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
      initial #15 $fmonitor("clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Variation Testbench 2:
    module

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do; // Change reg declarations to logic
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Error Message:
    ERROR: [VRFC 10-393] Verilog-2005 does not support "logic".
          (tst_dff_pbeh.sv,2)
        1  module tst_dff_pbeh();
        2    logic di,clk; wire do; // Change reg declarations to logic
        3    dff_p d1(do,di,clk); // Instantiate DFF with path delay
        4    initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
        5    always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
    tst_dff_pbeh.sv, line 2. Use -sv_extended if you want to support SystemVerilog
        6    always #5 di=~di; // Toggle data
        7    initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
        8  endmodule
          (tst_dff_pbeh.sv,3)
        1  module tst_dff_pbeh();
        2    logic di,clk; wire do; // Change reg declarations to logic
        3    dff_p d1(do,di,clk); // Instantiate DFF with path delay
        4    initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Compiler Notes:
    `ghdl -a --std=08 tst_dff_pbeh.v; ghdl -r --std=08 tst_dff_pbeh --vcd=tst_dff_pbeh.vcd`
    ghdl:error: [IOcomp:0296] tst_dff_pbeh.v:11: variable di of type logic is not declared as reg
    ghdl:error: [IOcomp:0296] tst_dff_pbeh.v:12: variable clk of type logic is not declared as reg
    ### Synthesized VHDL Source Code:
    module dff_p
    (
    	clk,
    	di,
    	do
    );
    	port (
    		clk : in std_logic;
    		di : in std_logic;
    		do : out std_logic
    	);
    begin
    	process (clk)
    	begin
    		if clk'event and clk = '1' then
    			do <= di;
    		end if;
    	end process;
    end;
    \end{code}
    
    Comment: It would seem that this is a warning about `ghdl` not being able to analyse the file which contains the module.  Can you please post the entire content of the file?
    
    Comment: I've added the complete code from the book for this example.
    
    Comment: What is the command you use to compile this? Why aren't you using a [standalone VHDL testbench](https://www.

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Modification Results:
    Testbench runs and reports:
    ```
    ERROR: tst_dff_pbeh:/tst_dff_pbeh:6: Module 'dff_p' was declared as a non-logic type, but instantiated as a logic type.
    ```
    ### RTL Code:
    ```
    module dff_p(out,din,clk)
      output out;
      input din,clk;
      wire din; // Create a wire to hold din
      always @(posedge clk)
        out <= din;
    endmodule
    ```
    ### Original Simulation Result:
    ```
        tst_dff_pbeh clk=1, di=1, do=x
            6 clk=0, di=1, do=x
           12 clk=1, di=1, do=x
           18 clk=0, di=1, do=x
           24 clk=1, di=1, do=x
           30 clk=0, di=1, do=x
           36 clk=1, di=1, do=x
           42 clk=0, di=1, do=x
           48 clk=1, di=1, do=x
           54 clk=0, di=1, do=x
           60 clk=1, di=1, do=x
           66 clk=0, di=1, do=x
           72 clk=1, di=1, do=x
           78 clk

- code: |-
    module tst_dff_pbeh();
      logic di,clk; wire do; // Change to logic here
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Simulation Log:
    0 clk=0, di=0, do=x
    1 clk=1, di=0, do=0
    2 clk=0, di=0, do=0
    3 clk=1, di=0, do=x
    4 clk=0, di=0, do=0
    5 clk=1, di=0, do=0
    6 clk=0, di=0, do=0
    7 clk=1, di=0, do=0
    8 clk=0, di=0, do=0
    9 clk=1, di=0, do=0
    10 clk=0, di=0, do=0
    11 clk=1, di=0, do=0
    12 clk=0, di=0, do=0
    13 clk=1, di=0, do=0
    14 clk=0, di=0, do=0
    15 clk=1, di=0, do=x
    16 clk=0, di=0, do=0
    17 clk=1, di=0, do=0
    18 clk=0, di=0, do=0
    19 clk=1, di=0, do=0
    20 clk=0, di=0, do=0
    21 clk=1, di=0, do=0
    22 clk=0, di=0, do=0
    23 clk=1, di=0, do=x
    24

- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Original Code + Variation: 
    module ALU ( input [7:0] a, b, input pass, add,
    output reg[7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Changelog
    
    date|description|by
    -|-|-
    2020-11-11|First draft|kabir
    2020-11-11|Addition of Variation header and explanation|kabir
    2020-11-11|Added modified code|kabir
    2020-11-11|Added changelog|kabir
    2020-11-11|Added original code with variation|kabir
    2020-11-11|Added original header|kabir
    2020-11-11|Added original code|kabir
    2020-12-12|Added Variation instruction|kabir
    2020-12-12|Added Variation description|kabir
    2020-12-12|Added Variation description|kabir
    2020-12-12|Added Variation description|kabir
    2020-12-12|Added Variation description|kabir

- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu

- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always_ff @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out =

- code: |-
    module ALU (input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Variation Instruction:
    Add some space at the end of the module. This is not necessary but shows how to add spacing.
    ### Modified Code:

- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Modified Verilog Testbench:
    module ALU_TB ();
    
        // Declare instance of ALU
        reg [7:0] a;
        reg [7:0] b;
        reg pass;
        reg add;
        wire [7:0] alu_out;
        ALU alu_i (.a (a),.b (b),.pass (pass),.add (add),.alu_out (alu_out));
    
        // Stimulus for ALU
        initial begin
            $display("Test1: Output should be 13");
            a = 10;
            b =  3;
            pass = 0;
            add = 1;
            #1;
            $display("%d + %d = %d", a, b, alu_out);
            #1;
            $display("Test2: Output should be 9");
            a = 7;
            b = 2;
            pass = 0;
            add = 1;
            #1;
            $display("%d + %d = %d", a, b, alu_out);
            #1;
            $display("Test3: Output should be 7");
            a = 7;
            b = 0;
            pass = 0;
            add = 1;
            #1;
            $display("%d + %d = %d", a, b, alu_out);
            #1;
            $display("Test4: Output should be 9");
            a = 7;
            b = 2;
            pass = 0;
            add = 0;
            #1;
            $display

- code: |-
    module counter( input clk, input rst, output reg[3:0] counter);
    
    initial counter = 4'b1111;
    
    always @(posedge clk)
    begin
    if (rst) counter <= 4'b0000;       // Default output is 0
    else counter <= counter + 1;      // Increment counter
    end
    
    endmodule
    
    ### Base Code:
    module counter( input clk, input rst, output reg[3:0] counter);
    
    always

- code: |-
    module ALU (
    input [7:0] a, b,
    input add_in,
    input pass_in,
    wire [7:0] alu_out);
    wire add;
    wire pass;
    assign add = add_in;
    assign pass = pass_in;
    assign alu_out = 0;
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Variation Instruction:
    Replace alu_out wire with an instance of a signal.
    ### Modified Code:

- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Original Test Bench code:
    module ALU_Test ( );
    reg [7:0] a; reg [7:0] b; wire pass; reg add; reg [7:0] result;
    // Instantiate the Unit Under Test (UUT)
    ALU uut (.a(a),.b(b),.pass(pass),.add(add),.alu_out(result) );
    initial begin
    $dumpfile("ALU.vcd"); $dumpvars(1, ALU_Test);    // Generate VCD
    #5; // Delay = 5 ns
    a = 10; b = 13; pass = 1; add = 1; #5;
    #5; // Delay = 10 ns
    a = 00; b = 23; pass = 0; add = 0; #10;
    #5; // Delay = 15 ns
    a = 12; b = 00; pass = 1; add = 0; #15;
    #5; // Delay = 20 ns
    a = 20; b = 20; pass = 0; add = 1; #25;
    #5; // Delay = 25 ns
    a = 20; b = 20; pass = 1; add = 1; #30;
    #5; // Delay = 30 ns
    a = 20; b = 20; pass = 1; add = 0; #35;
    end
    endmodule
    ### Variation Instruction:
    Replace the old a and b reg types with logic to align with modern signal declaration.
    ### Modified Test Bench

- code: |-
    ```
    // Verilog code
    module reg_test ( input pass, input clk, output [3:0] out );
    // Verilog register declaration
    reg [3:0] i;
    // Verilog wire declaration
    wire [3:0] j;
     
    always @(posedge clk) begin
    if (pass)
        out <= i;
    else
        out <= j;
    end
    
    endmodule
    ```
    ### Ex

- code: |-
    module ALU (a, b, pass, add, alu_out);
    input [7:0] a;
    input [7:0] b;
    input pass;
    input add;
    output logic [7:0] alu_out;
    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0
    endmodule
    ### Testbench:
    module ALU_testbench;
    // Local parameters (constants)
    parameter input_width = 8;
    parameter output_width = 8;
    
    // Inputs
    reg [input_width-1:0] a=0;
    reg [input_width-1:0] b=0;
    reg pass;
    reg add;
    
    // Outputs
    wire [output_width-1:0] alu_out;
    
    // Instantiate the Unit Under Test (UUT)
    // ALU my_alu (a, b, pass, add, alu_out);
    ALU my_alu (a, b, pass, add, alu_out);
    // Test inputs
    initial
    begin
    // Toggle inputs after 100 ns to allow component to stabilize
    #100;
    $dumpfile("alu.vcd");
    $dumpvars;
    pass = 0;
    #100; pass=1;
    end
    // Stimulus
    always
    begin
    #100; a = 1;
    #100; a = 2;
    a = 3;
    end
    endmodule
    ### Simulation:
    ![ScreenShot_1](ScreenShot_1.png)
    ### Discussion:
    Why have you chosen to use a reg instead of a wire as the output?
    regs allow latching, which is when the output of a flip-flop (register) is fed back into the flip-flop's input. In the case of this assignment, the reg alu_out is used as an output only and is not fed back into the circuit as an input.

- code: |-
    module AndOr (output X, Y, input [7:0] A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Output Directory:
    Output directory is the directory where the output files are to be written to. If
    not present, the current directory is taken as the output directory, i.e. the
    cwd.
    ### Output File Name:
    The Output file name is the name of the ver

- code: |-
    module AndOr (output X, Y, input A, B, C);
    bit [7:0] A;
    bit [7:0] B;
    bit [7:0] C;
    bit X;
    bit Y;

- code: |-
    module AndOr (output X, Y, input A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Variation Info:
    The purpose of the verification is to demonstrate the usage of SystemVerilog bit type instead of wire type.
    ### Result Expectation:
    No error due to use of SystemVerilog bit type.
    ### Correct Output:
    No output
    ### Error Output:
    No output
    ### Runtime Error:
    No runtime error
    ### Compilation Error:
    No compilation error
    ### Running Time:
    150ms
    ### Expected Running Time:
    150ms
    ### Code Optimization:
    No optimization
    ### Code Complexity:
    No complexity
    ### Code Design:
    No design
    ### Requirements:
    1. Verilog code written in files verilog_code_1.v and verilog_code_1.v.
    2. Testbench written in file testbench_1.sv.
    3. A batch script file named create_x

- code: |-
    module AndOr (output X, Y, input [1:0] A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Reference Code:
    module AndOr (output X, Y, input [1:0] A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    
    ### Test Case:
    1. Checks to make sure code can synthesize.
    
    ### Pass Criteria:
    Code synthesizes without error.
    
    ### Fail Criteria:
    Code does not synthesize without error.
    
    ### Comments:
    
    ### Requirements Covered:
    - B-1484259
    - B-1219357
    
    ### Covered Issues (in `requirements.txt`):
    - B-1484259
    - B-1219357
    
    ### Tested Modules:
    - `andor.sv` (non-forked)
    
    ### Tested Functional Units:
    - `and`
    - `or`
    
    ### Tested

- code: |-
    module AndOr (output

- code: |-
    module AndOr (output X, Y, input [1:0] A, [1:0] B, [1:0] C, output [1:0] Z);
    assign #10 {X, Z} = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Screens

- code: |-
    module AndOr (output X, Y, input Reg A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Original Code:
    module AndOr (output X, Y, input A, B, C);

- code: |-
    ```
    module AndOr (output X, Y, input [0:0] A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ```
    
    ## Code Preparation Steps
    
    ### Step 1: Create a Project
    
    1. Create an empty project or copy the project from *Project - Create New Project...*.
    2. Copy the code from *Base Verilog Code* to *Variation Instruction* to *Modified Code*.
    
    ### Step 2: Compile the Verilog Code
    
    1. Right click the project and click *Compile*.
    2. Check the *Compile* window for compilation errors.
    
    ### Step 3: Run the Design
    
    1. Create test bench module as shown below.
    2. Right click the test bench module and click *Run*.
    
    ```
    module TestBench();
    AndOr #1 UUT (.A(1'b1),.B(1'b0),.C(1'b1),.X(),.Y());
    initial
    	#10 $finish;
    endmodule
    ```
    
    ### Step 4: Simulation Results
    
    1. Check the simlution results in the *Waveform* window.
    
    ### Step 5: Examine the Modifications
    
    * Open the *

- code: |-
    ```cpp
    module AndOr (output X, Y, input [1:0] A, B, C);
    assign #1

- code: |-
    module AndOr (output X, Y, input [1:0] A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Original ModelSim command line:
    vlib vlib_work
    vmap work vlib_work
    vlog "D:/Documents/GitHub/FPGA-Practice-2021/Digital-Logic-Lab/src/Verilog/AndOr.v"
    vsim -novopt work.AndOr
    add wave -radix hex /AndOr/*
    run -all
    ### Original ModelSim Console Output:
    Error: [Common 17-155] file does not exist: "D:\Documents\GitHub\FPGA-Practice-2021\Digital-Logic-Lab\src\Verilog\AndOr.v"

- code: |-
    module ArrayTest ( input load, clk,
    output reg [7:0] data_out );
    logic [1:0] A [0:3];
    logic B [1:3][2:5];
    always @( posedge clk )
    if ( load ) data_out <= A;
    endmodule
    ### Expected Output:

- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out

- code: |-
    module IR_DV (input logic [7:0] data_in, input logic load, clk,
    output reg [7:0] data_out);
    // Create a 7

- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule
    ### Original Testbench Code:
    module IR_TB ();
    logic [7:0] data_in;
    logic load;
    logic clk;
    wire [7:0] data_out;
    IR u_module (.data_in(data_in),.load(load),.clk(clk),.data_out(data_out) );
    initial begin
    data_in = 8'd11;
    load = 1'b0;
    #5
    load = 1'b1;
    #5
    load = 1'b0;
    #5
    end
    endmodule
    ### Modified Testbench Code:
    module IR_TB ();
    logic [7:0] data_in;
    logic load;
    logic clk;
    wire [7:0] data_out;
    IR u_module (.data_in(data_in),.load(load),.clk(clk),.data_out(data_out) );
    initial begin
    $dumpfile("IR_TB_data.vcd");
    $dumpvars;
    data_in = 8'd11;
    load = 1'b0;
    #5
    load = 1'b1;
    #5
    load = 1'b0;
    #5
    end
    endmodule
    ### Pass/Fail Criteria:
    Passes if there is a 1-by-1 dump of data_in and data_out, which means that a read of data_out should return data_in (8'd11)
    
    # 16.2 Modify the testbench to include an $stop() statement at the end of the last phase of the simulation.
    ### Original Testbench Code:
    module IR_TB ();
    logic [7:0] data_in;
    logic load;
    logic clk;
    wire [7:0] data_out;
    IR u_module (.data_in(data

- code: |-
    module IR_test ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule
    ### Variation Instruction:
    Make module IR_test an interface-based design, and create an instance of that design

- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data

- code: |-
    module IR ( input logic [7:0] A [0:3], input load, clk,
    output reg [2:1] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) begin
    logic [7:0] C [0:3];
    C = A;
    data_out <= C[1] + 1;
    end
    endmodule

- code: |-
    module ALU( input [7:0] A, input [7:0] B, input mode,
    output reg [7:0] sum);
      // Unpacked 1D array
      logic op_valid [1:0];
      // 2D array
      logic op_valid2 [0:4][0:4];
    
      // Inside expression
      logic [1:0] op = A[1:0];

- code: |-
    module IR ( input logic [2:0] data_in, input load, clk, output reg [2:0] data_out ); logic [2:0] A [0:3]; always @(posedge clk) if (load) data_out <= A[data_in]; endmodule
    ### Variation Instructions:
    1.  Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.
    2.  Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.
    3.  Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.
    4.  Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.
    
    ### Result
    The input parameter is a 1D array. The output parameter is a 1D array.
    
    ### Description
    The input parameter is a 1D array. The output parameter is a 1D array.
    
    ### Base Verilog Code:
    module MUL ( input logic [9:0] A [0:3], input logic [9:0] B [0:3], input load, clk, output logic [9:0] S [0:3], output reg [9:0] O [0:3] ); // Declare the variable S (the output) and O (the output) logic-vector arrays as packed-vectors.
    // Compute the output S (the output) by multiplying the inputs A (the input) and B (the input)
    always @( posedge clk )

- code: |-
    module IR ( input logic [

- code: |-
    module Problem10(input [3:0] a, b, output [3:0] diff);
      struct packed{
        logic [3:0] x;
        logic [3:0] y;
        logic [3:0] z;
      }my_struct;
      assign my_struct = a;
      assign diff = (my_struct.x + my_struct.y) + my_struct

- code: |-
    module Problem9(input [3:0] a, b, output [3:0] diff);
          reg [3:0] x;
          reg [3:0] y;
          reg [3:0] z;
       function [3:0] foo;
         input [3:0] a;
         input [3:0] b;
         begin
         if (a > b)
           foo = a;
         else
           foo = b;
         end
       endfunction
        always @(*) begin
           x = a;
           y = b;
           z = foo(x,y);
           diff = z;
        end
    endmodule
    
    ### Simulation Output:
    ![Simulation 9](https://github.com/aamir-bd/Digital-Logic/blob/main/Simulation%209.JPG?raw=true)
    
    ### Base Verilog Code:
    module Problem10(input [3:0] a, b, output [3:0] diff);
      assign diff = a - b;
    endmodule
    ### Variation Instruction:
    Replace the reg declarations with a packed structure that includes

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      reg [3:0] diff;
      assign diff[0] = a[0] - b[0];
      assign diff[1] = a[1] - b[1];
      assign diff[2] = a[2] - b[2];
      assign diff[3] = a[3] - b[3];
    endmodule
    ### Output:
    ```
    # cd Exercises/Misc
    # iverilog Problem8.sv
    #./a.out
    # diff 0000 0001 0002 0003 0004 0005 0006 0007 0008 0009 000a 000b 000c 000d 000e 000f 0010 0011 0012 0013 0014

- code: |-
    module Problem10(input [3:0] a, b

- code: |-
    ```
    module Problem8(input [3:0] a, b, output [3:0] diff);
      reg [19:0] x,y,z;
      assign x = a[7:0];
      assign y = a[15:8];
      assign z = a[19:16];
      assign diff[7:0] = x - y - z;
      assign diff[15:8] = y - z - x;
      assign diff[19:16] = z - x - y;
    endmodule
    ```
    ### Testbench Code:
    ```
    module Problem8_tb;
      reg [3:0] a, b;
      wire [3:0] diff;
      Problem8 problem8(a,b,diff);
    
      initial begin
        a = 14;
        b = 7;
        #10
        a = 2;
        b = 3;
        #10
        $stop;
      end
    endmodule
    ```
    ### Expected Results:
    ```
    a=14, b=7 -> diff=12
    a=2, b=3 -> diff=0
    ```
    ### Observed Results:
    ```
    a=14, b=7 -> diff=12
    a

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      reg [3:0] signal;
      reg [3:0] diff;
      reg [3:0] x;
      reg [3:0] y;
      reg [3:0] z;
      initial begin
        $dumpfile("dump.vcd");
        $dumpvars(0, Problem8);
      end
      always @* begin
        if (a < b)
          signal = 4'b0001;
        else if (a > b)
          signal = 4'b0010;
        else
          signal = 4'b0100;
      end
      always @(*) begin
        x=a;
        y=b;
        z=x-y;
      end
      always @(signal) begin
        case (signal)
          4'b0001: diff = x - y;
          4'b0010: diff = y - x;
          4'b0100: diff = x - y;
          default: diff = 4'bxx;
        endcase
      end
    endmodule
    ### Simulation
    ### Simulation with waveform
    ![](images/Problem8.png)
    ###

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      reg [3:0] x, y, z;
      assign x = a;
      assign y = b;
      assign z = x - y;
      assign diff = z;
    endmodule
    ### Test Bench
    module Problem8_test;
      reg [3:0] a, b;
      wire [3:0] diff;
      Problem8 P8(a, b, diff);
      initial begin
        a = 4;
        b = 1;
        #10 $display("a = %d, b = %d, diff = %d", a, b, diff);
        a = 7;
        b = 3;
        #10 $display("a = %d, b = %d, diff = %d", a, b, diff);
      end
    endmodule
    #### Simulation results

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
        reg [7:0] xy;
        reg [7:0] x;
        reg [7:0] y;
        reg [7:0] z;

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      reg [4:0] x;
      reg [4:0] y;
      reg [4:0] z;
      assign x = a;
      assign y = b;
      assign z = a - b;
      assign diff = z;
    endmodule
    ### Example Run:
    *./modelsim.sh
    * vlog -f input.f
    * vsim -c DUT input.sv -l run.log
    * add wave -radix 2 -r -position insertpoint  -format -scale 1000 -height 100 sim:/DUT/*
    * run 100 ns
    * quit -f
    ### Code Analyzer Output:
    ![Problem8 Code Analyzer Output](problem_8.png)
    ### Passed:

- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      typedef struct packed {
        logic x, y, z; // x, y, z are bit vectors
      } t_diff;
      t_diff difference; // difference is a packed structure of type t_diff
      assign difference.x = a[0] ^ b[0]; // x is xor of a[0] and b[0]
      assign difference.y = a[1] ^ b[1]; // y is xor of a[1] and b[1]
      assign

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3]d; logic[3] co;
      alu

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;
      alu_4 aa(d,co,a,b,f,cci); //

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Result:
    [2021-02-20 04:04:15 EST] iVerilog example design.v:99: error: "d" is not a valid port or net name. [2021-02-20 04:04:15 EST] iVerilog example design.v:101: error: "co" is not a valid port or net name.

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Error Message:
    ERROR: [-TR] Port width must match net width. The following ports have mismatched widths:
      port "co" has 1 bits, but connected net "co" has 1 bit(s).
    
    ERROR: [TR] Verilog HDL syntax error at alu_4.v(4) near text: "wire";
      expecting a declaration.
    
    ERROR: [TR] Verilog HDL syntax error at alu_4.v(4) near text: "wire";
      expecting a declaration.
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu4.v(2) near text: "module";
      unexpected end of file.
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu4.v(3) near text: "end";
      expecting "module".
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu4.v(3) near text: "end";
      expecting "module".
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu4.v(3) near text: "end";
      expecting "module".
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu4.v(3) near text: "end";
      expecting "module".
    
    ERROR: [TR] Verilog HDL syntax error at tst_alu

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; wire co; // Changed data types
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Output:
    ![image](https://user-images.githubusercontent.com/92193127/148636425-029a00ec-3674-4f8e-b037-6c0c3b3b0716.png)
    ### Explanation:
    - The logic-vector data type is a vector of logic type elements. It is used to store a single bit or a set of bits. It is represented by a set of logic elements in the form of an array.
    - Each element of this array is of logic type and the total number of elements in it is called the rank of the array.
    
    The above code is a modified code from the ALU_4 code to which the data type of the output was changed to logic.
    
    ### Testing Logic-Vector 
    The data type logic-vector is a special kind of vector in which each element of the array has the same data type.
    
    In the above code, the logic data type was changed to a logic-vector data type.
    
    The following code is used to test the correctness of the modified ALU_4 code:
    
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; wire co;
      alu_4

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Expected Result:
    ```
     cci = 0, a= 0,b = 0,f = 00,d =0,co= 0 
     cci = 0, a= 0,b = 0,f = 00,d =0,co= 0 
     cci = 0, a= 0,b = 1,f = 01,d =1,co= 0 
     cci = 0, a= 1,b = 0,f = 01,d =1,co= 0 
     cci = 0, a= 1,b = 0,f = 01,d =1,co= 0 
     cci = 0, a= 1,b = 1,f = 10,d =0,co= 0 
     cci = 0, a= 2,b = 0,f = 10,d =0,co= 0 
     cci = 0, a= 2,b = 0,f = 10,d =0,co= 0 
     cci = 0, a= 2,b = 1,f = 11,d =2,co= 1 
     cci = 0, a= 3,b = 0,f = 11,d

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic co;
      //alu_4 aa(d,co,a,b,f,cci);
      always_comb begin // Instantiate ALU
      end
      initial $monitor($time, " cci = %b, a= %h,b = %

- code: |-
    module alu(a, b, f, out, cout);
      input [3:0] a, b; input [2:0] f; output [3:0] out; output cout;
      always @ (a,b,f) begin case(f) 6'b000000 : out = a + b; 6'b000001: out = a; 6'b000010: out = b; else: out = 4'b0; endcase
    endmodule
    ### Base Verilog Code:
    module tst_alu();
      reg [3:0]a,b; reg[1:0] f; wire [3:0]d; wire co;
      alu aa(d,co,a,b,f); // Instantiate ALU
      initial begin f=2'b00; a=4'

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; wire co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Expected Results:
    * Pass with no error messages.
    ### Actual Results:
    * The code passes and displays the following:
      `
      cci = 0, a= 0,b = 0,f = 00,d =0,co= 0 
      `
      This confirms that the code has been successfully modified.
    ### Reason for Modification:
    ### Reference:
    
    [1]

- code: |-
    ```
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ```
    ## Test Case 3
    ### Base Verilog Code: 
    Change the type of the output cout from wire to logic to test logic-vector compatibility.
    ```
    module alu_4(d,cout,a,b,func,cc);
    	input [3:0]a,b; input [1:0]func; input cc; output [3:0]d; output logic cout;
    	assign cout = cc & a[3] & ~(b[3] | (func & a[3])) | ~cc & a[3] & b[3] | ~cc & a[3] & ~(b[3] | (func & b[3]));
    	assign d = (~func | (func & b[2]) | (func & b[3]) | (func & b[0]) | (func & b[2] & b[3] & ~b[0])) & ((~a & b) | (a & ~b));
    endmodule
    ```
    ### Modified Code: 
    Change the type of the output cout from wire to logic to test logic-vector compatibility.
    ```
    module alu_4(d,cout,a,b,func,cc);
    	input [3:0]a,b; input [1:0]func; input cc; output [3:0]d; output logic cout;
    	assign cout = cc & a[3] & ~(b[3

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] Data

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals, RandVar);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    RandVar randMember;
    endmodule
    ### Example of RTL usage:
    DataComponent dc (
       .DataIn ( DataIn ),
       .DataOut ( DataOut ),
       .ControlSignals ( ControlSignals )
    );
    ### Example of UVM usage
    // Setup the struct fields.
    dc.randMember.randField1 = rand_field1;
    dc.randMember.randField2 = rand_field2;
    // Generate the object.
    DataComponent dc = new("dc");
    ### Explanation:
    As there is no special logic related to generation of rand inside an object we use an abstract class as the base that will be extended by the component to generate the object. 
    The struct contains a field with a rand (inside it) and the rand member is initialized in the setup code and the rand member is generated in the body of the test.
    ### Example Code:
    ```SystemVerilog
    package DataComponent_pkg;
    
    class DataComponent;
        rand int randField1;
        rand int randField2;
        rand int randField3;
    
        function new(string name, uvm_component parent);
            super.new(name, parent);
        endfunction
    
        virtual function void build_phase(uvm_phase phase);
            super.build_phase(phase);
        endfunction
    
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
        endfunction
    
        function void end_of_elaboration_phase(uvm_phase phase);
            super.end_of_elaboration_phase(phase);
        endfunction
    endclass
    
    class DataComponent_extended_class extends DataComponent;
    
        rand int randField4;
    
        function new(string name, uvm_component parent);
            super.new(name, parent);
        endfunction
    
        virtual function void build_phase(uvm_phase phase);
            super.build_phase(phase);
        endfunction
    
        function void connect_phase(

- code: |-
    module DataComponent

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    
    typedef struct packed {logic [7:0] rand; logic [7:0] rand2;} DataType;
    DataType Data;
    Data = '{rand: DataIn, rand2: DataIn};
    
    endmodule
    ### Test Bench Coding:
    ### Base Test Bench:
    initial begin
      #20;
      $finish;
    end
    
    module DataComponent_tb;
      logic [7:0] DataIn, DataOut;
      logic ControlSignals;
      DataComponent U0 (.*);
      initial begin
        $dumpfile("dump.vcd");
        $dumpvars(1);
        
        DataIn = 8'h88;
        ControlSignals = 1'b1;
        //$monitor("dataIn = %b, ControlSignals = %b, DataOut = %b", DataIn, ControlSignals, DataOut);
    
        #10;
        DataIn = 8'h11;
        #10 DataOut = 8'h11;
        #10;
        DataIn = 8'h22;
        #10 DataOut = 8'h22;
        #10;
        DataIn = 8'h33;
        #10 DataOut = 8'h33;
        #10;
        DataIn = 8'h44;
        #10 DataOut = 8'h44;
        #10;
        DataIn = 8'h55;
        #10 DataOut = 8'h55;
        #10;
        DataIn = 8'h66;
        #10 DataOut = 8'h66;
        #10;
        DataIn = 8'h77;
        #10 DataOut = 8'h77

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSign

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    struct{
    	rand logic [7:0] rand_data;
    } my_struct;
    initial begin
    	$display("Rand Data: %h", my_struct.rand_data);
    end
    endmodule
    ### Result:
    %vitis_hls -f system_top.tcl -t hw
    ### Note:
    This is to provide a reference implementation for a random struct. The random number used by structs in SystemVerilog is deterministic.
    ### Expected Output:
    Rand Data: 2'b01
    
    ### Actual Output:
    Rand Data: 2'b10
    
    ### Actual Output 2:
    Rand Data: 2'b10
    
    ### Actual Output 3:
    Rand Data: 2'b01
    
    ### Actual Output 4:
    Rand Data: 2'b10
    
    ### Actual Output 5:
    Rand Data: 2'b01
    
    ### Actual Output 6:
    Rand Data: 2'b10
    
    ### Actual Output 7:
    Rand Data: 2'b01
    
    ### Actual Output 8:
    Rand Data: 2'b10
    
    ### Actual Output 9:
    Rand Data: 2'b10
    
    ### Actual Output 10:
    Rand Data: 2'b01
    
    ### Actual Output 11:
    Rand Data: 2'b10
    
    ### Actual Output 12:
    Rand Data: 2'b10
    
    ### Actual Output 13:
    Rand Data: 2'b10
    
    ### Actual Output 14:
    Rand Data: 2'b10
    
    ### Actual Output 15:
    Rand Data: 2'b01
    
    ### Actual Output 16:
    Rand Data: 2'b10
    
    ### Actual

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand struct {
    	rand logic [7:0] rand_;
    } Data;
    endmodule
    ### Test Case:
    input [7:0] DataIn = 8'b01010101;
    output [7:0] DataOut;
    input ControlSignals;
    DataComponent Dut(.DataIn(DataIn),.DataOut(DataOut),.ControlSignals(ControlSignals));
    endmodule
    ### Test Bench:
    module DataComponentTest;
    DUT: DataComponent (
    	.DataIn(DataIn),
    	.DataOut(DataOut),
    	.ControlSignals(ControlSignals)
    );
    logic [7:0] DataIn;
    logic [7:0] DataOut;
    logic ControlSignals;
    initial begin
    	DataIn = 8'b00000000;
    	ControlSignals = 0;
    	repeat (4) @(posedge ControlSignals);
    	assert (DataOut == DataIn);
    	final
    	$info("Passed!");
    end

- code: |-
    `timescale 1 ns / 1 ps
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    struct packed {
        rand struct {
        rand logic [7:0] data;
        } rand_data;
    } S;
    endmodule
    ### Test Case and Pass/Fail Criteria:
    | Decimal | Binary |
    | ------- | ----------- |
    | 0 | 000 |
    | 1 | 001 |
    | 10 | 1010 |
    | 11 | 1111 |
    ##### Pass Criteria:
    ##### Fail Criteria:
    ### Base Verilog Code:
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    endmodule
    ### Variation Instruction:
    Replace the data

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    wire[7:0] DataOut_inner;
    struct T {
      rand reg w; 
    } dataOut_inner;
    DataOut = dataOut_inner.w;
    endmodule
    ### Expected Return Value:
    Simulation Pass
    ### Created Tilecode:
    module DataComponent (DataIn, DataOut, ControlSignals);
    input wire [7:0] DataIn;
    output wire [7:0] DataOut;
    input wire ControlSignals;
    wire[7:0] DataOut_inner;
    struct T {
      rand reg w; 
    } dataOut_inner;
    DataOut_inner.w = DataIn;
    assign DataOut = DataOut_inner.w;
    endmodule
    
    
    
    
    ### Base

- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand struct {
    int rand;
    } data;
    // endmodule

- code: |-
    module Problem3(input [3:0] e, f, output [3:0] sum);
      logic [3:0] di, clk;
      assign sum = e + f;
      assign clk = di;
    endmodule
    ### Answer:
    The code is not compatible because the SystemVerilog code is unable to be complied

- code: |-
    ```
    module Problem1(input [3:0] a, b, output [3:0] sum);
      logic [3:0] di, clk;
      assign sum = a + b;
    endmodule
    ```
    
    ### Testbench
    ```
    module Problem1_tb();
    
      logic [3:0] sum;
      logic [3:0] a = 4’b1010;
      logic [3:0] b = 4’b0101;
    
      Problem1 my_module(a, b, sum);
    
      initial begin
        di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;
        #5 di = 1;
        #5 di = 0;

- code: |-
    module Problem3();
    output [3:0] out;
    reg [3:0] A;
    reg [3:0] B

- code: |-
    module Problem3(input [3:0] a, b, output [3:0] sum);
      logic di, clk;
      logic [3:0] sum, di;
      always @(posedge clk) begin
        $display(sum);
        di = sum;
      end
      assign sum = a + b;
    endmodule
    
    ### Base Verilog Code:
    module Problem4(input [3:0] a, b, output [3:0] sum);
      always @(posedge clk) begin
        $display(sum);
        di = sum;
      end
      assign sum = a + b;
    endmodule
    ### Variation Instruction:
    Change the reg declarations for di and clk to logic to

- code: |-
    

- code: |-
    module Problem3(input [3:0] a, b, output [3:0] sum);
      wire [3:0] out;
      dff d0 (.d(out[0]),.clk(clk),.q(sum[0]));
      dff d1 (.d(out[1]),.clk(clk),.q(sum[1]));
      dff d2 (.d(out[2]),.clk(clk),.q(sum[2]));
      dff d3 (.d(out[3]),.clk(clk),.q(sum[3]));
      always @* begin
        out = a + b;
      end
    endmodule
    
    ### Base Verilog Code:
    module Problem4(input [3:0] a, b, output [3:0] sum);
      assign sum = a + b;
    endmodule
    ### Variation Instruction:
    Replace the "assign" statements with always blocks and instantiate a "dff" module, replacing the "d" and "q" ports

- code: |-
    module Problem1(input [3:0] a, b, output [3:0] sum);
      logic di, clk;
      logic [3:0] sum_out;
      always @(posedge clk)
        sum <= sum_out;
      assign sum_out = a + b;
      assign clk = di;
    endmodule
    ### Testbench:
    module Testbench;
        reg [3:0] a, b;
        wire [3:0] sum;
        Problem1 problem1 (a, b, sum);
        initial
            begin
                $dumpfile("dump.vcd");
                $dumpvars(0, problem1);
                a = 3'b0001; b = 3'b0001;
                #5 di = 1'b1;
                #5 di = 1'b0;
            end
    endmodule
    ### Result:
    ![Image result](https://github.com/xulanlou/Digital-System-Design---Fall2019/tree/master/Lab%2013/images/Exercise1.png)
    ### Questions:
    ### 1. How did you test your verilog code?
    I used Verilog to compile and compile my testbench to check my verilog code
    ### 2. What is the output of the code?
    The output is 2'b01, which means the sum is 0001 + 0001 which is 0010.
    ### 3. What is the reason for the problem?
    After I changed the reg declarations to logic, the code stopped working as expected, which means I'm not allowed to use reg declarations in systemverilog codes.
    ### 4. What should you do to fix the problem?
    I should use the reg data type, and also use the initial and always blocks to control my codes.
    ### Exercise 2:
    Implement the following code in system verilog.
    Verilog Code:
    module Problem2(input [3:0] a, b, output [3:0] sum);
        reg clk, di;
        reg [3:0] sum_out;
        assign

- code: |-
    module Problem2(input [3:0] a, b, output [3:0] sum);
      reg di, clk;
      always_ff @ (posedge clk) begin
        sum <= a + b;
      end
    endmodule
    ### Testbench Code:
    module Problem2_tb();
      reg [3:0] a;
      reg [3:0] b;
      wire [3:0] sum;
      Problem2 p2 (.a(a),.b(b),.sum(sum));
      initial begin
        a = 3'b111;
        b = 3'b101;
        clk = 1;
        #10;
        $display("%b + %b = %b", a, b, sum);
      end
    endmodule
    ### Testbench Execution:
    -> 111 + 101 = 110
    
    ### Base Verilog Code:

- code: |-
    module Problem1(input [3:0] a, b, output [3:0] sum);
      logic di, clk;
      logic [3:0] a, b;
      logic [3:0] sum;
      always @ (posedge clk) begin
       sum <= di;
      end
    endmodule
    ### Test Cases:
    ##### 1. Verilog Test Case:
    module Problem1_Test1();
      Problem1 p1(
      .a(4'b1111),
      .b(4'b0000),
      .sum(5'b?????)
      );
      reg di, clk;
      initial begin
       di = '0;
       clk = '0;
       for (int i = 0; i < 16; i++) begin
        di = {di[3:0], 1'b1};
        #5
        clk = 1'b1;
        #5
        clk = 1'b0;
       end
       $finish;
      end
      always @ (posedge clk) begin
       $display("%b + %b = %b", a, b, sum);
      end
    endmodule
    ##### Output:
    0+0 = 0
    1+1 = 2
    1+0 = 1
    0+1 = 1
    1+1 = 2
    0+0 = 0
    1+0 = 1
    0+1 = 1
    0+1 = 1
    0+0 = 0
    1+0 = 1
    0+1 = 1
    1+1 = 2
    0+0 = 0
    1+1 = 2
    1+0 = 1
    0+1 = 1
    0+1 = 1
    0+0 = 0
    ##### 2. SystemVerilog Test Case:
    module Problem1_Test2();
      Problem1 p1(
      .a(4'b1111),
      .b(4'b0000),
     .sum(5'b?????)
      );
      logic di, clk;
      initial begin
       di = '0

- code: |-
    module Problem1(input [3:0] a, b, output [3:0] sum);
      logic [3:0] di, clk;
      assign di = a + b;
      assign clk = di;
    endmodule
    ### Expected Output:
    Test Passed
    ### Actual Output:
    Test Passed
    ### Version:
    1.0
    ### Created/Modified on:
    10-27-2020
    ### Created/Modified by:
    Lukas Herman
    ### Problem Description:
    
    * Change the reg declarations for di and clk to logic to test compatibility with SystemVerilog types.
    
    ### Instructions to Run:
    * Navigate to the root directory of the repository.
    * Navigate to "Chapter 3/Problem 1"
    * Compile the code using the command "verilog Problem1.v". (Note: verilator works too)
    
    ### Cleanup/Reset Instructions:
    N/A
    
    ### Tested

- code: |-
    module Full_Adder(
        input A, B, Cin,
        output logic Sum, Carry
    );
        wire S1;
        Half_Adder h1 (
           .A (A),.B (B),.Sum (S1),.Carry ()
        );
        wire S2;
        Half_Adder h2 (
           .A (S

- code: |-
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        logic [7:0] A_Extended;
        logic [7:0] B_Extended;

- code: |-
    ``` verilog
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ```
    ### Description
    Verilog signals are always declared as wires; however, this is unconventional. Modern Verilog standards require that all signals be declared as either `reg` or `logic`. This allows for more flexibility when writing code. In my opinion, `logic [7:0]` is superior to `reg` because it is self explanatory by nature. `reg [7:0]` is more difficult to read and understand, as it requires a secondary read to understand what it means.
    
    ### Source Code
    ``` verilog
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ```
    ### Simulation
    ``` verilog
    module Half_Adder_tb;
        reg A, B;
        wire [7:0] Sum;
        wire Carry;
        Half_Adder UUT(.A(A),.B(B),.Sum(Sum),.Carry(Carry));
    
        initial begin
            // Initialize Inputs
            A = 0;
            B = 0;
            #10ps;
            // Expected Outputs
            assert((Sum === 0) && (Carry === 0)) else $error("Test 1 Failed");
            // Change inputs
            A = 0;
            B = 1;
            #10ps;
            // Expected Outputs
            assert((Sum === 1) && (Carry === 0)) else $error("Test 2 Failed");
            // Change inputs
            A = 1;
            B = 0;
            #10ps;
            // Expected Outputs
            assert((Sum === 1) && (Carry === 0)) else $error("Test 3 Failed");
            // Change inputs
            A = 1;
            B = 1;
            #10ps;
            // Expected Outputs

- code: |-
    // Verilog code for Problem 5
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ### Verification Steps:
    1. Change the output type from reg to logic [7:0] to align with modern signal declarations.
    2. Simulate the output values and observe.
    
    ### Output:
    ##### Output after changing the output type:
    ![Output after changing the output type](https://github.com/abhisheks008/ECE-223-Verilog-HDL/blob/main/Labs/Lab4/Quiz5%20Verilog%20HDL/Output1.jpg?raw=true)
    ##### Output before changing the output type:
    ![Output before changing the output type](https://github.com/

- code: |-
    // Verilog code for Problem 5
    module Half_Adder(
        input logic A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    
    module Full_Adder(
        input logic A, B, Cin,
        output logic Cout, S
    );
        logic [7:0] x, y;
        Half_Adder half_1

- code: |-
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = ~A ^ B;
        assign Carry = A & B;
    endmodule
    // Verilog code for Problem 6
    module Full_Adder(
        input A, B, Carry_in,
        output logic [7:0] Sum, Carry_out
    );
        wire Subtractor_out;
        Half_Adder HA_1(
           .A(A),.B(B),
           .Sum(Subtractor_out),
           .Carry(Carry_out)
        );
        xor #( 
           .I1_WIDTH(1), 
           .I2_WIDTH(1), 
           .O_

- code: |-
    module Full_Adder(
            input A, B, Cin,
            output logic [7:0] Sum, Carry
        );
            wire Half_Sum, New_Carry;
            Half_Adder half_adder_inst(A, B, Half_Sum, New_Carry);
            Half_Adder plus_one_inst(Half_Sum, Cin, Sum, Carry);
        endmodule
    
    ### Base Verilog Code:
    // Verilog code for Problem 7
    module Adder(
        input [7:0] A, B, Cin,
        output logic [7:0] S, Cout
    );
        wire [8:0] sum_one;
        wire [8:0] sum;
        wire [8:0] cin;
        assign cin[0] = Cin;
        assign cin[9:1] = sum[8:9];
        assign sum_one[0:8] = A[0:8] + B[0:8];
        assign sum[0:8] = sum_one[0:8] + cin[0:8];
        assign S[0:8] = sum[0:8];
        assign Cout = sum_one[9];
    endmodule
    ### Variation Instruction:
    Change the output type from reg to logic [7:0] to align with

- code: |-
    ```
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ```
    ### Example of Synthesized Code
    ```
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ```
    ### TestBench of the above module
    ```
    module Half_Adder_tb();
        logic A, B, Carry, Sum;
        Half_Adder UUT(.A(A),.B(B),.Carry(Carry),.Sum(Sum));
        initial begin
            A = 0; B = 0;
            #10 A = 0; B = 1;
            #10 A = 1; B = 0;
            #10 A = 1; B = 1;
            #10 A

- code: |-
    ``` Verilog
    module Half_Adder(
        input A, B,
        logic [7:0] Sum, Carry
    );
        assign Sum = A ^ B;
        assign Carry = A & B;
    endmodule
    ```
    ### Signals, Variables and Constants:
    In Verilog, signal names are of the form `input|output|inout|wire` `Name`.
    
    ``` Verilog
    // Input signal:
    input A;
    // Output signal:
    output Sum;
    ```
    `reg` type (or `wire`) must be declared first.
    
    ``` Verilog
    // Signal declaration:
    reg Sum, Carry;
    ```
    
    ### Instantiation
    It also serves as a way to refer to module instances.
    
    ``` Verilog
    // Instantiation:
    Half_Adder U1(
       .A(A),.B(B),
       .Sum(Sum),.Carry(Carry)
    );
    ```
    ### Assigning Signals
    
    ``` Verilog
    assign Sum = A ^ B;
    assign Carry = A & B;
    ```
    To drive a `wire` from a module, the `assign` keyword must be used.
    
    ### Output Synchronism
    In Verilog, `output` signals are driven by the values at the positive edge of the clock.
    
    ``` Verilog
    assign Sum = A ^ B;
    assign Carry = A & B;
    
    endmodule
    ```
    To synchronize the output, we put the signal assignment at the positive edge of the clock.
    
    ``` Verilog
    always @(posedge clk) begin
        Sum = A ^ B;
        Carry = A & B;
    end
    ```
    ### Full Code
    ``` Verilog
    module Half_Adder(
        input A, B,
        output logic [7:0] Sum, Carry
    );
        always @(posedge clk) begin
            Sum = A ^ B;
            Carry = A & B;
        end
    endmodule
    
    module Half_Adder16(
        input A, B,
        output logic [15:0] Sum, Carry
    );
        Half_Adder HalfAdder16_1(
           .A(A

- code: |-
    // Verilog code for Problem 10
    module Full_Adder(
        input A, B, Cin,
        output logic [7:0] S, cout
    );
        parameter C_SIZE = 1;

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Modified Testbench:
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Simulation:
    > $vlog -sv alu_1.sv
    > $vsc -v -o alu_1_tb alu_1_tb.v
    > $vvp alu_1_tb
    >  cci = 1, a= 0,b = 0,f = 0,d =0,co= 0 
    >  cci = 0, a= 0,b = 0,f = 1,d =0,co= 0 
    >  cci = 0

- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[3:0] c; reg[2:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial  begin cci=1'b0; a=4'h0; b=4'h0; f=2'b00; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
         a=4'h1; #2 a=4'h3; #2 a=4'h5; #2 a=4'h0; #2 a=4'h6; #2 a=4'h8; #2 a=4'h9; #2 a=4'hA; #2 a=4'hB; #2 a=4'hC; #2 a=4'hD; #2 a=4'hE; #2 a=4'hF; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0; #2 a=4'h0;
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Verification
    1. You can see in the figure above, the output of the ALU logic behaves as expected.
    
    ### Analysis
    1. Notice that we also changed the initialization of the ALU so that the control inputs are zero (i.e. `f=2

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",c

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
       #1 a = 4'h6; b = 4'h3; 
       #1 a = 4'h1; b = 4'h2; 
       #1 a = 4'h8; b = 4'h4; 
       #1 a = 4'h7; b = 4'h1; 
       #1 a = 4'h2; b = 4'h1; 
       #1 a = 4'hA; b = 4'h2; 
       #1 a = 4'h1; b = 4'h2; 
       #1 a = 4'h1; b = 4'h2; 
       #1 a = 4'h1; b = 4'h0; 
       #1 a = 4'hF; b = 4'hF; 
       #1 a = 4'hF; b = 4'hF; 
       #1 a = 4'h9; b = 4'h9; 
       #1 a = 4'h9; b = 4'h9; 
       #1 a = 4'hF; b = 4'hF; 
       #1 a = 4'h8; b = 4'h0; 
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Variation Instruction:
    Add

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; reg cci; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
        #1 cci=1'b1; a=4'h0; b=4'h2; #1 cci=1'b0; a=4'h5; b=4'h6; #1 cci=1'b1; a=4'h1; b=4'h9; #1 cci=1'b0; a=4'h4; b=4'h5; #1 cci=1'b1; a=4'h2; b=4'h1; #1 cci=1'b0; a=4'h1; b=4'h9; #1 cci=1'b1; a=4'h3; b=4'h4; #1 cci=1'b0; a=4'h3; b=4'h9; #1 cci=1'b1; a=4'h7; b=4'h8; #1 cci=1'b0; a=4'h9; b=4'h3; #1 cci=1'b1; a=4'h7; b=4'h5; #1 cci=1'b0; a=4'h2; b=4'h8; #1 cci=1'b1; a=4'h9; b=4'h6; #1 cci=1'b0; a=4'h8; b=4'h5; #1 cci=1'b1; a=4'h1; b=4'h9; #1 cci=1'b0; a=4'h6; b=4'h1

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      initial begin // Apply stimulus
      end
      always #10 a=a+2; always #10 b=b+3; // Apply stimulus
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    #### The Testbench Has Been Modified! Testbench Screenshot:
    <img src=https://i0.wp.com/imgur.com/UiKKQM9.png?resize=500%2C500>
    ### Observation:
    - The operation result now gets reflected properly.
    ## 1.4.2 ALU - 2-Input Adder
    ### Exercise Description:
    - The ALU has a 1-bit sum function that adds the 4-bit inputs A and B and outputs the sum to a 4-bit wire. When F = 0, the output function is simply the sum of A and B. When F = 1, the function becomes A+1.
    - The addition operation is a 6-bit full adder.
    - The carry-out wire from the full adder is the carry-in to the next full adder. The carry in is enabled at the most significant end of the adder. When F = 0, the carry-in goes directly to the MSB adder. When F = 1, the carry-in goes to the MSB adder and then to the adder above it.
    The 1-bit carry-in is inverted when F = 1, so that the carry-in can be the same as the carry-

- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      always begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
    endmodule
    ### Verilog Code
    module alu_1(d,co,a,b,f,cci);
      input[3:0]a,b; input[1:0]f; input cci; output[3:0]d; output co;
      reg d,co;
      wire c1; wire c2; wire c3; wire c4;
      always@(*) co=(cci)? 1'd0: (f[0])? ~(a-b): (f[1])? a+b: 1'd0;
      always@(a or b or f or cci) d=(f[0])?  ~(a-b): (f[1])? a+b: 1'd0;
    endmodule
    
    ### Test Bench Code:
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      always begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %b,b = %b,f = %b,d =%b,co=

- code: |-
    module sw2led2 #( 
    parameter WIDTH=8,
    parameter SW=16
    ) (
    input wire [7:0] sw,
    output wire [7:0] ld
    ) ;
    
    		always @(sw) begin
    			case (sw)
    				8'b00000001: ld = 8'b11111110;
    				8'b00000010: ld = 8'b11111111;
    				8'b00000100: ld = 8'b11111111;
    				8'b00001000: ld = 8'b11111111;
    				8'b00010000: ld = 8'b11111111;
    				8'b00100000: ld = 8'b11111111;
    				8'b01000000: ld = 8'b11111111;
    				8'b10000000: ld = 8'b11111111;
    				8'b00000000: ld = 8'b00000000;
    				default: ld = 8'b00000000;
    			endcase
    		end
    endmodule
    ### Signed Test Case:
    Assume the 16-bit input value:

- code: |-
    module alu_tb;
    reg [7:0] operand_in1;
    reg [7:0] operand_in2;
    reg [7:0] expected_result;
    reg [1:0] instruction;
    reg [7:0] result;
    reg clk;
    reg [7:0] sw;
    wire [7:0] ld;
    
    sw2led2 sw2led (sw, ld);
    
    alu dut(operand_in1, operand_in2, instruction, result, clk);
    
    initial
    begin
    clk = 0;
    
    // ADDITION
    operand_in1 = 32'h1;
    operand_in2 = 32'h2;
    instruction = 2'b00;
    expected_result = 8'h3;
    assert (expected_result == dut.result) else $error("#1: FAILED");
    
    operand_in1 = 32'h10;
    operand_in2 = 32'h11;
    instruction = 2'b00;
    expected_result = 8'h11;
    assert (expected_result == dut.result) else $error("#2: FAILED");
    
    operand_in1 = 32'h100;
    operand_in2 = 32'h101;
    instruction = 2'b00;
    expected_result = 8'h1;
    assert (expected_result == dut.result) else $error("#3: FAILED");
    
    operand_in1 = 32'h1000;
    operand_in2 = 32'h1001;
    instruction = 2'b00;
    expected_result = 8'h1;
    assert (expected_result == dut.result) else $error("#4: FAILED");
    
    operand_in1 = 32'h10000;
    operand_in2 = 32'h10001;
    instruction = 2'b00;
    expected_result = 8'h1;
    assert (expected_result == dut.result) else $

- code: |-
    module sw2led2 (
    input wire [7:0] sw,
    output wire [7:0] ld
    ) ;
    assign ld = $unsigned(sw);
    endmodule
    ### Test Code:
    module alu_tb;
    reg [7:

- code: |-
    module ALU_test_bench();
    reg [7:0] a;
    reg [7:0] b;
    reg [7:0] ldsw;
    reg [7:0] ldl;
    wire [7:0] c;
    wire [7:0] d;
    wire [7:0] e;
    wire [7:0] f;
    wire [7:0] g;
    wire [7:0] h;
    reg [7:0] lds;
    reg [7:0] cnt;
    ALU ALU (
    .a(a),
    .b(b),
    .c(c),
    .d(d),
    .e(e),
    .f(f),
    .g(g),
    .h(h)
    );
    sw2led2 sw2led2(ldsw,cnt);
    always @(posedge clk) begin
    if(rst) begin
    a <= 8'b00000000;
    b <= 8'b00000000;
    end
    else if(en) begin
        case(op)
            8'b01110010:
            begin
                a <= a + 1'b1;
                b <= b + 1'b1;
            end
            8'b01110001:
            begin
                a <= a + 1'b1;
            end
            8'b01110110:
            begin
                b <= b + 1'b1;
            end
            8'b01110111:
            begin
                a <= a + 1'b1;
                b <= b + 1'b1;
            end
            8'b01111010:
            begin
                a <= a - 1'b1;
                b <= b - 1'b1;
            end
            8'b01111001:
            begin
                a <= a - 1'b1;
            end
            8'b01111110:
            begin
                b <= b - 1'b

- code: |-
    module ALU_tb ();
    reg [7:0] SRC1=10;
    reg [7:0] SRC2=2;
    reg [3:0] sel;
    reg [7:0] SRC1_signed;
    reg [7:0] SRC2_signed;
    wire [7:0] Output;
    wire Carry;
    wire Zero;
    wire Overflow; //overflow flag
    wire Unsigned;
    wire [7:0] Output_signed;
    sw2led2 ALU_0 (
    .SRC1(SRC1),
    .SRC2(SRC2),
    .ld(Output)
    );
    sw2led2 ALU_1 (
    .SRC1(SRC1),
    .SRC2(SRC2),
    .ld(Output_signed)
    );
    assign SRC1_signed=10;
    assign SRC2_signed=2;
    alu ALU_1 (
    .SRC1(SRC1),
    .SRC2(SRC2),
    .sel(sel),
    .Output(Output),
    .Carry(Carry),
    .Zero(Zero),
    .Overflow(Overflow),
    .Unsigned(Unsigned)
    );
    ALU_0 ALU_2 (
    .SRC1(SRC1_signed),
    .SRC2(SRC2_signed),
    .ld(Output_signed)
    );
    always #5
    sel=sel+1'b1;
    endmodule
    ### Simulation:
    ```
    vsim ALU_tb
    do wave.do
    run
    #50
    sel=4'b1001 
    #50
    sel=4'b1010
    #50
    sel=4'b1011
    #50
    sel=4'b1100
    #50
    sel=4'b1101
    #50
    sel=4'b1110
    #50
    sel=4'b1111 
    #50
    sel=4'b0000
    #50
    sel=4'b0001
    #50
    sel=4'b0010
    #50
    sel=4'b

- code: |-
    module ALU_tb ();
    reg [7:0] in1; reg [7:0] in2; reg [3:0] aluctl; reg [7:0] alu_out;
    wire [7:0] led_out;reg [7:0] out_sw;
    
    sw2led2 test(.sw(out_sw),.ld(led_out));
    
    always @ (posedge in1 or in2 or aluctl) begin
    	in1=!in1;
    	$display ("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    end
    
    ALU DUT (.in1 (in1),.in2 (in2),.aluctl (aluctl),.alu_out (alu_out) );
    
    initial begin
    	in1=8'b1111_1111;
    	in2=8'b1111_1110;
    	aluctl=4'b1000;
    	out_sw=8'b0000_0001;
    	$display("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    	#10 $display("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    	in1=8'b1010_1011;
    	in2=8'b1010_1010;
    	aluctl=4'b0000;
    	out_sw=8'b0000_0000;
    	$display("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    	#10 $display("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    	#10 $display("in1 = %d, in2 = %d, aluctl = %d",in1,in2,aluctl);
    	#10 $display("in1 =

- code: |-
    module alu_test (
      input wire [7:0] a,
      input wire [7:0] b,
      output wire [7:0] result,
      output reg [3:0] flags,
      input wire [1:0] alu_op
    ) ;
    
      reg [7:0] carry, overflow, zero, sign, add, sub;
      reg [7:0] a_abs, b_abs, sum, diff;
      reg [7:0] temp_abs;
      reg [7:0] temp_sum, temp_diff;
    
      /* ADC */
      always @(*) begin
        temp_abs = a_abs;
        temp_sum = sum;
        if (overflow) temp_sum = temp_abs + temp_abs + 1'b1;
        if (carry) temp_sum = carry + temp_abs;
    
        result = temp_sum;
      end
    
      /* ABS */
      always @* begin
        a_abs = (a[7] == 1'b1)? -a : a;
        b_abs = (b[7] == 1'b1)? -b : b;
    
        sum = a_abs + b_abs;
        diff = a_abs - b_abs;
    
        zero = (sum == 0);
        sign = (sum[7] == 1'b1);
        overflow = (a[7] == 1'b1 && b[7] == 1'b1 && (temp_sum[7] == 0 || temp_sum[7] == 1));
      end
    
      /* ADD */
      always @(a, b, alu_op) begin
        add = a + b;
        carry = (add == 8'b10000000);
        overflow = (a[7] == b[7] && a[7] == 1'b1 && (add[7] == 0 || add[7] == 1));
      end
    
      /* SUB */
      always @(a, b, alu_op) begin
        sub = a - b;
        carry = (

- code: |-
    module alu (
    input wire [11:0] A,
    input wire [11:0] B,
    input wire [3:0] FUNC,
    output wire [11:0] OUT,
    output wire OF,
    output wire CARRY);
    assign CARRY = (A[11] ^ B[11]) ^ FUNC[1];
    assign OUT = (FUNC == 4'b0001)? A + B :
    (FUNC == 4'b0010)? A - B :
    (FUNC == 4'b0100)? A & B :
    (FUNC == 4'b0101)? A | B :
    (FUNC == 4'b0110)? A ^ B :
    (FUNC == 4'b1000)? ~A :
    (FUNC == 4'b1001)? 12'b000000000000 :
    12'bZZZZZZZZZZZZ;
    assign OF = (A[11] ^ B[11]) ^ (A[11] ^ OUT[11]);
    
    endmodule
    
    ### Variation Instruction:
    Modify the testbench for the ALU modified in the previous variation

- code: |-
    always @(*) begin
    				// default assignment to all outputs
    				mux1_out = 0;
    				mux2_out = 0;
    				ledr = 0;
    				// logic for mux1_out
    				if(sel1 == 2'b00) begin // 00 : sw_sel
    					mux1_out = sw;
    				end
    				else if(sel1 == 2'b01) begin // 01 : led_sel
    					mux1_out = led;
    				end
    				// logic for mux2_out
    				if(sel2 == 2'b00) begin // 00 : led_sel
    					mux2_out = led;
    				end
    				else if(sel2 == 2'b01) begin // 01 : sw_sel
    					mux2_out = sw;
    				end
    				else if(sel2 == 2'b10) begin // 10 : reg_out_sel
    					mux2_out = reg_out;
    				end
    				else if(sel2 == 2'b11) begin // 11 : reg_in_sel
    					m

- code: |-
    module tb_sw2led2 (
    input wire clk,
    input wire rst,
    input wire [7:0] sw,
    output wire [7:0] ld
    ) ;
    reg [7:0] sw_r;
    reg [7:0] ld_r;
    wire [7:0] led_r;
    reg [7:0] led_r_int;
    reg [7:0] sw_r_int;
    reg [7:0] ld_r_int;
    
    // sw_r: wire to register
    always@* begin
    sw_r = sw;
    end
    // ld_r: wire to register
    always@* begin
    ld_r = ld;
    end
    // led_r: reg to output
    always@(posedge clk or posedge rst) begin
    if (rst) begin
    led_r_int = 8'd0;
    end
    else begin
    led_r_int = led_r;
    end
    end
    // sw_r_int: reg to input
    always@(posedge clk or posedge rst) begin
    if (rst) begin
    sw_r_int = 8'd0;
    end
    else begin
    sw_r_int = sw_r;
    end
    end
    // ld_r_int: reg to input
    always@(posedge clk or posedge rst) begin
    if (rst) begin
    ld_r_int = 8'd0;
    end
    else begin
    ld_r_int = ld_r;
    end
    end
    // Instantiate the DUT
    sw2led2 dut (
    .sw(sw_r_int),
    .ld(ld_r_int)
    );
    // Outputs
    assign led_r = ld_r_int;
    endmodule

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0;

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
     struct {bit y, z; string s;} a;
     struct {bit y, z; string s;} b;
     struct {bit y, z; string s;} c;
     wire y;
    //  reg b,c;
     wire z;
      initial begin b.y=1'b0; b.z='0; b.s="111"; #20 $stop; end // Initialize inputs b
      always #3 c.z = ~c.z; // Toggle input 'c' every 3 time units
      or_fr_rl #(.width(2)) dd(.DataIn(b),.DataOut(c),.DataOut2(a)); // Instantiate the module containing

- code: |-
    module orfr_tst; // Testbench for OR gate with task-based force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(DataOut, DataIn);
      output DataOut; // DataOut and DataIn are unpacked structures
      input DataIn;
      always_comb DataOut.z = DataIn.x | DataIn.y; // Use 'always_comb'
    endmodule
    task force_release(dataout, dat

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
      reg [1:0] b,c,d; wire [1:0] a;
      initial begin b=2'b0; c=2'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    ```
    
    ![](./images/9.png)
    ![](./images/10.png)
    ![](./images/11.png)
    
    ## **Q1.**
    In the following code, the `assign` keywords are commented out. What are the differences between the latch-like functionality of the `always` block and the `assign` statement?
    
    ```verilog
    module assign_block(in1, in2, out);
        input in1, in2;
        output out;
        assign out = in1 | in2;
        always @* begin out = in1 | in2; end
    endmodule
    ```
    
    ## **A1.**
    The `assign` statement is latch-like and has the same functional behavior as the `always` block. The `assign` statement does not have any delays because of the lack of combinational logic. `always @*` is a synchronous block that is similar to `always @(in1 or in2)`, but has a much longer combinational delay.
    
    ## **Q2.**
    Using the following code, write a testbench to test the function of the `assign` statement and the `always @*` block.
    
    ```verilog
    module assign_block(in1, in2, out);
        input in1, in2;
        output out;
        assign out = in1 | in2;
        always @* begin out = in1 | in2; end
    endmodule
    ```
    
    ## **A2.**
    ```verilog
    module tb_or_fr();
        logic [1:0] in1, in2, out;
        assign_block ib(.in1(in1),.in2(in2),.out(out));

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(out, din1, din2);
      input din1, din2; wire out;
      string s="or_fr,rl";
      // The following structure contains both a logic vector and a string
      struct { logic [3:0] out; string name; } out_str;
      // The following typedef defines the type of the unpacked
      // structure containing the data and name fields
      typedef struct { logic [3:0] out; string name; } output_str_t;
      assign out_str.out = din1 | din2;
      assign out_str.name = s;
      assign out = out_str.out;
    ```
    ### Reference:
    * [Verilog HDL Simulation - Part 2](https://www.vlsm

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
      initial begin
        $display("**************************\
        \n  Structural Port Connection:");
        dd.DataIn.b = 1'b1;
        dd.DataIn.c = 1'b1;
        dd.DataOut.a = 1'b0;
        dd.DataOut.b = 1'b0;
        dd.DataOut.c = 1'b0;
      end
    
      initial begin
        $display("**************************\
        \n  Behavioral Port Connection:");
        dd.DataIn = '{b:1'b1, c:1'b1};
        dd.DataOut = '{a:1'b0, b:1'b0,

- code: |-
    module orfr_tst(
    ); // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(
        output wire a, input wire b, input wire c
    ); // Module containing force/release
        typedef struct packed {
            logic [7:0] data_in;
            string msg_in;
        } or_struct;
        or_struct data_in;
        or_struct data_out;
        
        always_comb begin
            data_in.data_in = b;
            data_in.msg_in = "I am B.";
            data_out.data_in = data_in.data_in | c;
            data_out.msg_in = data_in.msg_in;
            $display("%s", data_out.msg_in);
            $display("%b",data_out.data_in);
        end
                    
        assign a = data_out.data_in;
    endmodule
    ### Test:
    ```
    vlib work
    vlog orfr_tst.v or_fr_rl.v
    vsim -novopt work.orfr_tst
    ```
    Result:
    ```
    Testbench initialisation
    
    b = 0
    data_in.data_in = 0
    "I am B."
    data_out.data_in = 0
    
    b = 0
    data_in.data_in = 0
    "I am B."
    data_out.data_in = 1
    
    b = 1
    data_in.data_in = 1
    "I am B."
    data_out.data_in = 1
    
    b = 0
    data_in.data_in = 0
    "I am B."
    data_out.data_in = 0
    
    b = 1
    data_

- code: |-
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(DataIn, DataOut); // Use a structure to hold inputs and outputs
      input [1:0] DataIn; // Now defined as an unpacked structure
      output [1:0] DataOut; // Now defined as an unpacked structure
      assign {DataOut.or_out, DataOut.or_str} = DataIn; // Structure member names are used to read/assig
      always @(DataIn) force DataIn.or_out = DataIn.or_in; // Force is applied only to data element #1
      always @(DataIn) release DataIn.or_str; // Release is applied only to data element #2
    endmodule
    module tst_or_st;
      logic [1:0] din, dout;
      initial begin din=2'b00; #20 $stop; end // Initialize inputs
      always #3 din = ~din; // Toggle input 'c' every 3 time units
      or_fr_rl or_st(din, dout); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(DataIn, DataOut); // Use a structure to hold inputs and outputs
      input [1:0] DataIn; // Now defined as an unpacked structure
      output [1:0] DataOut; // Now defined as an unpacked structure
      assign {DataOut.or_out, DataOut.or_str} = DataIn; // Structure member names are used to read/assig
      always @(DataIn) force {DataIn.or_out, DataIn.or_str} = DataIn; // Use structure element names
      // Also use structure names in this case
      always @(DataIn) release DataIn.

- code: |-
    ```
    module or_fr_rl (
      input wire DataIn.a,
      input wire DataIn.b,
    ...
      output wire DataOut.out
    );
    ...
    endmodule
    ```
    ```
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    ```
    ### Note:
    
    * It is not necessary to change the testbench.
    * This type of change is a **good** practice.
    * We can use a struct or a class instead of a union or a struct.
    
    ### Testbench Code:
    ```
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    ```
    
    ### Base Verilog Code:
    ```
    module or_fr_rl (      // OR gate with force/release
      input wire DataIn.a,
      input wire DataIn.b,
      input wire DataIn.c,
      output wire DataOut.out
    );
      DataOut dout;
      always @(posedge a or posedge b or posedge c)
        dout.out = a|b|c;  // OR combination
      assign DataOut.out = dout.out;
    endmodule
    ```
    ```
    module orfr_tst; // Testbench for OR gate with force/release
      reg b,c; wire a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always

- code: |-
    module orfr_tst(out); // Testbench for OR gate with force/release
      reg [31:0] b,c; wire [31:0] a;
      initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs
      always #3 c = ~c; // Toggle input 'c' every 3 time units
      or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    endmodule
    module or_fr_rl(dataOut,dataIn); // OR with force/release
      parameter IN1_W = 32;
      parameter DATA_W = 32;
      parameter STR_LEN = 32;
      parameter UL_LEN = 32;
      localparam ST_LEN = STR_LEN + UL_LEN + 1;
      localparam OUT_W = DATA_W + ST_LEN;
      reg [IN1_W-1:0] dataIn[0:1];
      wire [OUT_W-1:0] dataOut;
      always @(dataIn[0], dataIn[1]) begin
        dataOut = dataIn[0] | dataIn[1];
      end
      always @(dataOut) begin
        dataOut[OUT_W] = "1";
      end
    endmodule
    ### Simulation Result:
    
    >
    simulator: ModelSim 10.4c
    sources: orfr_tst.v;
    compile: orfr_tst.v -o orfr_tst.v.exe;
    simulate: orfr_tst.v.exe;
    ###
    **Warning: (vsim-3032) Data types and data sizes do not match.
      The value on the left is of type 'int' and the value on the
      right is of type'struct'.
    ###
    
    sources: orfr_tst.v;
    compile: orfr_tst.v -o orfr_tst.v.exe;
    simulate: orfr_tst.v.exe;
    ###
    **Warning: (vsim

- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
        (Clk *> ArgA)  = $unsigned(ArgA);
        (Clk *> ArgB)  = $unsigned(ArgB);
        (Clk *> OverFLow) = (ArgA + ArgB) > 2**32;
    endmodule
    ### Description of Variation:
    The $unsigned operator is used to convert the values of ArgA and ArgB to unsigned binary numbers. This will help in testing unsigned arithmetic operations.
    ### Example
    ```verilog
    module CLU (output[

- code: |-
    ```verilog
    module ALU_signed (output logic signed [3:0] Result, input logic signed [3:0] ArgA, ArgB, input logic Clk);
    wire signed [4:0] x = ArgA, y = ArgB, sum;
    assign sum = x + y;
    assign Result = x[3]? -sum[4:0] : sum[4:0];
    specify
    	specparam tRise = 5, tFall = 4;
    	(Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
    ```
    ### Simulation
    * Run simulation
    ![alt text](https://github.com/adnan-sagar/RISCV-CPU/blob/master/lab02/lab02SimOV.PNG)
    * Output waveform
    ![alt text](

- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specparam tRise = 5, tFall = 4;
        logic signed [3:0] iA, iB;
        logic[31:0] sResult;
        (Clk *> iA) = (tRise, tFall);
        (Clk *> iB) = (tRise, tFall);
        (Clk*>sResult) = (tRise, tFall);
        iA = ArgA[3:0];
        iB = ArgB[3:0];
        if(sResult[2] == 1 || sResult[2] == 0) begin
            (Clk*>Result) = (tRise, tFall);
            Result = sResult[31:0];
        end
        else begin
            (Clk*>Result) = (tRise, tFall);
            Result = 32'hFFFFFFFF;
        end
    endspecify
    endmodule
    ### Testbench Code:
    module Top;
    logic a[31:0], b[31:0], c[31:0];
    logic clk;
    logic[31:0] r, r0;
    logic signed [3:0] ia, ib;
    logic [31:0] sResult;
    
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> a) = (tRise, tFall);
        (Clk *> b) = (tRise, tFall);
        (Clk *> c) = (tRise, tFall);
        (Clk *> clk) = (tRise, tFall);
    endspecify
    
    ALU DUT(.Result(r),.ArgA(a),.ArgB(b),.Clk(clk));
    
    initial begin
        clk = 0;
        a = 'h12345678;
        b = 'h9ABCDEF0;
        c =

- code: |-
    module Mux4 (out, in1, in2, in3, in4, in5, in6, in7, in8, sel);
    specify
        specparam tRise = 2, tFall = 3;
        (Clk *> out) = (tRise, tFall);
    endspecify
    endmodule
    
    ### Base Verilog Code:
    module Mux8_16 (output[15:0] Result, input[15:

- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
        assign ArgA = $signed(ArgA);
        assign ArgB = $signed(ArgB);
    endspecify
    endmodule
    ### Expected Result:
    * Result = $signed(ArgA) + $signed(ArgB)
    ### Pass Criteria:
    * Output should be correct for all test cases.
    
    ### Testcase:
    1. Addition of two positive signed numbers.
    ```verilog
    module tb;
      logic Clk = 0;
      always #5 Clk = ~Clk;
      logic [31:0] Result;
      logic [31:0] ArgA = 42;
      logic [31:0] ArgB = 8;
      ALU uut (.*);
    endmodule
    ```
    ### Expected Result:
    * Result = 50
    ### Pass Criteria:
    * Output should be correct for all test cases.
    ### Testcase:
    2. Addition of two negative signed numbers.
    ```verilog
    module tb;
      logic Clk = 0;
      always #5 Clk = ~Clk;
      logic [31:0] Result;
      logic [31:0] ArgA = -42;
      logic [31:0] ArgB = -8;
      ALU uut (.*);
    endmodule
    ```
    ### Expected Result:
    * Result = -50
    ### Pass Criteria:
    * Output should be correct for all test cases.
    
    ### Testcase:
    3. Subtraction of two positive signed numbers.
    ```verilog
    module tb;
      logic Clk = 0;
      always #5 Clk = ~Clk;
      logic [31:0] Result;
      logic [31:0] ArgA = 42;
      logic [31:0] ArgB = 8;
      ALU uut (

- code: |-
    module ALU (input[3:0] ArgA, ArgB, input Clk, output logic Result, input Clock);
    specify
        specparam tRise =

- code: |-
    module ALU_Signed (output[31:0] Result, input[31:0] ArgA, ArgB, input clk);
    specify
        specparam tRise = 5, tFall = 4;
        (clk *> Result) = (tRise, tFall);
        (Clk *> ArgA) = (tRise, tFall);
        (Clk *> ArgB) = (tRise, tFall);
    endspecify
    endmodule
    ### Scope:
    - ALU_Signed: The resulting logic data (Result) is unsigned, and should be converted to signed data.
    ### Expected Result:
    The ALU_Signed module should pass any test that was previously passing with the ALU module.
    ### Failures:
    - The ALU_Signed module does not perform the arithmetic operations on the signed data.
    ### Modification:
    The input and output value type signatures need to be modified to be signed as well as the test code to properly compare the output.
    ### Code:
    ```
    module ALU_Signed (output logic signed [31:0] Result, input logic signed [31:0] ArgA, ArgB, input logic Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
        (Clk *> ArgA) = (tRise, tFall);
        (Clk *> ArgB) = (tRise, tFall);
    endspecify
    endmodule
    
    module TB_ALU_Signed();
    reg Clk;
    reg signed [31:0] ArgA;
    reg signed [31:0] ArgB;
    wire logic signed [31:0] Result;
    ALU_Signed alu_signed(Result, ArgA, ArgB, Clk);
    initial begin
        Clk = 0;
        repeat(100) # 10;
        ArgA = 10;
        ArgB = 5;
        repeat(10) # 10;
        Clk = 1;
        repeat

- code: |-
    module ALU_Tester();
    
    logic Clk;
    wire[31:0] Result;
    wire[3:0] ArgA, ArgB;
    wire[31:0] C;
    ALU alu(.Result(Result),.ArgA(ArgA),.ArgB(ArgB

- code: |-
    ```verilog
    // --------------------------------------------	
    module ALU(output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 7, tFall = 6;
        (Clk *> Result) = (tRise, tFall);
        (Clk *> ArgA)

- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
        //logic [3:0] a, b;
        int a, b;
    endspecify
    endmodule
    ### DUT:
    assign a = ArgA[3:0];
    assign b = ArgB[3:0];
    # Add
    assign Result[3:0] = a[3:0] + b[3:0];
    # Subtract
    assign Result[3:0] = a[3:0] - b[3:0];
    
    ### Testbench:
    # Add
    tb_Result = tb_ArgA + tb_ArgB;
    # Subtract
    tb_Result = tb_ArgA - tb_ArgB;

- code: |-
    module show_aa(o,i); // NOT gate with delay 2
      output [7:0] o; input [7:0] i; wire [7:0] o, i;
      not #2 (o[5],i[5]); not #2 (o[4],i[4]); not #2 (o[3],i[3]); not #2 (o[2],i[2]); not #2 (o[1],i[1]); not #2 (o[0],i[0]);
    endmodule
    ### Test Cases:
    #### Test with default value:
      Input:
      ```
      parameter A = 1, B = 2;
      show_aa a1 (.o(o[0]),.i(i));
      show_aa a2 (.o(o[1]),.i(i));
      show_aa a3 (.o(o[2]),.i(i));
      show_aa a4 (.o(o[3]),.i(i));
      show_aa a5 (.o(o[4]),.i(i));
      show_aa a6 (.o(o[5]),.i(i));
      show_aa a7 (.o(o[6]),.i(i));
      ```
      Output:
      ```
      0x00
      ```
    #### Test with all non-default values:
      Input:
      ```
      parameter A = 0, B = 0;
      show_aa a1 (.o(o[0]),.i(i));
      show_aa a2 (.o(o[1]),.i(i));
      show_aa a3 (.o(o[2]),.i(i));
      show_aa a4 (.o(o[3]),.i(i));
      show_aa a5 (.o(o[4]),.i(i));
      show_aa a6 (.o(o[5]),.i(i));
      show_aa a7 (.o(o[6]),.i(i));
      ```
      Output:
      ```
      0x7f
      ```
    #### Test with default value, non-default value, default value, and non-default value:

- code: |-
    module show_bb(ao,ai); // NOT gate with delay 2
      output ao; input ao,ai;
      enum logic { default=0, non_default=1} ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Test Code:
    initial
      begin
        integer i;
        show_bb out_aa, in_bb; // Declare an instance
        for (i=0; i<1000; i++)
          begin
            in_bb=i;
            in_bb=in_bb?default:non_default;
            @(posedge out_aa.ao); // Tick the clock
            $display("ao is %b", out_aa.ao);
          end
    end
    ### Expected:
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao is 1
    ao is 0
    ao

- code: |-
    module show_aa_mod(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Parameters:
    None
    ### Sources:
    None
    ### RTL:
    ao = ~ai;
    ### Simulation:
    A: 1, B: 1 -> ao = 0
    A: 0, B: 0 -> ao = 1
    A: 0, B: 1 -> ao = 1
    A: 1, B: 0 -> ao = 0
    A: 1, B: 2 -> ao = 1
    A: 2, B: 1 -> ao = 0
    A: 2, B: 2 -> ao = 1
    ### Summary:
    enum values can be used as input to gates and other logic blocks.
    ### Related:
    None
    ### Similar:
    None
    ### Variation:
    None
    ### References:
    None
    ### Future Extensions:

- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      parameter A_DEF = 3'b101;
      parameter B_DEF = 3'b110;
      parameter A_NON_DEFAULT = 3'b100;
      parameter B_NON_DEFAULT = 3'b011;
      parameter WIDTH_DEF = 3; 
      parameter WIDTH_NON_DEFAULT = 3;
      localparam DEFAULT_WIDTH = 8;
      localparam DEFAULT_WIDTH_2  = 8;
      typedef enum logic [WIDTH_NON_DEFAULT-1:0] {
        ENUM_ZERO = 3'b000,
        ENUM_ONE = 3'b001,
        ENUM_TWO = 3'b010,
        ENUM_THREE = 3'b011,
        ENUM_FOUR = 3'b100,
        ENUM_FIVE = 3'b101,
        ENUM_SIX = 3'b110,
        ENUM_SEVEN = 3'b111
      } packed_enum;
      logic [WIDTH_DEF-1:0] a;
      logic [WIDTH_DEF-1:0] b;
      always_comb begin
        a = ai;
        b = ai;
      end
      packed_enum a_packed;
      packed_enum b_packed;
      always_comb begin
        a_packed = a;
        b_packed = b;
      end
      always_comb ao = (a_packed == ENUM_ONE && b_packed == ENUM_TWO);
    endmodule
    ### Unit Under Test (UUT):
    module top ();
      wire a;
      wire b;
      wire ao;
      show_aa SHOW_AA_inst0 (ao, a);
      show_aa SHOW_AA_inst1 (b, a);
      assign a = 3'b001;

- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Synthesized Code:
    (* LOC=LOC, KEEP, DONT_TOUCH *)
    (* FAMILY="FAMILY", MEM_INIT4={0,0,1,1,1,0,0}, MEM_INIT5={
      0,1,1,1,1,0,0} *)
    module SHOW_AA_X0 (ao, ai);
      output ao;
      input ai;
      wire ao, ai;
      reg ao, ao0, ao1, ai;
      wire ao, ai;
      not #2 (ao0, ai);
      not #2 (ao1, ao0);
      not #2 (ao, ao1);
    endmodule
    
    module show_aa_1(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_2(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_3(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_4(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_5(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_6(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    
    module show_aa_7(ao,ai); // NOT gate with delay 2
      output

- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Test bench code:
    module show_aa_tb;
      wire a, b, c, d;
      show_aa #(.A(a),.B(b)) a_gate(c,d);
      show_aa #(.A(b),.B(a)) b_gate(d,c);
      initial begin
        $monitor("%d %d %d %d",$time,a,b,c,d);
        fork
          f1; f2;
        join
      end
      task f1;
        begin
          a = 1'bX; b = 1'b1; #100;
        end
      endtask
      task f2;
        begin
          b = 1'b0; #1000;
        end
      endtask
    endmodule
    ### Simulation Log:
    ```
     0 ps 0 0 0 0 
    100 ps 1 1 1 0 
    100 ps 1 0 1 0 
    150 ps 1 0 1 0 
    200 ps 1 0 1 0 
    250 ps 1 0 1 0 
    300 ps 1 0 1 0 
    350 ps 1 0 1 0 
    400 ps 1 0 1 0 
    450 ps 1 0 1 0 
    500 ps 1 0 1 0 
    550 ps 1 0 1 0 
    600 ps 1 0 1 0 
    650 ps 1 0 1 0 
    700 ps 1 0 1 0 
    750 ps 1 0 1 0 
    800 ps 1 0 1 0 
    850 ps 1 0 1 0 
    900 ps 1 0 1 0

- code: |-
    module show_ac(ao,ai); // AND gate
      output ao; input ai; wire ao, ai;
      typedef enum {a=0,b=4,c=8} x;
      x a, b; //a,b are enums
      x c = c; //c is default value of c
      and #2 (ao,ai);
    endmodule
    ### Original Code:
    module show_ad(ao,ai,bi); // A and B should be ignored
      output ao; input ai, bi; wire ao, ai, bi;
      and #2 (ao,ai);
    endmodule
    ### Variation Instruction:
    Change A and B from logic to packed enums

- code: |-
    module test_enum (a,b,c,d,e,f,g,h,i,j,k,l,m,n);
    	parameter x = 3, y = 3, z = 1;
    	output a,b,c,d,e,f,g,h,i,j,k,l,m,n;
    	input [2:0] c,d,e,f,g,h,i,j,k,l,m,n;
    	wire abcd = a && b && c && d;
    	wire abce = a && b && c && e;
    	wire abcf = a && b && c && f;
    	wire abcg = a && b && c && g;
    	wire abch = a && b && c && h;
    	wire abci = a && b && c && i;
    	wire abcj = a && b && c && j;
    	wire abcj = a && b && c && k;
    	wire abcj = a && b && c && l;
    	wire abcj = a && b && c && m;
    	wire abcj = a && b && c && n;
    	wire abcd = a && b && d;
    	wire abce = a && b && e;
    	wire abcf = a && b && f;
    	wire abcg = a && b && g;
    	wire abch = a && b && h;
    	wire abci = a && b && i;
    	wire abcj = a && b && j;
    	wire abcj = a && b && k;
    	wire abcj = a && b && l;
    	wire abcj = a && b && m;
    	wire abcj = a && b && n;
    	wire abcd = a && b && c;
    	wire abce = a && b && d;
    	wire abcf = a && b && e;
    	wire abcg = a && b && f;
    	wire abch = a && b && g;
    	wire abci = a && b && h;
    	wire abcj = a && b && i;
    	wire abcj = a && b && j;
    	wire abcj = a && b && k;

- code: |-
    module show_ab(ao,ai); // NOT gate with delay 2
      typedef enum {F1 = 0, F2 = 1} flag_type; // packed enum with 2 symbols
      output ao; input ai;
      wire ao, ai; logic a, b;
      assign a = ai; // unpacked input to packed input
      assign b = ai; // packed input to packed input
      not #2 (ao,a); not #2 (b); // unpacked input to packed input
      not #1 (ao, ai); // packed input to packed input
      // not #3 (ao,ai); // not allowed
    endmodule
    ### Simulation Logic:
    // Not allowed:
    // not #3 (ao,ai); // error: Illegal use of packed arrays (ao) as lvalue
    
    // Ok:
    // not #1 (ao, ai); // legal
    // not #2 (ao,a); // legal (a is unpacked)
    // not #2 (b); // legal (b is packed)
    ### Expected Result:
    Ao should be 1 on every clock.
    ### Simulation Logic:
    // not #1 (ao, ai); // legal
    // not #2 (ao,a); // legal (a is unpacked)
    // not #2 (b); // legal (b is packed)
    // not #3 (ao,ai); // error: Illegal use of packed arrays (ao) as lvalue
    ### Expected Result:
    Ao should not change on every clock.
    ### Actual Results:
    Ao should stay 0.
    ### Pass/Fail Criteria:
    Pass if Ao is not 1 on every clock; fail otherwise.
    
    ### Potential Problems:
    None
    
    ### Notes:
    None
    
    ### Design Goals:
    None
    
    ### Design Considerations:
    None
    
    ### Potential Future Changes:
    None
    
    ### 2019-04-23 14:34:20 UTC:
    
    ### Base Verilog Code:
    module show_ac(ao,ai,bj,bi);
      output ao; input ai,

- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Parameters:
    ### Example Timing Report:
    ### Example Code:
    module tb;
    timeprecision` 1ns;
    timeunit` 1ns;
    
    reg a, b, out;
    initial begin
      a = 0;
      b = 0;
      for (;;) begin
        #5; 
        if (a == 1 && b == 1) begin // not gate
          assert (out == 0) $display("Not gate working correctly!");
          else begin 
            $display ("Not gate faulty!");
          end
        end
        if (a == 0 && b == 1) begin // and gate
          assert (out == 0) $display("And gate working correctly!");
          else begin 
            $display ("And gate faulty!");
          end
        end
        if (a == 1 && b == 0) begin // or gate
          assert (out == 1) $display("Or gate working correctly!");
          else begin 
            $display ("Or gate faulty!");
          end
        end
        if (a == 0 && b == 0) begin // null gate
          assert (out == 0) $display("Null gate working correctly!");
          else begin 
            $display ("Null gate faulty!");
          end
        end
        $display ("a = %b, b = %b, out = %b", a, b, out);
      end
    end
    
    show_aa out (out, a);
    show_aa a (a, b);
    
    initial begin
      a = 0;
      b = 1;
      #25;
      a = 1;
      b = 0;
      #25;
      a = 1;
      b = 1;
      #25;
      a = 0;
      b = 0;
      #25;
      a = 0;
      b = 1;
      #25;
      a = 1;

- code: |-
    module tb_dff();
    reg [7:0] clk, resetn;
    wire [7:0] inst[0:99];
    wire [7:0] qe[0:99];
    reg [7:0] en;
    integer i;
    initial begin
        clk = 0;
        resetn = 0;
        en = 0;
        #10 resetn = 1;
    end
    dff_inst dff_i (inst[0], clk, resetn, qe[0]);
    always #(2) clk = ~clk;
    always @(posedge clk) begin
        if (en == 1'b1) begin
            for (i = 0; i < 100; i = i + 1) begin
                inst[i] = $random;
            end
            en = 0;
        end
    end
    always @(posedge clk) begin
        if (en == 1'b1) begin
            $display("%8d %1b %8b %8b %8b", clk, en, inst[0], inst[1], qe[0]);
        end
    end
    endmodule
    
    ### Simulation:
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hilight.js/0.12.0/hilight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <div id="dff_sim" markdown="1">
    ```verilog
    #10 resetn = 1;
    #10 en = 1;
    #10 en = 0;
    #11 en = 1;
    #11 en = 0;
    #12 en = 1;
    #12 en = 0;
    #13 en = 1;
    #13 en = 0;
    #14 en = 1;
    #14 en = 0;
    #15 en = 1;
    #15 en = 0;
    #16 en = 1;
    #16 en = 0;
    #17 en = 1;
    #17 en

- code: |-
    module tb_dff();
      localparam N = 10;
    
      reg [0:N-1] D_array;
      reg Clock, Resetn;
    
      wire [0:N-1] Q_array;
      wire Q;
    
      dff_array dut(D_array, Clock, Resetn, Q_array);
    
      initial begin
        Clock = 0;
        Resetn = 1;
    
        #100;
        Clock = 1;
        for (int i = 0; i < N; i = i + 1) begin
          #1 D_array[i] = i;
        end
        #100;
        Clock = 0;
        for (int i = 0; i < N; i = i + 1) begin
          #1 $display("D[%3d]=%3d, Q=%3d", i, D_array[i], Q_array[i]);
        end
        Resetn = 0;
        #100;
        Resetn = 1;
    
        for (int i = 0; i < N; i = i + 1) begin
          #1 $display("Q[%3d]=%3d", i, Q_array[i]);
        end
        $finish;
      end
    endmodule
    
    module dff_array(
      input [0:N-1] D,
      input Clock,
      input Resetn,
      output [0:N-1] Q);
    
      lpm_ff flipflop_array[0:N-1] (
       .data(D[0:N-1]),
       .aclr(Resetn),
       .clock(Clock),
       .q(Q[0:N-1]));
    
      defparam flipflop_array.lpm_width = 1;
    endmodule
    ### Expected Results:
    Q = 0, Q = 1, Q = 2, Q = 3, Q = 4, Q = 5, Q = 6, Q = 7, Q = 8,

- code: |-
    Modify the code at line 19 to line 33 to include a 4-bit data width. The code must generate a 4-bit long shift register.
    ```
    module dff_4_inst(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock;
    input Resetn;
    output [3:0] Q;
    integer i;
    integer N;
    initial N = 4;
    reg [3:0] Q_reg;
    always @

- code: |-
    ```
    module testbench;
    reg Clk, Resetn;
    integer i;
    reg [31:0] data_in_array[3:0];
    wire [31:0] Q;
    
    dff_inst dff_inst0 (data_in_array[0], Clk, Resetn, Q);
    dff_inst dff_inst1 (data_in_array[1], Clk, Resetn, Q);
    dff_inst dff_inst2 (data_in_array[2], Clk, Resetn, Q);
    dff_inst dff_inst3 (data_in_array[3], Clk, Resetn, Q);
    
    initial
    begin
        Clk = 0;
        Resetn = 1;
    end
    
    always #0.5 Clk = ~Clk;
    
    initial begin
        #5 Resetn = 0;
        data_in_array[0] = 32'd1;
        data_in_array[1] = 32'd2;
        data_in_array[2] = 32'd3;
        data_in_array[3] = 32'd4;
        #10 Resetn = 1;
        data_in_array[0] = 32'd5;
        data_in_array[1] = 32'd6;

- code: |-
    module test_dff_inst();
    // Inputs
    reg [1:0] D;
    reg Clock;
    reg Resetn;
    integer i;
    reg [1:0] Q;
    initial begin
    $dumpfile("dff_inst_tb.vcd");
    $dumpvars;
    // End of initial block
    // Test case 1
    i = 0;
    while (i < 6) begin
        D = i;
        Clock = 0;
        Resetn = 1;
        #10;
        Resetn = 0;
        #10;
        Resetn = 1;
        #10;
        Clock = 1;
        #10;
        Clock = 0;
        // Checking for output
        assert(Q == D) else
        $display("Q is %d and D is %d",Q,D);
        i = i + 1;
    end
    // End of test case 1
    // Test case 2
    i = 0;
    while (i < 6) begin
        D = i;
        Clock = 0;
        Resetn = 1;
        #10;
        Resetn = 0;
        #10;
        Resetn = 1;
        #10;
        Clock = 1;
        #10;
        Clock = 0;
        #10;
        Clock = 1;
        #10;
        Clock = 0;
        // Checking for output
        assert(Q == D) else
        $display("Q is %d and D is %d",Q,D);
        i = i + 1;
    end
    // End of test case 2
    // End of testcases
    // Testbench termination
    $finish;
    end// end of testbench
    endmodule
    ### Modified Output:
    # Q is 6 and D is 0
    # Q is 5 and D is 0
    # Q is 4 and D is 0
    # Q is 3 and D is 0
    # Q is 2 and D is 0
    # Q is 1 and

- code: |-
    module tb_dff_inst;
      logic [1:0] din;
      logic clock, resetn;
      logic [1:0] q;
      dff_inst u0(din, clock, resetn, q);
      dff_inst u1(din, clock, resetn, q);
    
      initial begin
        din = 2'b00;
        resetn = 1'b0;
        #10;
        resetn = 1'b1;
        #10;
        din = 2'b01;
        #10;
        din = 2'b11;
        #5;
        din = 2'b01;
        #20;
        $finish;
      end
    
      initial begin
        clock = 1;
        forever #10ns clock = ~clock;
      end
      initial begin
        $fsdbDumpfile("dff_inst.fsdb");
        $fsdbDump

- code: |-
    ``` verilog
    module dff_testbench;
    reg D;
    reg Clock;
    reg Resetn;
    wire Q;
    reg [NUM_QS-1:0] dff_inst_inst_s0_pSelect_bus;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pSelect_bus_1;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pSelect_bus_2;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pSelect_bus_3;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pSelect_bus_4;
    reg dff_inst_inst_s0_pSelect_bus_we;
    reg [NUM_QS-1:0] dff_inst_inst_s0_pPData_bus;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPData_bus_1;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPData_bus_2;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPData_bus_3;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPData_bus_4;
    reg dff_inst_inst_s0_pPData_bus_we;
    reg dff_inst_inst_s0_pPData_bus_4_we;
    reg [NUM_QS-1:0] dff_inst_inst_s0_pPExt_bus;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPExt_bus_1;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPExt_bus_2;
    wire [NUM_QS-1:0] dff_inst_inst_s0_pPExt_bus_3;
    wire [NUM_QS-1:0

- code: |-
    module tb_lpm_ff();
    
    reg [7:0] input [3:0];
    reg Reset;
    reg Clock;
    reg [7:0] output;
    
    dff_inst dff (.D(input[0]),.Clock(Clock),.Resetn(Reset),.Q(output[0]));
    dff_inst dff1 (.D(input[1]),.Clock(Clock),.Resetn(Reset),.Q(output[1]));
    dff_inst dff2 (.D(input[2]),.Clock(Clock),.Resetn(Reset),.Q(output[2]));
    dff_inst dff3 (.D(input[3]),.Clock(Clock),.Resetn(Reset),.Q(output[3]));
    
    initial begin
        Clock = 0;
        Reset = 1;
        #5
        Reset = 0;
    end
    
    
    always
    begin
        Clock = #5 ~Clock;
    end
    
    sequence test_vector(inputs, outputs);
        @(posedge Clock) Resetn == 0;
        for(int i=0; i<4; i = i+1) 
        @(posedge Clock) $rose(inputs[i]) |=> $rose(outputs[i]);
    endsequence
    
    assert property(test_vector(input, output));
    endmodule
    ```
    
    ### 15.10 - 15.18
    
    ### Base Verilog Code:
    ```verilog
    module bcd_counter_inst(Clock, Resetn, Num, En, BCD);
    input Clock, Resetn;
    input [3:0] Num;
    input En;
    output [6:0] BCD;
    
    reg [3:0] cnt;
    reg [3:0] cntn;
    
    always @ (posedge Clock or negedge Resetn)
    begin
        if(~Resetn)
        begin
            cnt <= 0;
            cntn <= 0;
            BCD <= 0;
        end
        else
        begin
            cnt <=

- code: |-
    module tb_dff();
    logic CLK, RESETn;
    logic D, Q;
    integer index;
    logic [7:0] test_vectors

- code: |-
    reg [

- code: |-
    module latch (input d, c, output [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Test Bench Codes:
    module top();
    timeunit 1ns; timeprecision 1ps;
    logic d=0;
    logic c=0;
    wire [7:0] q;
    wire [7:0] q_b;
    latch test(d,c,q,q_b);
    defparam test.q=3;
    defparam test.q_b=3;
    initial begin
    ## Set Inputs
    d=0; c=0;
    ## Set Delay
    #10
    ## Set Outputs
    $display("Simulation Ended");
    $stop;
    end
    endmodule
    ### Output:
    Simulation Ended
    ### Expected Output:
    Simulation Ended
    ### Notes:
    ### See Also:
    See the following links for more details:
    1. https://www.edaplayground.com/x/X47X
    2. https://www.edaplayground.com/x/3z8P
    3. https://www.edaplayground.com/x/5ZqK
    4. https://www.edaplayground.com/x/qBQW
    5. https://www.edaplayground.com/x/H8jg
    6. https://www.edaplayground.com/x/6Bxg
    7. https://www.edaplayground.com/x/2h5y
    8. https://www.edaplayground.com/x/9qKX
    9. https://www.edaplayground.com/x/7DGg
    10. https://www.edaplayground.com/x/7G8G
    11. https://www.edaplayground.com/x/7H5q
    12. https://www.edaplayground.com/x/7NWq
    13. https://www.edaplayground.com/x/7ZGs
    14. https://www.edaplayground.com/x/9CpK
    15. https://www.

- code: |-
    module latch_param (input [7:0] d, c, output [7:0] q );
    genvar i;
    parameter w = 8;
    generate
    genvar j;
    if( w== 8 )begin
    for ( i = 0; i <= 7; i = i + 1 )
    begin:

- code: |-
    ```
    module latch (input d, c, output q, q_b );
    union u { reg [7:0] q_b; reg q; }
    union u_d;
    always begin
    wait ( c );
    u_d.q_b = d;
    q_b = u_d.q_b;
    q = u_d.q;
    end
    endmodule
    ```
    ### Listing of VHDL code:
    ```
    architecture Behavioral of latch is
        signal s_q : std_logic_vector(7 downto 0);
    begin
    p_latch : process (d, en)
    begin
    if (en = '1') then
    s_q <= d;
    else
    s_q <= s_q;
    end if;
    end process p_latch;
    q <= s_q; 
    end architecture Behavioral;
    ```
    ### Listing of VHDL reset and stimulus process from the testbench:
    ```
    p_reset_gen : process
    begin
    s_reset <= '0';
    wait for 45 ns;
    s_reset <= '1';
    wait for 5 ns;
    s_reset <= '0';
    wait for 5 ns;
    end process p_reset_gen;
     
    p_stimulus : process
    begin
    report "Stimulus process started" severity note;
    s_d <= "0000";
    
    wait for 30 ns;
    s_d

- code: |-
    module latch (input d, c, output logic [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Simulation Output:
    sim > add wave /* add all sigs */
    sim > run 1000 /* run 1000 sim clks */
    Time: 0 ps  Iteration: 0  Instance: /latch
    d                                                       : 0
    c                                                       : 1
    q                                                       : x
    q_b                                                     : x
    
    Time: 1000 ps  Iteration: 1  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 2000 ps  Iteration: 2  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 3000 ps  Iteration: 3  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 4000 ps  Iteration: 4  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 5000 ps  Iteration: 5  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 6000 ps  Iteration: 6  Instance: /latch
    d                                                       : 1
    c                                                       : 1
    q                                                       : 1
    q_b                                                     : 0
    
    Time: 7000 ps  Iteration: 7  Inst

- code: |-
    module latch (input d, c, output [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Simulation:
    simulator: ModelSim 10.3
    ### Passed:
    yes
    ### Skipped:
    no
    ### Failed:

- code: |-
    module latch_

- code: |-
    module latch (input d, c, output latch_type q, q_b );
      latch_type tmp;
      always begin
        wait ( c );
      end
    endmodule
    ### Simulation Setup
    - `Verilog` file: `latch.v`
    - `TOP` file: `latch.v`
    - `uut` module: `latch`
    ### Sythesis Results
    <!--- Add images of both sythesis and simulation setup --->
    ### Simulation Results 1
    <!--- Add a screenshot of simulation --->
    ### Simulation Results 2
    <!--- Add a screenshot of simulation --->
    ### Simulation Results 3
    <!--- Add a screenshot of simulation --->
    ### Conclusion
    <!--- Add a conclusion to this test --->
    ### Reference
    - https://www.xilinx.com/support/answers/31965.html
    ### Additional Information
    <!--- Add any additional information that the reviewer should know --->
    
    ### Reviewer Comments
    - The test needs to be run with -sv (V

- code: |-
    module latch (input d, c, output reg [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Additional Comments:
    The packed union is a union containing several different types of data, which can be useful for passing a single value that can be multiple types (most commonly an integer in a union with a single bit representing the value's type--the first packed union in this test).
    ### Known Unsupported Operations:
    - Combinational logic in the form of always_comb. 
    - Multi-state latches.
    ### Passing test cases:
    - When the input value is a packed union, the value of the output is the value of the input.
    ### Failing test cases:
    - When the input value is not a packed union, the value of the output is not the value of the input.
    - When the input value is a packed union containing more than one element, the value of the output is not the value of the input.
    ### Expected Output:
    Regression output should be identical to original.
    ### Significance:
    The packed union data type allows a single value to be represented in multiple

- code: |-
    module latch (input d, c, output [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Passed Simulation:
    - N
    ### Expected Simulation:
    - Y
    #### Screenshot:
    ![simulation1](screenshots/04_simulation1.jpg)
    ### Passed Synthesis:
    - N
    ### Expected Synthesis:
    - Y
    #### Synopsis:
    - No module instantiation due to lack of argument for port q_b.
    #### Screenshot:
    ![synthesis1](screenshots/04_synthesis1.jpg)
    ### Passed FMax:
    - N
    ### Expected FMax:
    - Y
    #### Screenshot:

- code: |-
    module latch (input d, c, output reg q, q_b );

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    reg c; c = 0;
    always @(posedge clk)
      begin
        $display("c=%b", c);
        if(c == 0)
          c = 1;
        else
          c = 0;
        case(c)
          1:
            begin
              assign g = (x1 & x3) | (x2 & x4);
              assign h = (x1 | x3) & (x2 | x4);
              assign f = g | h;
            end
          0:
            begin
              assign g = (x3 & x1) | (x4 & x2);
              assign h = (x3 | x1) & (x4 | x2);
              assign f = g | h;
            end
        endcase
      end
    endmodule
    ### Final Code including randomization:
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    reg c; c = 0;
    always @(posedge clk)
      begin
        $display("c=%b", c);
        if(c == 0)
          c = 1;
        else
          c = 0;
        case(c)
          1:
            begin
              assign g = (x1 & x3) | (x2 & x4);
              assign h = (x1 | x3) & (x2 | x4);
              assign f = g | h;
            end
          0:
            begin
              assign g = (x3 & x1) | (x4 & x2);
              assign h = (x3 | x1) & (x4 | x2);
              assign f = g

- code: |-
    module example4(x1, x2

- code: |-
    ```verilog
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    rand bit a;
    rand bit b;
    rand bit c;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = 1'b1;
    initial begin
    $display("begin, a = %d, b = %d, c = %d", a, b, c);
    wait(a);
    $display("wait a, a = %d, b = %d, c = %d", a, b, c);
    wait(b);
    $display("wait b, a = %d, b = %d, c = %d", a, b, c);
    wait(c);
    $display("wait c, a = %d, b = %d, c = %d", a, b, c);

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);

- code: |-
    module example4_tb(x1, x2, x3, x4, f, g, h, done);
    rand bit x1, x2, x3, x4;
    wire f, g, h;
    wire done;
    example4 uut(.x1(x1),.x2(x2),.x3(x3),.x4(x4),.f(f),.g(g),.h(h));
    initial begin
        x1 = 1'bx;
        x2 = 1'bx;
        x3 = 1'bx;
        x4 = 1'bx;
        #10;
        c = 1;
        while (c <= 10) begin
            #10;
            c = c + 1;
        end
        $finish;
    end
    initial begin
        $display("f=%b, g=%b, h=%b, done=%b", f, g, h, done);
    end
    endmodule
    ### Verification Passed:
    ### Passed on DS-5

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    
    // Replace the wait(c) statement with a blocking assignment inside a structure containing rand members
    struct {
    	rand bit x;
    	rand bit y;
    } c;
    
    initial begin
    	@(posedge clk);
    	wait(x1); // Wait until x1 goes high
    	c.x = x1;
    	c.y = x2;
    	repeat(4) @(posedge clk);
    	f = 1'b1;
    end
    
    endmodule
    ### Simulation Output:
    Time | x1 | x2 | x3 | x4 | f | g | h
    -----|----|----|----|----|---|---|---
    0    | 0  | 0  | 0  | 0  | 0 | 0 | 0
    4    | 0  | 0  | 0  | 0  | 0 | 0 | 0
    8    | 0  | 0  | 0  | 0  | 0 | 0 | 0
    12   | 0  | 0  | 0  | 0  | 0 | 0 | 0
    20   | 1  | 0  | 0  | 1  | 0 | 1 | 1
    24   | 1  | 1  | 1  | 1  | 0 | 1 |

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    // The line below is the only line that changed
    output wire f;
    input x1, x2, x3, x4;
    output f, g, h;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    wire [3:0] c;
    
    always @(*)
    begin
        if (c == 0)
            f = 1'b0;
        else
            f = 1'b1;
    end
    
    endmodule
    ###

- code: |-
    module example6(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    reg [5:0] c = 0;
    string s = "";
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    always @(posedge x1 | posedge x2)
    begin
    if (x1)
    c = $random();
    else
    c = $random();
    end
    always @(posedge x2 | posedge x3)
    begin
    if (x2)
    c = $random();
    else
    c = $random();
    end
    endmodule
    ### Modified Testbench:
    module example4_tb();
    wire x1, x2, x3, x4;
    wire f, g, h;
    reg [5:0] c = 0;
    string s = "";
    assign x1 = $random();
    assign x2 = $random();
    assign x3 = $random();
    assign x4 = $random();
    example4 dut(.x1(x1),.x2(x2),.x3(x3),.x4(x4),.f(f),.g(g),.h(h));
    initial begin
    c = $random();
    for (int i = 0; i < 5; i = i+1)
    begin
        if (c[i])
    s = {s, "1"};
    else
    s = {s, "0"};
    end
    if (c > 31)
    $display("WARNING: rand value outside of bitstring range");
    $display("rand value: %b = %s", c, s);
    end
    initial begin
    wait (x1 | x2);
    c = $random();
    for (int i = 0; i < 5; i = i+1)
    begin
        if (c[i])
    s = {s, "1"};
    else
    s = {s, "0"};
    end

- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    
    initial begin
    #10
    f = g | h;
    end
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (

- code: |-
    module par(in, parity, all_ones);
    input logic [7:0] in;
    output logic parity, all_ones;
    struct packed {
    	logic [7:0] x;
    } in;
    assign parity = ^in.x;
    assign all_ones = &in.x;
    endmodule
    ### Expected output:
    - parity = x ^ x ^ x ^ x
    - all_ones = (x & x & x & x)
    
    
    ## Testcase 11
    ### Base Verilog Code:
    module par(in, parity, all_ones);
    input logic [7:0] in;
    output

- code: |-
    module packed_array_parity(in, size);
    parameter SIZE = 4;
    struct packed [SIZE-1:0] in;
    output xor_in, and_in;
    assign xor_in = ^in;
    assign and_in = &in;
    endmodule
    ### Variation

- code: |-
    module par_struct(in, parity, all_ones);
    input [3:0] in;
    output parity, all_ones;
    struct packed {
    	logic [2:0] a;
    	logic b;
    } unpacked_struct;
    assign unpacked_struct = {in[2:0], in[3]};
    assign parity = ^unpacked_struct.a;
    assign all_ones = &unpacked_struct.a;
    endmodule
    ### Expected Result:
    Verilog should compile successfully.
    ### Pass Criterion:
    Verilog should compile successfully.
    ### Troubleshooting Tips:
    * Ensure that the struct is marked as `packed`.
    * Ensure that the struct is unpacked properly.
    ### Known bugs:
    * None.

- code: |-
    module struct(x1, x2, x3, x4, result_x1, result_x2, result_x3, result_x4);
    input [7:0] x1, x2, x3, x4;
    output [7:0] result_x1, result_x2, result_x3, result_x4;
    // TODO: This is the bit that is changing
    struct { 
      logic x_1_bit_1;
      logic x_2_bit_2;
      logic x_3_bit_3;
      logic x_4_bit_4;
    } in;
    
    assign in.x_1_bit_1 = x1;
    assign in.x_2_bit_2 = x2;
    assign in.x_3_bit_3 = x3;
    assign in.x_4_bit_4 = x4;
    
    // struct to logic conversion
    logic [7:0] result_x1, result_x2, result_x3, result_x4;
    logic parity, all_ones;
    
    // TODO: This is the bit that is changing
    par p(in, result_x1, result_x2);
    
    // TODO: This is the bit that is changing
    struct s(in, result_x3, result_x4, parity, all_ones);
    
    endmodule
    ```
    
    ### Design Description
    
    The design uses struct-based modular interconnection to connect the four instances of the `par` module together. The `par` module is instantiated four times in the top-level `struct` module, each time with a new instance name. The struct-based interconnect consists of a crossbar and muxes. The crossbar contains a set of connections to the input lines, one per member of the structure. The muxes that route the output lines to the outputs of the `struct` module.
    
    The `par` module represents the structural interconnection between the four instances.
    
    ### Structural Code
    
    ```verilog
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    
    assign parity = ^in;
    assign all_ones = &in;
    end

- code: |-
    module test_struct(in, out);
    typedef struct {
    logic  [7:0] x1;
    logic  [7:0] x2;
    logic  [7:0] x3;
    logic  [7:0] x4;
    } test_t;
    input  test_t in;
    output test_t out;
    assign out.all_ones = ^in;
    assign out.parity   = ^in;
    endmodule
    ### Testbench Code:
    module test_struct_tb();
    test_struct  dut(in_struct, out_struct);
    logic [7:0] x1, x2, x3, x4;
    test_t in_struct, out_struct;
    reg [7:0] x1, x2, x3, x4;
    initial begin
    	//Initialize Inputs
    	#10;
    	//Wait 100 ns for global reset to finish
    	
    	while (true) begin
    		x1 = $random;
    		x2 = $random;
    		x3 = $random;
    		x4 = $random;
    		in_struct.x1 = x1;
    		in_struct.x2 = x2;
    		in_struct.x3 = x3;
    		in_struct.x4 = x4;
    		
    		#10;
    		//Check Outputs
    		if (out_struct.all_ones!= $onehot(in_struct)) begin
    			$display("ERROR : all_ones mismatch");
    		end
    		if (out_struct.parity!= $onehot0(in_struct)) begin
    			$display("ERROR : parity mismatch");
    		end
    		$display("all_ones

- code: |-
    module in_struct_out_struct_struct(in, out);
    input struct {
    logic [7:0] x1;
    logic [7:0] x2;
    logic [7:0] x3;
    logic [7:0] x4;
    } in;
    output struct {
    logic p;
    logic a;
    } out;
    assign out.p = ^in.x1;
    assign out.a = &in.x1;
    endmodule
    ### Sim

- code: |-
    module par(in, parity, all_ones);
    input [3:0][7:0] in;
    output parity, all_ones;
    assign parity = ^in;
    assign all_ones = &in;
    endmodule
    ### Simulation of Modified Code:
    ![Simulation](https://github.com/parth2702/CPEN-391-Digital-Design/blob/main/Labs/Task1/task1_sim3_testbench_100MHz.PNG)
    ### Modification Task 4:
    
    #### Description of task:
    Modify the code by removing the ‘assign’ keyword from the statements that perform the bitwise operations. Also, add a local wire for each bitwise operation.
    
    #### Steps to Modify:
    ### Base Verilog Code:
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    assign parity = ^in;
    assign all_ones = &in;
    endmodule
    ### Modification Task 4:
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    wire[7:0] tmp;
    logic parity_in, all_ones_in;
    assign parity_in = ^in;
    assign all_ones_in = &in;
    assign tmp = ^in;
    assign parity = parity_in;
    assign all_ones = all_ones_in;
    endmodule
    ### Simulation of Modified Code:
    ![Simulation](https://github.com/parth2702/CPEN-391-Digital-Design/blob/main/Labs/Task1/task1_sim4_testbench_100MHz.PNG)
    
    ### Modification Task 5:
    #### Description of task:
    
    Modify the code by removing the ‘assign’ keyword from the statements that perform the bitwise operations. Also, add a local wire for each bitwise operation. However, now connect each bitwise operation to a different wire.
    
    #### Steps to Modify:
    ### Base Verilog Code:
    module par(in,

- code: |-
    module par_struct(x1, x2, x3, x4, all_ones, parity);
    input [3:0] x1, x2, x3, x4;
    output all_ones, parity;
    logic all_ones_temp, parity_temp;
    struct packed {logic data; logic parity; logic all_ones;} a, b, c, d;
    assign a.data = x1[0];
    assign a.all_ones = ~a.data;
    assign a.parity = ^x1;
    assign b.data = x2[0];
    assign b.all_ones = ~b.data;
    assign b.parity = ^x2;
    assign c.data = x3[0];
    assign c.all_ones = ~c.data;
    assign c.parity = ^x3;
    assign d.data = x4[0];
    assign d.parity = ^x4;
    assign parity = ^(a.data, b.data, c.data, d.data);
    assign all_ones = &(a.all_ones, b.all_ones, c.all_ones, d.all_ones);
    endmodule
    ### Suggested Code to Test:
    module par_struct_tb;
    par_struct dut(
       .x1(1'b1),
       .x2(1'b1),
       .x3(1'b1),
       .x4(1'b1)
    );
    default clocking @(posedge clk);
        endclocking
        initial begin
            clk = 1;
            rst = 1;
            repeat (2) @(posedge clk);
            rst = 0;
            repeat (5) @(posedge clk);
        end
        always @(posedge clk);
        assert ($stable(dut.all_ones)) else $error("all_ones is not stable");
        assert ($stable(dut.parity)) else $error("parity is not stable");
        assert (dut.parity === 1) else $error("parity is %b, but should be 1", dut.parity);
        assert (

- code: |-
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    logic [7:0] in_v = in;
    logic parity_v, all_ones_v;
    assign parity_v = ^in_v;
    assign all_ones_v = &in_v;
    assign parity = parity_v;

- code: |-
    module par_struct(in, parity, all_ones);
    input [31:0] in;
    logic parity, all_ones;
    logic [7:0] x1, x2, x3, x4; // 0x1234
    assign x1 = in[15:8];
    assign x2 = in[7:0];
    assign x3 = in[23:16];
    assign x4 = in[31:24];

- code: |-
    module FourFlopsByteH #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? byte'(QWire) : 'bz;
    endmodule
    ### Reason for Modification:
    This test is used to test byte-type vector compatibility.
    ### Variation Verilog Code:
    module FourFlopsShortL #(parameter DClk = 2, DBuf =

- code: |-
    module FourFlopsStructH #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'b0;
    endmodule
    ### Verilator Final Structure (with all possible variations):
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructA;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructB;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructC;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructD;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructE;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructF;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructG;
    
    struct {
        wire [3:0] Q;
        wire [3:0] D;
        wire Ena;
        wire Clk;
    } FourFlopsStructH;
    
    //------------------------------------------------------------------------------

- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Modified Test:
    module FourFlopsStructLTest;
    parameter DClk = 2, DBuf = 1;
    reg[3:0] D;
    reg Ena;
    wire[3:0] Q;
    
    //Instantiate the structural code
    FourFlopsStructL #(DClk, DBuf) DUT (.Q(Q),.D(D),.Ena(Ena),.Clk(Clk));
    
    initial begin
    for(int i=0; i<128; i=i+1) begin
        D = i;
        Ena = 0;
        #1;
        Ena = 1;
        #DClk;
        Ena = 0;
        #1;
    end
    $stop;
    end
    endmodule
    ### Test Results
    Simulator Name: NCVPIM Version 7.0.012
    Simulation Time: 0.001 sec
    
    Simulation Timeline :
    
    Simulation Time:     0 ns
    
    Simulation Time:     1 ns
    
    Simulation Time:     2 ns
    
    Simulation Time:     3 ns
    
    Simulation Time:     4 ns
    
    Simulation Time:     5 ns
    
    Simulation Time:     6 ns
    
    Simulation Time:     7 ns
    
    Simulation Time:     8 ns
    
    Simulation Time:     9 ns
    
    Simulation Time:    10 ns
    
    Simulation Time:    11 ns
    
    Simulation Time:    12 ns
    
    Simulation Time:    13 ns
    
    Simulation Time:    14 ns
    
    Simulation Time:    15 ns

- code: |-
    module FourFlopsStructM #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Modified TestBench:
    module FourFlopsStructM_tb();
    reg[3:0] D;
    reg Ena;
    reg Clk;
    wire[3:0] Q;
    FourFlopsStructM #(DClk = 2, DBuf = 1) DUT(.Q(Q),.D(D),.Ena(Ena),.Clk(Clk));
    initial begin
    $dumpfile("FourFlopsStructM.vcd");
    $dumpvars(0, DUT);
    end
    initial clk=1'b1;
    always clk=#5 ~clk;
    initial begin
    D=4'b0000;
    #5;
    Ena=1'b1;
    #5
    D=4'b0001;
    #5
    D=4'b0010;
    #5
    D=4'b0011;
    #5
    D=4'b0100;
    #5
    D=4'b0101;
    #5
    D=4'b0110;
    #5
    D=4'b0111;
    #5
    D=4'b1000;
    #5
    D=4'b1001;
    #5
    D=4'b1010;
    #5
    D=4'b1011;
    #5
    D=4'b1100;
    #5
    D=4'b1101;
    #5
    D=4'b1110;
    #5
    D=4'b1111;

- code: |-
    module FourFlopsStructS_byte (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Original Verilog Code:
    module FourFlopsStructS_byte_param (DClk, DBuf, output[3:0] Q, input[3:0] D, input Ena, Clk);
    parameter DClk = 2;
    parameter DBuf = 1;
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? Q

- code: |-
    module TestModule #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    Qunit.module("Verilog Type Compatibility", {});
    Qunit.test("FourFlopsStructL: vector compatibility test with byte-type", function (ok) {
        var ok = QUnit.assert;
        var verilogCode ='module FourFlopsStructL #(parameter DClk = 2, DBuf = 1) '+
            '(output[3:0] Q, input[3:0] D, input Ena, Clk);'+
            'wire[3:0] QWire;'+
            'localparam DTot = DBuf + DClk;'+
            'DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));'+
            'assign #DTot Q = (Ena==1\'b1)? QWire : \'bz;'+
            'endmodule';
        var testBenchCode ='module TestModule #(parameter DClk = 2, DBuf = 1) '+
            '(output[3:0] Q, input[3:0] D, input Ena, Clk);'+
            'wire[3:0] QWire;'+
            'localparam DTot = DBuf + DClk;'+
            'DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));'+
            'assign #DTot Q = (Ena==1\'b1)? QWire : \'bz;'+
            'endmodule';
        var design = Util.getDesign({
            code: verilogCode,
            top: 'Test

- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Simulation Logic:
    `timescale 1ns/1ns
    
    module FourFlopsStructLTestbench();
    reg D [3:0] = 'b0;
    reg Ena;
    reg Clk;
    wire [3:0] Q;
    
    FourFlopsStructL #(8, 1) flops (.Q(Q),.D(D),.Ena(Ena),.Clk(Clk));
    
    always #5 Clk =!Clk;
    initial
    begin
        Ena = 'b1;
        D = 'b0;
        #10;
        D = 'b1;
        #20;
        D = 'b0;
        #20;
        D = 'b1;
        #10;
        D = 'b0;
        #20;
        D = 'b1;
        #20;
        D = 'b0;
        #20;
        D = 'b1;
        #20;
        D = 'b0;
        #20;
        D = 'b1;
        #10;
        D = 'b0;
        #20;
        D = 'b1;
        #20;
        D = 'b0;
        #20;
        D = 'b1;
        #30;
        D = 'b0;
        #20;
        D = 'b1;
        #20;
        D = 'b0;
        #20;
        D = 'b1;
        #20;

- code: |-
    module FourFlopsStructL1 #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Modified Verilog Code:
    module FourFlopsStructL1 #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Base Design:
    Two flops with structural connections, one with a buffer, the other without.
    ### Variation 1:
    Remove the buffer in the structural module.
    ### Variation 2:
    Declare the structural module to use a byte-type vector.
    ### Baseline Design:
    Two flops with structural connections, one with a buffer, the other without.
    ### Variation 1:
    Remove the buffer in the structural module.
    ### Variation 2

- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule

- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Cl

- code: |-
    ```
    module DFF (clk, input d, output q);
    //...
    endmodule
    `endif
    
    `ifndef DFF_WITH_UNION
    //...
    import "DPI-C" function void dff_with_union(logic [7:0] a, logic [7:0] b, logic [7:0] c, logic [7:0] d, logic [7:0] e, logic [7:0] f, logic [7:0] g, logic [7:0] h, logic [7:0] i, logic [7:0] j, logic [7:0] k);
    `define DFF_WITH_UNION
    module DFF (clk, input d, output q);
    //...
    endmodule
    `endif
    
    module DFF_WITH_UNION (
         input clk,
         input d,
         output q
    );
       timeunit 1ns;
       timeprecision 1ps;
    `ifdef USE_PLI
       parameter STEP = 10ns;
    `endif
       reg q_out;
       wire d_out, clk_out;
       reg [7:0] a, b, c, d, e, f, g, h, i, j, k;
    
    `ifdef USE_PLI
       initial begin
          a = 8'h11;
          b = 8'h22;
          c = 8'h33;
          d = 8'h44;
          e = 8'h55;
          f = 8'h66;
          g = 8'h77;
          h = 8'h88;
          i = 8'h99;
          j = 8'hAA;
          k = 8'hBB;
          dff_with_union(a,b,c,d,e,f,g,h,i,j,k);
       end
    `endif
    
       always begin
          #STEP
          $display("-- A = %0h", a);
          $display("-- B = %0h", b);
          $display("-- C

- code: |-
    module DFF (input logic clk, input logic D, output logic Q);
    DFF_PQT #(logic[7:0] packed_union) dut (
       .clk(clk),
       .D(D),
       .Q(Q)
    );
    endmodule
    #### Package Definition:
    package DFF_PQT;
    parameter logic [7:0] packed_union;
    endpackage
    ### Variation Inst

- code: |-
    module DFF (input [7:0] x, output reg [7:0] q);
    q <= x;
    endmodule
    
    ### Changes:
    - [Bugzilla 1541672] Incorrect portwidth for packed union
    ### Diff file:
    
    Diff file for bug 1541672:
    @@ -1,4 +1,4 @@
    -//

- code: |-
    module DFF(input wire [3:0] in, output wire [7:0] out);
    union packed {
      struct {
        logic [3:0] m;
        logic [7:0] n;
      } s_in;
      logic [7:0] u;
    } u_in;
    u_in.s_in.m = in;
    u_in.s_in.n = 1'b1;
    out = u_in.u;
    endmodule
    ### Expected Output:
    y = 4'b0101
    ### Simulation Output:
    y = 4'b1101
    ### Simulation Output Diff:
    y - 4'b1001 = 4'b0101
    ### Simulation Output Diff Expected:
    y - 4'b1001 = 4'b0101
    ### Code Modifications:
    Differences discovered during simulation.
    ### Simulation Log:
    
    #### Expected Behavior:
    ### Actual Behavior:
    ### Data:
    
    ### Data Dump:
    #### Simulation Log:
    #### Simulation Waveform:
    
    ### Explanation:
    #### Note:
    
    ### Impact On Other Features:
    #### Related Tests:
    #### Other Platforms:
    #### Notes:
    
    
    ### Summary:
    
    ### Test Name:
    DFFE-R-1
    ### Test Type:
    Full regression
    ### Requirements Covered:
    R-1
    ### Preconditions:
    #### Description:
    This test case verifies the implementation of a simple DFF (flip-flop) with an asynchronous reset.
    #### Test Steps:
    1. Set clk to 0 and rst_n to 0.
    2. Verify that the output is 1.
    3. Set clk to 1 and rst_n to 0.
    4. Verify that the output goes to 0.
    5. Set clk to 0 and rst_n to 1.
    6. Verify that the output goes to 1.
    #### Expected Results:
    1. The output should read a 1.

- code: |-
    module DFF (input logic [(1+2+3+4)*8-1:0] a, output logic [(1+2+3+4)*8-1:0] y);
    always_ff @(posedge clk)
    y <= a;
    endmodule
    
    module top();
      logic [3:0] a;
      logic [3:0] b;
      logic [3:0] c;
      
      DFF #(4) dff(a, b);
      DFF #(3) dff_1(b, c);
      
      Anding anding(.*);
      assign c = (dff_1, dff);
    
    endmodule
    
    ### Expected Output:
    y = 0x0
    ### Expected Dump File:
    # Variable Information
    
    # Instances:
    top = top@1 (anding@1, dff@1, dff_1@1, top@3)
    
    # Hierarchy
    
    top@3
      top@1 (anding@1, dff@1, dff_1@1, top@3)
      - anding@1
      - dff@1
      - dff_1@1
      top@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@1
      - anding@1
      - dff@1
      - dff_1@

- code: |-
    module Anding (input a, b, output y);
    and (y, a, b);
    endmodule
    
    ### Assumptions:
    None
    ### Test Cases:
    Test Case 1:
    ### Pass/Fail Criteria:
    Pass:
    - There are no errors in the log file.
    - There is no unexpected behavior when the code is simulated.
    ### Instructions to Build, Execute and Test the Module
    ##### Step 1:
    ```
    cd verilog-module-template-anding
    ```
    ##### Step 2:
    Create a new file called `anding.v` in the verilog folder.
    ##### Step 3:
    Copy the below design code into the `anding.v` design file.
    ```verilog
    module Anding (input a, b, output y);
    and (y, a, b);
    endmodule
    ```
    ##### Step 4:
    Add the following code inside the `testbench.v` file.
    ```verilog
    module testbench;
    
    logic [7:0] a = 0;
    logic [7:0] b = 0;
    logic [7:0] y = 0;
    
    logic [8:0] a_arr = 0;
    logic [8:0] b_arr = 0;
    logic [8:0] y_arr = 0;
    
    localparam DATA_WIDTH = 8;
    localparam NUM_OF_DATA = 2;
    
    Anding #(.DATA_WIDTH(DATA_WIDTH),.NUM_OF_DATA(NUM_OF_DATA)) UUT (
       .a(a_arr),
       .b(b_arr),
       .y(y_arr)
    );
    
    initial begin
        a_arr = 8'hA;
        b_arr = 8'hB;
        repeat (10) begin
            #10;
            a = a + 1;
            b = b + 1;
        end
    end
    
    initial begin
        $display("a = %d", a);
        $display("b = %d", b);
        $display("y = %d", y);
        $display("a_arr = %

- code: |-
    module DFF (
        input clk,
        input [31:0] in_data,
        output [31:0] out_data
    );
    reg [31:0] data;
    always @(posedge clk)
        data <= in_data;

- code: |-
    ```verilog
    module DFF (input logic [0:7] A, output logic [0:7] Y);
    always @(A)
    begin
    Y <= A[0:7];
    end
    endmodule
    
    module Anding (input logic [0:7] a, logic [0:7] b, output logic [0:7] y);
    DFF DFF0 (A, y[0:7] == y[0:7], b[0:7] == b[0:7]);
    endmodule
    ```
    ### Result:
    Succeeded on the first attempt.
    ### Compilation Flags:
    `-v`
    ### Additional Options/Configuration:
    ```shell
    ./build.sh
    ```
    ### Command Line:
    ```shell
    vvp -M./obj_dir -m dff_union_mod bdf_union_and.vvp
    ```
    ### Expected Output:
    ```shell
    [0]:[0]
    [1]:[1]
    [2]:[2]
    [3]:[3]
    [4]:[4]
    [5]:[5]
    [6]:[6]
    [7]:[7]
    [0]:[0]
    [1]:[1]
    [2]:[2]
    [3]:[3]
    [4]:[4]
    [5]:[5]
    [6]:[6]
    [7]:[7]
    [0]:[0]
    [1]:[1]
    [2]:[2]
    [3]:[3]
    [4]:[4]
    [5]:[5]
    [6]:[6]
    [7]:[7]
    [0]:[0]
    [1]:[1]
    [2]:[2]
    [3]:[3]
    [4]:[4]
    [5]:[5]
    [6]:[6]
    [7]:[7]
    [0]:[0]
    [1]:[1]
    [2]:[2]
    [3]:[3]
    [4]:[4]
    [5]:[5]
    [6]:[6]
    [7]:[7]
    [0]:[0]
    [1]:[1]
    [2

- code: |-
    module Anding (input uni [2:0] in, output y);
    and (y, in[0], in[1]);
    endmodule
    ### Original Code:
    initial begin
        $display("Input: %b", 2'b00);
        #30 $display("Output: %b", anding_1.y);
        #30;
        $display("Input: %b", 2'b01);
        #30 $display("Output: %b", anding_1.y);
        #30;
        $display("Input: %b", 2'b10);
        #30 $display("Output: %b", anding_1.y);
        #30;
        $display("Input: %b", 2'b

- code: |-
    module Anding (input logic a_tmp, b_tmp, output logic y_tmp);
      logic a_tmp2, b_tmp2;
      union packed {
        logic [31:0] a;
        logic [15:0] b;
        logic [7:0] c;
        logic [3:0] d;
        logic [2:0] e;
      } u;
    
      always @(a_tmp, b_tmp) begin
        u.a = a_tmp;
        u.b = b_tmp;
        a_tmp2 = u.a;
        b_tmp2 = u.b;
      end
    
      df

- code: |-
    module mos_strength_enum (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    // Enum declarations
    typedef enum bit [1:0] {St0 = 2'b00, St1 = 2'b01, Z  = 2'b10} state_e;
    localparam state_e Zn = St0, Zp = St1;
    // Define state signals
    wire [1:0] a_c, z0_p, z1_n, z2_zn, z3_zp;
    assign a_c = a & c;
    assign z0_p = (a_c)? St1 : St0;
    assign z1_n = (a_c)? St1 : St0;
    assign z2_zn = (a_c)? St0 : Z;
    assign z3_zp = (a_c)? Z : St1;
    assign zn = (a_c)? z0_p : z2_zn;
    assign zp = (a_c)? z1_n : z3_zp;
    endmodule
    ### Simulation Setup
    Testbench:
    module testbench();
    mos_strength dut(.*);
    endmodule
    Inputs:
    module test_inputs();
    initial begin
    $monitor("a=%b, c=%b, zn=%b, zp=%b", dut.a, dut.c, dut.zn, dut.zp);
    
    $monitor("a=%b, c=%b, zn=%b, zp=%b", dut.a, dut.c, dut.zn, dut.zp);
    
    end
    endmodule
    Test Bench Simulation:
    module simulation();
    mos_strength_enum dut(.*);
    initial begin
    $monitor("a=%b, c=%b, zn=%b, zp=%b", dut.a, dut.c, dut.zn, dut.zp);
    
    $monitor("a=%b, c=%b, zn=%b, zp=%b", dut.a, dut.c, dut.zn, dut.zp);
    
    end
    endmodule
    Test Results:
    ```
    ### Verification

- code: |-
    module mos_struct_strength (xn, xp);
    input xn, xp;
    output z;
    wire en, c;
    assign c = xn ^ xp;
    nmos n1 (z, en, c); // NMOS passes 'en' when 'c'

- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    localparam logic[1:0] St0 = 2'b00, St1 = 2'b01, Z = 2'b10; // Use enum instead of xor and and expressions
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
    ### Instruction
    1. Use and enum to replace the xor and and expressions
    2. Define a localparam enum that holds the same values as the xor expressions, then use it to replace them
    ### Testbench:
    module mos_strength_tb();
    logic a, c, zn, zp;
    mos_strength mos(.a(a),.c(c),.zn(zn),.zp(zp));
    initial begin // Initialize the inputs
        $dumpfile("mos_strength.vcd");
        $dumpvars(0,mos_strength);
        c = 1;
        a = 0;
        #10 $finish;
    end // End the testbench
    endmodule
    ### Expected Output:
    ![

- code: |-
    module mos_strength_test_enum (a, c, zn, zp);
    input a, c;
    output zn, zp;
    //nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    //pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    //replace with enum
    nmos_enum (nmos_out, a, c);
    pmos_enum (pmos_out, a, c);
    //assign to 'zn' and 'zp'
    assign zn = nmos_out ^ pmos_out;
    assign zp = nmos_out & pmos_out;
    endmodule
    ### Modified Test Code:
    test_mos_strength_enum test_mos_strength_enum (inputs, outputs);
    inputs = {1'b0, 1'b0};
    inputs = {1'b1, 1'b0};
    inputs = {1'b0, 1'b1};
    inputs = {1'b1, 1'b1};
    ### Modified Test Bench:
    initial begin
    		$dumpfile("mos_strength_enum_test.vcd");
    		$dumpvars(0, mos_strength);
    		// test strength for N-MOS
    		inputs = {1'b0, 1'b0}; // should output 0
    		@(posedge tb_clk);
    		assert (outputs == 1'b0);
    		@(posedge tb_clk);
    		// test strength for P-MOS
    		inputs = {1'b1, 1'b0}; // should output 1
    		@(posedge tb_clk);
    		assert (outputs == 1'b1);
    		@(posedge tb_clk);
    		// test strength for N-MOS with complementary input
    		inputs = {1'b0, 1'b1}; // should output 1
    		@(posedge tb_clk);

- code: |-
    ```
    module mos_strength (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
    ```
    ### Generated Constraint File:
    ```
    //----- Enum Variables.
    enum {A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z} a;
    enum {A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z} c;
    //----- Ports.
    output [1:0] z0, z1;
    //----- Nets.
    wire [1:0] z0, z1;
    //----- Module Body.
    nmos (z0, a, c);
    pmos (z1, a, c);
    endmodule
    ```
    ### Generated Test Bench File:
    ```
    module mos_strength_tb (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn, a, c);
    pmos (zp, a, c);
    endmodule
    ```
    ### Generated Test Bench Module Properties:
    ```
    module mos_strength_tb_prop (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn, a, c);
    pmos (zp, a, c);
    endmodule
    ```
    ### Generated Test Bench Case 0:
    ```
    `timescale 1ns / 1ps
    module mos_strength_tb_case_0 (a, c, zn, zp);
    `ifdef SIMULATOR

- code: |-
    module enum_strength (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn, a,

- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    parameter ST_NMOS = 2'b00;
    parameter ST_PMOS = 2'b11;
    parameter ST_EMPTY = 2'bzz;
    parameter [1:0] ST_HYST = ST_NMOS; // Set threshold to ST_NMOS
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
    ### Modified Code (2)
    The modification to the code above is to replace the xor and and gate expressions with enum, 
    but the logic-vector format will be used for the parameter.
    ### Code Snapshot:
    ```
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    parameter [1:0] ST_NMOS = 2'b00;
    parameter [1:0] ST_PMOS = 2'b11;
    parameter [1:0] ST_EMPTY = 2'bzz;
    parameter [1:0] ST_HYST = ST_NMOS; // Set threshold to ST_NMOS
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
    ```
    ### Testbench Code:
    The testbench code will be the same as the first code, but will test the new logic-vector based enum as 
    part of the test.
    ### Testbench Snapshot:
    ```
    module test_case;
    reg c, a, Zp, Zn;
    mos_strength mos
    (
     .a ( a ),
     .c ( c ),
     .Zp ( Zp ),
     .Zn ( Zn

- code: |-
    module mos_test (
       a1,a2,c,z,
       z1,z2,z3,z4,
       z5,z6,z7,z8,
       z9,z10,z11,z12,
       z13,z14,z15,z16
    );
    input a1,a2,c;
    output z,z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15,z16;
    
    logic [15:0] mux [0:1];
    
    
    assign mux[0] = {z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15};
    assign mux[1] = {z16};
    
    assign z = (c)? mux[1] : mux[0];
    
    nmos

- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn[0], a, c);
    pmos (zn[1], a, c);
    endmodule
    ### Expected Output (1):
    zn = 2'b00
    zp = 2'b00
    ### Expected Output (2):
    zn = 2'b10
    zp = 2'b01
    ### Expected Output (3):
    zn = 2'b00
    zp = 2'b00
    ### Expected Output (4):
    zn = 2'b11
    zp = 2'b11
    ### Expected Output (5):
    zn = 2'b11
    zp = 2'b11
    ### Expected Output (6):
    zn = 2'b10
    zp = 2'b11
    ### Expected Output (7):
    zn = 2'b10
    zp = 2'b10
    ### Ex

- code: |-
    module mos_strength (a, c, zn, zp);
    input [1:0] a, c;
    output [1:0] zn, zp;
    nmos (zn, a[0], c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a[1], c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    endmodule
    ### Test-bench Code:
    module ver_test();
    //Test input and output
    reg [1:0] a = 0;
    reg c = 0;
    wire [1:0] zn, zp;
    mos_strength moso(.a(a),.c(c),.zn(zn),.zp(zp));
    initial
    begin
        c = 0;
        a = 0;
        #15
        c = 1;
        a = 1;
        #20
        c = 0;
        a = 0;
        #15
        c = 1;
        a = 1;
        #5
        c = 0;
        a = 0;
        #15
        c = 1;
        a = 1;
        #20
        c = 0;
        a = 0;
        #20
        c = 1;
        a = 1;
        #

- code: |-
    ```
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [7:0] a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[6],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[6],c,b);
    endmodule
    ```
    ### Modified Instrumenatation:
    ```
    instrument_module gade_instrumented();
    ```
    ### Original Code :
    ```
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [7:0] a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[6],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[6],c,b);
    endmodule
    ```
    ### Original Instrumentation:
    ```
    instrument_module gade_instrumented();
    ```
    ############################################################
    ### Base Verilog Code:
    module gaex(a,a1,b,c,b1,c1,d,e,f);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    // Instantiate OR gate with inertial delay 3
    or #3 gg3(d,e,f);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg4(e,g,h);
    // Instantiate OR gate with inertial delay 3
    or #3 gg5(f,g,h);
    // Inst

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [1:0] a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[1],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[0],c,b);
    endmodule
    ### Modified Test Structure:
    module tb;
    // Instantiate A1 and A2
    gade a1(a1,a1_1,b,c,b_1,c_1);
    gade a2(a2,a2_1,b,c,b_2,c_2);
    assign b = 1;
    assign c = 1;
    assign b_1 = 1;
    assign c_1 = 1;
    // Instantiate and connect B1
    gade b1(b1,b1_1,b,c,b_1,c_1);
    gade b2(b2,b2_1,b,c,b_2,c_2);
    assign c_2 = 1;
    // Instantiate and connect C1
    gade c1(c1,c1_1,b,c,b_1,c_1);
    gade c2(c2,c2_1,b,c,b_2,c_2);
    assign c_1 = 1;
    endmodule
    ### Simulation Resutls:
    **Note:** In the original code, the testbench outputs are connected to the output of the top-level module of each instance using an implicit connection. In the modified code, the outputs of the top-level module are explicitly connected to the testbench outputs.
    | Time | a1 | a1_1 | a2 | a2_1 | b1 | b1_1 | b2 | b2_1 | c1 | c1_1 | c2 | c2_1 |
    | ---- | -- | ---- | -- | ---- | -- | ---- | -- | ---- | -- | ---- | -- | ---- |

- code: |-
    ```
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);

- code: |-
    module gad(o,i);
        output [1:0] o;
        input [1:0] i;
        assign o[0] = i[0] & i[1];
        assign o[1] = i[1] | i[0];
    endmodule
    module gade(a,b,c,d);
    input b,c,d;
    output [1:0] a;
    wire [1:0] temp;
    gad ff1(a,temp[1:0],d); // gad is unpacked-gad
    gad ff2(temp[1:0],b,c); // gad is unpacked-g

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [2:0] a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[2],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[1:0],c,b);
    endmodule
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [2:0] a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[2],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[1:0],c,b);
    endmodule
    
    ### Base Verilog

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
    module top();
      wire a,aa,a1,b,c,b1,c1;
      gade g1(a1,a,b1,b,c1,c);
      initial begin
        #100;
        $finish;
      end
    endmodule
    ### Modified testbench:
    module top();
      wire a,aa,a1,b,c,b1,c1;
      gade g1(a1,a,b1,b,c1,c);
      initial begin
        #100;
        $finish;
      end
    endmodule
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time: 0.168ms
    ### Simulation Time:

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
    ### Unit Test:
    def test():
            gade()
            gade1 = gade()
            gade2 = gade()
            gade1.a1 = 1
            gade1.b = 1
            gade1.c = 0
            gade1.c1 = 0
            gade1.b1 = 1
            assert gade1.a == 1
            assert gade2.a == 1
            assert gade1.a1 == 1
            assert gade2.a1 == 1
    
            gade2.a1 = 1
            gade2.b = 1
            gade2.c = 0
            gade2.c1 = 0
            gade2.b1 = 1
            assert gade2.a == 1
            assert gade1.a == 1
            assert gade2.a1 == 1
            assert gade1.a1 == 1
    test()

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [31:0]a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[31:17],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a[31:17],c[31:17],b[31:17]);
    endmodule
    ',
                'vlog_str' =>'module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output [31:0]a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1[31:17],c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
    ### Compilation
    `ncvlog gade.v`
    ### Running Simulation
    ##### Output:
    `ncvlog: *E,UNHANDLED (Unhandled statement)`
    `ncvlog: *W,NCEG2003 (Naming Conventions: Inconsistent naming between `gade.v' and unnamed item in file:

- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b

- code: |-
    module tstha_10(clk,rst,a,b,ca,s);

- code: |-
    module tstha_10();
      reg a,

- code: |-
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      reg [3:0] clk = 4'b0001;
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
      always begin #5 clk = clk + 1'b1; end
    endmodule
    ### Modified Verilog Code:
    module tstha_9();
      reg clk = 1;
      reg a,b;
      wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 clk = 1'b0;
      always begin #5 clk = 1;
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
    
    ### Base Verilog Code:
    module tstha_10();
      reg [4:0] a,b; wire s,ca;
      ha_10 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=5'b10001;b=5'b00001; #5 a

- code: |-
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
    
    module ha_9(s,ca,q1,q2);
         input q1,q2,ca;
         output s;
    
         wire t1,t2,t3,t4,t5,t6,t7;
         assign s = ca;
    
         full_adder_9 f1(t1,t2,t3,t4,t5,t6,t7,q2,q1,ca);
         full_adder_9 f2(t4,t5,t6,t7,s,t3,t2,t1,ca,q1);
    endmodule
    
    module full_adder_9(s,c,a,b,cin);
         input a,b,cin;
         output s,c;
    
         wire t1,t2,t3,t4;
    
         ha_8 fa1(c1,t2,a,b,cin);
         ha_8 fa2(s,c2,a,b,c1);

- code: |-
    module tstha_16();
      (* KEEP = "TRUE" *) reg a,b; wire s,ca;
      reg [1:0] c; reg [3:0] d;
      ha_16 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      assign c = d[2:1];
      initial begin a=0;b=0; end
      always begin #5 a=1

- code: |-
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
    //  initial #30 $stop;
    endmodule
    module ha_9(output s,ca,output ca,input a,input b);
      reg s;
      reg [3:0] clk; wire [3:0] clk2;
      assign clk2 = clk;
      adder add(.data1({a,b}),.data2({1'b1,1'b1}),.sum(s));
      alu alu_1 (.in1({a,b}),.in2(1'b1),.operation({ca}),.sum(ca),.carry(clk));
      always @(posedge clk2[0])
        begin
          clk=clk+1;
        end
    endmodule
    module adder(input logic [3:0][3:0] data1, data2, output logic [3:0] sum);
      assign sum = data1 + data2;
    endmodule
    module alu(.in1(data1),.in2(data2),.operation(operation),.sum(sum),.carry(carry));
    //  reg [3:0] sum;
      reg carry;
      reg [3:0] data1,data2,operation;
      assign carry=0;
      assign sum=data1+data2;
    endmodule
    ### Expected Result:
    ![simulation](https://github.com/johnnyawesome/COMP2200-DE1/blob/master/hw1/ex13/expected.PNG)
    ### My Simulation:
    ![simulation](https://github.com/johnnyawesome/COMP2200-DE1/blob/master/hw1/ex13/sim.PNG)

- code: |-
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9_packed_struct hh(s,ca,a,b);
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b, out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
    ### Expected Result:
    Test Passed
    ### Actual Result:
    Test Failed
    ### Compilation Logs:
    ```
    -------------------------
    File       : tstha_9.v
    Line       : 7
    Description: Instance 'hh' of entity 'ha_9' is missing port mapping for port 'clka'.
                  ** Error: (vlog-2117) $unit: "tstha_9": $fatal: "tstha_9.v, 7": instance 'hh': Instance of entity 'ha_9' is missing port mapping for port 'clka'.
    -------------------------
    File       : tstha_9.v
    Line       : 7
    Description: Instance 'hh' of entity 'ha_9' is missing port mapping for port 'clkb'.
                  ** Error: (vlog-2117) $unit: "tstha_9": $fatal: "tstha_9.v, 7": instance 'hh': Instance of entity 'ha_9' is missing port mapping for port 'clkb'.
    -------------------------
    File       : tstha_9.v
    Line       : 7
    Description: Instance 'hh' of entity 'ha_9' is missing port mapping for port 'a'.
                  ** Error: (vlog-2117) $unit: "tstha_9": $fatal: "tstha_9.v, 7": instance 'hh': Instance of entity 'ha_9' is missing port mapping for port 'a'.
    -------------------------
    File

- code: |-
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      packed struct {bit x,y;} clk;
      initial clk = 1'b1;
      always #5 clk.x = ~clk.x;
      initial #30 $stop;
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
    endmodule
    ### Modified Testbench:
    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      packed struct {bit x,y;} clk;
      initial clk = 1'b1;
      always #5 clk.x = ~clk.x;
      initial #30 $stop;
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
    endmodule
    #### Output:
    ```
    a = 0, b = 0,out carry = 0, outsum = 0 
    a = 1, b = 0,out carry = 0, outsum = 1 
    a = 0, b = 1,out carry = 1, outsum = 1 
    a = 1, b = 1,out carry = 0, outsum = 2 
    a = 0,

- code: |-
    module tstha_9(clock,a,b);
      parameter P_CLK_PERIOD = 5;
      reg [3:0]  clock; //Packed struct in port of clock input
      reg a,b; wire s,ca;
      ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=clock[1];b=clock[0]; end
      initial $monitor($time, " a = %b,%b, b = %b,%b,out carry = %b, outsum = %b ",clock[3:2],clock[1:0],a,b,ca,s);
      initial #30 $stop;
    endmodule
    ### Expected Results:
    Test should result in a signal routing test error.
    ### Relevant Coding

- code: |-
    module tstha_9p();
      reg a,b; wire s,ca;
      ha_9p hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $

- code: |-
    module example4(In1, In2, Out1, Out2);
    input [3:0] In1;
    input [3:0] In2;
    output [7:0] Out1;
    output [7:0] Out2;
    wire [3:0] Out1_2;
    wire [3:0] Out2_2;
    wire [7:0] Out1;
    wire [7:0] Out2;
    assign Out1[0] = Out1_2[0];
    assign Out1[1] = Out1_2[1];
    assign Out1[2] = Out1_2[2];
    assign Out1[3] = Out1_2[

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 ([3:0] Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Expected Data:
    This test will not work because the Sum wire is not compatible with RegSum, which is defined as a reg4 array.
    ### Error Message:
    Reg3[4]: Output Sum[4] (of Instance example3.R1) has a conflicting type Sum[4][4] and

- code: |-
    module example4(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = RegSum[3:0] + Data;
    endmodule
    
    ### Simulation Log

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset, Sum;
    input [3:0] Data;
    output [3:0] RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    endmodule
    ### Result of run:
    No warning messages

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign {Sum, RegSum} = Data + RegSum;
    endmodule
    ### Modified Block Diagram:
    ![full-adder-register-unpacked-

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Variation Verilog Code: 
    module example5(Data, Clock, Reset, RegSum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    
    ### Modified Code: 
    module example5(Data, Clock, Reset, RegSum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    
    ### Variation Verilog Code: 
    module example6(Data, Clock, Reset, RegSum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    
    ### Modified Code: 
    module example6(Data, Clock, Reset, RegSum);
    input Clock, Reset;
    input [3:0] Data;
    output wire [3:0] Sum, RegSum;
    //wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Variation Verilog Code: 
    module example7(Data, Clock, Reset, RegSum);
    input Clock, Reset;
    input [3:0

- code: |-
    module example5(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire

- code: |-
    module example5(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [7:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    wire [4:0] Sum_wire[3:0];
    assign Sum_wire = Data + RegSum;
    endmodule
    ### Modified Verilog Code:
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    wire [4:0] Sum_wire[3:0];
    assign Sum_wire = Data + RegSum;
    endmodule
    ### Changes from Verilog Code:
    - Changed the output Sum from wire to wire[4:0]
    ### Unit Tests:
    ### Unit Test Code:
    import cocotb;
    from cocotb.binary import BinaryValue
    from cocotb.clock import Clock
    from cocotb.result import TestSuccess
    from cocotb.result import TestFailure
    from cocotb.triggers import RisingEdge
    
    async def run_test_case(dut, tb_signal):
        tb_signal.value_enum.setepoch(1234)
        tb_signal.write(BinaryValue('0000', 4))
        await RisingEdge(dut.clock)
        tb_signal.write(BinaryValue('1111', 4))
        await RisingEdge(dut.clock)
        if(tb_signal.value_enum!= BinaryValue('1111111', 7)):
            raise TestFailure("test fail")
        raise TestSuccess
    
    async def initial_test(dut):
        tb_signal = Signal(intbv(0, min=-2, max=15))
        cocotb.fork(run

- code: |-
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = @(b) b;
    always @(a) b > a;
    endmodule
    ### Original Context:
    None
    ### Variation Instruction:
    Change `>=` to `>`.
    ### Modified

- code: |-
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b[b.class_test()] <= a;
    endmodule
    
    // Original Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n;
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n <= m[i];
    end
    endmodule
    
    // Variation Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n;
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n[m[i].class_test()] <= m[i];
    end
    endmodule
    
    // Original Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n[2:0];
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n[i] <= m[i];
    end
    endmodule
    
    // Variation Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n[2:0];
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n[i][m[i].class_test()] <= m[i];
    end
    endmodule
    
    // Original Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n[2:0][1:0];
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n[i] <= m[i];
    end
    endmodule
    
    // Variation Code
    module SchedTest;
    reg [3:0] m[2:0];
    reg [4:0] n[2:0][1:0];
    for (i = 0; i < 2; i++) begin
        always @(m[i]) n[i][m

- code: |-
    module SchedDelayB;
    class obj;
    int x;
    endclass
    reg [31:0] a, b;
    obj obj;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Test Case:
    ```
    module top_test();
    SchedDelayB t;
    initial begin
    end
    endmodule
    ```
    ### Synthesized Verilog Code:
    ```
    module top_test(
    );
    SchedDelayB t;
    initial begin
    end
    endmodule
    ```
    ### Synthesized Verilog Code for base case:
    ```
    module SchedDelayA(
        output [31:0] a,
        output [31:0] b,
        input [31:0] a,
        input [31:0] b
    );
    reg a, b;
    initial begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ```
    ### Synthesized Verilog Code for modified case:
    ```

- code: |-
    module SchedDelayB;
    class C;
    int var1;
    int var2;
    var1 = 0;
    var2 = 0;
    endclass
    reg a, b;
    reg [31:0] c;
    initial
    begin
    $system("touch c.dat");
    $system("touch c1.dat");
    end
    always @(b) begin
    c[b] = c[b] + 1;
    c[b+1] = c[b+1] + 1;
    end
    always @(a) begin
    if (c[a]) 
    c[a] --;
    if (c[a+1]) 
    c[a+1] --;
    end
    always @(c) begin
    if (c[a]) 
    c[a] --;
    if (c[a+1]) 
    c[a+1] --;
    end
    endmodule

- code: |-
    module SchedDelayH;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Original Code:
    module SchedDelayI;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Variation Instruction:
    Replace one of the inputs with a class handle and

- code: |-
    module SchedDelayA;
    class cls;
    input a;
    input b;
    endclass
    reg cls c_a [0:1];
    initial
    begin
    end
    always @(c_a[1].b) c_a[1].a = c_a[1].b;
    always @(c_a[0].a) c_a[0].b <= c_a[0].a;
    endmodule
    
    ### Variation Description:
    This variation introduces a class handle to access an associative array with a class member inside operator.
    
    ### Testing Procedure and Expected Results
    For the given variation of the testbench (with the modified code), no error was reported.
    
    ### Pass/Fail Criteria
    Test passes if the design does not crash.
    
    ### Comments
    
    ### Pre-Simulation
    
    ### Post-Simulation

- code: |-
    module SchedDelayA;
    reg A[0:3];
    initial
    begin
    end
    always @(A[0]) A[1] = A[0];
    always @(A[1]) A[2] = A[1];
    always

- code: |-
    module SchedDelayB;
    class C;
    int a;
    function new(a);
      this.a = a;
    endfunction
    endclass
    
    reg [31:0] a;
    int a_var [3] = '{1,2,3};
    C a_class [3] = new [3] (3);
    initial
    begin
    end
    always @(b) a = b;
    always @(b_class) a = b_class.a;
    always @(b_class) a = b_class.a;
    always

- code: |-
    module SchedDelayB;
    reg b;
    class cls_b;
    exposed localparam a = 1;
    rand int b;
    constraint c {b == 1;}
    endclass
    cls_b b_inst[5];
    initial
    begin
    end
    always @(b) b_inst[0].a = b_inst[1].a;
    always @(b) `ifdef SYNTHESIS b_inst[2].b == 1; `endif
    always @(b) b_inst[3].b <= b_inst[4].b;
    always @(b) `ifdef SYNTHESIS b_inst[5].b == 1; `

- code: |-
    ```
    module SchedDelayA;
    class A;
      rand int x;
    endclass
    reg [32-1:0] a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a.x;
    endmodule
    ```
    ### Expected Result:
    Pass
    ### Actual Result:
    Fail at simulation time, the following error message:
    ```
    SchedDelayA cannot be used with non-blk and non-inst references, (a.x) is not supported in this context
    ```
    ### Error Message:
    ```
    SchedDelayA cannot be used with non-blk and non-inst references, (a.x) is not supported in this context
    ```
    ### Version:
    v2020.1
    ### Prerequisites:
    - The regression testbench is initialized before the verilog simulation starts.
    ### Test Case #1:
    ```
    module SchedDelayA;
    class A;
      rand int x;
    endclass
    reg [32-1:0] a, b;
    initial
    begin
    end
    always @(b) a = |b;
    always @(a) b <= a.x;
    endmodule
    module top;
    SchedDelayA dut();
    endmodule
    ```
    ### Expected Result (from DC):
    Pass
    ### Actual Result (from DC):
    Pass
    ### Version:
    v2020.1
    ### Prerequisites:
    - The regression testbench is initialized before the verilog simulation start.
    ### Test Case #2:
    ```
    module SchedDelayA;
    class A;
      rand int x;
    endclass
    reg [32-1:0] a, b;
    initial
    begin
    end
    always @(b) a = |b;
    always @(a) b <= a[a.x];
    endmodule
    module top;
    SchedDelayA dut();
    endmodule
    ```
    ### Expected Result (from DC):
    Pass
    ### Actual Result (from DC):
    Pass
    ### Version:
    v2020.1
    ### Prerequisites:
    - The regression testbench is initialized before the verilog simulation

- code: |-
    module netdelay2(x,y);
    input x;
    output [31:0] y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y[0]=nn; // Assign 'nn' to 'y[0]' (direct assignment)
    endmodule
    ### Testplan:
    - Test the original netdelay module.
    - Test the modified netdelay module.
    - Test the netdelay module with 1000000000000000 iterations.
    
    ### Dut
    - Original netdelay module.
    - Modified netdelay module.
    - netdelay module with 1000000000000000 iterations.
    
    ### Expected Results
    - All tests passes.
    
    ### Actual Results
    #### Original netdelay module:
    - All tests pass.
    #### Modified netdelay module:
    - All tests pass.
    #### netdelay module with 1000000000000000 iterations:
    - All tests pass.
    
    ### Simulation Time:
    - Original netdelay module:
    	- 788ms
    - Modified netdelay module:
    	- 784ms
    - netdelay module with 1000000000000000 iterations:
    	- 818ms
    
    ### Conclusion:
    - The modified netdelay module passes all the tests.
    
    ### Recommendation:
    - There is no need to

- code: |-
    module netdelay4(x2,y);
    input x2;
    output y;
    wire #(2,1) nn;
    not (nn,x2); // Assign NOT(x2) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule
    
    ### Base Verilog Code:
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn;
    not

- code: |-
    module netdelay1(x,y);
    input x;
    output reg [31:0] y; // y is now a packed structure
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule
    ### Generated Verilog Code and its meaning:
    module netdelay1(x,y);
    input x;
    output reg [31:0] y;
    wire #(2,1) nn;
    not (nn,x);
    assign [31:31] y[0]=nn;
    assign [30:30] y[1]=nn;
    assign [29:29] y[2]=nn;
    assign [28:28] y[3]=nn;
    assign [27:27] y[4]=nn;
    assign [26:26] y[5]=nn;
    assign [25:25] y[6]=nn;
    assign [24:24] y[7]=nn;
    assign [23:23] y[8]=nn;
    assign [22:22] y[9]=nn;
    assign [21:21] y[10]=nn;
    assign [20:20] y[11]=nn;
    assign [19:19] y[12]=nn;
    assign [18:18] y[13]=nn;
    assign [17:17] y[14]=nn;
    assign [16:16] y[15]=nn;
    assign [15:15] y[16]=nn;
    assign [14:14] y[17]=nn;
    assign [13:13] y[18]=nn;
    assign [12:12] y[19]=nn;
    assign [11:11] y[20]=nn;
    assign [10:10] y[21]=nn;
    assign [9:9]

- code: |-
    module netdelay2(x,y);
    input x;

- code: |-
    module netdelay2(x,y);
    input [31:0] x;
    output reg [31:0] y;
    wire nn; // No delay
    not (nn,x); // Assign NOT(x) to 'nn' (no delay)
    always @ (nn) begin
    	y=nn; // Assign 'nn' to 'y' (no delay)
    end
    endmodule
    ### Original Code:
    module netdelay1(x,y);
    input x;
    output reg y;
    wire nn; // No delay
    not (nn,x); // Assign NOT(x) to 'nn' (no delay)
    always @ (nn) begin
    	y=nn; // Assign 'nn' to 'y' (no delay)
    end
    endmodule
    ### Variation Instruction:
    Add a 32-bit wide input signal x to the netdelay circuit and change the delay values of the output signal to 2ns and 1ns. (NOTE: The delay values are in the timeunit specified in the original netdelay1 code).
    ### Mod

- code: |-
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y={nn[0],nn[1],nn[2],nn[3],nn[4],nn[5],nn[6],nn[7],nn[8],nn[9],nn[10],nn[11],nn[12],nn[13],nn[14],nn[

- code: |-
    module netdelay1 (x,y,z,w);
    input x;
    output y,z;
    wire nn1,nn2;
    not (nn1,x);
    not (nn2,z);
    assign y=nn1;

- code: |-
    module netdelay2(x,y);
    input x;
    output reg [31:0] y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y={y[30:0],nn}; // Assign 'nn' to the 3rd (highest) field of 'y'
    endmodule
    ### Additional Note:
    This is a very simple but fundamental test, and may be replaced with more comprehensive test suites in future
    ### Experimental Result:
    
    | Code | Time | LUT | FF | BUF |
    |:----:|:----:|:---:|:--:|:---:|
    | netdelay1 | 00:05 | 2 | 4 | 1 |
    | netdelay2 | 00:06 | 2 | 6 | 1 |
    ### Conclusion:
    We can see that the synthesis tool manages to achieve the same performance between the two codes. This is because the synthesis tool is able to recognize that the output of the first code is to be used in the second code.
    
    ### Detailed Discussion:
    
    By redefining the output 'Result' as a structure with 32 fields, we have introduced structural granularity to the synthesis tool. The synthesis tool

- code: |-
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule

- code: |-
    module netdelay2(x,y);
    input x;
    output logic [31:0] y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule
    ### Result:
    * Modified code has no functional

- code: |-
    module func2(x1, x2, x3, f);
    input x1, x2, x3;
    output logic f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    
    module func2_tb();
    reg x1, x2, x3;
    wire f;
    
    func2 f1(x1, x2, x3, f);
    
    initial begin
        x1 = 0;
        x2 = 0;
        x3 = 0;
        #100 $finish;
    end
    endmodule
    
    ### Testbench Output:

- code: |-
    module func2(x

- code: |-
    ```
    module func2(x1, x2, x3, f);
    input signed logic x1, x2, x3;
    output logic f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ```
    
    ##### [2_test_vector.vhd](https://github.com/enthusiasticallyabstract/VHDL_Course/blob/main/01_Basics/

- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output signed logic f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Modified Code and Testbench:
    ```verilog
    `timescale 1ns / 1ps
    module tb_func1();
    //Inputs
    logic signed [3:0] x1_i, x2_i, x3_i;
    //Outputs
    logic signed [1:0] f_o;
    
    // Instantiate the Unit Under Test (UUT)
    func1 func1_i (
       .x1(x1_i),
       .x2(x2_i),
       .x3(x3_i),
       .f(f_o)
    );
    
    //Initialize Inputs
    initial begin
        x1_i = 1;
        x2_i = 0;
        x3_i = 0;
        #10
        x1_i = 1;
        x2_i = 1;
        x3_i = 0;
        #10
        x1_i = 0;
        x2_i = 1;
        x3_i = 0;
        #10
        x1_i = 0;
        x2_i = 0;
        x3_i = 1;
        #10 x1_i = 1;
        x2_i = 1;
        x3_i = 1;
        #10
        x1_i = 0;
        x2_i = 1;
        x3_i = 1;
        #10 x1_i = 1;
        x2_i = 0;
        x3_i = 1;
        #10
        x1_i = 1;
        x2_i = 0;
        x3_i = 0

- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output logic signed [15:0] f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Synthesized Verilog Code:
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output logic signed [15:0] f = 1'sd0;
    assign f = 1'sd0 | (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Sample Design:
    module top1(clock);
    input clock;
    wire a, b, c;
    wire f;
    func1 f_inst(a, b, c, f);
    
    always #1 clock = ~clock;
    always @(negedge clock)
    begin
    a <= 1'b0;
    b <= 1'b0;
    c <= 1'b0;
    end
    
    always #2
    if (a == 1'b0 && b == 1'b0 && c == 1'b0)
    begin
    a <= 1'b1;
    b <= 1'b0;
    c <= 1'b0;
    end
    
    else if (a == 1'b0 && b == 1'b0 && c == 1'b1)
    begin
    a <= 1'b1;
    b <= 1'b0;
    c <= 1'b0;
    end
    
    else if (a == 1'b0 && b == 1'b1 && c == 1'b0)
    begin
    a <= 1'b1;
    b <= 1'b0;
    c <= 1'b0;
    end
    
    else if (a == 1'b0 && b == 1'b1 && c == 1

- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output logic signed [0:2] f;
    assign f[0] = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    assign f[1] = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    assign f[2] = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Verification:
    #### Test Cases:
      1. x1 = 0, x2 = 0, x3 = 0, f = 4'b0;
      2. x1 = 1, x2 = 0, x3 = 0, f = 4'b0;
      3. x1 = 0, x2 = 1, x3 = 0, f = 4'b0;
      4. x1 = 1, x2 = 1, x3 = 0, f = 4'b0;
      5. x1 = 0, x2 = 0, x3 = 1, f = 4'b0;
      6. x1 = 1, x2 = 0, x3 = 1, f = 4'b0;
      7. x1 = 0, x2 = 1, x3 = 1, f = 4'b0;
      8. x1 = 1, x2 = 1, x3 = 1, f = 4'b1;
    ##### Passed 4 tests
    ### Concept Check:
    While using signed logic vectors, the LSB is for sign and all others are for the magnitude.
    ### Variation Instruction:
    Change the output type from logic

- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output signed logic f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Constraints:
    #### 1) This test is synthesizable
    
    ### Results:
    #### 1) This test is synthesizable
    #### 2) Changing the output type from logic to logic signed makes the test synthesizable.
    #### 3) When the output type is changed from logic to logic signed, the output value of this test changes from a 32 bit vector (4 bits for each f) to a 64 bit vector (8 bits for each f).
    
    ### Original verilog file:
    ```
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ```
    ### Variation file:
    ```
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output signed logic f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ```
    ### Synthesized Verilog code:
    ```
    module func1 (input  wire [3:0] x1,
    input  wire [3:0] x2,
    input  wire [3:0] x3,
    output wire [7:0] f);
    
    wire [7:0] x1_muxed;
    wire [7:0] x2_muxed;
    wire [7:0] x3_muxed;
    wire [7:0] not_x

- code: |-
    module func1(x1, x2, x3, f);
    input signed logic [5:0] x1, x2, x3;
    output signed logic [4:0] f;
    assign f = (x1 & x2 & x3) | (x1 & ~x2 & ~x3) | (~x1 & x2 & x3) | (x1 & x2 & x3);
    endmodule
    ```
    
    The **x** bits represent the 24 input bits.
    
    ```verilog
    ### Base Verilog Code:
    module func1(x1, x

- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    logic signed [3:0] f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Simulation code:
    `timescale 1ns/1ns
    module testbench();
    logic x1, x2, x3, f;
    func1 m1(x1, x2, x3, f);
    integer j;
    initial begin
        $dumpfile("dump.vcd");
        $dumpvars(1,m1);
        for (j = 0; j < 15; j++) begin
            $display("x1 = %b, x2 = %b, x3 = %b", x1, x2, x3);
            #1
            if (x1) x1 = 1'b1; else x1 = 1'b0;
            if (x2) x2 = 1'b1; else x2 = 1'b0;
            if (x3) x3 = 1'b1; else x3 = 1'b0;
            $display("f = %8b", f);
            #1
        end
    end
    endmodule
    ### Simulation

- code: |-
    module func1(x1, x2, x3, f);
    input signed [2:0] x1, x2, x3;
    output signed [2:0] f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Testbench code:
    module func1_test();
    reg signed [3:0] x1, x2, x3;
    wire signed [3:0] f;
    
    func1 func1_i(x1, x2, x3, f);
    
    parameter [100:0] max_len = 100;
    integer len;
    initial begin
        len = max_len;
        $dumpfile("func1_tb.vcd");
        $dumpvars(0, func1_test);
        #100;
        $finish;
    end
    
    initial begin
        x1 = 0;
        x2 = 0;
        x3 = 0;
        #10;
        assert(f === 0)
            else $error("assert failed for i=0");
        #10;
        x1 = 4'hf;
        #10;
        assert(f === -1)
            else $error("assert failed for i=1");
        #10;
        x2 = -4'hf;
        #10;
        assert(f === -1)
            else $error("assert failed for i=2");
        #10;
        x3 = -4'hf;
        #10;
        assert(f === 0)
            else $error("assert failed for i=3");
        #10;
        x2 = 4'hf;
        #10;
        assert(f === 0)
            else $error("assert failed for i=4");
        #10;
        x1 = 0;
        x2 = 0;
        x3 = 1;
        #10;
        assert(

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    initial #100 $finish;
    enum bit {default, non_default} Resetn;
    //enum bit  {default, non_default} Resetn;
    //enum logic [28:0] {default, non_default} Resetn;
    //enum logic [1:0] {default, non_default} Resetn;
    //enum int 28 {default, non_default} Resetn;
    //enum int 1 {default, non_default} Resetn;
    //enum int 29 {default, non_default} Resetn;
    //enum int 10 {default, non_default} Resetn;
    //enum longint 10 {default, non_default} Resetn;
    //enum int unsigned 10 {

- code: |-
    always @(posedge clock) begin
      a_reg <= a_next;
      b_reg <= b_next;
    end
    ### Original Code:
    always @(posedge clock) begin
      if (resetn == 1'b0) begin
        a_reg <= 1'b0;
      end else begin
        a_reg <= a_next;
      end

- code: |-
    module Clock_Prog (clock);
    parameter T=1000000000000/FREQ;
    
    parameter enum {FREQ1, FREQ2=100000001} FREQ;
    reg clock;

- code: |-
    module t_Mixed_Sync ();
    parameter PROG_ENUM = 3;
    
    default mixed_sync_enum_type = PROG_ENUM;
    
    wire sync;
    wire resetn;
    wire clock;
    
    Mixed_Sync M1 (sync, resetn, clock);
    endmodule
    ### Modified Testbench:
    module tb_t_Mixed_Sync ();
    t_Mixed_Sync M2 (sync, resetn, clock);
    endmodule
    ### Original Code:
    module t_Reset_Sync ();
    wire sync

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    initial #100 $finish;
    Clock_Prog M1 (clk);
    endmodule
    module clock_prog (
    	clk,
    	done,
    	resetn
    );
    
    timeunit 1ns / 1ps;
    
    
    timeprecision 1ns / 1ps;
    
    
    default clocking @(posedge clk);
    endclocking
    
    enum {
    	reset_n_val = 0
    } resetn_val_default;
    
    enum {
    	reset_n,
    	default
    } resetn_val_non_default;
    
    parameter WIDTH = 8;
    parameter DATA_WIDTH = 4;
    
    
    input 	clk;
    output 	done;
    input 	resetn;
    
    
    wire [WIDTH-1:0] sum = $unsigned(a) + $unsigned(b);
    wire [WIDTH-1:0] a = 0;
    wire [WIDTH-1:0] b = 0;
    wire [WIDTH-1:0] c = 0;
    wire [WIDTH-1:0] d = 0;
    wire [WIDTH-1:0] e = 0;
    wire [WIDTH-1:0] g = 0;
    wire [WIDTH-1:0] h = 0;
    wire [WIDTH-1:0] i = 0;
    wire [WIDTH-1:0] j = 0;
    wire [WIDTH-1:0] k = 0;
    wire [WIDTH-1:0] l = 0;
    wire [WIDTH-1:0] m = 0;
    wire [WIDTH-1:0] n = 0;
    wire [WIDTH-1:0] o = 0;
    wire [WIDTH-1:0] p = 0;
    wire [WIDTH-1:0] q = 0;
    wire [WIDTH-1:0] r = 0;
    wire [WIDTH-1:0] s = 0;
    wire [WIDTH-1:0] t = 0;
    wire [WIDTH-1:0] u = 0;
    wire [WIDTH-1:0] v = 0;
    wire [WIDTH-

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    always @ (posedge clock) begin
     clock <= ~clock;
    end
    endmodule
    module Clock_Prog(input clk);
    
    logic clock;
    parameter enum {DEFAULT, HIGH} my_enum;
    default clock = 1'b1;
    
    always @ (posedge clock) begin
     clock <= ~clock;
    end
    endmodule
    
    
    ### Base Verilog Code:
    module t_Clock_Prog (output

- code: |-
    module t_Clock_Prog (reset_n);
    wire clk;
    
    initial #100 $finish;
    Clock_Prog M1 (reset_n, clk);
    endmodule
    Clock_Prog M1 (reset_n, clk);
    endmodule
    
    module Clock_Prog(reset_n, clk);
    
    parameter Reset_Type = 1'b1;
    
    parameter Reset_Type_not_default = 3'b001;
    
    
      reg [7:0] test_score = 0;
    
      reg reset_n;
      wire clock;
    
      initial begin
        $display("test score: %d", test_score);
        $finish;
      end
    
      always @* begin
        clock = (reset_n == Reset_Type)? 0 : 1;
      end
    
      always @(posedge clock) begin
        test_score = test_score + 1;
      end
    
    endmodule
    
    module t_Clock_Prog (reset_n);
    wire clk;
    
    initial #100 $finish;
    Clock_Prog M1 (reset_n, clk);
    endmodule
    Clock_Prog M1 (reset_n, clk);
    endmodule
    
    module Clock_Prog(reset_n, clk);
    
      parameter Reset_Type = 1'b1;
    
      parameter Reset_Type_not_default = 3'b001;
    
    
      reg [7:0] test_score = 0;
    
      reg reset_n;
      wire clock

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    initial #100 $finish;
    Clock_Prog M1 (clk);
    endmodule
    
    typedef enum { Default, Non_Default } t_enum;
    
    module Clock_Prog (clock, resetn);
    
    input clock;
    
    //parameter resetn = 1'b1;
    input resetn;
    
    
    
    
    
    
    logic [31:0] counter;
    logic [31:0] maxcount;
    logic [31:0] next_counter;
    logic reset;
    
    parameter resetn = 1'b1;
    
    always_ff @(posedge clock or negedge resetn) begin
        if (resetn == 1'b0) begin
            reset <= 1'b1;
        end
        else begin
            reset <= 1'b0;
        end
    end
    
    always_ff @(posedge clock or posedge reset) begin
        if (reset == 1'b1) begin
            counter <= 'b0;
            next_counter <= 'b0;
        end
        else begin
            if (counter < maxcount)
                counter <= counter + 'b1;
            next_counter <= counter;
        end
    end
    
    always_comb begin
        if (next_counter == 'b0)
            maxcount = 'b0;
        else
            maxcount = next_counter;
    end
    
    endmodule
    ### Original Code:
    module t_Clock1();
    wire clock;
    
    initial #100 $finish;
    Clock1 M1 (clk);
    endmodule
    
    module Clock1 (clock);
    
    input clock;
    
    logic [31:0] counter;
    logic [31:0] maxcount;
    logic [31:0] next_counter;
    logic reset;
    
    parameter reset = 1'b1;
    
    always_ff @(posedge clock or negedge reset) begin
        if (reset == 1'b1) begin
            counter <= 'b0;
            next_counter <= 'b0;
        end
        else begin
            if (counter < maxcount)
                counter <=

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    initial #100 $finish;
    Clock_Prog M1 (clk);
    endmodule
    ### Variation: 2309475184 (base_type_enum_only_

- code: |-
    module t_Clock_Prog ();
    wire clock;
    
    initial #100 $finish;
    Clock_Prog M1 (clk);
    endmodule
    
    module Clock_Prog(out clock);
    parameter 
        reset_type = 3'b111,
        clk_type = 4'b0010,
        clk_base = 1'b0,
        clk_input = 1'b1;
    
    logic [3:0] resetn;
    reg clock_reg,clock;
    always_ff @ (posedge resetn or posedge clock) begin
       clock_reg <= clock;
       clock <= clock_reg;
    end
    
    always_comb begin
        clock = clock_input;
    end
    
    defparam
        M1.resetn = reset_type,
        M1.clock = clk_type,
        M1.clock_reg = clk_base,
        M1.clock_input = clk_input;
    
    Clock_Prog M1 (
       .clock(clock)
    );
    endmodule
    ### Test Cases Executed
    t = 1
    ### Summary Log:
    
    Test Complete, 3 Tests Passed, 0 Failed, 0 Skipped, 0 Unsupported.
    ### Coverage Log:
    
    // Code Coverage: 
    // 
    
    // Parameter Coverage: 
    // 
    
    // Conditional Coverage: 
    // 
    
    // Path Coverage: 
    // 
    
    // Expression Coverage: 
    // 
    
    // Assertion Coverage: 
    // 
    
    // Assignment Coverage: 
    // 
    
    // State Coverage: 
    // 
    
    // State Cycle Coverage: 
    // 
    
    ### Report Log:
    
    // Summary: 2 Passed, 0 Failed, 0 Total
    // 
    // Test Application: /afs/ece/j/jyang/ref/verilog/coverage/Clock_Prog.v
    // 
    // Coverage Summary: 
    // 
    // 
    // 
    // 
    // 
    // Test Results:
    // 
    // Test Name

- code: |-
    ```verilog
    typedef struct {int signed s, int signed ca, int signed co;} delays_t;
    module fa_1(s,ca,co,a,b,c); // Full Adder with gate delays
      input a,b,c; output s,ca,co;
      and #(9,10) (s,a,b);
      xor #(14,15) (s,a,c);
      xor #(11,12) (s,a,s);
      and #(17,18) (co,a,b);
      xor #(23,24) (co,a,c);
      x

- code: |-
    module struct_ha_1(s,ca,a,b);
      input a,b; output s,ca;
      wire c;
      xor #(a.a1,a.a2) (s,a,b);
      and #(b.a1,b.a2) (c,a,b);
      or #(c.a

- code: |-
    module pa_2(o,a,b); // Full Adder with gate delays
      input a,b; output o;
      wire s,ca;
      ha_2 ha1(s1,ca1,a,b);
      ha_2 ha2(s2,ca2,ca1,b);
      xor #(1ns,-2ns) (o,s1,s2);
      and #(3ns,-4ns) (s,ca1,ca2);
    endmodule
    ### Compilation Parameters:
    - -fexplicit-parameterize-delay
    - -fexplicit-parameterize-delay-list="ca1,ca2,s1,s2"
    ### Compilation Output:
    > vlog -fexplicit-parameterize-delay -fexplicit-parameterize-delay-list="ca1,ca2,s1,s2" ha.v
      INFO: [Common 17-357] -- Compiling module 'pa_1'.
      INFO: [Common 17-357] File 'ha.v' line 61: HDL parameterized delay of's1' is changed to '1ns'
      INFO: [Common 1

- code: |-
    module ha_2(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(i.a,i.b) (s,a,b);
      and #(i.a,i.b) (ca,a,b);
      parameter signed struct {
        int a,b;
      } i = '{a:1,b:2};
    endmodule
    ### Original Test Code:
    module x1;
      wire a,b,s,ca;
      ha_1 u1(s,ca,a,b);
      initial begin
        a=0; b=0; #(10); a=1; b=0; #(10); a=0; b=1; #(10);
      end
    endmodule
    ### Variation Test Bench:
    module vtb;
      wire s,ca,a,b;
      ha_2 u1(s,ca,a,b);
      x1 u2(a,b,s,ca);
      initial begin
        $monitor("%t %b %b %b %d %d %d %d","",a,b,s,ca,u1.i.a,u1.i.b,u2.i.a,u2.i.b);
        a=0; b=0; #(10); a=1; b=0; #(10); a=0; b=1; #(10);
      end
    endmodule
    ### Design Flow:
    - Design -> Verify -> Synthesize -> Simulate
    ### Synopsis:
    - Use signed type for delay values
    - Define the value with parameter struct within the module
    - Initialize the delay values within the module
    - Verify by simulating the module
    ### Conclusion:
    - Pass the delay values which are stored in a struct to an unpacked structure and use these values to assign delays for an input.
    ### Additional Readings:
    -

- code: |-
    module ha_1(s,ca,a,b); //

- code: |-
    module ha_1(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,-($delay_1.delay_1)) (s,a,b);
      and #(3,-($delay_3.delay_3)) (ca,a,b);
      timeunit 1ns;
      timeprecision 1ps;
      parameter struct {time delay_1; time delay_3;} delays = '{delay_1:0ps, delay_3:0ps};
      time $delay_1 = delays.delay_1;
      time $delay_3 = delays.delay_3;
    endmodule
    module ha_2(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,-($delay_2.delay_2)) (s,a,b);
      and #(3,-($delay_4.delay_4)) (ca,a,b);
      timeunit 1ns;
      timeprecision 1ps;
      parameter struct {time delay_2; time delay_4;} delays = '{delay_2:0ps, delay_4:0ps};
      time $delay_2 = delays.delay_2;
      time $delay_4 = delays.delay_4;

- code: |-
    module ripple_carry_1(cin,x,

- code: |-
    module adder(s,ca,c,a,b); // Full Adder with gate delays
      input a,b,c; output s,ca,c;
      ha_1 sum(s,ca,a,b);
      and #(3,4) (c,a,b);
      or #(5,6) (c,a,b);
    endmodule
    module adder(s,ca,c,a,b); // Full Adder with gate delays
      input a,b,c; output s,ca,c;
      ha_1 sum(s,ca,a,b);
      and #(3,4) (c,a,b);
      or #(5,6) (c,a,b);
    endmodule
    
    ### Base Verilog Code:
    module rca_1(o,s,a,b); // Ripple Carry Adder with gate delays
      input a[0:6],b[0:6]; output o[0:7]; wire carry[0:6];
      ad

- code: |-
    module ha_4(s,ca,a,b); // Half Adder with gate delays
      input

- code: |-
    module ha_1(s,ca,a,b);
      input a,b; output s,ca;
      xor #(1,2) (s,a,b);
      and #(3,4) (ca,a,b);
    endmodule
    module top(in1,in2,s,ca);
      input [7:0] in1,in2; output s,ca;
      ha_1 u1(s,ca,in1[0],in2[0]);
      ha_1 u2(s,ca,in1[1],in2[1]);
      ha_1 u3(s,ca,in1[2],in2[2]);
      ha_1 u4(s,ca,in1[3],in2[3]);
      ha_1 u5(s,ca,in1[4],in2[4]);
      ha_1 u6(s,ca,in1[5],in2[5]);
      ha_1 u7(s,ca,in1[6],in2[6]);
      ha_1 u8(s,ca,in1[7],in2[7]);
    endmodule
    
    module delay_1 (y,delay,x);
      input [15:0] delay,x; output y;
      wire [15:0] z;
      ha_1 u1(z[0],z[1],x,1'b1);
      ha_1 u2(z[1],z[2],z[0],1'b0);
      ha_1 u3(z[2],z[3],z[1],1'b0);
      ha_1 u4(z[3],z[4],z[2],1'b0);
      ha_1 u5(z[4],z[5],z[3],1'b0);
      ha_1 u6(z[5],z[6],z[4],1'b0);
      ha_1 u7(z[6],z[7],z[5],1'b0);
      ha_1 u8(z[7],z[8],z[6],1'b0);
      ha

- code: |-
    wire_assign2 module( input in, output out );
        assign out = in;
    endmodule
    
    wire_assign3 module( input [3:0] in, output [3:0] out );
        for (genvar i=0; i<4; i++) begin:gen_wire_assign
            assign out[i] = in[i];
        end
    endmodule
    ### How to Run:
    ```
    $ iverilog wire_assign2.v wire_assign3.v
    $./a.out
    ```
    ### Expected Output:
    ```
    # ** No output expected. **
    ```
    ### Simulation Output
    ```
    $./a.out
    ```
    ### References:
    [1][https://www.verilogpro.com/wire-verilog-tutorial-and-examples/#associative-arrays]
    ### 2.4
    ### Base Verilog Code:
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out

- code: |-
    module wire_assign( input in, output out );
        // change in to an associative array
        logic [31:0] in [(Clock + 1) : 0];
        // assign out to in[Clock]
        assign out = in[(Clock + 1)];
    endmodule
    
    
    // Variation 1.E:
    ### Base Verilog Code:
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Variation Instruction:
    Change the input Clock to a wildcard-index

- code: |-
    // Create a module with one

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input [3:0] in, output out );
        // assign out to in
        assign out = in[default:*][2];
    endmodule
    
    ### Variation Name:
    wildcard indexing of associative array with default wildcard
    ### Base Verilog Code:
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input [3:0] in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Variation Instruction:
    Change the input Clock to a

- code: |-
    ```verilog
    module wire_assign( input in, output out );
        // change the input type to a wildcard-indexed associative array and access it via the inside operator to test wildcard indexing.
        input [1:0] in[];
        assign out = in[1];
    endmodule
    ```
    
    ### Modified Testbench:
    ```verilog
    module tb;
        wire clk;
        wire clk2;
        wire cnt;
        wire [3:0] out;
        wire [3:0] in;
        // instantiate the design under test
        wire_assign dut(out, in);
        
        // Instantiate the clock source
        localparam CLK_PERIOD = 10ns;
        initial begin
            $dumpfile("dump.vcd");
            $dumpvars(0, tb);
        end
        
        // Clock generation
        initial begin
            clk = 0;
            forever #CLK_PERIOD clk = ~clk;
        end
        
        // Stimulus for the design under test
        initial begin
            in[0] = 0;
            in[1] = 1;
            in[2] = 0;
            in[3] = 1;
            #CLK_PERIOD;
            wait(clk);
            in[0] = 1;
            in[1] = 1;
            in[2] = 1;
            in[3] = 1;
            wait(clk);
            in[0] = 0;
            in[1] = 0;
            in[2] = 0;
            in[3] = 0;
            wait(clk);
            in[0] = 1;
            in[1] = 0;
            in[2] = 1;
            in[3] = 0;
            wait(clk);
            in[0] = 0;
            in[1] = 1;
            in[2] = 0;
            in[3] = 1;
            wait(clk);
            in[0] = 1;
            in[

- code: |-
    input clk,
        input [7:0] data,
        input [7:0] data2,
        output out0,
        output wire out1,
        output wire out2,
        output [7:0] out3
        input [3:0] sel,
        input [3:0] sel2
    
    wire_assign wl(clk[sel], out0);
    wire_assign wl2(clk[sel2], out1);
    wire_assign wl3(data[sel], out2);
    wire_assign wl4(data2[sel2], out3);
    
    
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input clk, input data,  input data2, output out0, output out1, output out2, output [7:0] out3);
        // wire assignments
        // assign out to in
        assign out0 = clk;
        assign out1 = clk[sel];
        assign out2 = data[sel];
        assign out3 = data2[sel2];
    endmodule
    ### Modified Testbench :
        // Set up clock
        initial begin
          clk = 0;

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    module main( input clk[], output res[], input in[] );
        // instanciate 4 Wires
        wire_assign wire_inst[3:0];
        // assign the clocks to the wires
        assign wire_inst[0].in = clk[0];
        assign wire_inst[1].in = clk[1];
        assign wire_inst[2].in = clk[2];
        assign wire_inst[3].in = clk[3];
        // assign the outputs of the wires to the outputs
        assign res[0] = wire_inst[0].out;
        assign res[1] = wire_inst[1].out;
        assign res[2] = wire_inst[2].out;
        assign res[3] = wire_inst[3].out;
        // assign the inputs to the instances inputs
        assign wire_inst[0].in = in[0];
        assign wire_inst[1].in = in[1];
        assign wire_inst[2].in = in[2];
        assign wire_inst[3].in = in[3];
    endmodule
    ### Simulation

- code: |-
    // Create a module with wildcard-indexed input and output that behaves like a wire
    module wire_assign( in, out );
        // declare a wildcard-indexed input associative array
        input [4:0][3:0] in[*];
        assign out = in[0][0];
    endmodule
    ### Run Simulation:
    Run the simulation using a 5-element input array and check that output[0] is equal to input[0][0].
    
    ### Result:
    ![Result](https://i.imgur.com/0F2W62u.png)
    
    ### Analysis:
    Using a wildcard indexing is not allowed in a module instantiation.  The following Verilog code will fail:
    ```
    module wire_assign_fail( in

- code: |-
    module wire_assign_mod( input clk[8], output out );
        // assign out to clk[*]
        assign out = clk[*];
    endmodule
    """
    
    import sys
    import re
    
    def check_test_cases(test_cases, verbose):
        return_code = 0
        for test_case in test_cases:
            test_name = test_case[0]
            expected_output = test_case[1]
            actual_output = test_case[2]
            if expected_output == actual_output:
                if verbose:
                    print("Test Passed: " + test_name)
            else:
                print("Test Failed:\n" + test_name)
                print("Expected Output: \n" + expected_output)
                print("Actual Output: \n" + actual_output)
                return_code = 1
        return return_code
    
    def main(argv):
        verbose = False
        test_cases = [
            ["Input_01", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_02", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_03", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_04", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_05", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_06", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_07", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_08", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_09", "Module instantiated with a wildcard index.", "Module instantiated with a wildcard index."],
            ["Input_10", "Module instantiated with a wildcard index.",

- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out to


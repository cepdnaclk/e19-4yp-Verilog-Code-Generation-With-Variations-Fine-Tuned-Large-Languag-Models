- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        if (a inside {1,2,3,4,5,6,7,8})
          (a, b *> s) = dl1;
        else
          (a, b *> s) = dl2;
        if (a inside {1,2,3,4,5,6,7,8})
          (a, b *> ca) = dl1;
        else
          (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Testbench Code:
    module tb_ha_8; // Testbench for the modified design ha_8
      reg a,b,clock;
      wire s,ca;
      ha_8 uut(s,ca,a,b);
      initial
        begin
          $dumpfile("dump.vcd"); $dumpvars;
          a = 0; b = 0;
          clock = 0;
          repeat (2) #10;
          a = 1; b = 1;
          repeat (2) #10;
          a = 1; b = 0;
          repeat (2) #10;
          a = 0; b = 1;
          repeat (2) #10;
          $finish;
        end
      always #1 clock = ~clock;
      initial
        begin
          #10;
          clock = 1;
          repeat (10)
            #10;
        end
    endmodule
    ### Simulation Result:
    ### Screenshot of Waveform:
    
    ![Waveform](https://raw.githubusercontent.com/hugh-lim/Digital-System-Design-2/main/Labs/Lab4B/ha_8_with_specparam_path_delays_tb_output.PNG)
    
    ### Reflection:
    - I noticed that if I removed the `a inside {1,2,3,4,5,6,7,8}` statements, the design output matched exactly with the unmodified design.
    - `a inside {1,2,3,4,5,6,7,8}` is basically a if condition with a logical expression and a path delay expression. 
    - The result of the logical expression, in this case, `a inside {1,2,3,4,5,6,7,8}`, is either true or false, which means that I can simply use `a inside {1,2,3,4,5,6,7,8}` as a condition to add a delay to a path.
    - The delay expression after the condition is assigned to the path.
    - The original design had both paths delay `dl1`.
    - The modified design has different delays for each path.
    - Path delay expressions have a higher priority than other expressions.
    - The `if` statement will always be evaluated first before the logical expression, which means that both the `if` statement and the logical expression will be evaluated before the path delay expressions are assigned to the paths.
    - `a inside {1,2,3,4,5,6,7,8}` will evaluate to true if a is within the values 1 through 8.
    - Hence, the modified design will have the paths with different delays when a value of 1 through 8 is assigned to a.
    
    ##### Reference:
    [Verilog Expressions](https://www.allaboutcircuits.com/textbook/verilog/chpt-7/expressions/)
    [Array Slice Expressions](https://www.t

- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        if(a[5:1] inside {[6:10], [2:4], [0:2]}) begin
          (a, b *> s) = dl1;
          (a, b *> ca) = dl2;
        end
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Verification:
    Run the command "run" to obtain the summary report.
    The expected report should be:
    ```

- code: |-
    module ha_10(s,ca,a,b);
      input a,b; output s,ca;
      specify
        specparam dl1 = 1;
        specparam dl2 = dl1 + 1;
        // Assign path delays using specparams
        if (`a in {s[6:0],d[2:0]})
          (a, b *> s) = dl1;

- code: |-
    module ha_9(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        if ( (a, b) inside {[0:1] [6:7], [4:5] [8:9]} ) begin
          (a, b *> s) = dl1;
          (a, b *> ca) = dl2;
        end
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### What does this do?
    1. This adds an if condition checking whether the element is inside the range list [0:1] [6:7] or [4:5] [8:9].
    2. If it is inside the range list, then we apply the path delays for the output.
    
    ### Sample Testbench Code:
    module ha_test;
      wire ca, s;
      reg [3:0] a,b;
      ha_9 dut(.s(s),.ca(ca),.a(a),.b(b));
      initial begin
        $dumpfile("ha_viz.vcd"); $dumpvars(1);
        #(10);

- code: |-
    module ha_9(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor(s,a,b);
      and(ca,a,b);
    endmodule
    module dlx_9(s,a,b); // Design Library Xor
      input a,b; output s;
      ha_9 h0(s,a,b);
    endmodule
    module dlx_5(s,a,b); // Design Library And
      input a,b; output s;
      dlx_9 dlx0(s,a,b);
    endmodule
    module top(s,a,b);
      xor s;

- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Pass/Fail Criteria:
    HDL compilers should reject any HDL file containing logic error.
    ### Sample Testbench:
    module tb;
      logic [3:0] a,b,s,ca;
      ha_8 u0(.*);
      initial begin
        repeat(5) begin
          #10;
          a = $random;
          b = $random;
          $display("a=%b, b=%b, s=%b, ca=%b",a,b,s,ca);
        end
        $finish;
      end
    endmodule
    ### Passing Code:
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a[1], b[1]) *> ca = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a[1],b[1]);
    endmodule
    ### Sample Testbench:
    module tb;
      logic [3:0] a,b,s,ca;
      ha_8 u0(.*);
      initial begin
        repeat(5) begin
          #10;
          a = $random;
          b = $random;
          $display("a=%b, b=%b, s=%b, ca=%b",a,b,s,ca);
        end
        $finish;
      end
    endmodule
    ### Passing Code:
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a[1], b[1:1]) *> ca = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a[1],b[1:1]);
    endmodule
    ### Pass/Fail Criteria:
    HDL compilers should reject any HDL file containing logic error.
    ### Sample Testbench:
    module tb;
      logic [3:0] a,b,s,ca;
      ha_8 u0(.*);
      initial begin
        repeat(5) begin
          #10;
          a = $random;
          b = $random;
          $display("a=%b, b=%b, s=%b, ca=%b",a,b,s,ca);
        end
        $finish;
      end
    endmodule
    ### Passing Code:
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a[1], b[1:2]) *> ca = dl2;
      endspec

- code: |-
    module ha_8(s,ca,a,b);
      input a,b; output s,ca;
      specify
        specparam dl1 = 1;
        specparam dl2 = dl1 + 1;
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
        if (a[0:1][0:1]==2'b00)
          (a, b *> s) = 1;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Expected Output:
    ```
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      'dl1' is not a constant
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      'dl2' is not a constant
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to 'a'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to 'b'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to's'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to 'ca'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to's'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      Illegal array reference to 'ca'.
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      'dl1' is not a constant
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      'dl2' is not a constant
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      (ca, a, b) 
      'ca' is not a signal
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      (ca, a, b) 
      'a' is not a signal
    11/14/20 20:45:04 Error: HDL error in (file <file:hdl> line <number:1>): 
      (ca, a, b) 
      'b' is not a signal
    ```
    ### Version 1:
    #### Base Verilog Code:
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Variation Instruction:
    Add an if condition that checks whether a 4D

- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      if (s[3:1] inside {2'b101,2'b110,2'b111,2'b011})
        s = 1;
      else if (s [3:1] inside {2'b010,2'b011,2'b100,2'b101})
        ca = 1;
      else if (s[3:1] inside {2'b100,2'b010})  // Note use of 'inside' operator
        s = ca = 0;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Synthesis Log:
    [Synth 8-508] synth_design -top testbench_h -part xc7a100tfgg484-3
    ### Simulation Log:
    [Sim 8-508] do_simulate -force xcelium -input testbench_h
    Using Xcelium version 20.1.0-1139954
    .l ha_8.v
    .l testbench_h.v
    .procs
    .end
    trce -labels -v
    rtrace -labels -v
    .end
    .tran 0.01 0.10
    .end

- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        if(a && b)
          (a, b *> s) = dl1;
        if(ca)
          (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Synthesis Results:
    #### Latency:
    ![alt text](https://github.com/ahmed-si/Low-Power-FPGA-Designs/blob/main/Specify_path_delays/src/results/specify_path_delays_latency.png?raw=true)
    #### Area: 
    ![alt text](https://github.com/ahmed-si/Low-Power-FPGA-Designs/blob/main/Specify_path_delays/src/results/specify_path_delays_

- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        if (a[3:0] inside {2,3})
          // Assign path delays using specparams
          (a, b *> s) = dl1;
        else
          (a, b *> s) = dl1 + 2;
        if (a[3:0] inside {2,3})
          (a, b *> ca) = dl2;
        else
          (a, b *> ca) = dl2 + 2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Simulation Log:
    ```
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        if (a[3:0] inside {2,3})
          // Assign path delays using specparams
          (a, b *> s) = dl1;
        else
          (a, b *> s) = dl1 + 2;
        if (a[3:0] inside {2,3})
          (a, b *> ca) = dl2;
        else
          (a, b *> ca) = dl2 + 2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    
    module tb_ha_8();
      reg [7:0] a; reg b; wire s; wire ca;
      ha_8 h (.s(s),.ca(ca),.a(a),.b(b));
      initial begin
        a = 2'b00; b = 1'b1; 
        #1;
        a = 2'b00; b = 1'b0;
        #1;
        a = 2'b01; b = 1'b1; 
        #1;
        a = 2'b01; b = 1'b0;
        #1;
        a = 2'b10; b = 1'b1; 
        #1;
        a = 2'b10; b = 1'b0;
        #1;
        a = 2'b11; b = 1'b1; 
        #1;
        a = 2'b11; b = 1'b0;
        #1;
      end
    endmodule
    module rtl;
      ha_8 h (.s(s),.ca(ca),.a(a),.b(b));
    endmodule
    
    module tb_ha_8();
      reg [7:0] a; reg b; wire s; wire ca;
      ha_8 h (.s(s),.ca(ca),.a(a),.b(b));
      initial begin
        a = 2'b00; b = 1'b1; 
        #1;
        a = 2'b00; b = 1'b0;
        #1;
        a = 2'b01; b = 1'b1; 
        #1;
        a = 2'b01; b = 1'b0;
        #1;
        a = 2'b10; b = 1'b1; 
        #1;
        a = 2'b10; b = 1'b0;
        #1;
        a = 2'b11; b = 1'b1; 
        #1;
        a = 2'b11; b = 1'b0;
        #1;
      end
    endmodule
    tb_ha

- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            default: ParOut <= 8'bX;
            4: Par

- code: |-
    `timescale 1ns/100ps

- code: |-
    `timescale 1ns/100ps
    
    module ShiftRegister32 (input sl, sr

- code: |-
    ```verilog
    timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= {ParIn[5:2], ParIn[1:0], ParOut[7:6]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    ```
    ### Simulation:
    ![Simulation](https://github.com/Elsfa7-110/Verilog-Tutorial/blob/master/11%20-%20Vector%

- code: |-
    ```verilog
    module ShiftRegister #(parameter N = 8) (input sl, sr, clk, input [N-1:0] ParIn, input [1:0] m, output reg [N-1:0] ParOut);
        always @(negedge clk) begin
            case (m)
                0: ParOut <= ParOut;
                1: ParOut <= {sl, ParOut[N-1:1]};
                2: ParOut <= {ParOut[N-1:2], sr};
                3: ParOut <= ParIn;
                default: case (N)
                        0: ParOut <= {N{1'bX}};
                        1: ParOut <= {1'bX};
                        2: ParOut <= {ParOut[1:0]};
                        3: ParOut <= {ParOut[2:1]};
                        4: ParOut <= {ParOut[3:1]};
                        5: ParOut <= {ParOut[4:1]};
                        6: ParOut <= {ParOut[5:1]};
                        7: ParOut <= {ParOut[6:1]};
                        8: ParOut <= {ParOut[7:1]};
                        default: ParOut <= {N{1'bX}};
                    endcase
            endcase
        end
    endmodule
    ```
    ### Simulation:
    ![simulation](./waveform2.jpg)
    
    
    ### Task 3
    
    The new module is an array of parameterized modules.
    ### Base Verilog Code:
    ```verilog
    module ShiftRegister #(parameter N = 8) (input sl, sr, clk, input [N-1:0] ParIn, input [1:0] m, output reg [N-1:0] ParOut);
        always @(negedge clk) begin
            case (m)
                0: ParOut <= ParOut;
                1: ParOut <= {sl, ParOut[N-1:1]};
                2: ParOut <= {ParOut[N-1:2], sr};
                3: ParOut <= ParIn;
                default: case (N)
                        0: ParOut <= {N{1'bX}};
                        1: ParOut <= {1'bX};
                        2: ParOut <= {ParOut[1:0]};
                        3: ParOut <= {ParOut[2:1]};
                        4: ParOut <= {ParOut[3:1]};
                        5: ParOut <= {ParOut[4:1]};
                        6: ParOut <= {

- code: |-
    ```verilog
    timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParIn[1], ParIn[0]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    ```
    ### Modified Simulation Results:
    ![Packed Vector Array Select with Combinational Operator Example](packed_vector_array_select_with_combinational_operator_example.png)
    
    ### Source Code:
    - [ShiftRegister8.vhd](ShiftRegister8.vhd)
    - [ShiftRegister8_mod.vhd](ShiftRegister8

- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case ({m, [2:0] ParIn[7:5]})
            3'b000: ParOut <= ParOut;
            3'b001: ParOut <= {sl, ParOut[7:1]};
            3'b010: ParOut <= {ParOut[6:0], sr};
            3'b011: ParOut <= ParIn;
            3'b100: ParOut <= {1'b0, ParOut[7:1]};
            3'b101: ParOut <= {1'b0, ParOut[6:0], sr};
            3'b110: ParOut <= {1'b0, ParOut[5:0], ParIn[7], sl};
            3'b111: ParOut <= {1'b0, ParOut[4:0], ParIn[6:0], sr};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    ### Modified Code Test Bench
    ```
    `timescale 1ns/100ps
    module ShiftReg8tb();
    reg clk;
    reg ParIn [7:0];
    reg sl, sr;
    reg [1:0] m;
    wire [7:0] ParOut;
    reg [2:0] m_list = 3'b000,3'b001,3'b010,3'b011,3'b100,3'b101,3'b110,3'b111;
    ShiftRegister8 ShReg(ParIn, clk, ParOut, sl, sr, m);
    
    initial begin
        clk = 0;
        #50;
        $display("%d", ParOut);
        ParIn <= 8'hA1;
        clk <= ~clk;
        #50;
        $display("%d", ParOut);
        sl <= 1;
        sr <= 1;
        ParIn <= 8'hB2;
        cl

- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= {ParOut, parin[m-3]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    ```
    ### What are the differences between vector concatenation versus the inside operator?
    - Concatenation involves concatenating two or more vectors to produce a single vector that is wider than the input vectors.
    - Inside operator on the other hand involves assigning specific bit positions of the input vector to the output vector.
    
    ### Assigning values to specific bits of a packed array:
    ```
    parout = {parin[0:1], parin[7:3]};
    ```
    - A concatenated selection of the input vector is then assigned to the output vector.
    
    ### Shift Register:
    ```
    module ShiftRegister8( input clk, input [7:0] ParIn, output [7:0] ParOut );
    reg [7:0] ParOut;
    always begin
        ParOut = { ParOut[6:0], ParIn[7] };
    end
    endmodule
    ```
    - A shift register is a sequential circuit that shifts the contents of the shift register in a specific direction.
    - Since the output value is an eight bit vector, the contents can be shifted left one position (the shift is to the left).
    
    ### Synchronous Sequential:
    ```
    module SynchronousSequential( input clk, input [7:0] ParIn, output [7:0] ParOut );
    reg [7:0] ParOut;
    always @( posedge clk ) begin
        ParOut = { ParOut[6:0], ParIn[7] };
    end
    endmodule
    ```
    - Since the synchronous sequential model does not specify any edge, the simulation result is same as a combinational model.
    
    ### Asynchronous Sequential:
    ```
    module AsynchronousSequential( input clk, input [7:0] ParIn, output [7:0] ParOut );
    reg [7:0] ParOut;
    always @ ( posedge clk ) begin
        ParOut = { ParOut[6:0], ParIn[7] };
    end
    endmodule
    ```
    - An asynchronous sequential model specifies that the combinational output would be valid at a **positive edge** of the clock.
    
    ### Truth Table:
    ![Truth Table](https://i.imgur.com/LqGxbHr.png)
    - The truth table is used to generate a VHDL or Verilog model for a combinational circuit.
    - It is also used to synthesize a circuit.
    - A clock value associated with the input values is assigned to a clock signal.
    - The clock value is used to synchronize the computation of the output values.
    
    
    ### Testbench for Synchronous Sequential Circuit:
    ```
    module tb_ss_circuit;
    reg [7:0] ParIn;
    wire [7:0] ParOut;
    wire [7:0] SyncParOut;
    reg clk;
    integer i;
    
    SynchronousSequential ss_circuit ( clk, ParIn, SyncParOut );
    
    initial begin
        i=0;
        ParIn = 8'b0_0000_0000;
        clk = 0;
        #1    
        while(i<8) begin
            ParIn = 8'd1<<i;
            clk = 0;
            #60
            clk = 1;
            #60
            i = i + 1;
        end
    end
    
    initial begin
    #100        
    $finish;
    end
    
    endmodule
    
    ```
    - There are two outputs associated with this circuit.
    - The first output is synchronous and uses a clock signal.
    - The second output is asynchronous and does not use a clock signal.
    - The difference between the two outputs is that the synchronous output is at the same frequency as the

- code: |-
    ```
    timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= ParOut[2:0] | {1'b0, ParOut[3:2]};
            default: ParOut <= 8'bX;

- code: |-
    ```
    timescale 1ns/100ps
    module ShiftRegister8
    (
        input sl, sr, clk,
        input [7:0] ParIn,
        input [1:0] m,
        output reg [7:0] ParOut
    );
        always @(negedge clk) begin
            case (m)
                0: ParOut <= ParOut;
                1: ParOut <= {sl, ParOut[7:1]};
                2: ParOut <= {ParOut[6:0], sr};
                3: ParOut <= ParIn;
                default: ParOut <= 8'bX;
                case (m[1:0])
                    {2'b00}: ParOut <= ParOut;
                    {2'b01}: ParOut <= {sl, ParOut[7:1]};
                    {2'b10}: ParOut <= {ParOut[6:0], sr

- code: |-
    // Create a task that can be called with any method
    task create_task(method);
    // Use the inside mechanism to obtain an index from the packed array
    int index =

- code: |-
    module example7_4_6(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [1:0] my_arr;
    always @(posedge Clock)
    begin
        my_arr[0] <= D;
        my_arr[1] <=

- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [3:0] memory [3:0];
    always @(posedge Clock)
    begin
        for(int i = 0; i < 3; i++)
        begin
            memory[i] = D;
        end
        Q1 <= memory[0];
        Q2 <= memory[1];
    ```
    ### Output Code:
    ```
    # *******************************************
    # Start module: example7_4
    # *******************************************
    # Add ports
      add_port "D" INPUT "D"
      add_port "Clock" INPUT "Clock"
      add_port "Q1" OUTPUT "Q1"
      add_port "Q2" OUTPUT "Q2"
    # Add reg_array memory
      reg_array memory "memory" "3:0" "3:0"
    # Add block:
      add_block "example7_4_loop"
      set_block_attribute "example7_4_loop" "loop_variable" "i"
      set_block_attribute "example7_4_loop" "loop_condition" "i < 3"
      add_block_alias "example7_4_loop" "loop_invar_0" "memory[i]"
      add_block_alias "example7_4_loop" "memory[i]" "memory[i]"
      add_block_alias "example7_4_loop" "memory[i]" "D"
      add_block_alias "example7_4_loop" "memory[i]" "Q1"
      add_block_alias "example7_4_loop" "Q2" "memory[i]"
    # Add instruction:
      add_instruction "example7_4_loop" "memory[i]" "memory[i]" "memory[i] <= D"
    # Add output:
      add_output "Q1" "memory[0]" "Q1"
      add_output "Q2" "memory[1]" "Q2"
    # *******************************************
    # End module: example7_4
    # *******************************************
    ```
    ### Verification:
    ```
    * Regression test
    >./main.py -v../testcase/example7_4.ysv -o 1
    ** Execute the original verilog code and the output verilog code **
    * Verilog file used
    > example7_4.ysv
    > orig.ysv
    * Synthesis results
    > ----------------------------------------------------------------------------
    > ----------
    > Synthesis results for../testcase/example7_4.ysv
    > ----------
    > ----------------------------------------------------------------------------
    > Synthesis result: 
    > ----------------------------------------------------------------------------
    > Memory Name       :  memory
    > Size              :  4 bits
    > ----------------------------------------------------------------------------
    > Memory Instance   :  
    > memory_instance_1
    > ----------------------------------------------------------------------------
    > SRAM Size         :  4
    > ----------------------------------------------------------------------------
    > SRAM Instance   :  
    > memory_instance_1_instance_1
    > ----------------------------------------------------------------------------
    > Memory Type       :  SRAM
    > Width             :  4
    > Depth             :  4
    > Write Address     :  D[3:0]
    > Write Data        :  D[3:0]
    > Write Enable      :  Clock
    > Output 1          :  Q1
    > Output 2          :  Q2
    > ----------------------------------------------------------------------------
    > Total Memory Size :  32
    > ----------------------------------------------------------------------------
    * Synthesis results
    > ----------------------------------------------------------------------------
    > ----------
    > Synthesis results for 1_example7_4.ysv
    > ----------
    > ----------------------------------------------------------------------------
    > Synthesis result: 
    > ----------------------------------------------------------------------------
    > Memory Name       :  memory
    > Size              :  4 bits
    > ----------------------------------------------------------------------------
    > Memory Instance   :  
    > memory_instance_1
    > ----------------------------------------------------------------------------
    > SRAM Size         :  4
    > ----------------------------------------------------------------------------
    > SRAM Instance   :  
    > memory_instance_1_instance_1

- code: |-
    module example7_10(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [1:0] R;
    integer i;
    assign R[i] = D;
    always @(posedge Clock)
    begin
        Q1 <= R[0];
        Q2 <= R[1];
    end
    while (i < 2)
    begin
    i++;
    end
    endmodule
    ### Modified Code Description:
    Use a while loop and assign the value of `D

- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    integer i, j;
    while (i<8)

- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

- code: |-
    module example7_4_modified(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [7:0] Qs_packed[15:0];
    integer index;
    always @(posedge Clock)
    begin
        if (index < 15)
            Qs_packed[index] <= D;
        else
            Qs_packed[index] <= 0;
        index <= index + 1;
    end
    assign Q2 = Qs_packed[index];
    assign Q1 = Qs_packed[index - 1];
    endmodule
    ### Testbench Code:
    module example7_4_tb;
    timeunit    1ns;
    timeprecision   1ns;
    logic   D = 0;
    logic   Clock = 0;
    initial Clock = 0;
    final Clock = 1;
    logic   Q1;
    logic   Q2;
    example7_4    u0 (D, Clock, Q1, Q2);
    initial begin
        D = 1;
        repeat (10) @(posedge Clock);
        D = 0;
        repeat (10) @(posedge Clock);
        D = 1;
        repeat (10) @(posedge Clock);
    end
    always begin
        #5 Clock = ~Clock;
    end
    endmodule
    ### Simulation Result:
    ### Base Verilog Code
    ![example7_4_result_base](https://github.com/AoEiuV020/aoeiuv/blob/master/content/snow/vhdl/example7_4_result_base.png)
    ### Variation Instruction
    ![example7_4_result_modified](https://github.com/AoEiuV020/aoeiuv/blob/master/content/snow/vhdl/example7_4_result_modified.png)
    ### Testbench Code
    ![example7_4_result_tb](https://github.com/AoEiuV020/aoeiuv/blob/master/content/snow/vhdl/example7_4_result_tb.png)
    ### Sim

- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [3:0] array_of_bits [1:0];
    integer i;
    initial begin
        i=0;
    end
    
    always @(posedge Clock)
    begin
        i = i+1;
        while (i<4) begin
            with (i)
            begin
                array_of_bits[i] <= D;
            end
        end

- code: |-
    module example7_6(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [1:0] Q[2:0];
    integer i;
    always @(posedge Clock)
    begin
        for(i = 0; i < 3; i = i + 1)
        begin
            Q[i][0] <= D;
            Q[i][1] <= Q[i][0];
        end
        Q1 <= Q[2][1];
        Q2 <= Q[1][1];
    end
    endmodule
    ### Screenshot:
    ![Screenshot](images/example-7-6.PNG)
    ### Code Example:
    ### Base Verilog Code:
    module example7_7(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [1:0] Q[2:0];
    integer i;
    always @(posedge Clock)
    begin
        i = 0;
        while(i < 3)
        begin
            Q[

- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [3:0] regs_arr[4:0];
    reg [3:0] regs_arr_1[4:0];
    integer i;
    integer j;
    always @(posedge Clock)
    begin
        begin
            i = 0;
            j =

- code: |-
    module FA;
        input A, B;
        wire Y;
        assign Y = A ^ B;
    endmodule
    
    module Ripple_Add;
        input [4:0] A;
        input [4:0] B;
        output reg [4:0] Y;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        always @*
            begin
                fa0.A = A[0];
                fa0.B = B[0];
                fa1.A = A[1];
                fa1.B = B[1];
                fa2.A = A[2];
                fa2.B = B[2];
                fa3.A = A[3];
                fa3.B = B[3];
                fa0.Y = fa1.Y;
                fa1.Y = fa2.Y;
                Y = fa3.Y;
            end
    endmodule
    ### Verilog Modelsim Simulation Result:
    ![Simulation Result](https://github.com/J-Jie/EE192_Project/blob/main/2-Verilog/project_2/Simulation%20Result%202.png)
    ##

- code: |-
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        always @* begin
            {fa3.a[1:0], fa2.a[1:0], fa1.a[1:0], fa0.a[1:0]} = 
                {fa2.a[1:0], fa1.a[1:0], fa0.a[1:0]};
        end
    endmodule
    
    ### Modified Verilog Code:
    module FA;
        input a;
        output q;
        FA_FF ff();
        always @* begin
            ff.d = a;
        end
        always @* begin
            q = ff.q;
        end
    endmodule
    
    module FA_FF;
        input

- code: |-
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        wire [3:0] a, b, sum;
    
        always @(a, b) begin
            sum[3:1] = a[2:0] + b[2:0];
            sum[0] = a[0] + b[0] + fa1.out[0];
        end
    
        FA #(.n(1)) fa1 ();
        FA #(.n(1)) fa2 ();
        FA #(.n(1)) fa3 ();
    
    endmodule
    ### Simulation Log:
    ```
    # **Ripple_Adder_Testbench**
    ### Description:
    Testbench to verify the Ripple Adder module. The testbench checks if the output of the Ripple Adder is equivalent to the sum of its inputs.
    ### Source Files used:
    ```
    testbench.sv
    ripple_add.sv
    ```
    ### Compile and Link:
    ```
    iverilog ripple_add_tb.sv
    ```
    ### Run:
    ```
    vvp a.out
    ```
    ### View Results:
    ```
    ghdl -r ripp

- code: |-
    module FA;
        reg [3:0] i;
        wire [3:0] o;
        always @(*)
            o[1:2] = i;
        assign o[0] = 0;
    endmodule
    
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        FA fa4();
        FA fa5();
        FA fa6();
        FA fa7();
        FA fa8();
    endmodule
    ### Modified SDF Graph:
    
    ![Modified SDF Graph](FA_variation1.dot.svg)
    
    
    ### Original SDF Graph:
    
    ![Original SDF Graph](FA_variation0.dot.svg)
    
    
    ### SDF File:
    
    [FA_variation1.sdf.txt](FA_variation1.sdf.txt)
    
    
    ### SDF Graph File:

- code: |-
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        int A[3:0];
        int B[3:0];
        int C[1:0];
        int D;
        wire [2:0] result;
        always @* begin
            result = {C, B, A};
        end
        assign fa0.A = A;
        assign fa0.B = B;
        assign fa0.C = C;
        assign C = fa0.D;
        assign fa1.A = C;

- code: |-
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
    
        always @(a) b[3:0] = a[3:0] + b[2:0];
    endmodule
    
    module Ripple_Add (
        input  logic [3:0] a,
        input  logic [3:0] b,
        output logic [3:0] sum
    );
    
        fa0 (
           .a   ( a[3] ),
           .b   ( b[3] ),
           .sum ( sum[3] )
        );
        fa1 (
           .a   ( a[2] ),
           .b   ( b[3] ),
           .sum ( sum[2] )
        );
        fa2 (
           .a   ( a[1] ),
           .b   ( b[2] ),
           .sum ( sum[1] )
        );
        fa3 (
           .a   ( a[0] ),
           .b   ( b[1] ),
           .sum ( sum[0] )
        );
    endmodule
    
    module Ripple_Add (
        input  logic [3:0] a,
        input  logic [3:0] b,
        output logic [3:0] sum
    );
        fa0 (
           .a   ( a[3] ),
           .b   ( b[3] ),
           .sum ( sum[3] )
        );
        fa1 (
           .a   ( a[2] ),
           .b   ( b[3] ),
           .sum ( sum[2] )
        );
        fa2 (
           .a   ( a[1] ),
           .b   ( b[2] ),
           .sum ( sum[1] )
        );
        fa3 (
           .a   ( a[0] ),
           .b   ( b[1] ),
           .sum ( sum[0] )
        );
    endmodule
    
    module Ripple_Add (
        input  logic [3:0] a,
        input  logic [3:0] b,
        output logic [3:0] sum
    );
        fa0 (
           .a   ( a[3] ),
           .b   ( b[3] ),
           .sum ( sum[3] )
        );
        fa1 (
           .a   ( a[2] ),
           .b   ( b[3] ),
           .sum ( sum[2] )
        );
        fa2 (
           .a   ( a[1] ),
           .b   ( b[2] ),
           .sum ( sum[1] )
        );
        fa3 (
           .a   ( a[0] ),
           .b   ( b[1] ),
           .sum ( sum[0] )
        );
    endmodule
    
    module Ripple_Add (
        input  logic [3:0] a,
        input  logic [3:0] b,
        output logic [3:0] sum
    );
        fa0 (
           .a   ( a[3] ),
           .b   ( b[3] ),
           .sum ( sum[3] )
        );
        fa1 (
           .a   ( a[2] ),
           .b   ( b[3] ),
           .sum ( sum[2] )
        );
        fa2 (
           .a   ( a[1] ),
           .b   ( b[2] ),
           .sum ( sum[1] )
        );
        fa3 (
           .a   ( a[0] ),
           .b   ( b[1] ),
           .sum ( sum[0] )
        );
    endmodule
    
    module Ripple_Add (
        input  logic [3:0] a,
        input  logic [3:0] b,
        output logic [3:0] sum
    );
        fa0 (
           .a   ( a[3] ),
           .b   ( b[3] ),
           .sum ( sum[3] )
        );
        fa1 (
           .a   ( a[2] ),
           .b   ( b[3] ),
           .sum ( sum[2] )
        );
        fa2

- code: |-
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
    
        always @*
            fa3.C = fa0[1].C? fa2.C : 1'b0;
    
    endmodule
    ### Variation Verilog Code:
    module FA;
        input A;
        input B;
        output C;
    
        assign C = A? B : 1'b

- code: |-
    module Ripple_Add;
        FA fa0();
        logic [3:0] b;
    
        always @* begin
            fa0.A = A[0:0];
            fa0.B = b;
        end
    endmodule
    ### Comments:
    A variable expression is used for B in fa0.
    ### Compliance:
    IEEE 1800-2017 4.4.2.1
    IEEE 1800-2017 11.4.2.1
    IEEE 1800-2017 11.5.2.1
    IEEE 18

- code: |-
    module Ripple_Add;
        parameter COUNTER_WIDTH = 3;
        parameter ARRAY_LENGTH =

- code: |-
    ```verilog
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        reg [7:0] fa0_data;
        reg [7:0] fa1_data;
        reg [7:0] fa2_data;
        reg [7:0] fa3_data;
        always @ * begin
            fa1_data = fa0.out[1:0];
        end
        always @ * begin
            fa2_data = fa1.out[1:0];
        end
        always @ * begin
            fa3_data = fa2.out[1:0];
        end
        always @ * begin
            fa0_data = fa3.out[1:0];
        end
        assign fa0.in = fa0_data;
        assign fa1.in = fa1_data;
        assign fa2.in = fa2_data;
        assign fa3.in = fa3_data;
    endmodule
    ```
    ### Result:
    ![ripple_add](./images/ripple_add.png)
    
    ### Combination of Variations:
    module FA;
    endmodule
    
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        reg [7:0] fa0_data;
        reg [7:0] fa1_data;
        reg [7:0] fa2_data;
        reg [7:0] fa3_data;
        always @ * begin
            fa1_data = fa0.out[3:0];
        end
        always @ * begin
            fa2_data = fa1.out[2:0];
        end
        always @ * begin
            fa3_data = fa2.out[1:0];
        end
        always @ * begin
            fa0_data = fa3.out[1:0];
        end
        assign fa0.in = fa0_data;
        assign fa1.in = fa1_data;
        assign fa2.in = fa2_data;
        assign fa3.in = fa3_data;
    endmodule
    
    ![ripple_add](./images/ripple_add_p6.png)
    
    ### Combination of Variations:
    module FA;
    endmodule
    
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        reg [7:0] fa0_data;
        reg [7:0] fa1_data;
        reg [7:0] fa2_data;
        reg [7:0] fa3_data;
        always @ * begin
            fa1_data = fa0.out[7:4];
        end
        always @ * begin
            fa2_data = fa1.out[7:4];
        end
        always @ * begin
            fa3_data = fa2.out[7:4];
        end
        always @ * begin
            fa0_data = fa3.out[7:4];
        end
        assign fa0.in = fa0_data;
        assign fa1.in = fa1_data;
        assign fa2.in = fa2_data;
        assign fa3.in = fa3_data;
    endmodule
    
    ![ripple_add](./images/ripple_add_p7.png)
    
    ### Combination of Variations:
    module FA;
    endmodule
    
    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        reg [7:0] fa0_data;
        reg [7:0] fa1_data;
        reg [7:0] fa2_data;
        reg [7:0] fa3_data;
        always @ * begin
            fa1_data = fa0.out[7:4] & fa0.out[3:0];
        end
        always @ * begin
            fa2_data = fa1.out[7:4] & fa1.out[3:0];
        end
        always @ * begin
            fa3_data = fa2.out[7:4

- code: |-
    ```
    module nand8(a[7:0],b[7:0],out[7:0]); // 8-bit NAND
      input a[7:0],b[7:0];
      output out[7:0];
      supply0 gnd;
      for (i=0; i<8; i=i+1)
        begin
          nand2(a[i],b[i],out_array[i]);
        end
      // Connect out to an array of wires called out_array
      // NB: use the index result of inside(1) when creating the element of the array
      for (i=0; i<8;

- code: |-
    module caseInst(clk, in1,in2,out1, out2);
      output out1, out2;
      input clk, in1,in2;
      wire b; // The output wire
      // Variation:
      // 1. Create a case statement
      // 2. Create a function to determine inside or outside using function
      // 3. Add a case statement to determine inside or outside using function
      function inside; 
        input input;
        inside = input;
      endfunction // inside
      always @(posedge clk) begin
        b <= inside(in1) | inside(in2);
      end
      nor2NMOS dut(b,b, out1);
      nor2NMOS dut(b,b, out2);
    endmodule
    
    ########################################################################
    ### Base Verilog Code:
    module nor2NMOS(in1,in2,b); // 2-input NMOS NOR
      output b;
      input in1,in2;
      supply0 a; // Ground
      wire b; // Output wire (should

- code: |-
    module jk(n,r,q,c); // 4 input JK flip-flop
      output r, q;
      input n,r,c;
      supply0 a,b; // Ground, supply
      wire r,q; // Outputs
      wire a,b; // Internal nodes
      nand (r, c, n, b); // Combinational process
      nand (q, n, r, b); // Combinational process
      nmos (a, b, n); // NMOS tristate
      nnor3NMOS(a,b,c,r); // 3-input NOR
      nand3 (a,b,c); // 3-input NAND
    endmodule
    ### Variation Instruction:
    Modify the jk instantiation to include a case statement and a 3-input NMOS NOR and a 3

- code: |-
    module jkflipflop(clk,rst,d,q,qbar);
      input clk, rst;
      input d;
      output q, qbar;
      wire a,b,c,d,e,f;
      nor3NMOS jkff(b,f,e,a); // 3-input NMOS NOR
      nand2MOS jklatch(c,d,e,a); // 2-input NMOS NAND
      nor3NMOS jkff2(b,f,e,a);
      nand2MOS jklatch2(c,d,e,a);
      nor3NMOS jkff3(b,f,e,a);
      nand2MOS jklatch3(c,d,e,a);
      nor3NMOS jkff4(b,f,e,a);
      nand2MOS jklatch4(c,d,e,a);
      nor3NMOS jkff5(b,f,e,a);
      nand2MOS jklatch5(c,d,e,a);
      nor3NMOS jkff6(b,f,e,a);
      nand2MOS jklatch6(c,d,e,a);
      nor3NMOS jkff7(b,f,e,a);
      nand2MOS jklatch7(c,d,e,a);
      nor3NMOS jkff8(b,f,e,a);
      nand2MOS jklatch8(c,d,e,a);
      nor3NMOS jkff9(b,f,e,a);
      nand2MOS jklatch9(c,d,e,a);
      nor3NMOS jkff10(b,f,e,a);
      nand2MOS jklatch10(c,d,e,a);
    endmodule
    ### Variation Instruction:
    Modify the jk instantiation to include a case statement

- code: |-
    module jk(j,k,q);
         output q;
         input j,k;
         wire b;
         wire c;
         nor3NMOS(j,k,b,c);
         case (c) 
           1: q = inside(b,2);
           2: q = inside(b,4);
           3: q = inside(b,8);
           4: q = inside(b,16);
           5: q = inside(b,32);
           6: q = inside(b,64);
           7: q = inside(b,128);
           8: q = inside(b,256);
           9: q = inside(b,512);
           10: q = inside(b,1024);
           11: q = inside(b,2048);
           12: q = inside(b,4096);
           13: q = inside(b,8192);
           14: q = inside(b,16384);
           15: q = inside(b,32768);
           16: q = inside(b,65536);
           17: q = inside(b,131072);
           18: q = inside(b,262144);
           19: q = inside(b,524288);
           20: q = inside(b,1048576);
         endcase
      endmodule
    
    ### Test Bench
    module jk_tb;
      reg j;
      reg k;
      wire q;
      jk uut(j,k,q);
      initial begin
         j<= 0;
         k<= 1;
         #10
         j<= 0;
         k<= 1;
         #10
         j<= 0;
         k<= 1;
         #10
         j<= 0;
         k<= 1;
      end
    endmodule
    ### Expected Output
     01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010
    ### Actual Output
     01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010 01010 11010
    ### Points to Consider:
     - In the test bench, we have been using `initial` statements rather than `always` block which doesn't need to be synthesized.
     - Instead of using `initial` block, if we use `always` block, since the sensitivity list is empty, the block will always be triggered on every clock edge and generate this 32-bit  pattern.
    
    ### Reference
     - Section 10.1.3 (page 139 to 140) of `Verilog: A Guide for Synthesis and FPGA Application, 2nd Edition`
     - [IEEE 1800-2012](http

- code: |-
    module jkFlipFlop(clock, reset, in, out);
      output out;
      input clock, reset, in;
    
      // Add variables
      wire clock_invert, reset_invert;
      wire [1:0] nor_out;
      wire[1:0] nor_out_invert;
      wire [1:0] nor_out_out;
    
      // invert inputs for JK flip-flop
      not (clock_invert, clock);
      not (reset_invert, reset);
    
      // 2-input NAND
      nand2 (clock_nand, clock_invert, clock_invert);
      nand2 (reset_nand, reset, reset_invert);
    
      nor3NMOS(nor_out[0], nor_out[1], clock_nand, nor_out_out[0]);
      nor3NMOS( nor_out[1], reset_nand, clock_nand, nor_out_out[1]);
    
      nor3NMOS( nor_out_invert[0], nor_out_out[0], nor_out_out[1], nor_out_invert[1]);
      nor3NMOS( nor_out_invert[1], reset_nand, nor_out_out[1], nor_out_invert[0]);
    
      // use nor_out to determine output
      // case/endcase block using inside with function
      case(inside_with(nor_out_invert))
        2'b00:

- code: |-
    ```verilog
    module jk(q,r,s,t,clk,rst); // JK flip-flop with asynchronous reset
      output q,r;
      input rst;
      input clk,s,t;
      supply0 a;
      wire q,r;
      nmos (r, a, s);
      nmos (q, a, t);
      if (clk)
        inside
        case (and(rst,s))
          0: q <= r;
          1: q <= t;
          1'bx: q <= r;
        endcase
        pullup (r);
        pullup (q);
    endmodule
    //Simulation Results:
    ```
    ![](https://github.com/JingweiToo/EE2020_summer/blob/main/week1/img/jk_ff_inside

- code: |-
    module jkflipflop(
      output out1,out2,clock,reset,
      input [1:0] switch1, switch2
    );
      wire notin1, notin2, nor3out, nor4out, nor3norflipout, nor4norflipout;
      wire nor3norflip, nor4norflip;
      nor3NMOS nor3norflipinst(notin2, switch1[0], switch1[1], nor3norflip);
      nor3NMOS nor3norflipinst2(notin1, nor3norflip, nor4norflip, nor3norflipout);
      nor3NMOS nor4norflipinst(notout2, nor3norflip, nor4norflip, nor4norflipout);
      nor3NMOS nor4norflipinst2(notout1, nor4norflip, switch2[1], nor4norflip);
      notgate notinst1(notin1, switch2[0]);
      notgate notinst2(notin2, switch1[1]);
      notgate notinst3(notout1, clock);
      notgate notinst4(notout2, reset);
      andNMOS andinst1(out1, notin1, nor3norflipout);
      andNMOS andinst2(out2, notin2, nor4norflipout);
    endmodule
    ### Discussion / Commentary
    ##### 1. What is the purpose of adding the case statement?
    ##### 2. What do you think is the difference between the index and the function call result for the case statement index?
    ##### 3. What happens if the index is an input?
    ##### 4. What happens if the index is a constant?
    ##### 5. What is the purpose of the pullup/pulldown devices?
    ##### 6. Is a pullup device required for an output?
    ##### 7. What are some other uses for pullup/pulldown devices?
    ##### 8. What happens if the function call result is used in a pullup/pulldown device?
    ##### 9. Why are the devices for the case statement necessary?
    ##### 10. Why is there no pullup/pulldown device inside the nmos or notgate instances?
    ##### 11. How is the nor3norflipreg needed if nor3norflipout is also used?
    ##### 12. What happens if the nor3norflip and nor4norflip wires are connected directly to each other instead of being connected to nor3norflipinst and nor4norflipinst?
    ##### 13. Why is the reg (register) needed? Would it work if it was removed?
    ##### 14. What happens to the inputs of the inside notgate instances if just the nmos instances are used?
    ##### 15. What happens to the inputs of the inside nmos instances if just the notgate instances are used?
    ##### 16. Why is the reg needed for the notgate instances as well?
    ##### 17. How can you see if the output of the instances is what you expect?
    ##### 18. Would it work to have a notgate with an input of an output from an NOR gate?
    ##### 19. What would happen if the wire is removed from the jkflipflop and replaced with an input?
    ##### 20. Would it work to have a notgate with an input of an output from an NOR gate?
    ##### 21. What would happen if the jkflipflop was just an AND gate with an input of an output from a NOR gate?
    ##### 22. What would happen if the jkflipflop was just an AND gate with an input of an output of an NOR gate?
    ##### 23. What would happen if the jkflipflop was just an AND gate with an input of an output of a NOR gate and another AND gate?
    ##### 24. What are the inputs of the jkflipflop instances?
    ##### 25. What is the output of the jkflipflop instances?
    ##### 26. What are the differences between an input and an output?
    ##### 27. Do you think a pullup device is needed on a notgate input?
    #####

- code: |-
    module jk(clk,r,s,q);
      input clk, r,s;
      output q;
      wire inside;
      wire q0,q1,q2;
      nand(clk,s,q0);
      nand(clk,r,q1);
      NOR3NMOS(q0~q1,q0,q1,inside);
      NOR3NMOS(inside~q0,q0,q1,q2);
      NOR3NMOS(inside~q1,q1,q2,q);
    endmodule
    ### Explanation:
    By using the inside signal to control the NOR3NMOS instances, this reduces the number of transistors that need to be built. This way the number of transistors are reduced by 3/2 = 1.5. 
    ### Testbench Code:
    module jk_test();
      reg clk, r, s;
      wire q;
      jk dut(clk,r,s,q);
      initial begin
        clk = 0;
        forever #5 clk = ~clk;
      end
      initial begin
        #20;
        r = 1;
        #20;
        r = 0;
        #20;
        r = 1;
        #20;
        r = 0;
        #20;
        r = 1;
        #20;
        r = 0;
        #20;
        r = 1;
        #20;
        r = 0;
      end
      initial begin
        #10;
        s = 1;
        #20;
        s = 0;
        #20;
        s = 1;
        #20;
        s = 0;
      end
      initial begin
        #100 $display("Result: %b", q);
      end
    endmodule
    ### Output:
    Result

- code: |-
    module jk(clk, clr, in, out); // JK flipflop
      input clk, clr;
      input in;
      output out;
      wire n1, n2; // n1 and n2 are two inputs to nor3NMOS
      // nor3NMOS instantiation
      nor3NMOS (n1, in, clk, out);
      nor3NMOS (n2, clr, clk, out);
    endmodule
    ### Testbench Code:
    module jk_TB;
      wire clr, clk, out;
      // clk: 50 MHz, clr: 1 MHz
      initial begin
        clr = 1'b1;
        clk = 1'b0;
        #(1000000000/2); // T
        clr = 1'b0;
        #(1000000/2); // T
        clk = 1'b1;
        #(1000000/2); // T
        clr = 1'b1;
        #(1000000/2); // T
        clr = 1'b0;
        #(1000000/2); // T
        clk = 1'b0;
        #(1000000/2); // T
        clk = 1'b1;
        #(1000000/2); // T
      end
      jk ff (clk, clr, 1'b1, out);
      initial begin
        $monitor("out = %d", out);
        $monitor("clk = %d", clk

- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    always @(j, k) a[j * k][j * k] <= 1'b1;
    2d

- code: |-
    ```verilog
    module mux_tb;
    wire [31:0] in0, in1, in2, in3, sel, out;
    reg [31:0] in0, in1, in2, in3;
    reg sel;
    mux_8_1 mux(out, sel, in0, in1, in2, in3);
    initial begin
    in0=32'b00000000000000000000000000000001;
    in1=32'b00000000000000000000000000000010;
    in2=32'b00000000000000000000000000000100;
    in3=32'b00000000000000000000000000001000;
    sel=0;
    end
    always #10 sel = ~sel;
    endmodule
    ```
    ### Modified Design Testbench:
    ```verilog
    module tb_mux;
    reg [31:0] in0, in1, in2, in3;
    wire [31:0] out;
    reg sel;
    mux_tb dut(in0,in1,in2,in3,out,sel);
    initial begin
    in0=32'b0000000000000000000000000

- code: |-
    module test_k;
    parameter N = 4;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1

- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    m555 timer(clock);
    logic a[2][3][4] [5:0];
    logic a11 [4][5];
    always_comb
    begin
     a11 = a[2];
    end
    endmodule
    ### Expected Output:
    ### Compile-Time Failure:
    ### Runtime Semantic Checks:
    Type Check: 
        - [x] PASS: a11 has type logic[4][5]
    Value Check: 
        - [x] PASS: a11[2][3] == a[2][2][3]
        - [x] PASS: a11[2][1] == a[2][2][1]
        - [x] PASS: a11[2][0] == a[2][2][0]
        - [x] PASS: a11[1][3] == a[2][1][3]
        - [x] PASS: a11[1][2] == a[2][1][2]
        - [x] PASS: a11[1][1] == a[2][1][1]
        - [x] PASS: a11[1][0] == a[2][1][0]
        - [x] PASS: a11[0][3] == a[2][0][3]
        - [x] PASS: a11[0][2] == a[2][0][2]
        - [x] PASS: a11[0][1] == a[2][0][1]
        - [x] PASS: a11[0][0] == a[2][0][0]
        - [x] PASS: a11 has type logic[4][5]
    Type Check: 
        - [x] PASS: a11[1][2][3] == a[2][1][2][3]
        - [x] PASS: a11[1][1][3] == a[2][1][1][3]
        - [x] PASS: a11[1][0][3] == a[2][1][0][3]
        - [x] PASS: a11[1][2][2] == a[2][1][2][2]
        - [x] PASS: a11[1][1][2] == a[2][1][1][2]
        - [x] PASS: a11[1][0][2] == a[2][1][0][2]
        - [x] PASS: a11[1][2][1] == a[2][1][2][1]
        - [x] PASS: a11[1][1][1] == a[2][1][1][1]
        - [x] PASS: a11[1][0][1] == a[2][1][0][1]
        - [x] PASS: a11[1][2][0] == a[2][1][2][0]
        - [x] PASS: a11[1][1][0] == a[2][1][1][0]
        - [x] PASS: a11[1][0][0] == a[2][1][0][0]
        - [x] PASS: a11[0][2][3] == a[2][0][2][3]
        - [x] PASS: a11[0][1][3] == a[2][0][1][3]
        - [x] PASS: a11[0][0][3] == a[2][0][0][3]
        - [x] PASS: a11[0][2][2] == a[2][0][2][2]
        - [x] PASS: a11[0][1][2] == a[2][0][1][2]
        - [x] PASS: a11[0][0][2] == a[2][

- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jkFF[2:0](q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    m555 timer(clock);
    endmodule
    ### Final Code:
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk[0:2](q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    m555 timer(clock);
    endmodule
    ### Test Cases
    ![alt text](JK_FF_2D_array_inlined_passing.png)
    ### Passed Results
    ![alt text](JK_FF_2D_array_inlined_passing.png)
    ### Failed Results
    ![alt text](JK_FF_2D_array_inlined_failing.png)
    ### Non-Functional Test Case
    ![alt text](JK_FF_2D_array_inlined_nonfunctional.png)
    ### Passed: 1.000
    ### Failed: 0.000
    ### Aborted: 0.000
    ### Pass_Tolerance: 0.020
    ### Fail_Tolerance: 0.000
    ### Not_Run: 0.000
    ### Total: 1.000
    ### MDA: 6.000
    ### Coverage: 75.00%
    ### MDA/Coverage: 50.00%
    ### MD/C: 50.00%
    ### MDA_Coverage: 33.33%
    ### MDA_MD_C: 5.56%
    ### Coverage_MD_C: 66.67%
    ### Summary:
    2

- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg q;
    reg [9:0] t [0:1];
    reg [3:0] count;
    assign q = t[count[3:1]][count[0]];
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    m555 timer(clock);
    endmodule
    
    ## Test Cases:
    ### Test Case 1
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[3:1]][count[0]]" to the module.
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test Case 2
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[2]][count[3:1]][count[0]]" to the module.
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test Case 3
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[3:1]][count[0]]" to the module.
    2. Change the procedural assignment "q=t[count[3:1]][count[0]]" to "q=t[count[3:1]][count[2:0]]".
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test Case 4
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[3:1]][count[0]]" to the module.
    2. Remove the procedural assignment "q=t[count[3:1]][count[0]]".
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test Case 5
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[3:1]][count[0]]" to the module.
    2. Change the procedural assignment "q=t[count[3:1]][count[0]]" to "q=t[count[3:1]][count[2:0]]".
    3. Remove the procedural assignment "q=t[count[3:1]][count[2:0]]".
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test Case 6
    ### Description:
    The test verifies that all cases of constant index with array assignment are covered. 
    ### Pass Criteria:
    The testbench finishes without errors.
    ### Setup Flow: 
    1. Add the procedural assignment "q = t[count[3:1]][count[0]]" to the module.
    2. Change the procedural assignment "q=t[count[3:1]][count[0]]" to "q=t[count[3:1]][count[2:0]]".
    3. Add the procedural assignment "q=t[count[3:1]][count[2:0]]" to the module.
    ### Ref Flow:
    n/a
    ### Output:
    n/a
    ### Results:
    n/a
    ## Test

- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg [11:0] arr [1:0];
    reg j, k;
    jkEdgeFF jk(q

- code: |-
    module jkEdgeFF(q, clock, j, k, preset, clear);
    input j, k, clock;
    input preset, clear;
    output q;
    reg q;
    logic [3:0] array [2:0];
    always @(posedge clock)
    begin
      // Procedural assignment to array using constant index
      array[0] = 4'b1111;
      if(preset)
      begin
        q <= 1;
      end
      else if(clear)
      begin
        q <= 0;
      end
      else if(j)
      begin
        q <= ~ q;
      end
    end
    endmodule
    ### Expected Output:
    Simulation should halt with an error message along the lines of:
    "Procedural assignment has been detected while executing the following statement: array[0] = 4'b1111"
    ### Simulation Logic
    This example test case will show the same procedural code as the first test case, but will use an 1D array instead of a 2D array.
    ### Test Case:
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    logic [3:0] array [2:0];
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    $display(array[0][0]);
    end
    m555 timer(clock);
    endmodule
    ### Expected Output:
    Simulation should halt with an error message along the lines of:
    "Procedural assignment has been detected while executing the following statement: array[0][0] = 1'b0"
    ### Summary:
    This example should demonstrate a procedural assignment to a 2D logic array. Since the index is a constant, and the memory is not large enough to accommodate the index, MDA will raise an error.
    ### Simulation Logic
    Similar to the second test case, but now with a procedural assignment to an 1D logic array.
    ### Test Case:
    module jkEdgeFF(q, clock, j, k, preset, clear);
    input j, k, clock;
    input preset, clear;
    output q;
    reg q;
    logic [3:0] array [2:0];
    always @(posedge clock)
    begin
      // Procedural assignment to array using constant index
      array = 6'b111111;
      if(preset)
      begin
        q <= 1;
      end
      else if(clear)
      begin
        q <= 0;
      end
      else if(j)
      begin
        q <= ~ q;
      end

- code: |-
    module test_k4(parameter N = 127);
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk[N:0](q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    for (int i=0

- code: |-
    module test_k;
    wire q, clock, j,

- code: |-
    module clock_gen_for; // Renamed module for clarity
      reg clk, en;
      // Generate clock using for loop controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        for (integer i = 0; i < 5; i++)
          #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Explanation:
    The expression <code>#2 clk = ~clk</code> inside the 'for' loop performs the actual toggling of the clock. If we want to display this value of the clock, we need a $display statement. This $display statement should display the current value of the clock and the time value (in time units) when the clock is toggled. The expression <code>$time</code> gives the current time value in 100ps units when it is evaluated.
    ### Simulation:
    ![](Simulation/ClockGen1.JPG)
    
    
    ### Task 4:
    ### Base Verilog code:
    module clock_gen_while; // Renamed module for clarity
      reg clk, en;
      // Generate clock using for loop controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        while (i < 5) begin
          #2 clk = ~clk; // Toggle clock every 2 time units forever
          i++;
        end
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
      integer i = 0;
    endmodule
    ### Variation

- code: |-
    module clock_gen_forever2; 
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      integer i;
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        $display("Starting clock_gen_forever2");
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time, en);
    endmodule
    ### Modified Test:
    module clock_gen_forever2_tb;
      reg clk_en, clk;
      // Clock and reset
      always
      begin
        #10;
        clk_en = 1'b0; // Start disabled
        #100;
        clk_en = 1'b1; // Start enabled
        #10;
        clk_en = 1'b0; // Stop enabled
        #100;
      end
      clock_gen_forever2 clock_obj (.clk(clk),.en(clk_en));
      // Test code and module
      initial
      begin
        $monitor("clk=%b, t=%0d, en=%b ",clk,$time, clk_en);
        #200;
        $finish;
      end
    endmodule
    ### Expected Output:
    ```
      clk=0, t=0, en=0
      clk=0, t=20, en=0
      clk=1, t=40, en=0
      clk=1, t=60, en=0
      clk=1, t=80, en=0
      clk=0, t=100, en=0
      clk=0, t=120, en=0
      clk=0, t=140, en=0
      clk=1, t=160, en=0
      clk=1, t=180, en=0
      clk=0, t=200, en=0
      clk=0, t=220, en=0
      clk=0, t=240, en=0
      clk=1, t=260, en=0
      clk=1, t=280, en=0
      clk=0, t=300, en=0
      clk=0, t=320, en=0
      clk=1, t=340, en=0
      clk=1, t=360, en=0
      clk=1, t=380, en=0
      clk=0, t=400, en=0
      clk=0, t=420, en=0
      clk=0, t=440, en=0
      clk=0, t=460, en=0
      clk=1, t=480, en=0
      clk=1, t=500, en=0
      clk=1, t=520, en=0
      clk=1, t=540, en=0
      clk=0, t=560, en=0
      clk=0, t=580, en=0
      clk=0, t=600, en=0
      clk=1, t=620, en=0
      clk=1, t=640, en=0
      clk=1, t=660, en=0
      clk=1, t=680, en=0
      clk=0, t=700, en=0
      clk=0, t=720, en=0
      clk=0, t=740, en=0
      clk=0, t=760, en=0
      clk=1, t=780, en=0
      clk=1, t=800, en=0
      clk

- code: |-
    module clock_gen_forever_func;
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      // Function returning a range of values (can have arbitrary length)
      function rangen [1:0] range_func(input int num);
        rangen ret[1:0];
        for (int i=0; i<num; i=i+1)
          ret[i]=i;
        return ret;
      endfunction
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Simulation Logic:
      clk=0, t=0, en=0
      clk=0, t=2, en=0
      clk=1, t=4, en=0
      clk=0, t=6, en=0
      clk=0, t=8, en=0
      clk=1, t=10, en=0
      clk=0, t=12, en=0
      clk=0, t=14, en=0
      clk=1, t=16, en=0
      clk=0, t=18, en=0
      clk=0, t=20, en=0
      clk=1, t=22, en=0
      clk=0, t=24, en=0
      clk=0, t=26, en=0
      clk=1, t=28, en=0
      clk=0, t=30, en=0
      clk=0, t=32, en=0
      clk=1, t=34, en=0
    ### Pass/Fail Criteria:
    The verification passes if the clock period is 5ns as expected.
    ### Unit Under Test:
    forever loop in a module
    ### Instruction(s) to Test:
    for loops with expressions in for loop initialization
    #### Method to Test:
    Procedural Testing using $monitor

- code: |-
    module clock_gen_forever_modified;
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      function calculateIndex;
        @(posedge clk);
        calculateIndex = (calculateIndex+2)%10; // calculateIndex will be incremented on each clock cycle, starting at 0
      endfunction : calculateIndex
      // Use 'calculateIndex' to generate the for loop
      initial
      begin
        @(posedge en) // Start clock generation on posedge en
          for (int i=0; i < 10; i = calculateIndex) // For loop to generate

- code: |-
    ```
    module clock_gen_forever (
      input clk,
      outpout en,
      input en_init, 
      input [4:0] period
    );
      wire en;
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      // Initialize en and period
    
      initial begin
        en = en_init;
        clk = 1'b0; // Initialize clock
        $display("en is %b",en);
        $display("period is %b",period);
      end
      // Initialize en and period
    
      function [4:0] n_period (input [4:0] value);
        n_period = period/value;
      endfunction
    
      initial
      begin
        en = 0; // Start disabled
        for (int i = 1; i <= n_period(2); i++) begin // Toggle clock for 
          #2 en = ~en; // Toggle clock for n_period units
        end
      end
      // Initialize en and period
    
    ```
    ### Experiment Results:
    ```
    en is 1
    period is 30
    clk=0, t=0, en=0
    clk=1, t=2, en=0
    clk=0, t=4, en=0
    clk=1, t=6, en=0
    clk=0, t=8, en=0
    clk=1, t=10, en=0
    clk=0, t=12, en=0
    clk=1, t=14, en=0
    clk=0, t=16, en=0
    clk=1, t=18, en=0
    clk=0, t=20, en=1
    clk=1, t=22, en=1
    clk=0, t=24, en=1
    clk=1, t=26, en=1
    clk=0, t=28, en=1
    clk=1, t=30, en=1
    clk=0, t=32, en=1
    clk=1, t=34, en=1
    clk=0, t=36, en=1
    clk=1, t=38, en=1
    clk=0, t=40, en=1
    clk=1, t=42, en=1
    clk=0, t=44, en=1
    clk=1, t=46, en=1
    clk=0, t=48, en=1
    clk=1, t=50, en=1
    clk=0, t=52, en=1
    clk=1, t=54, en=1
    clk=0, t=56, en=1
    clk=1, t=58, en=1
    clk=0, t=60, en=1
    clk=1, t=62, en=1
    clk=0, t=64, en=1
    clk=1, t=66, en=1
    clk=0, t=68, en=1
    clk=1, t=70, en=1
    clk=0, t=72, en=1
    clk=1, t=74, en=1
    clk=0, t=76, en=1
    clk=1, t=78, en=1
    clk=0, t=80, en=1
    clk=1, t=82, en=1
    clk=0, t=84, en=1
    clk=1, t=86, en=1
    clk=0, t=88, en=1
    clk=1, t=90, en=1
    clk=0, t=92, en=1
    clk=1, t=94, en=1
    clk=0, t=96, en=1
    clk=1, t=98, en=1
    clk=0, t=100, en=1
    clk=1, t=102, en=1
    clk=0, t=104, en=1
    clk=1, t=106, en=1
    clk=0, t=108, en=1
    clk=1, t=110, en=1
    clk=0, t=1

- code: |-
    module clock_gen_for_loop; // Renamed module for clarity
      reg clk, en;
      // Generate clock using for loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        for(clk = 1'b1; en; clk = ~clk) // Toggle clock every 2 time units forever
          #2; // Do nothing, keep clock on
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Tested Code:
    module clock_gen_for_loop_test; // Renamed module for clarity
      reg clk, en;
      clock_gen_for_loop clock_gen_for_loop_inst(.clk,.en); // Clock generation instance
      initial
      begin
        #100 en = 1; // Enable clock
        #200 en = 0; // Disable clock
        #500 $finish; // Exit testbench
      end
    endmodule
    ### Simulation:
    - First Simulation:
    ```
    # clock_gen_for_loop_test
    # clock_gen_forever
    
    # clock_gen_forever
    clk=0, t=0, en=0
    #100 clk=0, t=100, en=1
    clk=0, t=102, en=1
    #200 clk=0, t=302, en=0
    #500 $finish
    ###
    ```
    - Second Simulation:
    ```
    # clock_gen_for_loop_test
    # clock_gen_forever
    
    # clock_gen_forever
    clk=0, t=0, en=0
    #100 clk=0, t=100, en=1
    #200 clk=0, t=300, en=0
    #500 $finish
    ###
    ```
    
    ### Design Changes:
    - The change was primarily in the for loop. The initial 'clk = 1'b1;' was moved to within the for loop so it is run on every loop.
    - Additionally, the '#2' was moved to after the for loop so it is run once after each loop.
    - The initial clock value of 0 was moved to within the for loop as well; since it is already initialized to 0, it would be run on every loop,

- code: |-
    module clock_gen_forever; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        for (int i = 0; i <= 10; i = i + 1)  // Generate clk 11 times, starting at 0
          #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Explanation:
    For loop is modified to have a loop index that is calculated via a function call.
    The function call is:
      i = i + 1
    Function i_inc is defined as follows.
    ```verilog
    function automatic int i_inc(int i);
      i_inc = i + 1;
    endfunction
    ```
    The function is automatically registered with the iverilog compiler.
    The first time the function is called from within a generate loop, the for loop is entered.
    At that point, the loop index is set to 0.
    The function is called again on the next iteration of the loop and the loop index is set to 1.
    The function is called to increment the loop index on the next iteration and so on.
    The value of the function call is the value of the loop index.
    The function is called i times, where i is the number of iterations in the loop.
    The value of the function call is always one less than the loop iteration number.
    
    ### Simulation Results
    ![alt text](Pictures/6-

- code: |-
    module clock_gen_for;
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        for (int i=0; i < 3; i=i+1) clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Discussion:
    The code is not equivalent.  In the original `forever` loop, the clock toggles 3 times. In the modified `for` loop, the clock toggles once.  The reason is due to the `i = i+1` expression in the for loop.  Every time the for loop runs, the next time the `for` loop will run `i` will be 0.  Thus, the only time the `i` is 1 is the first iteration.  This is why the clock toggles only once.
    ### Common Suggestions:
    If the intention is to have the `clk` signal toggle 3 times, then change the `i` index variable to:
    ```
      always @(posedge en) // Start clock generation on posedge en
        for (int i=0; i < 3; i=1) clk = ~clk; // Toggle clock every 2 time units forever
    ```

- code: |-
    module clock_gen_forever_func; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      function [3:0] f; // Declare function 'f'
        input [3:0] x; // x has range [0:15]
        begin
          f = x | 4'h8; // Return x with the high bit set
        end
      endfunction
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule

- code: |-
    module clock_gen_forever; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      function int i;
        i = 0;
      endfunction
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ```
    ##### 3.3.1.a.iv
    ```verilog
    ### Base Verilog Code:
    module clock_gen_forever; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        forever #2 clk = ~clk; // Toggle clock every 2 time units forever
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial

- code: |-
    module testcase(
    	// Inputs
    	input		clk,
    	input		rst,
    	input		sel,
    	// Outputs
    	output reg	out1,
    	output reg	out2
    );
    	// Control and assign modules
    	control_assign uu1(sel, out1, out2);
    	initial begin
    		if(!(out1 | out2)) begin
    			out1 = 0;
    			out2 =

- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    initial
    	o = i1[3:0] | i2[3:0]; // Array inside expression test
    endmodule
    ### Result:
    PASS
    ### Note:
    The input side array is

- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with

- code: |-
    module contres_1(o,i1,i2);
    // Specify the input ports of the module
    input i1,i2;
    // Specify the output ports of the module
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    initial begin // Added initial block
        if ((i1 | i2) == 1'b0) begin // Array expression
            o = 0;
        end
    end
    endmodule
    ### Test Solution:
    Test solution for this variation can be found [here](TestSolution.md).
    ### Simulation Logs:

- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Initial block to test the array as a whole range
    initial begin
    	for (i=0; i<10; i=i+1) begin
    		if ((arr[i]!=1) || (arr[9-i]!=0)) begin
    			$display("ERROR: array is not resolved correctly");
    			$finish();
    		end
    	end
    end
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Comparison of the two Verilog Modules:
    
    <table>
    <tr>
    <td>
    
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    </td>
    <td>
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Initial block to test the array as a whole range
    initial begin
    	for (i=0; i<10; i=i+1) begin
    		if ((arr[i]!=1) || (arr[9-i]!=0)) begin
    			$display("ERROR: array is not resolved correctly");
    			$finish();
    		end
    	end
    end
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    </td>
    </tr>
    </table>
    
    ### Changes in the initial block:
    * The code now checks the array as a whole range. 
    * The for loop is executed 10 times and checks each value in the array against the expected value (1 or 0).
    * The code now uses the if statement in the for loop that checks both the values on each iteration of the loop.
    
    
    ### Output of the modified code:
    ```console
    ...
    ERROR: array is not resolved correctly
    Simulation failed.
    Error: Unknown error, simulation aborted
    ```
    ### Reflection:
    * It was a bit difficult to decide where to put the code in the initial block.
    * The if code inside the loop does not seem very efficient. 
    
    ### Changes in the base Verilog Module:
    * Change the buffer instantiations from two to an array of two instantiations.
    * Add a wire 'o' as an output.
    * Add a wire 'i' as an input.
    * Add an array 'arr' of 10 elements.
    * Add a process 'p' that stores the value of 'o' in each element of the 'arr' array.
    * Write an if statement to check the value of the 'o' output for each element in the 'arr' array.
    
    ### Modified Code

- code: |-
    module contres_m(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1, weak0); // Drives pull '1', weak '0'
    //buf(pull1, weak0) g2(o,i2, weak0); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    if(i1==1)
        o=1;
    else
        o=0;
    if(i2==1)
        o=1;
    else
        o=0;
    endmodule
    ### Simulation Log:
    	> iverilog -o contres_m.vvp contres_m.v
    	> vvp contres_m.vvp
    	i1 = 0, i2 = 0: 0 0
    	i1 = 0, i2 = 1: 0 1
    	i1 = 1, i2 = 0: 1 0
    	i1 = 1, i2 = 1: 1 1
    ### Base Verilog Code:
    module contres_m(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1, weak0); // Drives pull '1', weak '0'
    //buf(pull1, weak0) g2(o,i2, weak0); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1;

- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    initial begin
        o = (i1

- code: |-
    ```verilog
    module test(out, in_array);
    wire out;
    wire out_1;
    wire out_2;
    wire out_3;
    wire[3:0] in_array;
    // Drive wire 'out' from two buffers with specified output strengths
    buf(pull1, weak0) g1(out, in_array[0]); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(out_1, in_array[1]); // Drives pull '1', weak '0'
    buf(pull1, weak0) g3(out_2, in_array[2]); // Drives pull '1', weak '0'
    buf(pull1, weak0) g4(out_3, in_array[3]); // Drives pull '1', weak '0'
    ```
    ### Simulation:
    
    ```sh
    >> vsim test
    >> add wave -position insertpoint  /test/*
    >> force -freeze sim:/test/in_array 4'b0110
    >> run 1ms
    >> exit
    ```
    ![](https://github.com/jia-sy/Basic_Vivado_Tutorial_Qsys/blob/main/images/8.png)
    
    ### Problem:
    
    If we run this simulation, what value is 'out'?
    ### Variation Instruction:
    Change the 'force' statement to drive a 4'b0010 or a 4'b0100 or a 4'b1000.
    ### Simulation:
    
    ```sh
    >> vsim test
    >> add wave -position insertpoint  /test/*
    >> force -freeze sim:/test/in_array 4'b0010
    >> run 1ms
    >> exit
    ```
    ![](https://github.com/jia-sy/Basic_Vivado_Tutorial_Qsys/blob/main/images/9.png)
    
    ### Problem:
    
    If we run this simulation, what value is 'out'?
    ### Variation Instruction:
    Change the 'force' statement to drive a 4'b0001 or a 4'b1001 or a 4'b1010.
    ### Simulation:
    
    ```sh
    >> vsim test
    >> add wave -position insertpoint  /test/*
    >> force -freeze sim:/test/in_array 4'b0001
    >> run 1ms
    >> exit
    ```
    ![](https://github.com/jia-sy/Basic_Vivado_Tutorial_Qsys/blob/main/images/10.png)
    
    ### Problem:
    
    If we run this simulation, what value is 'out'?
    ### Variation Instruction:
    Change the 'force' statement to drive a 3'b011 or 3'b101 or 3'b110 or 3'b111.
    ### Simulation:
    
    ```sh
    >> vsim test
    >> add wave -position insertpoint  /test/*
    >> force -freeze sim:/test/in_array 3'b011
    >> run 1ms
    >> exit
    ```
    ![](https://github.com/jia-sy/Basic_Vivado_Tutorial_Qsys/blob/main/images/11.png)
    
    ### Problem:
    
    If we run this simulation, what value is 'out'?
    ### Variation Instruction:
    Change the 'force' statement to drive a 4'b0111 or a 4'b1111 or a 4'b0000 or a 4'b1101.
    ### Simulation:
    
    ```sh
    >> vsim test
    >> add wave -position insertpoint  /test/*
    >> force -freeze sim:/test/in_array 4'b0111
    >> run 1ms
    >> exit
    ```
    ![](https://github.com/jia-sy/Basic_Vivado_Tutorial_Qsys/blob/main/images/12.png)
    
    ### Problem:
    
    If we run this simulation, what value is 'out'?
    ### Variation Instruction:
    Change the 'force' statement to drive a 3'b011 or 3'b000 or 3'

- code: |-
    module contres(o,i1,i2);
    initial begin
    i1 = 1'b0;
    i2 = 1'b0;
    end
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Variation Verilog Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Variation Instruction:
    This is the same as the previous variation. Except that the test is over the whole array
    ### Variation Verilog Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    initial begin
    i1 = 1'b0;
    i2 = 1'b0;
    end
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Variation Instruction:
    Add an initial block: test the whole array of "i1" and "i2" separately
    ### Variation Verilog Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Variation Instruction:
    Do the same thing, but with a for-loop that test the array element by element (instead of the whole array at once)
    ### Variation Verilog Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    for (i=0; i<2; i=i+1) begin
    if ((i1[i] == 1'b1) && (i2[i] == 1'b1)) begin
    o = 1'b1;
    end
    else begin
    o = 1'b0;
    end
    end
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance

- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    initial begin
      assert(i1[0] == i2[0]) else $error("MISMATCH!");
    end
    endmodule
    ### Tested Code:
    module tb;
    logic clk,rst_n;
    logic [1:0] in1,in2;
    logic [1:0] out;
    // Instantiate the module under test
    contres dut(.o(out),.i1(in1),.i2(in2));
    initial begin
      in1 = 0;
      in2 = 0;
      clk = 1;
      rst_n = 1;
      repeat(6) @(posedge clk);
      in1 = 1;
      in2 = 1;
      repeat(6) @(posedge clk);
      in1 = 0;
      in2 = 0;
      repeat(6) @(posedge clk);
      in1 = 1;
      in2 = 0;
      repeat(6) @(posedge clk);
      in1 = 0;
      in2 = 1;
      repeat(6) @(posedge clk);
      $stop;
    end
    always #1 clk = ~clk;
    endmodule
    ### Simulation Results:
    Initially both in1/in2 are 1
    Output is 1.
    
    
    in1 is 1, in2 is 1
    Output is 1.
    
    
    in1 is 1, in2 is 0
    Output is 1.
    
    
    in1 is 0, in2 is 1
    Output is 1.
    
    
    in1 is 0, in2 is 0
    Output is 0.
    
    
    in1 is 1, in2 is Z
    Output is 1.
    
    
    in1 is 0, in2 is Z
    Output is X.
    
    
    in1 is Z, in2 is Z
    Output is Z.
    
    
    ### Simplified Instruction:
    Add a clocked block that tests an inside expression over an array as a whole range.
    ### Simplified Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    always @(posedge clk)
      assert(i1[0] == i2[0]) else $error("MISMATCH!");
    endmodule
    ### Simplified Code Results:
    
    in1 is 1, in2 is 1
    Output is 1.
    
    
    in1 is 1, in2 is 0
    Output is 1.
    
    
    in1 is 0, in2 is 1
    Output is 1.
    
    
    in1 is 0, in2 is 0
    Output is 0.
    
    
    in1 is 1, in2 is Z
    Output is 1.
    
    
    in1 is 0, in2 is Z
    Output is X.
    
    
    in1 is Z, in2 is Z
    Output is Z.
    
    
    ### Simplified Instruction:
    Add a clocked block that tests an inside expression

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    ### Modified Variation:
    This code is written in the testbench module tst_dec2_4beh.v as:
    `ifdef VAR
    always @(i)
    begin
        if(i == 2'b10 || i == 2'b11)
            o = 4'b0001;
        else
            o[i] = 1;
    end
    `endif
    ### Simulation Log:
    
    ```verilog

- code: |-
    module tst_dec4();
    wire [3:0]o;
    wire [3:0]i;
    reg en;
    dec4 dec(o,i,en);
    initial
    begin
    i =4'b1000; // Initialize i
    end
    initial begin
    i =4'b0000; // Set i to zero
    en =0; // Disable decoder
    //en =1; // Enable decoder
    end

- code: |-
    ```verilog
    module dec2_4beh(o,i);
    output [3:0]o;
    input [1:0]i;
    reg[3:0] o;
    always @(i) begin
    if (i[1]) o[3] = 1'b1;
    else o[3] = 1'b0;
    if (i[0]) o[2] = 1'b1;
    else o[2] = 1'b0;
    if (i[1]) o[1] = 1'b1;
    else o[1] = 1'b0;
    if (i[0]) o[0] = 1'b1;
    else o[0] = 1'b0;
    end
    endmodule
    ```
    ### Simulation
    ![decimating_behavior_h2](/BreakingNESWiF/images/decimating_behavior_h2.png)
    ###

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    reg [1:0]sel ;
    reg [1:0]en ;
    dec2_4beh dec(o,i,sel,en);
    initial
    begin
    i =2'b00;
    sel = 2'b00;
    en = 2'b00;
    end
    initial

- code: |-
    module tst_dec2_4beh();
     wire [3:0]o;
     reg[1:0] i;
     //reg en; // Enable not used in dec2_4beh
     dec2_4beh dec(o,i);
     initial
     begin
        foreach (i[j])
            $display ("%d = TRUE ", i[j]);
     end
     initial $mon

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b01;
    end
    initial #14 $stop; // Stop simulation
    endmodule
    ### Final Code
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b01;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    //  initial #14 $stop; // Stop simulation
    //endmodule
    //if (en==1'b1)
    if (i==2'b01)
    begin
    o[2] = 4'b1110;
    o[3] = 4'b0010;
    end
    else
    begin
    o[2] = 4'

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    // Modified code
    module dec2_4beh(o,i);
    input [1:0]i;
    output [3:0]o;
    wire [3:0]w;
    assign o[3:2] = i[1]? {1'b1,i[0]} : {1'b0,i[0]};
    assign o[1:0] = w[1:0];
    assign w[1:0] = i[1]? {1'b1,i[0]} : {1'b0,i[0]};
    
    endmodule
    ### Simulation Setup:
    ```
    initial
    begin
    $dumpfile("dec2_4beh.vcd");
    $dumpvars(0,tst_dec2_4beh);
    tst_dec2_4beh dut();
    i =2'b00;
    #16 i =2'b11;
    #16 i =2'b01;
    #16 i =2'b10;
    #16 i =2'b11;
    end
    ```
    ### Simulation Testing:
    ```
    $vlog tst_dec2_4beh.v
    $vsim tst_dec2_4beh -voptargs="+acc"
    initial
    begin
    $dumpfile("dec2_4beh.vcd");
    $dumpvars(0,tst_dec2_4beh);
    tst_dec2_4beh dut();
    i =2'b00;
    #16 i =2'b11;
    #16 i =2'b01;
    #16 i =2'b10;
    #16 i =2'b11;
    end
    $run 100
    ```
    ### Simulation Result:
    <p align="center">
      <img src="http://ws1.sinaimg.cn/large/006tBeITgy1frx1v52xwgj30m20b2dgl.jpg"/>
    </p>
    
    ### Discussion
    <p align="center">
      <img src="http://ws1.sinaimg.cn/large/006tBeITgy1frx1v4m9x5j307m02y3yf.jpg"/>
    </p>
    
    > 基本情况下，indexed part select语句和直接地址的select语句相同，但是当indexed part select用于if语句的条件成立判定时，会出现死逻辑。
    
    > 在if条件成立时，我们可以观察到o=11，因为i = 3，不符合dec2_4beh模块的设计。而在if条件不成立时，输出o = 00。因为i = 0.
    
    > 那么，如果我们把o[3:2]和o[1:0]拆分出来，每个时钟脉冲的整个值并不一样。
    
    > 因此，indexed part select可以与单独的wire和一些连接在一起的wire组合，但是不能用于if语句。
    
    ## Pipelining
    ### Base Verilog Code:
    ```
    module dec2_4beh(o,i);
    input [1:0]i;
    output [3:0]o;
    assign o[3:2] = i[1]? {1'b1,i[0]} : {1'b0,i[0]};
    assign o[1:0] = i[1]? {1'b1,i[0

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec2(o[3:0],i);
    initial
    begin
    o[i] = 1

- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg [1:0] i;
    //reg en; // Enable not used in dec2_4beh
    reg [7:0] o2;
    dec2_4beh dec(o2,i);
    assign o = o2[3:0];
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    
    ### Original Code
    module dec2_4beh (o, i);
    // Regs (1 bit)
    // 				   in			 out
    //			|			|			|
    //			1st bit			2nd bit			3rd bit			4th bit
    //			|			|			|			|
    //  +-------+			+-------+			+-------+			+-------+
    //	|					|				|				|			|
    //	V					V				V				V			V
    //			|			|			|			|			|
    //		o2	1			o2	2			o2	3			o2	4
    //			|			|			|			|			|
    //	+----+			+----+			+----+			+----+			+----+
    //	|					|				|				|			|
    //	V					V				V				V			V
    //			|			|			|			|			|
    //		o1	1			o1	2			o1	3			o1	4
    //			|			|			|			|			|
    //	+----+			+----+			+----+			+----+			+----+
    //	|					|				|				|			|
    //	V					V				V				V			V
    //			|			|			|			|			|
    //		o0	1			o0	2			o0	3			o0	4
    //			|			|			|			|			|
    //	+----+			+----+			+----+			+----+			+----+
    //	|					|				|				|			|
    //	V					V				V				V			V
    //			|			|			|			|			|
    //		o	1			o	2			o	3			o	4
    //			|			|			|			|			|
    //	+----+			+----+			+----+			+----+			+----+
    //	|					|				|				|			|
    //	V					V				V				V			V
    //			|			|			|			|			|
    //	i		1			i			2			i			3
    //			|			|			|			|			|
    //  +-------+			+-------+			+-------+			+-------+
    //	|					|				|				|			|
    //	V					V				V				V

- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;

- code: |-
    ```
    module pulses;
      reg [8:0] I;
      reg [12:0] Q [12:0];
      reg [9:0] a,b;
      initial
        while (I<100) begin
          a = I[0]; // Assign bit 1 of I to b (Corrected indexing)
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          Q[I[8:0]] = a + b; //Corrected indexing and a+b assignment.
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```
    ### Explanation:
    Since the `Q` is a 9 bit vector, we are storing the value of `a+b` in the corresponding index.
    ```
      initial
        while (I<100) begin
          a = I[0]; // Assign bit 1 of I to b (Corrected indexing)
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          Q[I[8:0]] = a + b; //Corrected indexing and a+b assignment
          I = I + 1; // Increment I
        end
    ```
    ### Assumptions:
    - The correct syntax for an inside case expressions using an array-slice range is: `inside { [range] }`.
    ### Simulation Results:
    - **Error**
        - The following error is seen when compiling the above Verilog code:
            - ```ERROR:HDLCompiler:118 -  The case expression at line 628 of my_pulses.v is not a legal expression.```
    - **Correction**:
        - To fix this issue we need to include an inside case expression in the code:
    - **Modified Code**:
        ```
        initial
          while (I<100) begin

- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a[10], b[10]; // Changed to array-slice range
      initial begin
        while (I<100) begin // Loop based on integer I
          case (I) // case statement
          inside // Includes only I's 1's
           [0:9]: begin // Inside 1's array
             b[I] = 1; // Assign I's bits to b
             a[I] = 1; // Assign I's bits to a
           end // case statement
           inside // Includes only I's 2's
           [0:10]: begin // Inside 2's array
             b[I] = 1; // Assign I's bits to b
             a[I] = 1; // Assign I's bits to a
           end // case statement
          inside // Includes only I's 3's
           [1:11]: begin // Inside 3's array
             b[I] = 1; // Assign I's bits to b
             a[I] = 1; // Assign I's bits to a
           end // case statement
          end // while statement
          I = I + 1; // Increment I
        end // initial begin block

- code: |-
    module pulses; // Corrected pulse generation
      reg [8:0] I[0:9];
      reg a,b;
      always_comb begin // Case-generation structure
        unique case(I[0:8]) inside // Case-generation inside

- code: |-
    module case_test; // Simple test for case functionality
      parameter a = 0;
      initial
      begin
        case (a)
          1: begin
            end
          2: begin
              $display("a=1");
            end
          3: begin
              $display("a=1");
            end
        endcase
      end
      initial
      begin
        case (a)
          1: begin
            end
          2: begin
              $display("a=2");
            end
          3: begin
              $display("a=3");
            end
        endcase
      end
      initial
      begin
        case (a)
          1: begin
            end

- code: |-
    module pulses2;
      reg [8:0] I;
      reg a,b;
      always @ (I) begin // Counter
        case (I[4:2]) // Use of a range that is 1 bit longer will always be 0
          0: I = I + 1; // Increment I
          1: I = I + 10; // Increment I
          2: I = I + 100; // Increment I
          3: I = I + 1000; // Increment I
        endcase
      end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Unit Test:
    module pulses_tb2;
      pulse pulses2();
    endmodule
    ### Scope:
    I:
    0: #100
    1: #100
    2: #100
    3: #100
    4: #100
    5: #100
    6: #100
    7: #100
    8: #100
    9: #100
    10: #100
    11: #100
    12: #100
    13: #100
    14: #100
    15: #100
    16: #100
    17: #100
    18: #100
    19: #100
    20: #100
    21: #100
    22: #100
    23: #100
    24: #100
    25: #100
    26: #100
    27: #100
    28: #100
    29: #100
    30: #100
    31: #100
    32: #100

- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
      always @(I) // Use a case statement
        case (I)       // with inside and a slice range
        8'd0: #12 a=0; // I == 0 -> a == 0
        inside {[2:9]}: #12 a=1; // I between 2 and 9 -> a == 1
        else #12 a=0; // Default case -> a == 0
        endcase // Need to add at end of block
        12'd60: #12 a=0; // I == 60 -> a == 0
        inside {[2:9]}: #12 a=1

- code: |-
    module pulses(I,b); // Add b as output port
      reg [8:0] I;
      reg [8:0] b;
      initial
        for (I=0; I<100; I=I+1) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Modification Type:
    Structural
    ### Motivation:
    To include the array slice to the case expression
    ### Explanation:
    The case expression must be unique in order for the case statement to be synthesizable.  The case expression is also dependent on the value of the input integer I; therefore, if a static case would be sufficient, the loop cannot be combined with the case.
    ### Reasoning:
    The case expression must be unique to support synthesis.  The loop is replaced by a `for` loop, which has a unique case expression.
    ### Modified Files:
    pulses.sv
    ### Result:
    #######
    1) Synthesize and view the netlist:
    > ncvlog -sv pulses.sv
    > nc

- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial I = 0; // Initialize I
      always #10 I = I + 1; // Increment I
      initial $stop; // Stop simulation
      always @(I) case (I) inside [3:7] default: b = 0; 2: b = 1; endcase endalways
    endmodule
    ### Correct Code:
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      reg [10:0] I_;
      initial I = 0; // Initialize I

- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          case(I) // case statement
            9, 17: // case
              case(I) // case statement
                9: // case inside
                  a = 1; // case inside
                17: // case inside
                  a = 0; // case inside
                default
                  a = 0; // default
              endcase // case
            default
              a = 1; // default
          endcase // case
          b = I[3]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Expected Output:
    ### Base

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    reg [6:0] buf_array [7:0];
    reg [3:0] d_buf_0, d_buf_1;
    always @(posedge Clock)
        if (Resetn == 0) begin
            Q <= 4'b0000;
            d_buf_0 <= 4'b0000;
        end else begin
            Q <= D;
            d_buf_0 <= D;
        end
    assign buf_array[0] = d_buf_0;
    assign buf_array[1] = d_buf_1;
    always @(posedge Clock)
        d_buf_1 <= buf_array[0];
    endmodule
    ### Note:
    This is a very simple example, but the buffering array is declared as an input signal to the
    module to facilitate verification. However, this is also a warning that your code has gone
    quite far from being a synthesizable Verilog module.
    (If your code is indeed synthesizable, you should be able to ignore this warning)
    ### Verification:
    The verification code is the same as the original one. The testbench is also the same as the original one, except that we added the following code to the beginning:
    ```verilog
    reg [3:0] d_buf_0, d_buf_1;
    ```
    and
    ```verilog
    assign buf_array[0] = d_buf_0;
    assign buf_array[1] = d_buf_1;
    always @(posedge CLK)
        d_buf_1 <= buf_array[0];
    ```
    And we modified the stimuli part to this:
    ```verilog
    initial begin
        CLK = 0;
        RST = 0;
        D = 4'b0001;
        #10 RST = 1;
        #10 D = 4'b0010;
        #10 D = 4'b0011;
        #10 D = 4'b0100;
        #10 D = 4'b0101;
        #10 D = 4'b0110;
        #10 D = 4'b0111;
        #10 D = 4'b1000;
        #10 D = 4'b1001;
        #10 D = 4'b1010;
        #10 D = 4'b1011;
        #10 D = 4'b1100;
        #10 D = 4'b1101;
        #10 D = 4'b1110;
        #10 D = 4'b1111;
        #10 D = 4'b0000;
        #10 RST = 0;
        #90 $finish;
    end
    ```
    The waveform is the same as before, except that now the output starts from `0000` to `0001` to `1111` to `0000`, and then back to `0000`.
    
    ### Code:
    
    * [Source](../src/tutorial16.v)
    * [Testbench](../src/tutorial16_tb.v)
    
    ## Tutorial 17
    ### Description:
    This tutorial will show you how to use if-else and case in Verilog.
    
    ### Base Verilog Code:
    ```verilog
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    ```
    ### Variation Instructions:
    Add logic to make the outputs of the Qs to change to 4'd7 when Q[0] is 1'

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    
    //Procedural continuous assignment
    wire [3:0] w;
    localparam DELAY = 0;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    
    //Added procedural assignment
    assign w[4] = Q[3];
    endmodule
    ### Expected Output:
    No change in operation.
    ### Test Plan:
    - Add the procedural assignment, and simulate in cadence with VCS.
    - Verify that the operation of the module remains the same as it did in the previous tutorial on procedural continuous assignment.
    - Add an additional delay assignment to the procedural continuous assignment, and simulate in cadence with VCS.
    - Verify that the addition of the delay assignment causes the operation of the module to change.
    ### Pass/Fail Criteria:
    ### Pass:
    - The operation of the module remains the same after procedural continuous assignment and delay is added.
    ### Fail:
    - The operation changes after procedural continuous assignment and delay is added.
    ### Fail:
    - The operation of the module remains the same after procedural continuous assignment and

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    reg [3:0] Q1;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    
        // A continuous assignment using inside with a dynamic array selected via expression
        for(i = 0; i < 4; i = i + 1)
            begin: Inside
                Q1[i%4] = Q[i] + 1;
            end
    endmodule
    ### Revised Verilog:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    reg [3:0] Q1;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    
        // A continuous assignment using inside with a dynamic array selected via expression
        for(i = 0; i < 4; i = i + 1)
            begin: Inside
                Q1[i%4] = Q[i] + 1;
            end
    endmodule
    ### 57. 
    ###### Description
    Add a procedural continuous assignment using inside with a dynamic array selected via function expression.
    ### Base Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    ```
    
    #### Cause
    
    An array variable is declared inside an `if-else` conditional statement, and the `size` of the array is not specified.
    
    #### Resolution
    
    An array element must be accessed through a constant index, or an index value must be assigned to a variable.
    
    #### References
    
    * [IEEE P16

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    
        always_comb begin
            int i;
            for (i = 0; i < 4; i++) begin
                if (i == D)
                    Q[i] = 1;
                else
                    Q[i] = 0;
            end
        end
    
    endmodule
    ### Original Simulation:
    ![original simulation](original_simulation.png)
    ### Modified Simulation:
    ![modified simulation](modified_simulation.png)
    ### Result of Verification:
    * Passed: All testvectors
    * Notes: There is a 1 clock delay on the modifed code.
    ### Reference:
    [Verilog Tutorial #4: Registers](https://www.youtube.com/watch?v=jBxAJDJK6Ek&list=PLowKtXNTBypGqImE

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    wire [3:0] WireX;
    reg [3:0] WireY [0:3];
    initial begin
        WireX = 4'b0000;
        for(int i = 0; i < 4; i++)
            WireY[i] = 4'b0000;
    end
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0) begin
            WireX = 4'b0000;
            for(int i = 0; i < 4; i++)
                WireY[i] = 4'b0000;
        end
        else begin
            WireX = D;
            for(int i = 0; i < 4; i++)
                WireY[i] = D;
        end
    endmodule
    ### Scope Overview:
    ### Scope Name:
    reg4
    ### Top-Level Entities:
    |Entity Name|Entity Type|
    |---|---|
    |reg4|module|
    ### Hierarchical Tree:
    ### Ports:
    |Port Name|Port Type|Port Direction|Port Width|Description|
    |---|---|---|---|---|
    |Clock|input|in|1|Clock|
    |D|input|in|4|D|
    |Q|output|out|4|Q|
    |Resetn|input|in|1|Resetn|
    ### Properties Used:
    |Property Name|Property Type|Property Direction|Property Reference|
    |---|---|---|---|
    |always_ff|always_ff|continuous|Always|
    |always_latch|always_latch|continuous|Always|
    |always_comb|always_comb|continuous|Always|
    |initial_block|initial_block|initial|Initial|
    |final_block|final_block|final|Final|
    |assert_known|assert_known|assert|Always|
    |assert_known|assert_known|assert|Initial|
    |clock_gate|clock_gate|assert|Always|
    |clock_enable|clock_enable|assert|Always|
    |latch_in_always|latch_in_always|assert|Always|
    |latch_in_always|latch_in_always|assert|Initial|
    |latch_out_always|latch_out_always|assert|Always|
    |latch_out_always|latch_out_always|assert|Final|
    |latch_edge_always|latch_edge_always|assert|Always|
    |latch_edge_always|latch_edge_always|assert|Final|
    |latch_final_block|latch_final_block|assert|Always|
    |latch_final_block|latch_final_block|assert|Final|
    |latch_in_always_0|latch_in_always_0|assert|Always|
    |latch_in_always_0|latch_in_always_0|assert|Initial|
    |latch_out_always_0|latch_out_always_0|assert|Always|
    |latch_out_always_0|latch_out_always_0|assert|Final|
    |latch_edge_always_0|latch_edge_always_0|assert|Always|
    |latch_edge_always_0|latch_edge_always_0|assert|Final|
    |latch_final_block_0|latch_final_block_0|assert|Always|
    |latch_final_block_0|latch_final_block_0|assert|Final|
    |latch_in_always_1|latch_in_always_1|assert|Always|
    |latch_in_always_1|latch_in_always_1|assert|Initial|
    |latch_out_always_1|latch_out_always_1|assert|Always|
    |latch_out_always_1|latch_out_always_1|assert

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    
    (* ram_style = "block" *) reg [3:0] Q;
    reg [3:0] Q1;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    wire [3:0] a;
    wire [3:0] b;
    wire [3:0] c;
    wire [3:0] d;
    wire [3:0] e;
    wire [3:0] f;
    wire [3:0] g;
    wire [3:0] h;
    wire [3:0] i;
    wire [3:0] j;
    wire [3:0] k;
    wire [3:0] x;
    wire [3:0] y;
    wire [3:0] z;
    wire [3:0] m;
    wire [3:0] n;
    wire [3:0] o;
    wire [3:0] p;
    wire [3:0] q;
    wire [3:0] r;
    wire [3:0] s;
    wire [3:0] t;
    wire [3:0] u;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    array1 = {a, b, c, d};
    array2 = {e, f, g, h};
    array3 = {i, j, k, x};
    array4 = {y, z, m, n};
    array5 = {o, p, q, r};
    array6 = {s, t, u, 4'b0};
    array7 = array4  | array5 | array6;
    assign Q = array1[D[3:0]] | array2[D[3:0]] | array3[D[3:0]] | array7[D[3:0]];
    ### Generated Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    wire [3:0] a;
    wire [3:0] b;
    wire [3:0] c;
    wire [3:0] d;
    wire [3:0] e;
    wire [3:0] f;
    wire [3:0] g;
    wire [3:0] h;
    wire [3:0] i;
    wire [3:0] j;
    wire [3:0] k;
    wire [3:0] x;
    wire [3:0] y;
    wire [3:0] z;
    wire [3:0] m;
    wire [3:0] n;
    wire [3:0] o;
    wire [3:0] p;
    wire [3:0] q;
    wire [3:0] r;
    wire [3:0] s;
    wire [3:0] t;
    wire [3:0] u;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    wire [3:0] a;
    wire [3:0] b;
    wire [3:0] c;
    wire [3:0] d;
    wire [3:0] e;
    wire [3:0] f;
    wire [3:0] g;
    wire [3:0] h;
    wire [3:0] i;
    wire [3:0] j;
    wire [3:0] k;
    wire [3:0] x;
    wire [3:0] y;
    wire [3:0] z;
    wire [3:0] m;
    wire [3:0] n;
    wire [3:0] o;
    wire [3:0] p;
    wire [3:0] q;
    wire [3:0] r;
    wire [3:0] s;
    wire [3:0] t;
    wire [3:0] u;
    reg [3:0] Q;
    // Continuous Assignment
    assign Q = a | b | c | d | e | f | g | h |

- code: |-
    ```verilog
    // Create the module
    module reg

- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    generate
        reg [3:0] val;
        always @(*) val = 4'b1111;
        integer i;
        always @(posedge Clock) if (Resetn == 0) {
            for(i = 0; i < 4; i = i + 1) begin
                Q[i] <= val[

- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;

- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    initial begin
    $display("Initialization Done");
    end
    endmodule
    ### Compiled Verilog Code:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign g1 = a && b;
    assign g = ~g1; // Final AOI output
    initial begin
    $display("Initialization Done");
    end
    endmodule
    ### Error Message:
    Error-[SE]:

- code: |-
    module aoi2(g,a,b,c,d);
      output g;
      input a,b,c,d;
      wire e,f,g1; // Intermediate signals
      // Dataflow assignments for AND, OR, and NOT operations
      assign e = a && b;
      assign f = c && d;
      assign g1 = e || f;
      assign g = ~g1; // Final AOI output
      function boolean get_dataflow_g1;
    	begin
    		if (d)
    			get_dataflow_g1 = (a && b);
    		else
    			get_dataflow_g1 = (c && d);
    	end
      endfunction
      initial
      begin
        g1 = get_dataflow_g1;
      end
    endmodule
    ### Source Code:
    module aoi2(g,a,b,c,d);
      output g;
      input a,b,c,d;
      wire e,f,g1; // Intermediate signals
      // Dataflow assignments for AND, OR, and NOT operations
      assign e = a && b;
      assign f = c && d;
      assign g1 = e || f;
      assign g = ~g1; // Final AOI output
      function boolean get_dataflow_g1;
    	begin
    		if (d)
    			get_dataflow_g1 = (a && b);
    		else
    			get_dataflow_g1 = (c && d);
    	end
      endfunction
      initial
      begin
        g1 = get_dataflow_g1;
      end
    endmodule
    ### Synthesis Options:
    AOI2_SYNTH_OPT_CONST1 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST2 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST3 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST4 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST5 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST6 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST7 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST8 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CARRY = 0;
    ### Synthesis Results:
    AOI2_SYNTH_OPT_CONST1 = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    AOI2_SYNTH_OPT_CONST2 = {1

- code: |-
    ```
    module aoi3_2(g1,g2,a,b,c

- code: |-
    module aoi6(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    initial
    begin
    g = (a||b) &&!(d||c

- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    initial begin
    e = a && b;
    f = c && d;
    g1 = e || f;
    g = ~g1; // Final AOI output
    end
    endmodule
    ### Implemented Design:
    ![Verilog code

- code: |-
    module mux4to1(z,x1,x2,x3,x4);
    output z;
    input x1,x2,x3,x4;
    wire y1,y2,y3;
    assign y1 = x1 || x2;
    assign y2 = x3 || x4;
    assign y3 = x1 && x3;
    
    initial
    some_var = some_fun(x1,x2,x3,x4);
    
    assign z = (y1 && x4) || (y2 && y3) || (y1 && y2);
    
    endmodule
    
    ### Expected Output:
    z = (y1 && x4) || (y2 && y3) || (y1 && y2);
    
    ### Final Output:
    z = (y1

- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    reg [4:0] g;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    initial begin
    g[4] = functionA();
    g[3] = functionB();
    g[2] = functionC();
    g[1] = functionD();
    g[0] = ~g1; // Final AOI Output
    end
    endmodule
    ### Modified Declaration:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    reg [4:0] g;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI Output
    initial begin
    g[4] = functionA();
    g[3] = functionB();
    g[2] = functionC();
    g[1] = functionD();
    end
    endmodule
    ### Modified Dataflow Assignments:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    reg [4:0] g;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    initial begin
    g[4] = functionA();
    g[3] = functionB();
    g[2] = functionC();
    g[1] = functionD();
    end
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI Output
    endmodule
    ### Modified Output:
    #### Original Output:
    aoi2.v:11: Warning: For loop variable is not used in the loop body.
    aoi2.v:11: (vlog-2083)
    aoi2.v:15: Warning: For loop variable is not used in the loop body.
    aoi2.v:15: (vlog-2083)
    aoi2.v:18: Warning: For loop variable is not used in the loop body.
    aoi2.v:18: (vlog-2083)
    aoi2.v:22: Warning: For loop variable is not used in the loop body.
    aoi2.v:22: (vlog-2083)
    aoi2.v:26: Warning: For loop variable is not used in the loop body.
    aoi2.v:26: (vlog-2083)
    aoi2.v:29: Warning: For loop variable is not used in the loop body.
    aoi2.v:29: (vlog-2083)
    aoi2.v:41: Error: Output variable '<G>' is a reg declaration and it is not connected to any value.
    aoi2.v:34:        g = ~g1; // Final AOI Output
    aoi2.v:28: Reg variable '<G>' defined.
    aoi2.v:15: Reg variable '<E>' defined.
    aoi2.v:19: Reg variable '<F>' defined.
    aoi2.v:23: Reg variable '<G1>' defined.
    aoi2.v:27: Reg variable '<A>' defined.
    aoi2.v:31: Reg variable '<B>' defined.
    aoi2.v:35: Reg variable '<C>' defined.
    aoi2.v:39: Reg variable '<D>' defined.
    aoi2.v:29:      assign g1 = e || f; 
    aoi2.v:50: Error (suppressible): Signal '<G>' is driven by multiple initial blocks.
    aoi2.v:41: Error: Output variable '<G>' is a reg declaration and it is not connected to any value.
    aoi2.v:34:        g = ~g1; // Final AOI Output
    ao

- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    initial begin // The base verilog code does not have an initial block
    	g[gFunction(a, b, c, d)] = 1'b0; // The index value for the g vector is assigned to 0
    end
    function [3:0] gFunction(input a, input b, input c, input d);
    	return a | (b & c) | (c & d);
    endfunction
    endmodule
    ### Final Code:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g[gFunction(a, b, c, d)] = ~g1; // Final AOI output
    initial begin // The base verilog code does not have an initial block
    	g[gFunction(a, b, c, d)] = 1'b0; // The index value for the g vector is assigned to 0
    end
    function [3:0] gFunction(input a, input b, input c, input d);
    	return a | (b & c) | (c & d);
    endfunction
    endmodule
    ### Final Compilation:
    # Compiled
    | Name | Module | Type | Description | Verilog Source |
    | :- | :- | :-: | :- | :- |
    | aoi2 | aoi2 | FUNCTIONAL | AOI 2-input gate (2-input AND + 2-input OR + 1-input NOT) | aoi2.v |
    | aoi2 | aoi2 |

- code: |-
    module aoi2_mod(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    initial
    g[a][b][c][d] = ~g1; // Final AOI output
    endmodule
    ### Variation Types:
    * Variable declaration/assignment (a,b,c,d)
    * Function call (a[][b][c][])
    * Expression (a[][b][c][d] = ~g1)
    ### Variation Instructions:
    * Variable declaration of 3 dimensional arrays (a[],b[],c[],d[])
    * Function call with an expression array index (a[][b][c][])
    * Function call with an immediate array index (a[][b][c][0] or a[][b][c][1])
    * Function call with a variable array index (a[][b][c][y])
    ### Variation Instructions:
    * Variable declaration of 4 dimensional arrays (a[],b[],c[],d[],e[])
    * Function call with an expression array index (a[][b][c][])
    * Function call with an immediate array index (a[][b][c][0] or a[][b][c][1])
    * Function call with a variable array index (a[][b][c][y])
    * Function call with a 2 dimensional array index (a[][b][][])
    * Function call with a 3 dimensional array index (a[][][c][d])
    * Function call with a 4 dimensional array index (a[][b][][] and a[][][c][d])
    ### Variation Types:
    * Variable declaration/assignment (g)
    * Function call (g[])
    * Expression (g[] = ~g1)
    ### Variation Instructions:
    * Use iniial block (initial g[] = 0)
    * Use iniial block (initial g[] = 1)
    * Use iniial block (initial g[] = 1; g2[a][b][c][d] = ~g1; g2[1][2][3][4] = 5; g2[] = g2[])

- code: |-
    module maj5 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    always @ (a, b, c, y) begin
        x[0] <= a;
        x[1:2] <= b;
        x[3] <= c;
    end
    endmodule
    ### Runtime Instruction(s):
    x = [0 1 0 1 0]
    ### Verification Instruction(s):
    x[0:2] = x[1:3]
    ### Runtime Test Input:
    x: [0 1 0 1 0]
    ### Runtime Test Output:
    y: 0
    ### Runtime Test Success
    ### End of Test
    ### Base Verilog Code:
    module maj6 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im

- code: |-
    module test;
    wire [31:0] a[0:7];
    wire [31:0] b[0:7];
    wire [31:0] c[0:7];
    wire [31:0] d[0:7];
    wire [31:0] e[0:7];
    wire [31:0] f[0:7];
    wire [31:0] g[0:7];
    wire [31:0] h[0:7];
    wire [31:0] i[0:7];
    wire [31:0] j[0:7];
    wire [31:0] k[0:7];
    wire [31:0] l[0:7];
    wire [31:0] m[0:7];
    wire [31:0] n[0:7];
    wire [31:0] o[0:7];
    wire [31:0] p[0:7];
    wire [31:0] q[0:7];
    wire [31:0] r[0:7];
    wire [31:0] s[0:7];
    wire [31:0] t[0:7];
    wire [31:0] u[0:7];
    wire [31:0] v[0:7];
    wire [31:0] w[0:7];
    wire [31:0] x[0:7];
    wire [31:0] y[0:7];
    wire [31:0] z;
    initial begin
        a[0] = 1'b0;
        a[1] = 1'b1;
        a[2] = 1'b0;
        a[3] = 1'b1;
        a[4] = 1'b0;
        a[5] = 1'b0;
        a[6] = 1'b1;
        a[7] = 1'b1;
        b[0] = 1'b0;
        b[1] = 1'b1;
        b[2] = 1'b0;
        b[3] = 1'b1;
        b[4] = 1'b0;
        b[5] = 1'b0;
        b[6] = 1'b1;
        b[7] = 1'b1;
        c[0] = 1'b0;
        c[1] = 1'b1;
        c[2] = 1'b1;
        c[3] = 1'b0;
        c[4] = 1'b0;
        c[5] = 1'b0;
        c[6] = 1'b1;
        c[7] = 1'b1;
    end
    always @*
        d[0] = a[0] ^ a[1] ^ a[4];
        d[1] = a[1] ^ a[2] ^ a[5];
        d[2] = a[2] ^ a[3] ^ a[6];
        d[3] = a[3] ^ a[4] ^ a[7];
        d[4] = a[4] ^ a[5] ^ a[0];
        d[5] = a[5] ^ a[6] ^ a[1];
        d[6] = a[6] ^ a[7] ^ a[2];
        d[7] = a[7] ^ a[0] ^ a[3];
        e[0] = a[0] & a[1] & a[4];
        e[1] = a[1] & a[2] & a[5];
        e[2] = a[2] & a[3] & a[6];
        e[3] = a[3] & a[4] & a[7];
        e[4] = a[4] & a[5] & a[0];
        e[5] = a[5] & a[6] & a[1];
        e[6] = a[6] & a[7] & a[2];
        e[7] = a[7] & a[0] & a[3];
        f[

- code: |-
    module maj5 (a, b, c, y);
    input a, b, c;
    output y;
    wire [2:0] ims;
    assign ims[0] = a && b;
    assign ims[1] = b && c;
    assign ims[2] = c && a;
    wire y0, y1;
    and #(2, 4) (y0, a, b);
    or #(3, 5) (y1, ims[3], ims[1], ims[2]);
    always @(y1) y = 1'b0;
    always @(*) y = 1'b0;
    endmodule
    ### Result: 
    y = 1'b0 and ims = 3'b101;
    ### Correctness:
    This variation is incorrect because the modified code relies on a constant range, so the LHS of an assignment is not guaranteed to be 1-bit wide.
    
    
    ### Base Verilog Code:
    module maj6 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);

- code: |-
    ```verilog
    module maj3_var (a, b, c, y);
    input [2:0] a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4) (im1, a[2], b),
                (im2, b, c),
                (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
    ```
    ### Modified Testbench:
    ```verilog
    module maj3_var_tb ();
        reg [2:0] a, b, c;
        wire y;
    
        maj3_var uut (
           .a(a),
           .b(b),
           .c(c

- code: |-
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a[1:0], b),
        (im2, b, c),
        (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
    ### Verification Steps:
    1. Compile and run simulation with the modified code on the base verilog.
    2. Compile and run simulation with the modified code on the modified verilog.
    3. Compare the outputs.
    ### Expected Output:

- code: |-
    ```
    module index_test (bypass, data_in, clk, reset, q);
    input clk, reset;
    input [3:0] data_in;
    output [3:0] q;
    output bypass;
    wire bypass;
    reg [3:0] q;
    reg [3:0] data_in_buf;
    reg clk_buf, reset_buf;
    always @(posedge clk or posedge reset)
        begin
            clk_buf <= clk;
            reset_buf <= reset;
            if (reset_buf == 0)
                data_in_buf <= {4{1'b0}};
            else
                data_in_buf <= data_in;
        end
    always @*
        begin
            q[data_in_buf[2:1]] <= data_in_buf[data_in_buf[2:1]];
            bypass <= 1'b1;
        end
    ```
    ### Verilog Simulation Code:
    ```
    module index_test_tb ();
    reg clk, reset;
    reg [3:0] data_in;
    wire [3:0] q;
    wire bypass;
    index_test dut (.clk(clk),.reset(reset),.data_in(data_in),.bypass(bypass),.q(q));
    integer i;
    initial begin
      reset = 1'b1;
      clk = 1'b0;
      #5
      reset = 1'b0;
      #5
      clk = 1'b1;
      data_in = 4'b1010;
      #5
      clk = 1'b0;
      #5
      clk = 1'b1;
      #5
      clk = 1'b0;
      #5
      clk = 1'b1;
      #5
      clk = 1'b0;
      #5
      clk = 1'b1;
      #5
      $finish;
    end
    always
      #5 clk = ~clk;
    endmodule
    ```
    ### C++ Source Code:
    ```
    #include<iostream>
    #include<fstream>
    #include<string>
    using namespace std;
    
    ifstream fin("index_test_tb.v");
    char buff[256];
    
    void print_indent(int indent)
    {
      for (int i = 0; i < indent; i++)
        printf("  ");
    }
    int main(int argc, char **argv)
    {
      fin.getline(buff, 256);
      while(!fin.eof())
      {
        string line(buff);
        if (line.find("#")!= string::npos)
          continue;
        if (buff[0] == '/')
        {
          int indent = 0;
          while (buff[indent] =='')
            indent++;
          print_indent(indent);
          printf("%s\n", buff);
        }
        else if (buff[0] == '.')
        {
          int indent = 0;
          while (buff[indent] =='')
            indent++;
          print_indent(indent);
          printf("// %s\n", buff);
        }
        else
        {
          int indent = 0;
          while (buff[indent] =='')
            indent++;
          print_indent(indent);
          printf("%s\n", buff);
        }
        fin.getline(buff, 256);
      }
      fin.close();
      return 0;
    }
    
    ```
    ### Console Output:
    ```
    $./index_test_tb.exe
      module index_test (
          bypass,
          data_in,
          clk,
          reset,
          q
    );
    input bypass;
    input clk;
    input data_in;
    output q;
    output reset;
    reg bypass;
    reg [3:0] q;
    wire bypass;
    reg clk;
    reg [3:0] data_in;
    reg reset;
    reg [3:0] data_in_buf;
    reg clk_buf, reset_buf;
    
    module index_test (
        bypass,
        data_in,

- code: |-
    module test_maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire [4:0] im;
    assign im[0] = a;
    assign im[1] = b;
    assign im[2] = c;
    and #(2, 4)
        (im[0], a, b),
        (im[1], b, c),
        (im[2], c, a);
    or #(3, 5) (y, im[0:2]);
    endmodule
    ### Description of Addition:

- code: |-
    module maj3_2var 
    	#(parameter d = 4)
    (a, b, c, y);
    input a, b, c;
    output y;
    wire [1:0] im1, im2, im3;
    and #(2, 4) (im1[1], a, b), (im1[0], b, c);
    and #(2, 5) (im2[1], b, c), (im2[0], c, a);
    and #(2, 6) (im3[1], c, a), (im3[0], a, b);
    or #(3, 7) (y, im1, im2, im3);
    endmodule
    #(parameter d = 4)
    ### Simulator Log Output:
    Executing in 64 bit mode.
    Simulator name : XMR 10.2 64-bit
    XMR 10.2 64-bit Build 1867, Sep 22 2010
    Copyright (c) 1989-2010, Cadence Design Systems, Inc.
    This program is the proprietary software of Cadence Design Systems, Inc. 
    and is available only under a license agreement with Cadence.
    
    Use of this software is governed by the license agreement you received with this file.
    
    *
    *
    *
    *
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2' is being automatically packed.
    
    Warning (10620): Unpacked array 'im3' is being automatically packed.
    
    Warning (10620): Unpacked array 'y' is being automatically packed.
    
    Warning (10620): Unpacked array 'im1' is being automatically packed.
    
    Warning (10620): Unpacked array 'im2'

- code: |-
    module maj3 (a, b, c, y);
      input a, b, c;
      output y;
      wire [1:0] im1, im2, im3;
    
      and #(2, 4)
        (.im1(im1[1]),.a(a),.b(b)),
        (.im2(im1[0]),.b(b),.c(c)),
        (.im3(im1[2]),.c(c),.a(a));
    
      or #(3, 5) (y, im1[1], im1[0], im1[2]);
    
      initial begin
        $display("%b %b %b %b", a, b, c, y);
      end
    endmodule
    ### Test Bench:
    module test;
      reg a, b, c;
      wire y;
      maj3 uut (.a(a),.b(b),.c(c),.y(y));
    
      initial begin
        a=1'b1; b=1'b0; c=1'b1; #1;
        a=1'b1; b=1'b1; c=1'b1; #1;
        b=1'b1; c=1'b1; a=1'b0; #1;
        c=1'b1; a=1'b1; b=1'b1; #1;
        a=1'b1; c=1'b1; b=1'b0; #1;
    
      end
    endmodule
    ### Expected Results:
    - 111 100 101 0 -> 110
    - 110 111 101 1 -> 111
    - 111 000 101 0 -> 110
    - 101 111 110 1 -> 111
    - 111 101 000 0 -> 110
    ### Simulation Logic:
    ![image](https://user-images.githubusercontent.com/87344540/122666054-5f950100-d158-11eb-983b-32a5939867d6.png)
    ### Simulation Result:
    ![image](https://user-images.githubusercontent.com/87344540/122821564-66fc7a00-d218-11eb-94b1-8709823afdd8.png)
    ### Conclusion
    This variation successfully replaces the packed array method with constant ranges.
    ### Difficulty Level
    Medium
    ### References Used
    - [Packed Arrays](https://www.ece.cmu.edu/~ee760/760docs/Verilog%20Notes%20-%20Packed%20Arrays.pdf)
    - [SystemVerilog Packed Arrays](https://www.verilogpro.com/systemverilog/systemverilog-tutorial-packed-arrays/)
    - [Verilog Arrays](https://www.instructables.com/id/Verilog-Arrays/)
    ### Suggested Readings
    - [Packed Arrays](https://www.ece.cmu.edu/~ee760/760docs/Verilog%20Notes%20-%20Packed%20Arrays.pdf)
    - [SystemVerilog Packed Arrays](https://www.verilogpro.com/systemverilog/systemverilog-tutorial-packed-arrays/)
    - [Verilog Arrays](https://www.instructables.com/id/Verilog-Arrays/)
    ### Suggested Videos
    - [Arrays in Verilog](https://www.youtube

- code: |-
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    assign y = im1[3];
    endmodule
    ### Runtime:
    #### Base:
    #### Variation:
    ### Runtime Overview:
    ### Runtime Result:
    ### Synthesis Report:
    ### Misc:
    ### Known Problems:
    ### References:
    1. "Array and bit-select indexing - SystemVerilog HDL Reference Manual - Latt

- code: |-
    module tst_wand6; //testbench
    reg i1,i2,i3,i4,i5,i6,i7,i8;
    wire o; // Added wire declaration
    wand1 ww[7:0](i1,i2,o);
    initial
    begin
    i1=0; i2=0; i3=

- code: |-
    module tst_wand1;
    		reg i1,i2;
    		wire o;
    		wand1 ww(i1,i2,o);
    		reg [1:0] D;
    		reg [0:1] Y;
    		reg [0:1] Z;
    		integer i;
    		initial
    		begin
    			i1=0; i2=0;
    		end
    		initial
    		begin
    			i=0;
    			D=0;
    			Y=0;
    			Z=0;
    			repeat (2)
    			begin
    				i=i+1;
    				if (i==2) begin
    					D[i] <= 1;
    					Z[i] <= 1;
    				end
    				if (i==3) begin
    					if (i<$size(D)) begin
    						D[i] <= 1;
    						Z[i] <= 1;
    					end
    					else begin
    						$display("ERROR: Index value is out of bounds");
    					end
    				end

- code: |-
    module tst_wand3_a;
    reg i1,i2,i3,i4;
    wand3 ww(i1,i2,i3,i4);
    initial begin
    i1=0; i2=0; i3=0; i4=0; // Drv1=pull0, Drv2=pull0, Drv3=pull0, Drv4=pull0 -> o = pull0 (wand rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,i3=%b,i4=%b",i1,i2,i3,i4);
    endmodule
    
    ### Base Verilog Code:
    module tst_wand4; //testbench
    reg i1,i2;
    wand4 ww(i1,i2);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial $monitor($time,"i1=%b,i2=%b",i1,i2);
    initial #8 $stop; // Added stop
    endmodule
    ### Variation Instruction:
    Analyze the wand gate with different number of inputs

- code: |-
    module tst

- code: |-
    module tst_wand7; //testbench
    reg i1[7:0],i2[7:0];
    wire

- code: |-
    module tst_wand1; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    wand1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial

- code: |-
    module tst_nor1_lut_array; //testbench
    reg [15:0] i1,i2;
    wire o; // Added wire declaration
    nor1 nn(i1[7:6],i2[7:6],o);
    initial
    begin
    i1=0; i2=0; //

- code: |-
    module tst_wand2; //testbench
    reg i[6:0];
    wire o; // Added wire declaration
    wand2 ww(i[6:2],o);
    initial
    begin
    i[6]=0; i[5]=0; i[4]=0; i[3]=0; i[2]=1; i[1]=0; i[0]=0; // Drv1[6:2]=pull0, Drv2=pull0 -> o = pull0 (wand rule)

- code: |-
    module tst_wand2_v; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    wand2 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);

- code: |-
    module tst_wand1; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    wand1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
    ### Test Plan:
    * Design is a Wand gate.
    * Both input drivers are pull down.
    * Output should be pull down.
    ### Expected Result:
    * Output should be driven low by both the inputs.
    ### Pass/Fail Criteria:
    * Pass - Output is pulled down.
    * Fail - Output is not pulled down.
    
    ### Note:
    No change to the original design.
    
    ### Original Code
    <pre>
    module wand1 (i1, i2, o);
    	input i1, i2;
    	output o;
    
    	assign o = i1 & i2;
    endmodule
    
    module tb_wand1 ();
    
    	reg i1, i2;
    	wire o;
    	wand1 wand1_inst (i1, i2, o);
    
    	initial begin
    		i1=0;
    		i2=0;
    		#100
    		$stop;
    	end
    
    endmodule
    </pre>
    ### Modified Code
    <pre>
    module wand1 (i1, i2, o);
    	input i1, i2;
    	output o;
    
    	assign o = i1 & i2;
    endmodule
    
    module tb_wand1 ();
    
    	reg i1, i2;
    	wire o;
    	wand1 wand1_inst (i1, i2, o);
    
    	initial begin
    		i1=0;
    		i2=0;
    		#100
    		$stop;
    	end
    
    endmodule
    </pre>
    ### Original CDC Testbench
    <pre>
    `timescale 1ns / 1ps
    
    module tst_wand_cdc;
    	parameter CYCLES = 5000;
    	
    	reg i1, i2, i3;
    	wire o;
    	wand_cdc u_wand_cdc(.i1(i1),.i2(i2),.i3(i3),.o(o));
    	
    	initial begin
    		$monitor("%0t i1=%b i2=%b i3=%b o=%b", $time, i1, i2, i3, o);
    		for(int i=0; i<CYCLES; i++) begin
    			i1 = $urandom_range(0, 1);
    			i2 = $urandom_range(0, 1);
    			i3 = $urandom_range(0, 1);
    			#5;
    		end
    		#100;
    		$stop;
    	end
    
    endmodule
    
    module wand_cdc (i1, i2, i3, o);
    	input i1, i2, i3;
    	output o;
    	
    	assign o = i1 & i2 & i3;
    endmodule
    </pre>
    ### Modified CDC Testbench
    <pre>
    `timescale 1ns / 1ps
    
    module tst_wand_cdc;
    	parameter CYCLES = 5000;
    	
    	reg i1, i2, i3;
    	wire o;
    	wand_cdc u_wand_cdc(.i1(i1),.i2(i2),.i3(i3),.o(o));
    	
    	initial begin
    		$monitor("%0t i1=%b i2=%b i3=%b o=%b", $time, i1, i2, i3, o);
    		for(int i=0; i<CYCLES; i++) begin
    			i1 = $urandom_range(0, 1);
    			i2 = $urandom_range(0, 1);
    			i3

- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    0: y = case (a)
    0: b; // Select b if s=0
    1: a; // Select a if s=1
    endcase;
    1: y = b; // Select a if s=0
    endcase
    endmodule

- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else
    if(s == 1)
    y = b; // Select b if s=1
    else
    if(s == 2)
    y = 0; // Select 0 if s=2
    else
    if(s == 3)
    y = 0; // Select 0 if s=3
    else
    y = 0; // Select 0 if s=4
    endmodule
    
    ### Base Verilog Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else
    if(s == 1

- code: |-
    module mux41b (
    	input wire [3:0] a, b, s,
    	output reg [3:0] y
    );
    always @(*) // Combinational sensitivity
    begin // Blocking sensitivity
    	case (s) // Priority case structure
    		4'd0: y = a; // Select a if s=0
    		4'd1: y = b; // Select b if s=1
    		default: y = {4{1'b1}}; // Select c if s=1 and 0 if s=0
    	endcase
    end
    endmodule
    
    module mux81b (
    	input wire [3:0] a, b, s,
    	output reg [3:0] y
    );
    	mux41b u0 (.a(a[3:0]),.b(b[3:0]),.s(s[3:0]),.y(y[3:0]) );
    	mux41b u1 (.a(a[7:4]),.b(b[7:4]),.s(s[3:0]),.y(y[7:4]) );
    endmodule
    
    ### Formal Verification:
    Let A, B, and S be the input signals. The mux21b output is represented by the expression ‘y’.
    
    For each valid combination of S and A, B, the following conditions must be met.
    
    1. If S = 0, then y = A;
    
    2. If S = 1, then y = B;
    
    3. If S = 2, then y = 1010;
    
    4. If S = 3, then y = 1111;
    
    5. If S = 4, then y = 1101;
    
    6. If S = 5, then y = 1001;
    
    7. If S = 6, then y = 1011;
    
    8. If S = 7, then y = 1000;
    
    If A, B, and S satisfy these conditions, then y must also satisfy these conditions.
    
    The output function y must be completely determined by the input function A, B, and S.
    
    For example, when S = 0, then y = A, and when S = 1, then y = B. Therefore, the output function y is uniquely determined by the input function A, B, and S.
    ### Formal Verification:
    Let A, B, and S be the input signals. The mux41b output is represented by the expression ‘y’.
    
    For each valid combination of S and A, B, the following conditions must be met.
    
    1. If S = 0, then y = A;
    
    2. If S = 1, then y = B;
    
    3. If S = 2, then y = 1010;
    
    4. If S = 3, then y = 1111;
    
    5. If S = 4, then y = 1101;
    
    6. If S = 5, then y = 1001;
    
    7. If S = 6, then y = 1011;
    
    8. If S = 7, then y = 1000;
    
    9. If S = 8, then y = 1100;
    
    10. If S = 9, then y = 1110;
    
    11. If S = 10, then y = 1111;
    
    12. If S =

- code: |-
    module mux21b_variant (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else 
    case (s)
    	1: y = b;
    	2: y = a;
    	3: y = b;
    	4: y = a;
    	default: y = a;
    endcase
    endmodule
    ### Results:
    Simulation result:
    <div style="max-width: 90%; margin: auto; position: relative;">
    	<iframe src="https://www.tutorialspoint.com/compile_verilog_online.php" height="400" width="100%" style="border: 1px solid #999;"></iframe>
    </div><br>
    
    Synthesized result:
    <div style="max-width: 90%; margin: auto; position: relative;">
    	<iframe src="https://www.edaplayground.com/x/Xf6W" height="400" width="100%" style

- code: |-
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    always @(*) 
    begin
    case(s)
    1'b0:     y = a;
    1'b1:     y = b;
    default:  y = 0;
    endcase
    end
    endmodule
    ```
    ### Explanation:
    The combinational case structure has been replaced by a priority case statement.
    The default statement can be used to force the output to 0 when the input is invalid.
    This modification of the code is called a structural modification. 
    ### Tested Cases:
    ![image](images/mux21b_1.PNG)
    
    ### Recommended Codes:
    #### Code 1:
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    always @(*) 
    begin
    casex({s,a})
    2'b00:     y = 1'bx;
    2'b01:     y = a;
    2'b10:     y = b;
    2'b11:     y = 2'b00;
    default:   y = 1'bx;
    endcase
    end
    endmodule
    ```
    #### Code 2:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg unsigned [2:0] d={~s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 3:
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [2:0] d={~s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 4:
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    output tri reg d;
    always @(*)
    d=s? b : a;
    assign y=d;
    endmodule
    ```
    #### Code 5:
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg d={~s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 6:
    ```
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg unsigned [2:0] d={~s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 7:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [2:0] d={~s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 8:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg unsigned [2:0] d={s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 9:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [2:0] d={s,a,b};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 10:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg unsigned [2:0] d={a,b,s};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 11:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [2:0] d={a,b,s};
    always @(*)
    y=d[2];
    endmodule
    ```
    #### Code 12:
    ```
    module mux21b(
    input wire a,
    input wire b,
    input wire s,
    output

- code: |-
    module counter_reset (
    input wire clk,
    input wire reset,
    output reg [5:0] count
    );
    reg [5:0] counter_reg = 0; // register to store the counter
    wire overflow = (counter_reg == 31); // determine if overflow
    wire count_en = (reset == 1'b0) | overflow; // enable count if not reset or overflow
    always @ (posedge clk)
    begin
    if (count_en == 1'b1)
      counter_reg <= counter_reg + 1'b1; // increment if enabled
    if (overflow == 1'b1)
      counter_reg <= 6'b000000; // reset counter
    end
    assign count = counter_reg; // assign register count to output
    endmodule
    
    ### Base Verilog Code:
    module counter (
    input wire clk,
    input wire reset,
    output reg [5:0] count
    );
    reg [5:0] counter_reg = 0; // register to store the counter
    wire overflow = (counter_reg == 31); // determine if overflow
    wire count_en = (

- code: |-
    module mux21b (
    input wire a[2:0],
    input wire b[2:0],
    input wire s[3:0],
    output reg y // Output must be reg for procedural assignment
    );
    always @*
    begin:inside
    case(s)
    4'b0001: y = a; // Select a if s=0
    4'b0010: y = b; // Select b if s=1
    4'b0100: y

- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    2'b00: y = a;
    2'b01: y = b;
    2'b10: y = {2{a}};

- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [0:1] c;
    always @(*)
    begin
    if(s == 0)
    c = 2'b01;
    else
    c = 2'b10;
    end
    always @(*) // Combinational sensitivity
    begin
    case (c)
    2'b01: y = a;
    2'b10: y = b;
    2'b11: y = b;
    2'b00: y = a;
    endcase
    endmodule
    ### Testbench Code:
    ```
    module mux21b_test;
    reg a,b,s;
    wire y;
    mux21b mux(.a(a),.b(b),.s(s),.y(y));
    initial begin
    a = 1'b0;
    b = 1'b1;
    s = 1'b0;
    $monitor($time, " mux21b(y=%b,s=%b,a=%b,b=%b)", y,s,a,b);
    #10 s = 1'b1;
    #10;
    end
    endmodule
    ```
    ### Simulation
    ![21b_sim3](https://github.com/dineshbandla/mips32_processor/blob/master/image/21B_sim3.png)
    ### Passing the test:
    ![21b_sim4](https://github.com/dineshbandla/mips32_processor/blob/master/image/21B_sim4.png)
    
    ### Test case 3:
    ### Base Verilog Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else
    y = b; // Select b if s=1
    endmodule
    ### Variation Instruction:
    Add a priority case structure using inside with

- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    if(s == 0)
    y = a; // Select a if s=0
    else
    y = b; // Select b if s=1
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
       if(s == 0)
           y = a; // Select a if s=0
       else
           y = b; // Select b if s=1
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
       case(s)
       1'b0 : y = a; // Select a if s=0
       1'b1 : y = b; // Select b if s=1
       endcase
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
       case(s)
       1'b0 : y = a; // Select a if s=0
       1'b1 : y = b; // Select b if s=1
       endcase
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
       for (int i=0; i<2; i=i+1) // Iterating through the array
       case(i)
       0 : y = a; // Select a if s=0
       1 : y = b; // Select b if s=1
       endcase
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    
    always @(*) // Combinational sensitivity
       for (int i=0; i<2; i=i+1) // Iterating through the array
       case(i)
       0 : y = a; // Select a if s=0
       1 : y = b; // Select b if s=1
       endcase
    
    endmodule
    
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    
    always @(*) // Combinational sensitivity
       for (int i=0; i<2; i=i+1) // Iterating through the array
       case(s)
       2'b00 : y = a; // Select a if s=0
       2'b01 : y = b; // Select b if s=1
       endcase
    
    endmodule
    
    module mux21b (
    input wire [1:0] s,
    input wire [7:0] a,
    input wire [7:0] b,
    output reg [7:0] y // Output must be reg for procedural assignment
    );
    
    always @(*) // Combinational sensitivity
       for (int i=0; i<2; i=i+1) // Iterating through the array
       case(s)
       2'b00 : y = a; // Select a if s=0
       2'b01 : y = b; // Select b if s=1
       endcase
    
    endmodule
    
    module mux21b (
    input wire s,
    input wire [7:0] a,
    input wire [7:0] b,
    output reg [7:0] y // Output must be reg for procedural assignment
    );
    
    always @(*) // Combinational sensitivity
       case(s)
       '0 : y = a; // Select a if s=0
       '1 : y = b; // Select b if s=1
       endcase
    
    endmodule
    
    module mux21b (
    input wire s,
    input wire [7:0] a,
    input wire [7:0]

- code: |-
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        ALUout = left;
        case (mode)
            0: ALUout[7:0] = left[7:0] + right[7:0];
            1: ALUout[7:0] = left[7:0] - right[7:0];
            2: ALUout[7:0] = left[7:0] & right[7:0];
            3: ALUout[7:0] = left[7:0] | right[7:0];
            default: ALUout[7:0] = 8'bX;
        endcase
    end
    endmodule
    ```
    ### Modify Verilog Code:
    Add a new signal which holds the part select of `ALUout` for the case of `mode == 2` to avoid repetitive part selects in `ALUout[7:0]`.
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    // Add signal for holding part select of ALUout only once in case of mode == 2
    wire [7:0] ALUout_part_select;
    always_comb begin
        ALUout = left;
        case (mode)
            0: ALUout[7:0] = left[7:0] + right[7:0];
            1: ALUout[7:0] = left[7:0] - right[7:0];
            2: ALUout_part_select[7:0] = left[7:0] & right[7:0];
            3: ALUout[7:0] = left[7:0] | right[7:0];
            default: ALUout[7:0] = 8'bX;
        endcase
    end
    // Add assignment of ALUout_part_select to ALUout[7:0] only when mode == 2
    assign ALUout[7:0] = (mode == 2)? ALUout_part_select[7:0] : ALUout[7:0];
    endmodule
    ```
    ### Modify Verilog Code:
    Fix the bug in the modified code, where `ALUout_part_select` was not assigned to `ALUout[7:0]` on mode == 3.
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    // Add signal for holding part select of ALUout only once in case of mode == 2
    wire [7:0] ALUout_part_select;
    always_comb begin
        ALUout = left;
        case (mode)
            0: ALUout[7:0] = left[7:0] + right[7:0];
            1: ALUout[7:0] = left[7:0] - right[7:0];
            2: ALUout_part_select[7:0] = left[7:0] & right[7:0];
            3: ALUout_part_select[7:0] = left[7:0] | right[7:0];
            default: ALUout[7:0] = 8'bX;
        endcase
    end
    // Add assignment of ALUout_part_select to ALUout[7:0] only when mode == 2 or 3
    assign ALUout[7:0] = (mode == 2)? ALUout_part_select[7:0] : (mode == 3)? ALUout_part_select[7:0] : ALUout[7:0];
    endmodule
    ```
    ### Modify Verilog Code:
    If you look in the [Mux16-16](https://github.com/efabless/open_lanai/blob/main/verilog/designs/Mux16-16/Mux16-16.v) design we find that there is an

- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = {23'

- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
       case (mode)
          0: ALUout = left[mode] + right;
          1: ALUout = left[mode] - right;
          2: ALUout = left[mode] & right;
          3: ALUout = left[mode] | right;
          default: ALUout = 8'bX;
       endcase
    end
    endmodule
    
    ### Summary:
    The original code was combinational in nature. In fact, there is an implicit latch in the original code. In the modified code, the combinational nature of the code is maintained. However the part-select in the operands is replaced with an indexed array. This ensures that the part-select is evaluated in the same clock cycle.
    
    ### Changes to the original code:
    In the original code, the part-selects left[mode] and right are not evaluated in the same clock cycle. This is due to the fact that the case statement is evaluated in a different clock cycle. The part-selects are replaced with indexed arrays to ensure they are evaluated in the same clock cycle.
    
    
    ### Suggested Learning Outcomes:
    
    1. To know when indexed arrays can be used to replace part-selects.
    2. To know the consequences of replacing part-selects with indexed arrays.
    
    ### Difficulty

- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = left + right;
            1: ALUout = left - right;
            2: ALUout = left & right;
            3: ALUout = left | right;
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    ### RTL Code:
    ![RTL code](https://github.com/Ayush8111/FINAL_PROJECT/blob/main/ALU_8bit_RISCV/RTL%20code.png)
    
    ### Coverage:
    ![Coverage](https://github.com/Ayush8111/FINAL_PROJECT/blob/main/ALU_8bit_RISCV/Coverage.png)
    ### Synthesis:
    ![Synthesis](https://github.com/Ayush8111/FINAL_PROJECT/blob/main/ALU_8bit_RISCV/synth.PNG)
    ### RTL Code:
    ![RTL Codes](https://github.com/Ayush8111/FINAL_PROJECT/blob/main/ALU_8bit_RISCV/RTL%

- code: |-
    `timescale 1ns/100ps
    module ALU8(input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = left + right;
            1: ALUout = left - right;
            2: ALUout = left & right;
            3: ALUout = left | right;
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    `
    ### Description:
    Based on the instruction, the ALUout value depends on the mode.
    ### Procedural Assignment:
    - ALUout = left + right
    - ALUout = left - right
    - ALUout = left & right
    - ALUout = left | right
    ### Array Part-Select:
    - left + right
    - left - right
    - left & right
    - left | right
    - default (when mode is not 0,1,2,3)
    - left is the operand 1
    - right is the operand 2
    ### Reasoning:
    This is a good example where to implement the array part-select. This is because the ALUout value is dependant on left + right value, left - right, etc. So, the output value depends on the parts of left and right.
    ### Pros:
    - The array part-select is a better choice here than the concatenation.
    ### Cons:
    - The array part-select requires 4 bits of memory (4 registers) as compared to the concatenation method which required only 1 bit of memory.
    - The array-part-select has a longer verification time. This is due to the four case statements and the four always_comb blocks.
    - The array-part-select requires more resources (4 registers vs. 1 register).
    ### Design Changes:
    - The concatenation is converted to the array part-select method.
    ### Other:
    - The input part (8 bits) and the output part (8 bits) are not specified.
    - The default case is not commented.
    ### Benchmark:
    | No. | Method | Benchmark Value |
    | -- | :---: | --- |
    | 1 | Concatenation | 1482 |
    | 2 | Array Part-Select | 1461 |
    | 3 | Array Part-Select (1-3) | 1447 |
    | 4 | Array Part-Select (0) | 1445 |
    
    ### Experiment Summary:
    ![experiment_1](https://user-images.githubusercontent.com/83311280/139595409-0a173f75-eb72-4502-b5be-c0149d449376.png)
    
    ### Experiment Results:
    ![results_1](https://user-images.githubusercontent.com/83311280/139595411-70656a8d-0121-4f21-b419-3f05c2b1b086.png)
    
    ### Reflection:
    - The array-part-select is a better choice for the memory usage point of view.
    - The array-part-select is better for the verification-time point of view especially when the number of cases exceeds 4.
    - The array-part-select is better for the memory usage point of view.
    
    ### Reflection:
    - The concatenation is a better choice for the verification-time point of view.
    - The concatenation is better for the memory usage point of view.
    - The array-part-select is better for the verification-time point of view especially when the number of cases exceeds 4.
    
    ### Final Thoughts:
    - A case statement is a better choice when the number of conditions is not more than 4.
    - The concatenation is a better choice when the number of cases is more than 4.
    - The best way to design a circuit is to consider the memory use, the verification-time, the logic use, the resource use, and the port use.
    ### Summary:
    - The concatenation is a better choice when the number of cases is more than 4.
    - A case statement is a better choice when the number

- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always @* begin
        case (mode)
            0: ALUout = left[3:0] + right[3:0];
            1: ALUout = left[7:4] - right[7:4];
            2: ALUout = left[7:4] & right[3:0];
            3: ALUout = left[3:0] | right[7:4];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    
    ### Observations:
    - Passed simulation.
    ### Result: 3/3
    
    
    ### Case Study 4
    ### Base Verilog Code:
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always @(left, right, mode

- code: |-
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = left[3:0] + right[3:0];
            1: ALUout = left[3:0] - right[3:0];
            2: ALUout = left[3:0] & right[3:0];
            3: ALUout = left[3:0] | right[3:0];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    ```
    
    ### Skeleton Code:
    
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = left[3:0] + right[3:0];
            1: ALUout = left[3:0] - right[3:0];
            2: ALUout = left[3:0] & right[3:0];
            3: ALUout = left[3:0] | right[3:0];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    ```
    
    ### Test Bench Code:
    
    ```verilog
    timescale 1ns/100ps
    module ALU8_tb();
    reg [7:0] left, right;
    reg [1:0] mode;
    wire [7:0] ALUout;
    ALU8 dut(left, right, mode, ALUout);
    initial begin
        left = 8'b00110000;
        right = 8'b00001011;
        mode = 0;
        #1;
        $display("Left = %b, Right = %b, ALUout = %b", left, right, ALUout);
        $stop;
    end
    endmodule
    ```
    
    ### Output:
    
    ![output](https://user-images.githubusercontent.com/91019041/163982390-28f16893-bb71-4727-8651-676e7d204c

- code: |-
    ````verilog
    timescale 1ns/100ps
    module ALU8_test (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    
    always_comb begin // Changes
    	case (mode)
    		0: ALUout = left[0+:8] + right[0+:8];
    		1: ALUout = left[0+:8] - right[0+:8];
    		2: ALUout = left[0+:8] & right[0+:8];
    		3: ALUout = left[0+:8] | right[0+:8];
    		default: ALUout = 8'bX;
    	endcase
    end
    endmodule
    ````
    ### Summary:
    In the first version, case statement is used to make the ALU work on four input modes. The problem with this code is that case statement will consume more area than the selected operation. In the second version, only one case statement is used with part-select to make the ALU work on four input modes.
    
    ### What do we learn from this?

- code: |-
    ```verilog
    timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [3:0] mode, output reg [7:0] ALUout);
    always @* begin
        case (mode[1:0])
            0: ALUout = (mode[3:2] == 2'b00)? 
                        left[3:0] + right[3:0] : 
                        left[7:4] + right[7:4];
            1: ALUout = (mode[3:2] == 2'b00)? 
                        left[7:4] - right[7:4] : 
                        left[3:0] - right[3:0];
            2: ALUout = (mode[3:2] == 2'b00)? 
                        left[3:0] & right[3:0] : 
                        left[7:4] & right[7:4];
            3: ALUout = (mode[3:2] == 2'b00)? 
                        left[3:0] | right[3:0] : 
                        left[7:4] | right[7:4];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    ```
    
    ### Reference:
    https://www.xilinx

- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always @* begin
    	ALUout = 8'b0;
    	case (mode)
            0: ALUout[3:0] = left[3:0] + right[3:0];
            1: ALUout[3:0] = left[3:0] - right[3:0];
            2: ALUout[3:0] = left[3:0] & right[3:0];
            3: ALUout[3:0] = left[3:0] | right[3:0];
            default: ALUout = 8'bX;
        endcase
        case (mode)
            0: ALUout[7:4] = left[7:4] + right[7:4];
            1: ALUout[7:4] = left[7:4] - right[7:4];
            2: ALUout[7:4] = left[7:4] & right[7:4];
            3: ALUout[7:4] = left[7:4] | right[7:4];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule`
    
    ### Simulation Screenshots
    ![Simulation Screenshots](simulation-screenshots/simulation-1.png?raw=true "Simulation Screenshot")
    
    ### Code Listing For Driver - top.cpp
    ```C++
    #include <systemc.h>
    #include "ALU8.h"
    
    SC_MODULE(top)
    {
    	sc_in<sc_uint<4>> in1, in2;
    	sc_in<sc_uint<2>> op;
    	sc_out<sc_uint<8>> out;
    
    	sc_signal<bool> signal;
    
    	ALU8 alu8{"alu8"};
    
    	SC_CTOR(top)
    	{
    		alu8.in1(in1);
    		alu8.in2(in2);
    		alu8.mode(op);
    
    		alu8.out(out);
    	}
    
    	void stimulus()
    	{
    		in1 = 0;
    		in2 = 0;
    		op = 0;
    		wait(signal);
    
    		in2 = 1;
    		wait(signal);
    
    		in1 = 3;
    		wait(signal);
    
    		in2 = 4;
    		wait(signal);
    
    		in1 = 7;
    		wait(signal);
    
    		in2 = 2;
    		wait(signal);
    
    		in1 = 1;
    		wait(signal);
    
    		in2 = 2;
    		wait(signal);
    	}
    
    	void watch()
    	{
    		while (true)
    		{
    			std::cout << "in1: " << std::hex << (unsigned)in1 << " in2: " << std::hex << (unsigned)in2 << " op: " << std::hex << (unsigned)op << " out: " << std::hex << (unsigned)out << std::endl;
    			wait(1, SC_US);
    		}
    	}
    };
    
    int sc_main(int argc, char* argv[]) {
    	top top1{"top1"};
    	top1.in1(0);
    	top1.in2(0);
    	top1.op(0);
    	top1.out(0);
    	top1.signal(0);
    
    	sc_start();
    	return 0;
    }
    ```
    ### Code Listing For Verilog testbench - top.v
    ```Verilog
    module top(input logic [7:0] in1, in2, input logic [1:0] op, output logic [7:0] out);
    	logic [1:0] mode;
    	ALU8 alu8(.left(in1),.right(in2),.mode(mode),.out(out));
    
    	initial begin
    		mode =

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s)
    y = a;
    else
    y = b;
    endmodule
    
    ### Variation Subject:
    Simplify the condition expression.
    ### Variation Instruction:
    Simplify the condition expression to

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 1)
    y = a;
    else
    if(s == 2)
    y = b;
    else
    y = 4'b1010;
    endmodule
    ### Screenshot:
    ![image](https://user-images.githubusercontent.com/99939172/168863391-782b87a9-8f6d-4570-9055-4280c62ad312.png)
    
    ### Reflection:
    This question seemed to be rather easy, though i wasn't aware of the 3D array indexing. After practicing this and using this in my future designs, i think that i can easily understand it and utilize it to my greater benefit. Though i think that i have not gone with the intended solution, but i think that i have achieved the desired functionality.
    ### Code:
    ```
    `timescale 1ns/1ps
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output wire [3:0] y
    );
    always @(*)
    begin
    if(s == 1)
    y = a;
    else
    if(s == 2)
    y = b;
    else
    y = 4'b1010;
    end
    endmodule
    ```
    ### Reflection:
    I think that in this question, the task was to implement the 2D array to accept the values of S, A and B according to the given input in the table. The code that i have written is using the 2D array to store the values and then returning the corresponding value of A or B. I think that this is the right approach, and I think that it is useful to implement such a thing in real-time circuit design.
    ### Code:
    ```
    `timescale 1ns/1ps
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if(s == 1)
    y = a;
    else
    if(s == 2)
    y = b;
    else
    y = 4'b1010;
    end
    endmodule
    ```
    ### Reflection:
    This question seemed to be simple at first glance. I thought of creating the code for the mux using two input conditions rather than one. But the task was to create a code for the mux using 3 input conditions. So I created a 3D array. Then I created a condition that, if all the values were same, it should return 1111. After that, I added the conditions for the other rows, so that if s is 1 and 2, it would return the values stored in A and B respectively. The test bench that i created showed that the code is working properly.
    ### Code:
    ```
    `timescale 1ns/1ps
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    reg [3:0] arr3d [0:2][0:2][0:3];
    initial
    begin
    arr3d[0][0][0] = 4'b0000;
    arr3d[0][0][1] = 4'b0001;
    arr3d[0][0][2] = 4'b0010;
    arr3d[0][0][3] = 4'b0011;
    arr3d[0][1][0] = 4'b0100;
    arr3d[0][1][1] = 4'b0101;
    arr3d[0][1][2] = 4'b0110;
    arr3d[0][1][3] = 4'b0111;
    arr3d[0][2][0] = 4'b1000;
    arr3d[0][2][1] = 4'b1001;
    arr

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if(s == 0)
    y = a;
    else
    y = b;
    end
    endmodule
    ### Modification:
    
    Change the for loop with the code snippet below.
    
    ```c
    for(genvar j = 0 ; j < 4 ; j++)
        for(genvar i = 0 ; i < 4 ; i++){
            always @(*)
                if(s == 0)
    ```
    
    ### Expected Result:
    
    ![](images/24.png)
    
    ### Actual Result:
    
    ![](images/25.png)
    
    ### Failure Log:
    
    ![](images/26.png)
    
    ### Analysis:
    
    ```
    Error: (vlog-2157) Illegal output port connection. Output port 'y' cannot be connected to input port 'i' in assignment at mux_fail_1.v, line 17.
    ```
    
    The error message says that an output port cannot be connected to an input port.
    
    ### Severity:
    
    HIGH
    
    ### Modification:
    
    ### Passing Code:
    
    ```verilog
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if(s == 0)
    y = a;
    else
    y = b;
    end
    endmodule
    ```
    
    ### Failing Code:
    
    ```verilog
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    for(genvar j = 0 ; j < 4 ; j++){
        for(genvar i = 0 ; i < 4 ; i++){
            always @(*)
                if(s == 0)
    ```
    
    ### Expected Result:
    
    ![](images/24.png)
    
    ### Actual Result:
    
    ![](images/25.png)
    
    ### Failure Log:
    
    ![](images/26.png)
    
    ### Analysis:
    
    ```
    Error: (vlog-2157) Illegal output port connection. Output port 'y' cannot be connected to input port 'i' in assignment at mux_fail_1.v, line 17.
    ```
    
    The error message says that an output port cannot be connected to an input port.
    
    ### Severity:
    
    HIGH
    
    ### Modification:
    
    ### Passing Code:
    
    ```verilog
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if(s == 0)
    y = a;
    else
    y = b;
    end
    endmodule
    ```
    
    ### Failing Code:
    
    ```verilog
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    for(genvar j = 0 ; j < 4 ; j++){
        for(genvar i = 0 ; i < 4 ; i++){
            always @(*)
                if(s == 0)
    ```
    
    ### Expected Result:
    
    ![](images/24.png)
    
    ### Actual Result:
    
    ![](images/25.png)
    
    ### Failure Log:
    
    ![](images/26.png)
    
    ### Analysis:
    
    ```
    Error: (vlog-2157) Illegal output port connection. Output port 'y' cannot be connected to input port 'i' in assignment at mux_fail_1.v, line 17.
    ```
    
    The error message says that an output port cannot be connected to an input port.
    
    ### Severity:
    
    HIGH
    
    ### Modification:
    
    ### Passing Code:
    
    ```verilog
    module mux24

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    generate
    for(genvar i = 0; i < 4; i = i + 1) begin:for_gen_i
    for(genvar j = 0; j < 4; j = j + 1) begin:for_gen_j
    if(j == i) begin:for_gen_j_j_eq_i
    if(i == 0) begin:for_gen_j_j_eq_i_i_eq_0
    always @(*)
    begin:for_gen_j_j_eq_i_i_eq_0_always_1
    if(s == 0)
    y[i] = a[i];
    else
    y[i] = b[i];
    end
    end:for_gen_j_j_eq_i_i_eq_0_always_1
    end:for_gen_j_j_eq_i_i_eq_0
    else
    begin:for_gen_j_j_eq_i_i_neq_0
    always @(*)
    begin:for_gen_j_j_eq_i_i_neq_0_always_2
    if(s == 0)
    y[i] = a[i];
    else
    y[i] = b[i];
    end
    end:for_gen_j_j_eq_i_i_neq_0_always_2
    end:for_gen_j_j_eq_i_i_neq_0
    end:for_gen_j_j_eq_i
    end:for_gen_j
    end:for_gen_i
    endgenerate
    endmodule
    ### Base Verilog Code:
    module mux4b(
    input wire [1:0] a,
    input wire s,
    output reg y
    );
    always @(*)
    begin
    if(s == 0)
    y = a[0];
    else
    y = a[1];
    end
    endmodule
    ### Vari

- code: |-
    module mux24b(
        input wire [3:0] a,
        input wire [3:0] b,
        input wire s,
        output reg [3:0]

- code: |-
    ```vhdl
    module mux6_3x4(input wire [3:0] a [3:0], input wire s, output reg [3:0] y [3:0]);
    always @(*)
    if(s == 0)
    begin
    for (i=0; i<4; i=i+1)
    begin
    y[i] =a[i];
    end
    end
    else
    begin
    for (i=0; i<4; i=i+1)
    begin
    y[i] =b[i];
    end
    end
    end
    else
    begin
    for (i=0; i<4; i=i+1)
    begin
    y[i] =c[i];
    end
    end
    end
    else
    begin
    for (i=0; i<4; i=i+1)
    begin
    y[i] =d[i];
    end
    end
    endmodule
    ```
    ### Original Design:
    ```vhdl
    module mux8_2x4(input wire [3:0] a [3:0], input wire s, output reg [3:0] y [3:0]);
    always @(*)
    if(s == 0)
    begin
    for (i=0

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else if(s[1] == 1)
    y = b;
    else if(s[1] == 0 && s[0] == 1)
    y = b[1];
    else if(s[1] == 0 && s[0] == 0)
    begin
    y = b[2];
    y = b[1];
    end
    else if(s[1] == 0 && s[0] == 0)
    y

- code: |-
    module mux24b_variation(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @ (*)
    if(s == 0)
    y = a;
    else
    if(X[Y] == 1) // XMR style hierarchy
    y = b;
    else
    y = a;
    endmodule
    ### 2D array index expression
    X[Y]
    ### Variation Type:
    Bug Fix
    ###

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if (s == 0)
    y = a;
    else
    y = b;
    end
    if (s == 0)
    y[3] = a[3];
    else
    y[3] = b[3];
    if (s == 0)
    y[2] = a[2];
    else
    y[2] = b[2];
    if (s == 0)
    y[1] = a[1];
    else
    y[1] = b[1];
    if (s == 0)
    y[0] = a[0];
    else
    y[0] = b[0];
    endmodule
    ### Simulation Log:
    ### Step 1:
    ### Signal Initialization:
    ### Step 2:
    ### Signal Initialization:
    ### Step 3

- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    begin
    if(s == 0)
    y = a;
    else if(s == 1)
    y = b;
    else if(s == 2)
    y = 4'b0111;
    else if(s == 3)
    y = 4'b1001;
    else if(s == 4)
    y = 4'b

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = 
    case(s) // s[1] determines the case
    1'b00: c[0]
    1'b01: c[1]
    1'b10: c[2]
    1'b11: c[3]
    endcase;
    endmodule
    ### Verification Steps:
    1. Run and see the 4 outputs are 1's only.
    ### Expected Output
    z = 1 when c[0] = 1;
    z = 1 when c[1] = 1;
    z = 1 when c[2] = 1;
    z = 1 when c[3] = 1;
    ### Simulation Screens

- code: |-
    ```Verilog
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = 
    case (s)
    3'b000: c[0];
    3'b001: c[1];
    3'b010: c[2];
    3'b011: c[3];
    default: 0;
    endcase
    endmodule
    ```
    ### Simulation:
    ![simulation](https://github.com/h-ayat/fpga-study/blob/main/week4/images/simulation.png)
    ### Tips:
    #### Tips 1:
    If you want to select a single bit from a vector of bits, use this line:
    ```Verilog
    assign z = a[index];
    ```
    #### Tips 2:
    You can use the following line to select a vector of bits from a vector of bits:
    ```Verilog
    assign z = a[index:index+width-1];
    ```
    ### Simplification:
    #### Improvement 1:
    Rewrite

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    always_comb
    begin
    case(s)
    2'b00: z = 1'b0 & c[0]; // Select c[0] when s=00
    2'b01: z = 1'b0 & c[1]; // Select c[1] when s=01
    2'b10: z = 1'b0 & c[2]; // Select c[2] when s=10
    2'b11: z = 1'b0 & c[3]; // Select c[3] when s=11
    endcase
    end
    endmodule
    ### Notes:
    Simulation results show that the array elements can be tested seperately without the need to check the entire array. In the first modifiled code, the z value was declared as a 1-bit instead of a 4-bit, so the z output was not 1-bit.
    ### Simulation Results:
    ![mux41b_3](mux41b_3.png)
    ### Simulation Source Code:
    ```verilog
    module tb_mux41b ();
    
    // Inputs
    reg [1:0] s;
    reg [3:0] c;
    
    // Outputs
    wire z;
    
    // Instantiate the Unit Under Test (UUT)
    mux41b uut (
    .c(c),
    .s(s),
    .z(z)
    );
    
    initial begin
    $dumpfile("mux41b_3.vcd");
    $dumpvars(1);
    end
    
    initial begin
    s = 2'b00;
    c = 4'b0000;
    
    #100;
    s = 2'b01;
    #100;
    s = 2'b10;
    #100;
    s = 2'b11;
    #100;
    
    s = 2'b00;
    c = 4'b0100;
    #100;
    s = 2'b01;
    c = 4'b1001;
    #100;
    s = 2'b10;
    c = 4'b0011;
    #100;
    s = 2'b11;
    c = 4'b1110;
    #100;
    
    $finish;
    end
    
    endmodule
    ```
    ### Results:
    Results showed that with the modified code (m

- code: |-
    module mux41b (
        input wire [3:0] c,
        input wire [1:0] s,
        output wire z
    );
        always @(*)
            case (s)
                2'b00: z = c[0];
                2'b01: z = c[1];
                2'b10: z = c[2];
                2'b11: z = c[3];
            endcase
    endmodule
    ###

- code: |-
    module mux41b_1 (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    reg [3:0] a;
    always @(s or c) a[s] = c; // Assign c[0], c[1], c[2] or c[3] to a[0], a[1], a[2] or a[3] respectively according to s value
    assign z = a

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    
    assign z = 
    case (s)
    1'b00 : c[0];
    1'b01 : c[1];
    1'b10 : c[2];
    1'b11 : c[3];
    endcase;
    
    endmodule
    ### Testbench:
    module mux41b_testbench;
    wire [3:0] c;
    wire [1:0] s;
    wire [3:0] z;
    
    mux41b m (.*);
    
    initial begin
    for (int i=0; i<4; i++) begin
    	c = {2'b00, i};
    	s = 2'b00;
    	#200;
    	$display("%d ", z);
    	s = 2'b01;
    	#200;
    	$display("%d ", z);
    	s = 2'b10;
    	#200;
    	$display("%d ", z);
    	s = 2'b11;
    	#200;
    	$display("%d ", z);
    	s = 2'b00;
    	#200;
    	$display("%d ", z);
    end
    end
    endmodule
    ### Verilog Testbench Output:
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
      0
      1
      2
      3
    ### Synthesis and Simulation:
    1. Above code synthesize and simulate successfully.
    2. All cases are tested with success!
    ### Discussion:
    1. In some situation, we have to use case

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b01: c[1]; // Select c[1] when s=01
    2'b10: c[2]; // Select c[2] when s=10
    2'b11: c[3]; // Select c[3] when s=11
    endcase;
    endmodule
    ### Design Recommendations
    - It is important to note that case block will not work properly when assigning output variable and when not used in the context of a combinational circuit.
    - It is very important to note that case blocks are not meant to replace if-else statements.
    ### Example Design
    - It is common to see code like the following:
    ```verilog
    assign z = s[0]? c[0] : (s[0]? c[1] : (s[1]? c[2] : c[3]));
    ```
    - This code is correct, however, it is more readable when using a case block
    ```verilog
    assign z = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b01: c[1]; // Select c[1] when s=01
    2'b10: c[2]; // Select c[2] when s=10
    2'b11: c[3]; // Select c[3] when s=11
    endcase;
    ```
    - Using case blocks with 2-bit vectors is very common. In fact, case blocks can also be used with 1-bit vectors.
    - It is not uncommon to see a case block with 2-bit vectors nested inside another case block. This is fine for synthesis as long as it is not done with different widths.
    ```verilog
    assign z = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b01: case (s)
    2'b00: c[1]; // Select c[1] when s=00
    2'b01: c[2]; // Select c[2] when s=01
    2'b10: c[3]; // Select c[3] when s=10
    endcase; // Select c[3] when s=11
    endcase; // Select c[0] when s=00
    ```
    - The following code will not work as it is expecting a value for `s` when not providing a value for `s`.
    ```verilog
    assign z = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b01: case (s)
    2'b00: c[1]; // Select c[1] when s=00
    2'b01: c[2]; // Select c[2] when s=01
    2'b10: c[3]; // Select c[3] when s=10
    endcase; // Select c[3] when s=11
    endcase; // Select c[0] when s=00
    ```
    - This code will also not work. The error is that it is trying to evaluate `case (s)`, but since `s` has not been connected to anything, it will not work.
    ```verilog
    assign z = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b01: case (s)
    2'b00: c[1]; // Select c[1] when s=00
    2'b01: c[2]; // Select c[2] when s=01
    2'b10: c[3]; // Select c[3] when s=10
    endcase; // Select c[3] when s=11
    endcase; // Select c[0] when s=00
    ```
    - If the case block is not used with a combinational circuit, it will not work properly.
    ```verilog
    reg q[3:0];
    assign q[0] = case (s)
    2'b00: c[0]; // Select c[0] when s=00
    2'b0

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = c[0];
    endmodule
    ######
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = c[1];
    endmodule
    ######
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = c[2];
    endmodule
    ######
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = c[3];
    endmodule
    ### Tests:
    ##### test 5.1:
    input:
    wire [3:0] c;
    c[3] <= 1;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M1 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 1;
    ##### test 5.2:
    input:
    wire [3:0] c;
    c[2] <= 1;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M2 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 0;
    ##### test 5.3:
    input:
    wire [3:0] c;
    c[1] <= 1;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M3 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 1;
    ##### test 5.4:
    input:
    wire [3:0] c;
    c[0] <= 1;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M4 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 0;
    ##### test 5.5:
    input:
    wire [3:0] c;
    c[3] <= 0;
    c[2] <= 1;
    c[1] <= 0;
    c[0] <= 1;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M5 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 1;
    ##### test 5.6:
    input:
    wire [3:0] c;
    c[3] <= 1;
    c[2] <= 0;
    c[1] <= 1;
    c[0] <= 0;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M6 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 0;
    ##### test 5.7:
    input:
    wire [3:0] c;
    c[3] <= 0;
    c[2] <= 0;
    c[1] <= 1;
    c[0] <= 0;
    wire [1:0] s;
    s[1] <= 1;
    s[0] <= 1;
    output: 
    wire z;
    mux41b M7 (
    .c(c),
    .s(s),
    .z(z)
    );
    expected output: 
    z = 0;
    ##### test 5.8:
    input:
    wire

- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    case(s)
    0: z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    1: z = ~s[1] & s[0] & c[1] // Select c[1] when s=01
    2: z = s[1] & ~s[0] & c[2] // Select c[2] when s=10
    3: z = s[1] & s[0] & c[3]; // Select c[3] when s=11
    default: z = c[0];
    endcase
    endmodule
    ### Variation Instruction:
    Add a case block with inside testing array elements selected by dynamic variable

- code: |-
    ```vhdl
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    always @ (*) begin
    case (s)
    1'b0: z <= c[0]; 
    1'b1: z <= c[1];
    2'b10: z <= c[2];
    2'b11: z <= c[3];
    endcase
    end
    endmodule
    ```
    ### Combined Code:
    ```vhdl
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    always @ (*) begin
    case (s)
    1'b0: z <= c[0]; 
    1'b1: z <= c[1];
    2'b10: z <= c[2];
    2'b11: z <= c[3];
    endcase
    end
    endmodule
    ```
    ### Test bench:

- code: |-
    `timescale 1ns/100ps
    module maj4 (input [2:0] a, output reg [1

- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl

- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    
    always@(posedge c)
    begin
    y<=a||b||c;
    end
    
    endmodule
    ### Test Bench:
    `timescale 1ns/100ps
    
    module test_maj();
    
    reg a, b, c, clk, rst;
    wire y;
    
    maj3_p uut (
       .a(a)   ,.b(b),.c(c),    .y(y),
       .clk(clk),.rst(rst)
        );
    
    initial begin
    //rst=1;
    a=1'b0;
    b=1'b0;
    c=1'b0;
    #10;
    
    a=1'b0;
    b=1'b0;
    c=1'b1;
    #10;
    
    a=1'b0;
    b=1'b1;
    c=1'b0;
    #10;
    
    a=1'b0;
    b=1'b1;
    c=1'b1;
    #10;
    
    a=1'b1;
    b=1'b0;
    c=1'b0;
    #10;
    
    a=1'b1;
    b=1'b0;
    c=1'b1;
    #10;
    
    a=1'b1;
    b=1'b1;
    c=1'b0;
    #10;
    
    a=1'b1;
    b=1'b1;
    c=1'b1;
    #10;
    
    $finish;
    end
    endmodule
    ### Results Log:
    ```
    ** Note: The following log may vary depending on your

- code: |-
    ```
    timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    always @(*)
    begin
        y = (|{a, b, c

- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule
    
    
    
    module test (input clk, output y);
    wire x[3:0], y[3:0];
    
    assign x[0] = 1;
    assign x[1] = 0;
    assign x[2] = 1;
    assign x[3] = 1;
    
    maj3_p

- code: |-
    `timescale 1ns/100ps
    module maj3_d (input a, b, c, output y);
    wire z;
    always@(a, b, c)
        z=maj(a,b,c)[0];
    assign y=z;
    endmodule
    `
    ### Original Code

- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    always @(im3) y = im1[0]? a : (im2[0]? b : c);
    endmodule
    ### Listing of VHDL architecture:
    ```
    architecture dataflow of mult_4bit is
        signal s1, s2, s3: std_logic_vector(4 downto 0); 
    begin
        s1 <= a1_i and b1_i;
        s2 <= a2_i and b2_i;
        s3 <= a3_i and b3_i;
        c1_o <= s1(0) xnor s2(0) xnor s3(0);
        c2_o <= s1(1) xnor s

- code: |-
    timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3, im4, im5, im6, im7;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2,

- code: |-
    ```
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire [1:0] im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    always @(*)
        y = im1[0] | im1[1] | im2[0] | im2[1] | im3[0] | im3[1];
    endmodule
    ```
    ### Simulation Setup:
    **top.v**
    ```
    module top();
        logic [1:0] a, b, c, y, d;
    wire [1:0] e;
        maj3_p #(.tplh1(2),.tphl1(4),.tplh2(3),.tphl2(5)) dut_p
        (a, b, c, y);
        maj3_p #(.tplh1(2),.tphl1(4),.tplh2(3),.tphl2(5)) dut_p2
        (d, b, c, e);
    endmodule
    ```
    **top_test.v**
    ```
    `timescale 1ns/100ps
    module top_test;
        logic [1:0] a, b, c, y, d;
    wire [1:0] e;
        maj3_p #(.tplh1(2),.tphl1(4),.tplh2(3),.tphl2(5)) dut_p
        (a, b, c, y);
        maj3_p #(.tplh1(2),.tphl1(4),.tplh2(3),.tphl2(5)) dut_p2
        (d, b, c, e);
        initial begin
            a = 0; b = 0; c = 0;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 1; b = 0; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 0; b = 1; c = 0;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 1; b = 1; c = 0;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 1; b = 0; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 0; b = 1; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 1; b = 1; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 0; b = 0; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 0; b = 1; c = 1;
            #1;
            $display("a = %b, b = %b, c = %b, y = %b", a, b, c, y);
            a = 1; b = 0; c = 0;
            #1;
            $display("a = %b

- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    function [2:0] f;
        input [1:0] x;
        begin
            case (x)
                2'b00: f=3'b000;
                2'b01: f=3'b001;
                2'b10: f=3'b100;
                2'b11: f=3'b010;
            endcase
        end
    endfunction
    always @*
        begin
            im1=a&b;
            im2

- code: |-
    module counter (
         input wire cl

- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    initial begin
        count[1:0] = 2'b00;
    end
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    endmodule
    ### Trace Table:
    | #(s) | clk |                  |
    |------|-----|------------------|
    |    0 | 0   | (1, count = 0)   |
    |    1 | 0   | (2, count = 1)   |
    |    2 | 0   | (3, count = 2)   |
    |    3 | 1   | (2, count = 3)   |
    |    4 | 1   | (3, count = 4)   |
    |    5 | 1   | (4, count = 5)   |
    |    6 | 1   | (5, count = 6)   |
    |    7 | 1   | (6, count = 7)   |
    |    8 | 1   | (7, count = 8)   |
    |    9 | 1   | (8, count = 9)   |
    |   10 | 1   | (9, count = 10)  |
    |   11 | 1   | (10, count = 11) |
    |   12 | 1   | (11, count = 12) |
    |   13 | 1   | (12, count = 13) |
    |   14 | 1   | (13, count = 14) |
    |   15 | 1   | (14, count = 15) |
    |   16 | 1   | (15, count = 16) |
    |   17 | 1   | (16, count = 17) |
    |   18 | 1   | (17, count = 18) |
    |   19 | 1   | (18, count = 19) |
    |   20 | 1   | (19, count = 20) |
    |   21 | 1   | (20, count = 21) |
    |   22 | 1   | (21, count = 22) |
    |   23 | 1   | (22, count = 23) |
    |   24 | 1   | (23, count = 24) |
    |   25 | 1   | (24, count = 25) |
    |   26 | 1   | (25, count = 26) |
    |   27 | 1   | (26, count = 27) |
    |   28 | 1   | (27, count = 28) |
    |   29 | 1   | (28, count = 29) |
    |   30 | 1   | (29, count = 30) |
    |   31 | 1   | (30, count = 31) |
    |   32 | 1   | (31, count = 32) |
    |   33 | 1   | (32, count = 33) |
    |   34 | 1   | (33, count = 34) |
    |   35 | 1   | (34, count = 35) |
    |   36 | 1   | (35, count = 36) |
    |   37 | 1   | (36, count = 37) |
    |   38 | 1   | (37, count = 38) |
    |   39 | 1   | (38, count = 39) |
    |   40 | 1   | (39, count = 40) |
    |   41 | 1   | (40, count = 41) |
    |   42 | 1   | (41, count = 42) |
    |   43 | 1   | (42, count = 43

- code: |-
    module counter_regfile_aload (
        input wire clk, rst, aload,
        input wire [3:0] aload_data,
        output reg [3:0] count
    );
    reg [3:0] count_regfile[0:3

- code: |-
    module counter_381 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_381
    );
    wire [3:0] internal;
    initial begin
        internal <= count[3:0];
        count_381 <= internal;
    end
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    endmodule
    ### Variation Verilog Code:
    module counter_382 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_382
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_382 = count[3:0];
    endmodule
    ### Variation Verilog Code:
    module counter_383 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_383
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_383 = count[3:0];
    endmodule
    ### Variation Verilog Code:
    // Avoid use of [3:0] slice
    module counter_384 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_384
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_384 = count[7:4];
    endmodule
    ### Variation Verilog Code:
    // Avoid use of [3:0] slice
    module counter_385 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_385
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_385 = count;
    endmodule
    ### Variation Verilog Code:
    module counter_386 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_386
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_386 = count[7:4];
    endmodule
    ### Variation Verilog Code:
    module counter_387 (
        input wire clk, rst,
        output reg [7:0] count,
        output reg [3:0] count_387
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 8'b00000000;
        else count <= count + 1;
    end
    assign count_387 = count;
    endmodule
    ### Variation Verilog Code:

- code: |-
    ```
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    reg [3:0] count_array [3:0];
    reg [3:0] count_reg;
    reg [3:0] count_reg_2;
    reg [3:0] count_reg_3;
    wire [3:0] mux_out;
    
    initial begin
        count_array = 4'b0000;
    end
    
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    
    always @(*) begin
        if (count < 4) count_reg = count_array[count];
    end

- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count,
        output reg [3:0] addout
    );
    initial begin
        count <= 4'b0000;
        addout <= count[2:1];

- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    initial begin
        count[3:1] = 3'b100;
    end
    endmodule
    ### Final Code
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    initial begin
        count[3:1] = 3'b100;
    end
    endmodule
    ### Final Output: 
    (1)

- code: |-
    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    reg [3:0] slice;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            slice[3:0] <= 4'b0000;
            count <= 4'b0000;
        end
        else begin
            count <= count + 1;
            slice[3:

- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    wire [3:0] w;
    initial begin
        w[count+1:count] = 4'b0001;

- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    
    initial count[1:2] = count[1:2] + 2;
    wire [1:2] addition;
    assign addition = count[1:2] + 2;
    endmodule
    ### Simulation Setup
    #### Verilog Simulation SetUp
    ##### Compilation
    ```shell
    ghdl -a --std=08 counter.vhd
    ```
    ##### Simulation
    ```shell
    ghdl -r --std=08 counter --vcd=counter.vcd --workdir=work
    ```
    #### GTKwave Simulation
    ##### Compilation
    ```shell
    gtkwave counter.vcd &
    ```
    ##### Output
    ![image](https://user-images.githubusercontent.com/86429705/126040493-d80444f0-2b92-484a-96d7-3766a49d7c26.png)
    
    
    ## Verification Checklist
    ### Conditions to pass the test:
    1. Inputs (rst, clk) are defined in the test-bench.
    2. A counter module is instantiated in the test-bench.
    3. The counter module is defined in a separate Verilog file.
    4. The counter module is instantiated at least twice in the test-bench.
    5. The counter module has an output signal named `count`.
    6. The counter module is always enabled (there is no `if` statement inside the `always` block).
    7. The counter module has an input signal named `rst`.
    8. The counter module has an input signal named `clk`.
    9. The counter module has a combinational `always` block.
    10. The counter module always contains four-bit outputs.
    11. The counter module contains a two-bit output signal named `count` on its output port.
    12. The counter module has a two-bit input signal named `count`.
    13. The counter

- code: |-
    module ExtraCount (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    final begin
        Count[2:0] = {1'b0, Count[2:0]} << 2;
    end
    endmodule
    ##### Original Verilog Benchmark:
    ```verilog
    module counter_top (
        input         clk,
        input         rst,
        output [47:0] total_count
    );
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_0 (
       .clk(clk),
       .rst(rst),
       .count(total_count[7:0])
      );
    
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_1 (
       .clk(clk),
       .rst(rst),
       .count(total_count[15:8])
      );
    
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_2 (
       .clk(clk),
       .rst(rst),
       .count(total_count[23:16])
      );
    
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_3 (
       .clk(clk),
       .rst(rst),
       .count(total_count[31:24])
      );
    
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_4 (
       .clk(clk),
       .rst(rst),
       .count(total_count[39:32])
      );
    
      counter #(
       .INITIAL_VALUE(5'h00),
       .WIDTH(8)
      ) counter_5 (
       .clk(clk),
       .rst(rst),
       .count(total_count[47:40])
      );
    
    endmodule
    
    module counter (
        input         clk,
        input         rst,
        output [3:0]  count
    );
      always @(posedge clk) begin
        if (rst) begin
          count <= 4'h0;
        end else begin
          count <= count + 1;
        end
      end
    endmodule
    ```
    ##### Synthesis Results:
    ```shell
    ===============================================================================
    |                      Synthesis Results                                      |
    ===============================================================================
    |  Number of Slices (2-bit and larger)                                         |
    |   __________________________________________________________________________|
    |   |      32      |                                                          |
    |   __________________________________________________________________________|
    |   |      32      |  _______________________________________________________|
    |   |               | |       26      |                                      |
    |   |                ----                                                    |
    |   |                26      |                ______________________________|
    |   |                         | |       18      |                           |
    |   |                          -----                                        |
    |   |                          18      |          ________________________|
    |   |                                   | |        10      |              |
    |   |                                    ----                             |
    |   |                                    10      |           ____________|
    |   |                                                        |      8      |
    |   |                                                         ----       |
    |   |                                                         8      |    |
    |   |                                                                     |
    |   |_____________________________________________________________________|
    |                                                                          |
    |  Number of slices                                                          |
    |   __________________________________________________________________________|
    |   |      32      |                                                          |
    |   __________________________________________________________________________|
    |   |      32      |  _______________________________________________________|
    |   |               | |       26      |                                      |

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else {Count[0], Count[2:1], Count[3]} <= {Count[2:1], Count[3], Count[0]};
    end
    endmodule
    ### Result
    All tests Passed
    ```
    
    ## <span id="3.3">3.3</span>
    
    ```verilog
    ### Base Ver

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if

- code: |-
    module Chap1Counter2 (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    final begin:final1
       $display("Count[0:1] = %b", Count[0:1]);
       Count[0:1] = Count[1:2];
    end
    endmodule
    ### Explanation:
    The final statement in the module can have more than one procedural statement
    inside the final block. The procedural statements can be grouped by logical
    flow statements, such as if statements.
    ### Simulation:

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    final begin
        Count[1] = 1'b1; //This is the updated line
    end
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    endmodule
    ### Output Code:
    ![Counter Output](https://github.com/AkashSingh3031/The-Missing-Semester-of-Your-CS-Career/blob/master/

- code: |-
    module chap5_107(BTN, LEDR);
       input [2:0] BTN;
       output [6:0] LEDR;
       wire [2:0] SW;
    
       assign SW[2] = BTN

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    final Count[2:1] = 0;
    endmodule
    ### Expected Result:
    - Output:
    ![expected output](expected.png)
    - Error message:
    ![error message](error.png)
    - Source code:
    ![source code](source.png)
    
    Reference: [[1]](https://stackoverl

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    final begin :

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else

- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count = Count + 1;
    end
    final begin
        Count[2:0] = 3'b000; // <--
    end
    endmodule
    ### Modified TestBench Code:
    module Chap1Counter_TB();
    reg Clk;
    reg Reset;
    wire [3:0] Count;
    Chap1Counter UUT(Clk, Reset, Count);
    always begin
        Clk = 0;
        #10;
        Clk = 1;
        #10;
    end
    initial begin
        Reset = 1;

- code: |-
    module tst_nm_in();
      reg [3:0] in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in = 4'b1111; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
    initial
      begin
        for (i=0;i<20;i=i+1)
        #10 in=incr(in);
        $stop; // Stop simulation
      end
      // Case statement to increment input
      function [3:0] incr(input [3:0] in);
        case(in)
          4'b0000 : incr=4'b0001;
          4'b0001 : incr=4'b0011;
          4'b0010 : incr=4'b0101;
          4'b0011 : incr=4'b0111;
          4'b0100 : incr=4'b1001;
          4'b0101 : incr=4'b1011;
          4'b0110 : incr=4'b1101;
          4'b0111 : incr=4'b1111;
          4'b1000 : incr=4'b1001;
          4'b1001 : incr=4'b1011;
          4'b1010 : incr=4'b1101;
          4'b1011 : incr=4'b1111;
          4'b1100 : incr=4'b1001;
          4'b1101 : incr=4'b1011;
          4'b1110 : incr=4'b1101;
          4'b1111 : incr=4'b1111;
          default : incr=4'b0000;
        endcase
      endfunction
      initial
      begin
        for (i=0;i<20;i=i+1)
        #10 in=incr(in);
        $stop; // Stop simulation
      end
      // Case statement to increment input
      function [3:0] incr(input [3:0] in);
        case(in)
          4'b0000 : incr=4'b0001;
          4'b0001 : incr=4'b0011;
          4'b0010 : incr=4'b0101;
          4'b0011 : incr=4'b0111;
          4'b0100 : incr=4'b1001;
          4'b0101 : incr=4'b1011;
          4'b0110 : incr=4'b1101;
          4'b0111 : incr=4'b1111;
          4'b1000 : incr=4'b1001;
          4'b1001 : incr=4'b1011;
          4'b1010 : incr=4'b1101;
          4'b1011 : incr=4'b1111;
          4'b1100 : incr=4'b1001;
          4'b1101 : incr=4'b1011;
          4'b1110 : incr=4'b1101;
          4'b1111 : incr=4'b1111;
          default : incr=4'b0000;
        endcase
      endfunction
      initial
      begin
        for (i=0;i<20;i=i+1)
        #10 in=incr(in);
        $stop; // Stop simulation
      end
      //

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      always @*
        if (in == 1'b0)
          out = inside[`INV]; // out is the output of the inveter
      initial
        in =1'b1; // Start with input high -> output low
      initial #15 $stop; // Stop simulation
    
      function get_inv;
        input t;
        case (t)
          0: get_inv = `INV;
        endcase
      endfunction // get_inv
    
      localparam [3:0] inside[`NUM_INV][`VT][`VT][`VT] = '{ // Table of inverter delays
        `INV: { // 600ps
          '{`VDD,`VDD,`VDD,`VDD,`VDD,`VDD}
        },
        `INV1: { // 120ps
          '{`VDD,`VDD,`VDD,`VDD,`VDD,`VDD}
        },
        `INV2: { // 200ps
          '{`VDD,`VDD,`VDD,`VDD,`VDD,`VDD}
        },
        `INV3: { // 500ps
          '{`VDD,`VDD,`VDD,`VDD,`VDD,`VDD}
        },
        `INV4: { // >1us
          '{`VDD,`VDD,`VDD,`VDD,`VDD,`VDD}
        }
      };
    
    endmodule
    ### Expectation:
    The circuit should simulate correctly, showing the delay change depending on the case.
    ### Simulation Timeout:
    The simulation should finish within 10s.
    ### Simulation Log:
    In the simulation log, there should be a report on the output from the inverter. Here is an example that has been verified:
    
    ```
    #     time        | in = 1'b1, output = 1'b1
    #   600 ps        in = 1'b1, output = 1'b0
    #   640 ps        in = 1'b1, output = 1'b0
    #   680 ps        in = 1'b1, output = 1'b0
    #   720 ps        in = 1'b1, output = 1'b0
    #   760 ps        in = 1'b1, output = 1'b0
    #   800 ps        in = 1'b1, output = 1'b0
    #   840 ps        in = 1'b1, output = 1'b0
    #   880 ps        in = 1'b1, output = 1'b0
    #   920 ps        in = 1'b1, output = 1'b0
    #   960 ps        in = 1'b1, output = 1'b0
    #   1000 ps       in = 1'b1, output = 1'b0
    #   1040 ps       in = 1'b1, output = 1'b0
    #   1080 ps       in = 1'b1, output = 1'b0
    #   1120 ps       in = 1'b1, output = 1'b0
    #   1160 ps       in = 1'b1, output = 1'b0
    #   1200 ps       in = 1'b1, output = 1'b0
    #   1240 ps       in = 1'b1, output = 1'b0
    #   1280 ps       in = 1'b1, output = 1'b0
    #   1320 ps       in = 1'b1, output = 1'b0
    #   1360 ps       in = 1'b1, output = 1'b0
    #   1400 ps       in = 1'b1, output = 1'b0
    #   1440 ps       in = 1'b1,

- code: |-
    module tst_nm_in();
      reg in; wire out;
      reg [4:0] a;
      NMOSinv nmv[5][4][3][2][1](out,in);
      reg [0:4]  led;
      initial
        in =1'b1, a = 5'b00000; // Start with first element in array
      always @(*)
        case(in)
          1'b0: a = 5'b00000;
          1'b1: a = 5'b11111;
        endcase
      always @(*)
        begin
          led0 = out[0];
          led1 = out[1];
          led2 = out[2];
          led3 = out[3];
          led4 = out[4];
        end
      initial $monitor

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      always @(in) case(fun(in,0,2,3)) // 4D array index
        {1'b0:out = 1'b1;} // in->out Low->High
        default: out = 1'bX; // 4D array index
      endcase // switch on 4D array
      initial in =1'b1; // Start with input high -> output low
      always $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    ### Modified Function definition:
    function [3:0] fun(input [0:0] in,i1,i2,i3); // 4D array index
      case(i1)
        1: case(i2)
            2: case(i3)
              3: fun = 4'b1000; // (1,2,3) -> 4'b1000
              2: fun = 4'b0100; // (1,2,2) -> 4'b0100
              1: fun = 4'b0010; // (1,2,1) -> 4'b0010
              0: fun = 4'b0001; // (1,2,0) -> 4'b0001
            default: fun = 4'b0000; // (1,X,X) -> 4'b0000
            endcase // switch on i2
            1: case(i3)
              3: fun = 4'b0000; // (1,1,3) -> 4'b0000
              2: fun = 4'b0001; // (1,1,2) -> 4'b0001
              1: fun = 4'b0010; // (1,1,1) -> 4'b0010
              0: fun = 4'b0100; // (1,1,0) -> 4'b0100
            default: fun = 4'b1000; // (1,X,X) -> 4'b1000
            endcase // switch on i3
            0: fun = 4'b1000; // (1,0,X) -> 4'b1000
          default: fun = 4'b0100; // (1,X,X) -> 4'b0100
          endcase // switch on i1
        0: case(i2)
          1: case(i3)
            2: fun = 4'b0010; // (0,1,2) -> 4'b0010
            1: fun = 4'b0011; // (0,1,1) -> 4'b0011
            0: fun = 4'b0000; // (0,1,0) -> 4'b0000
          default: fun = 4'b1000; // (0,X,X) -> 4'b1000
          endcase // switch on i3
          0: case(i3)
            1: fun = 4'b0001; // (0,0,1) -> 4'b0001
            0: fun = 4'b0000; // (0,0,0) -> 4'b0000
          default: fun = 4'b1000; // (0,X,X) -> 4'b1000
          endcase // switch on i3
        default: fun = 4'b0100; // (X,X,X

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    
    ### Testing
    
    * Testing on the P130 board
    
      * `export MTDEV_PLATFORM_DESCR=p130`
      * `export MTDEV_PLATFORM_ROOT=<path-to-p130-platform>`
      * `export MTDEV_PLATFORM_RUNDIR=<path-to-p130-run-directory>`
      * `simulate tst_nm_in`
    
     ![img](pics/p130_nm_in.PNG)
    
      
    
    * Testing on the P201 board
    
      * `export MTDEV_PLATFORM_DESCR=p201`
      * `export MTDEV_PLATFORM_ROOT=<path-to-p201-platform>`
      * `export MTDEV_PLATFORM_RUNDIR=<path-to-p201-run-directory>`
      * `simulate tst_nm_in`
    
     ![img](pics

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      int i,j,k;
      case(j)
        1: i=1;
        2: i=2;
        3: i=3;
        default: i=0;
      endcase
      NMOS nms[4][4][4][4]; // 4D array of NMOS transistors
      initial begin
        in =1'b1; // Start with input high -> output low
        for (i=0; i<4; i=i+1) begin
          for (j=0; j<4; j=j+1) begin
            for (k=0; k<4; k=k+1) begin
              nms[i][j][k] = new( "nm_"+i+j+k); // Create new
              nms[i][j][k].connect("i",in);
              nms[i][j][k].connect("out",out);
            end
          end
        end
      end
      initial
        $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    ### Simulation Result:
    ![Screenshot](https://raw.githubusercontent.com/Brian-Gill/Digital-Circuits-Verilog-Code/master/Screenshot%20from%202019-04-19%2003-27-04.png)
    
    
    ## Variation 6:
    ### Base Verilog Code:
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in

- code: |-
    * Add a top level file:
    
    module tst_nm_in_top();
      tst_nm_in tst_nm_in_q1 = new(0);
      tst_nm_in tst_nm_in_q2 = new(1);
      tst_nm_in tst_nm_in_q3 = new(2);
      initial $monitor($time, "tst_nm_in_q1.in = %b, tst_nm_in_q1.out = %b, tst_nm_in_q2.in = %b, tst_nm_in_q2.out = %b, tst_nm_in_q3.in = %b, tst_nm_in_q3.out = %b",tst_nm_in_q1.in,tst_nm_in_q1.out,tst_nm_in_q2.in,tst_nm_

- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      initial #10 in = 1'b0;
      always
      begin
        case(func1(in))
          0:in = 1'b1;
          1:in = 1'b1;
          2:in = 1'b1;
          3:in = 1'b0;
        endcase
      end
      function [1:0] func1;
        begin
          return in;
        end
      endfunction
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    ### Unit Test:
    To verify the modified code, use the following testbench.
    
    module test(in, out);
      input in; output out;
      reg in; wire out;
      tst_nm_in nm1(out,in); // Instantiate NMOS inverter
    endmodule
    
    module tb();
      reg in; wire out;
      tst_nm_in nm2(out,in); // Instantiate NMOS inverter
      initial
      begin
        in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b0;
        #10 in = 1'b1;
        #10 in = 1'b1;
        #10 in = 1'b1;

- code: |-
    module tst_case();
    
      reg in; wire out;
      NMOSinv nmv[1:4][5:3][2:1][3:2];
      NMOSinv nm0[3:5][9:7][4:2][2:1];
      NMOSinv nm1[5:7][3:1][10:12][1:3];
      NMOSinv nm2[14:15][8:7][1:3][1:2];
      NMOSinv nm3[3:5][7:1][6:4][1:2];
      NMOSinv nm4[2:4][12:11][1:3][1:2];
      
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
      
      function case_func;
        input [1:0] i;
        case(i)
          2'b00: return nmv[1][1][1][1];
          2'b01: return nmv[1][1][1][2];
          2'b10: return nmv[1][1][1][3];
          2'b11: return nmv[1][1][2][1];
        endcase
    endfunction : case_func

- code: |-
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Modified
    end
    initial
    if (a)
    begin
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    end
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    ### Expected Output:
    t=0 display: a = 0, b = 0
    t=2 display: a = 1, b = 1
    t=5 display: a = 1, b = 1
    t=6 display: a = 0, b = 0
    ### Simulation Log:
    t

- code: |-
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Added time
    end
    always @(posedge a[1:0] ) // Added condition
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    ### Actual Output:
    t=0 display: a = 0, b = 0
    t=2 display: a = 1, b = 0
    t=5 display: a = 11, b = 0
    t=6 display: a = 11, b = 0
    ### Expected Output:
    t=0 display: a = 0, b = 0
    t=2 display: a = 1, b

- code: |-
    module nil;
    reg [3:0] a[7:0];
    always @ (*)
    begin
    a[5] = 4'b0111;
    if (a[5][2])
    begin
    $display("line %0d: 2nd bit set", `__LINE__);
    $display("line %0d: 2nd bit set", `__LINE__);
    end
    end
    initial
    begin
    // Wait a few clk cycles for simulation
    #1;
    a[7] = 4'b0111;
    a[6] = 4'b1010;
    a[5] = 4'b1111;
    a[4] = 4'b1111;
    a[3] = 4'b0100;
    a[2] = 4'b0100;
    a[1] = 4'b0100;
    a[0] = 4'b0100;
    end
    endmodule
    ### Expected Output:
    ### Actual Output:
    ### Other Comments:
    The monitor statements on line 16 and 17 are removed.
    ### Verification Steps:
    1. Compile the modified code.
    2. Run simulation.
    ### Expected Results:
    1. Compile passes.
    2. Monitor statement on line 16 is removed.
    3. No monitor output (desired).
    ### Simulation Output:
    ### Unit Test
    2020-02-15
    ## Unit Test Summary
    ### Name: 2020-02-16-verilog-monitor-part-select-in-if-statement
    ### Description:
    This variation introduces a problem. The monitor statement on line 9 is triggered at t=2 which is undesired. The monitor on line 10 is triggered at t=6 which is desired. The problem is that the monitor statement on line 10 is triggered on the clock edge after the value of a[5] has been changed by the statement on line 9.
    ### Base Verilog Code:
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Added time
    end
    initial
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    ### Variation Instruction:
    Use inside in a conditional expression within an always block that references a

- code: |-
    module nil;
    reg a [3:0], b [3:0];
    initial
    begin
    a = 4'b0;
    b = 4'b0;
    end
    always @(posedge clk) // Here clk is a signal for which we are monitoring
    begin
    if(b[2]

- code: |-
    module nil;
    wire [3:0] a, b;
    assign b = a[<1]; // Changed b = 4'b1010 to b = a[<1]
    initial
    begin
    a = 4'b0101;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b);
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    end
    endmodule
    ### Verification Steps:
    1. Launch the Verification Concolic Execution Engine (VCEE) and run the above code
    2. Choose a value for the variable <i>a[<1]</i> using the drop-down list at the top of the screen
    3. VCEE presents the modified code in the bottom pane.
    ### Expected Result:
    VCEE presents the modified code modified code such that the monitor statement triggers at each time step in which the specified expression <i>a[<1]</i> changes value.
    ### Actual Result:
    VCEE displays the following error message:
    ```
    Parse error at netlist line 5:
    assign b = a[<>1]; // Changed b = 4'b1010 to b = a[<1>]
           ^^ 2 errors parsing verilog expression
    ```
    ### Pass/Fail Criteria:
    Passes if VCEE produces the expected result. Fails if not.
    
    ### Comments:
    The VCEE should support any use of array subscripts in the left-hand side of an assignment statement.
    
    ### Note:
    This test case was originally coded in the form presented here, but the test failed due to a bug in the code.
    
    ## Test Case #29
    ### Base Verilog Code:
    module nil;
    wire [3:0] a, b

- code: |-
    module nil;
    reg a, b, c;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    c = 1'b1;
    $display ("t=%0t display: a = %b, b = %b, c = %b", $time, a, b, c);
    end
    initial
    $monitor("t=%0t monitor: a = %b, b = %b, c = %b", $time, a, b, c);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    ### Final Code:
    module nil;
    reg a, b, c;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    c = 1'b1;
    $display ("t=%0t display: a = %b, b = %b, c = %b", $time, a, b, c);
    end
    always @ (*)
    begin: a
    if (c == 1'b1)
        a = 1'b0;
    else
        a = 1'b1;
    end
    initial
    $monitor("t=%0t monitor: a = %b, b = %b, c = %b", $time, a, b, c);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    ### Output:
    t=0 display: a = 0, b = 0, c = 1
    t=2 display: a = 1, b = 0, c = 1
    t=5 display: a = 0, b = 0, c = 1
    t=6 monitor: a = 1, b = 0, c = 1
    t=10 display: a = 1, b = 0, c = 1
    t=12 monitor: a = 0, b = 0, c = 1
    t=15 display: a = 1, b = 0, c = 1
    t=16 monitor: a = 0, b = 0, c = 1
    t=20 display: a = 1, b = 0, c = 1
    t=22 monitor: a = 0, b = 0, c = 1
    t=25 display: a = 1, b = 0, c = 1
    t=26 monitor: a = 0, b = 0, c = 1
    t=30 display: a = 1, b = 0, c = 1
    t=32 monitor: a = 0, b = 0, c = 1
    t=35 display: a = 1, b = 0, c = 1
    t=36 monitor: a = 0, b = 0, c = 1
    t=40 display: a = 1, b = 0, c = 1
    t=42 monitor: a = 0, b = 0, c = 1
    t=45 display: a = 1, b = 0, c = 1
    t=46 monitor: a = 0, b = 0, c = 1
    t=50 display: a = 1, b = 0, c = 1
    t=52 monitor: a = 0, b = 0, c = 1
    t=55 display: a = 1, b = 0, c = 1
    t=56 monitor: a = 0, b = 0, c = 1
    t=60 display: a = 1, b = 0, c = 1
    t=62 monitor: a = 0, b = 0, c = 1
    t=65 display: a = 1, b = 0, c = 1
    t=66 monitor: a = 0, b = 0, c = 1
    t=70 display: a = 1, b = 0, c = 1
    t=72 monitor: a = 0, b = 0, c = 1
    t=75 display: a = 1, b = 0, c = 1
    t=76 monitor: a = 0, b = 0, c = 1
    t=80 display: a = 1, b = 0, c = 1

- code: |-
    module nil22;
    reg [0:15] ary [0:3];
    bit a;
    always @ (posedge $root.clk) begin
    if (...)
    $display("t=%0t display: %b", $time, ary[2][1]);
    end
    endmodule
    ### Explanation:
    The $display task does not reference a part-select of an array.
    ### Reasoning:
    The $monitor task triggers at every time step, whereas $display does not. Thus, $display does not reference a part-select on an array.
    ### References:
    - [IEEE 1800-2012](http://standards.ieee.org/getieee/1800/download/1800-2012.pdf), SystemVerilog 
    - [Mixed Logic](http://www.sunburst-design.com/papers/CummingsVLSISEA2007_MixedLogic.pdf)
    - [Anatomy of a Verilog Source Code](http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AnatomyV_4.pdf)
    ### Notes:
    ### To Do:
    - [ ] Add more examples
    - [x] Add explanation
    - [x] Add references
    - [x] Add reason

- code: |-
    module nil;

- code: |-
    module nil(input [3:0] a);
    reg [3:0] b;
    reg [3:0] c;
    initial
    begin
    a = 4'b0;
    b = 4'b0;
    c = 4'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b);
    end
    always @* begin
    if

- code: |-
    module nil;
    reg [7:0] a, b;
    always @(*)
    begin
    if (a[0] || b[0])
    c = 1'b1; // c = 1'b1
    else
    c = 1'b0; // c = 1'b0
    end
    initial
    begin
    a = 8'b01110101;
    b = 8'b01010110;
    end
    initial
    $monitor("t=%0t monitor: c = %b", $time, c); // Added time
    endmodule
    #### Testbench:
    module tb_nil;
    
    reg
    t;
    initial
    begin
    t = 0;
    end
    
    always @(t)
    begin
    #10 t = ~t;
    re
    end
    
    initial
    begin
    #10 $finish;
    end
    
    endmodule
    #### Output:
    t=0 monitor: c = 0
    t=10 monitor: c = 1
    t=20 monitor: c = 0
    t=30 monitor: c = 0
    t=40 monitor: c = 0
    t=50 monitor: c = 0
    t=60 monitor: c = 0
    t=70 monitor: c = 0
    t=80 monitor: c = 0
    t=90 monitor: c = 0
    t=100 monitor: c = 0
    t=110 monitor: c = 0
    t=120 monitor: c = 0
    t=130 monitor:

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
    endmodule
    
    
    
    
    ### Base Verilog Code:
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    if (Read==1

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else if (Adr>=2 && Adr<=7)
        ObusReg <= Storage[Adr];
    endmodule
    ### Synthesis Log Output Content:
    #### Synthesizes the code as a FlipFlop
    #### Synthesizes the code as a RAM
    ### Code Review:
    #### No data hazard and pipeline issues are addressed in this code.
    #### Code is not synthesizable.
    ### Testbench
    ### Input
    ![Testbench Input](https://github.com/Biplav135/Computer-Architecture-Lab-2/blob/main/RAM/Testbench%20Input.PNG)
    ### Output
    ![Testbench Output](https://github.com/Biplav135/Computer-Architecture-Lab-2/blob/main/RAM/Testbench%20Output.PNG)
    ### Experimental Output
    ![Testbench Output](https://github.com/Biplav135/Computer-Architecture-Lab-2/blob/main/RAM/Experimental%20Output.PNG)
    ### Conclusion
    #### Code is not synthesizable.
    ### Reference
    #### 1. https://www.doulos.com/knowhow/verilog

- code: |-
    module RAM4 (output[7:0] Obus, input[7:0] Ibus, input[3:0] Ad

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else begin
        ObusReg <= Storage[Adr];
        while(1'b1) begin
            $display("Hello World!");
            $finish(0);
            `ifdef FORMAL_VERIF
            assume(0);
            `endif
        end
    end
    endmodule
    ### Expected Output:
    ```
    ### Formal Verification (Formal Verifier)
    
    Formal Verifier (FV) accepts an SVA (SystemVerilog Assertion) file. The file must contain an SVA (SystemVerilog Assertion) defined with the following syntax:
    
    ```SystemVerilog {.line-numbers}
    assert [always|eventually|implicitly_on] {sva_name} ( {sva_condition} ) 
      severity {sva_severity};
    ```
    
    The **sva_condition** field accepts any valid SVA (SystemVerilog Assertion). The **sva_severity** may be any of the following:
    
    | Severity | Description 
    | :------: | -----------------
    | fatal    | The assertion must always be True in the design.
    | error    | The assertion must be True most of the time in the design.
    | warning  | The assertion may be False some of the time in the design. This may be OK, depending on the design intent.
    | info     | The assertion may be False occasionally in the design. This may be OK, depending on the design intent.
    | ignore   | Ignore (do not care) the assertion.
    
    ### Formal Verification Configuration for Verilator
    
    The following options are supported for formal verification with Verilator:
    
    + **--assert**: Specify a file containing SVA (SystemVerilog Assertion) to execute. If multiple files are provided, each one is executed.
    + **--trace**: Generate a VCD (Value Change Dump) trace file that can be used for formal verification.
    + **--trace-structtrace**: Generate a structural VCD trace file that can be used for formal verification.
    + **--sv**: Generate Verilog which contains SVA (SystemVerilog Assertion). This is required for formal verification.
    + **--exe**: Generate C/C++ executable. This is required for formal verification.
    
    
    ### Formal Verification Configuration for NCVerilog
    
    The following options are supported for formal verification with NCVerilog:
    
    + **--formal**: Generate Formal Assertion code. This is required for formal verification.
    + **--trace**: Generate a VCD (Value Change Dump) trace file that can be used for formal verification.
    + **--trace-structtrace**: Generate a structural VCD trace file that can be used for formal verification.
    + **--assert**: Specify a file containing SVA (SystemVerilog Assertion) to execute. If multiple files are provided, each one is executed.
    + **--exe**: Generate C/C++ executable. This is required for formal verification.
    
    ### Formal Verification Configuration for Yosys/Icarus
    
    The following options are supported for formal verification with Yosys/Icarus:
    
    + **-p**: Generate Verilog which contains SVA (SystemVerilog Assertion). This is required for formal verification.
    + **-o**: Generate C/C++ executable. This is required for formal verification.
    + **-f**: Specify a file containing SVA (SystemVerilog Assertion) to execute. If multiple files are provided, each one is executed.
    + **--vcd**: Generate a VCD (Value Change Dump) trace file that can be used for formal verification.
    + **--struct-vcd**: Generate a structural VCD trace file that can be used for formal verification.
    
    ### Formal Verification Configuration for CBMC
    
    The following options are supported for formal verification with CBMC:
    
    + **-V**: Specify a file containing SVA (SystemVer

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else begin
        ObusReg <= Storage[Adr];
        while (Storage[Adr]==0)
            Storage[

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
    endmodule
    
    module main (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    wire [7:0] a,b,c,d,e,f,g,h,i;
    RAM ram1(a,b,4'd0,Clk,1'b0);
    RAM ram2(c,d,4'd1,Clk,1'b0);
    RAM ram3(e,f,4'd2,Clk,1'b0);
    RAM ram4(g,h,4'd3,Clk,1'b0);
    RAM ram5(i,Ibus,Adr,Clk,1'b1);
    assign Obus=a;
    endmodule
    ```
    
    In the simulation result, there is no error.
    
    ### Result
    
    ![image](https://github.com/Xilinx/SysGen/raw/2017.2/HLS/docs/Vivado/Vivado_HLS_Tutorial/Systolic_Array/results/vivado-hls.png)
    
    **This example is from:**
    
    [https://github.com/Xilinx/SysGen/tree/2017.2/HLS/docs/Vivado/Vivado_HLS_Tutorial/Systolic_Array](https://github.com/Xilinx/SysGen/tree/2017.2/HLS/docs/Vivado/Vivado_HLS_Tutorial/Systolic_Array)
    
    # Verilog to RTL tutorial:
    
    ### 1. Get the IP
    
    There are two ways to get the IP, you can use vivado or vivado_hls.
    
    ### 2. Run the application
    
    To run the application, just double click the IP or use the following command:
    
    ```tcl
    % source./runme.tcl
    ```
    
    ### 3. Compile the RTL
    
    ```tcl
    % cd..
    % cd fft/prj/FFT_prj/solution
    % cd impl_1
    % vlog -work work../../src/main.v
    % vlog -work work../../src/ram.v
    % vlog -work work../../src/fft_top.v
    % vlog -work work../../src/fft_top_tb.v
    % vsim fft_top_tb -c -do "run -all; exit" -lxt2
    % cd../../..
    ```
    
    ### 4. Simulate the RTL
    
    ```tcl
    % cd sim/rtl/fft
    % simv -c -do "run -all; exit" -lxt2
    ```
    
    ### 5. Generate the bitstream
    
    ```tcl
    % cd../../../../prj/FFT_prj/solution
    % cd impl_1
    % export_design -rtl verilog -format ip_catalog -flow impl
    % exit
    ```
    
    ### 6. Create the xo
    
    ```tcl
    % cd../../..
    % cd prj
    % vivado
    ```
    
    You will enter vivado editor, then create a new project.
    
    ![image](https://github.com/Xilinx/SysGen/raw/2017.2/HLS/docs/Vivado/Vivado_HLS_Tutorial/sim-rtl/img/vivado.png)
    
    ### 7. Load the IP
    
    ![image](https://github.com/Xilinx/SysGen/raw/2017.2/HLS/docs/Vivado/Vivado_HLS_Tutorial/sim-rtl/img/vivado-1.png)
    
    ### 8. Create the xo
    
    ![

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    initial
        Storage <= '{8'b00000000, 8'b00000000};
    assign #1 Obus = ObusReg;
    endmodule
    ### Verilog Code to be Tested:
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    initial
        Storage <= '{8'b00000000, 8'b00000000};
    assign #1 Obus = ObusReg;
    endmodule
    ### Verilog Test Bench Code:
    module RAM_TB ();
    reg Adr;
    reg Ibus;
    reg Obus;
    reg Clk;
    reg Read;
    wire Clk;
    wire Read;
    wire Ibus;
    wire Obus;
    reg[7:0] Storage[15:0];
    RAM u1 (Obus, Ibus, Adr, Clk, Read);
    initial
    begin
        Adr = 0;
        Ibus = 0;
        Read = 1;
        Clk = 1;
        $monitor("%d %d", Obus, Adr);
    end
    always
    begin
        #10 Clk =!Clk;
        $monitor("%d %d", Obus, Adr);
        if (Adr == 3)
            $finish;
    end
    endmodule
    ### Execution Results:
    > Executed on DS-5 with Synopsys Design Compiler 2015 SP1, 2015-12-08
    
    > Compilation date: Aug 16, 2016
    
    > Execution results:
    >
    >     - Obus: 0 0
    >     - Obus: 0 1
    >     - Obus: 0 2
    >     - Obus: 0 3
    >     - Obus: 0 4
    >     - Obus: 0 5
    >     - Obus: 0 6
    >     - Obus: 0 7
    >     - Obus: 0 8
    >     - Obus: 0 9
    >     - Obus: 0 10
    >     - Obus: 0 11
    >     - Obus: 0 12
    >     - Obus: 0 13
    >     - Obus: 0 14
    >     - Obus: 0 15
    >     - Obus: 0 16
    >     - Obus: 0 17
    >     - Obus: 1 1
    >     - Obus: 1 2
    >     - Obus: 1

- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Ob

- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1[2](do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do,do2);
      function[1:0] get_d1_result;
        get_d1_result = d1[1].do;
      endfunction
      
      initial begin
        do2 = get_d1_result();
      end
    endmodule
    ### Results:

- code: |-
    module tst_dff_p_b();
        reg clk, di;
        wire do;
        wire [2:0] data;  
        dff_p d1(do, di,clk); // Instantiate the DFF
        initial begin
          clk = 0;
          di = 1'b0;
          # 20 $stop;
        end // Initialize & stop
        initial # 1
          assert (di == do) $display ("%m: Test Passed");
        initial # 1
          assert (di == 1'b0) $display ("%m: Test Passed");
        always # 3.5
          clk = ~clk;
        always # 5
          di = ~di;
        initial $display ("%m: Top-level testbench module"); // Display testbench name
        initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
        initial $monitor($time," data=%b", data);
        initial

- code: |-
    module tst_dff_p_b();
      reg clk; wire do;
      dff_p d1(do,1'b0,clk); // Instantiate the DFF
      initial begin clk=0; #500 $stop; end // Initialize & stop
      assign do =

- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin 
        clk=0; di=1'b0; #35 $stop; 
        $display("%m: Top-level testbench module"); // Display testbench name
        $monitor("$time,clk=%b

- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      always @(posedge clk)begin
        initial begin $display ("%m: Top-level testbench module"); // Display testbench name
        initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
        end
      end
      initial begin
        fsm_st_t curr_st = FSM_ST_INIT;
        for (int i=0; i<100; i=i+1) begin
          case (curr_st)
            FSM_ST_INIT: begin
              do[i] = 1'b?;
              di = 1'b?;
              if (i == 0)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
            FSM_ST_1: begin
              do[i] = 1'b1;
              di = 1'b1;
              if (i == 50)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
            FSM_ST_0: begin
              do[i] = 1'b0;
              di = 1'b0;
              if (i == 100)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
          endcase
        end
      end
    endmodule
    ### Fixed Code:
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
    
      initial begin
        fsm_st_t curr_st = FSM_ST_INIT;
        for (int i=0; i<100; i=i+1) begin
          case (curr_st)
            FSM_ST_INIT: begin
              di = 1'b?;
              if (i == 0)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
            FSM_ST_1: begin
              di = 1'b1;
              if (i == 50)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
            FSM_ST_0: begin
              di = 1'b0;
              if (i == 100)begin
                clk = 1'b0;
              end else begin
                clk = 1'b1;
              end
            end
          endcase
        end
      end
    endmodule
    ### Base Verilog Code:
    interface tst_intf_p_a();
      logic di;
      modport tpd_p(
        output di
      );
    endinterface
    module tst_dff_p_c();
      import tst_intf_p_a_pkg::*; // Import the interface
      tst_intf_p_a #(1) if_p_dff(di); // Instantiate the interface
      initial begin di=1'b0; #35 $stop; end // Initialize & stop
      always #3 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," di=%b",di);
    endmodule
    ### Variation Instruction:
    Add

- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      assign do=dff_p_f(di,clk);
      function [1:0] dff_p_f;
        input di,clk;
        reg [

- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); //

- code: |-
    module dff_p_b /* synthesis syn_black_box */ (
      input logic clk,
      input logic di,
      output logic do
    );
      initial begin
        do = 1'b0;
      end
      always @(posedge clk) begin
        do <= di;
      end
      assign do = (di == 1'b0 && clk == 1'b0)? 1'b0 : (di == 1'bx && clk == 1'bx)? 1'bx : (di == 1'bx && clk == 1'b0)? 1'bx : (di == 1'b0 && clk == 1'bx)? 1'bx : 1'bx;
    endmodule
    ### Modified Verilog Code:
    module dff_p_b_0 /* synthesis syn_black_box */ (
      input logic clk,
      input logic di,
      output logic do
    );
      initial begin
        do = 1'b0;
      end
      always @(posedge clk) begin
        do <= di;
      end
      assign do = (di == 1'b0 && clk == 1'b0)? 1'b0 : (di == 1'bx && clk == 1'bx)? 1'bx : (di == 1'bx && clk == 1'b0)? 1'bx : (di == 1

- code: |-
    module tst_dff_p_d();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always @(posedge clk) di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Simulation:
    ![](dff_p_d.png)
    ### Simulation-Errors:
    No errors;
    ### Verilog Code:
    module tst_dff_p_e();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always @(posedge clk) do=~do; // Toggle data

- code: |-
    module tst_dff_p_d();
      reg di,clk; wire do;
      dff_p d1(do,

- code: |-
    module example7_10(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;

- code: |-
    module example7_5_0(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    reg [1:0] t;
    wire [1:0] c = {x1, x2}; // Construct [1:0] array
    reg [1:0] d = c[t]; // Use t to select element in [1:0] array
    always @(posedge Clock)
    begin
        f = d[0]; // Use d[0] to select element in [1:0] array
        g = d[1]; // Use d[0] to select element in [1:0] array
    end
    endmodule
    ### Testbench Code :
    module example7_5_0_test;
    wire x1, x2, x3, f, g;
    reg Clock;
    initial Clock = 0;
    always #1 Clock =!Clock;
    example7_5_0 example1(x1, x2, x3, Clock, f, g);
    initial begin
        x1 = 1'b0;
        x2 = 1'b0;
        x3 = 1'b0;
        #10;
        x1 = 1'b1;
        x2 = 1'b1;
        x3 = 1'b1;
        #10;
        x1 = 1'b1;
        x2 = 1'b0;
        x3 = 1'b0;
        #10;
        x1 = 1'b0;
        x2 = 1'b1;
        x3 = 1'b1;
        #10;
        $stop;
    end
    endmodule
    ### Output:
    ![output](https://raw.githubusercontent.com/dineshannayya/dineshannayya.github.io/master/assets/img/output_0705.PNG)
    ### Explanation:
    1. In the first case statement, since t is at default value, the case statement is expanded to 
    ```
    always @(posedge Clock)
    begin
        f = x1 & x2;
        g = f | x3;
    end
    ```
    
    2. In the second case statement, the case statement is expanded to 
    ```
    always @(posedge Clock)
    begin
        f = 1;
        g = x3 | x1;
    end
    ```
    ### Clean up Verilog Code:
    ```
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    reg [1:0] t;
    reg [1:0] c = {x1, x2}; // Construct [1:0] array
    always @(posedge Clock)
    begin
        t = {x3, x1}; // Invert t and select element based on t
        case(t)
            2'b00 : f = x1 & x2;
            2'b10 : f = 1;
            2'b01 : f = x3;
            2'b11 : f = 1;
            default : f = x1 & x2;
        endcase
        case(t)
            2'b00 : g = f | x3;
            2'b10 : g = x3 | x1

- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    reg [2:0] a1, a2, a3, a4;
    int b1, b2, b3, b4;
    always @(posedge C

- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    
    assign Clock_Delay = 2'd1;
    reg[1:0] Clock_Delay;
    reg[2:0] d;
    wire[1:0] i;
    
    always @(posedge Clock)
    begin
        d[0] <= x1 & x2;
        d[1] <= d[0] | x3;
        d[2] <= d[1] | d[0];
    end
        assign i[0] = d[2];
        assign i[1] = d[2];
        case (1'd1)
            1'd1: assign f = i[1];
            1'd1: assign g = i[0];
        endcase
    endmodule
    ### Simulation Setup:
    import iverilog_hdl_path
    from iverilog_hdl_path.models.verilog.base import Module
    from iverilog_hdl_path.models.verilog import VerilogInterface
    
    dut = Module(
        name='example7_5',
        interfaces=[
            VerilogInterface(interface_name='x1'),
            VerilogInterface(interface_name='x2'),
            VerilogInterface(interface_name='x3'),
            VerilogInterface(interface_name='Clock'),
            VerilogInterface(interface_name='f'),
            VerilogInterface(interface_name='g'),
        ])
    
    def test_example7_5():
        dut.x1.value = 0  # x1
        dut.x2.value = 0  # x2
        dut.x3.value = 0  # x3
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
    
        dut.x1.value = 1  # x1
        dut.x2.value = 0  # x2
        dut.x3.value = 0  # x3
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
    
        dut.x1.value = 0  # x1
        dut.x2.value = 1  # x2
        dut.x3.value = 0  # x3
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
    
        dut.x1.value = 1  # x1
        dut.x2.value = 1  # x2
        dut.x3.value = 0  # x3
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
        dut.Clock.value = 0  # Clock
        dut.Clock.value = 1  # Clock
    
        dut.x1.value = 0  # x1
        dut.x2.value = 0  # x2
        dut.x3.

- code: |-
    module example7_5mod3(x1, x2, x3

- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Requirement
    The Verilog simulator that you are using or will use must support the $bits system task.
    ### Suggested Solution
    Add $bits to the beginning of the array definition to display the contents. Verify that the bit position of the element is correct by changing the value of the dynamic variable index.
    ### Original Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Suggested Solution
    Add $bits to the beginning of the array definition to display the contents. Verify that the bit position of the element is correct by changing the value of the dynamic variable index.
    ### Suggested Solution
    Add $bits to the beginning of the array definition to display the contents. Verify that the bit position of the element is correct by changing the value of the dynamic variable index.
    ### Original Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Modified Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Original Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Modified Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        endcase
    end
    endmodule
    ### Original Code
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer x_array[10];
    always @(posedge Clock) begin
        case(x1)
        x2: f = x_array[x2];
        x3: g = x3 & x_array[x3];
        default:;
        end

- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
      integer i;
      case(x1)
        1'b0: i = 0;
        1'b1: i = 1;
      endcase

- code: |-
    module example7_7(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    reg a[7];
    wire [2:0] sel;
    always @(sel or x1 or x2 or x3 or Clock)
    begin
        a[sel] <= x1 & x2;
        f <= a[sel];
        a[sel] <= x1 & x2;
        if (f)
          g <= x3;
        else
          g <= 'b0;
    end
    endmodule
    ### Expected Output:
    ![image](https://user-images.githubusercontent.com/90485603/154521307-5c5712d2-a2df-4973-a828-11ba58e47873.png)
    
    ### Example 7.8:
    ### Base Verilog Code:
    module example7_8(x1, x2, x3

- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    
    //Generate
    generate for(i=0;i<4;i=i+1)
    begin
    if (i==0) begin
        assign f = x1 & x2;
    end
    if (i==1) begin
        assign f = f & x2;
    end
    if (i==2) begin
        assign f = f & x3;
    end
    end
    endgenerate
    assign g = f | x3;
    endmodule
    ### Screenshot (Before):
    ![image](../pics/variation_example7_5_before.png)
    ### Screenshot (After):
    ![image](../pics/variation_example7_5_after.png)
    ### Simulation Result (before):
    ![image](../pics/variation_example7_5_before_sim.png)
    ### Simulation Result (after):
    ![image](../pics

- code: |-
    module example7_8(x1, x2, Clock, f, g);
    input x1, x2, Clock;
    output g;
    reg f, g;
    wire g_wire;
    
    always @(posedge Clock)
    begin
        case (x1)
            1'b0: begin
                f = 1'b1;
                g = 1'b1;
            end
            1'b1: begin
                f = 1'b0;
                g = 1'b0;
            end
        endcase
    end
    
    assign g = g_wire;
    endmodule
    ### 6.8.7
    ### Base Verilog Code:
    module example7_9(x1, x2, Clock, f, g);
    input x1, x2, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
        case (x1)
            1'b0: f = 1'b1;
            1'b1: f = 1'b0;
        endcase
        case (x2)
            1'b0: f = 1'b1;
            1'b1: f = 1'b0;
        endcase

- code: |-
    module example9(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg[3:0] g;
    reg[3:0] q;
    assign f = q[3:0] == g[3:0];
    always @(x3)
        q <= g;
    endmodule
    ### Original Design:
    module example10(x1, x2, x3, f);
    input x1

- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    reg [3:0] x [ 3:0];
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else
        begin
            if (x3[1:0] >= 2'b01)
                f = 1'b1;
            else
                f = x3;
        end
    endmodule
    ### Test code:
    import gscl45_examples_pkg::*;
    class gscl45_examples_test extends gscl45_examples_test_base_class;
    function new(string name, uvm_component parent = null);
        super.new(name, parent);
    endfunction
    task run_test();
        `uvm_info("gscl45_examples_test", "start", UVM_LOW)
        begin
            gscl45_examples_sequencer sqr = gscl45_examples_sequencer::type_id::create("sqr", this);
            gscl45_examples_driver drv = gscl45_examples_driver::type_id::create("drv", this);
            gscl45_examples_monitor mon = gscl45_examples_monitor::type_id::create("mon", this);
            gscl45_examples_agent  agt = gscl45_examples_agent::type_id::create("agt", this);
            uvm_config_db#(virtual gscl45_examples_if)::set(this, "*", "vif", agt.vif);
            agt.sqr = sqr;
            agt.drv = drv;
            agt.mon = mon;
            sqr.agt = agt;
            mon.agt = agt;
            repeat(2) begin
                drv.reset();
                @(posedge agt.vif.clk);
                drv.start_item(agt.rqst);
                agt.rqst.f = 0;
                agt.rqst.x1 = 1;
                agt.rqst.x2 = 0;
                agt.rqst.x3 = 1;
                drv.finish_item(agt.rqst);
                @(posedge agt.vif.clk);
                drv.start_item(agt.rqst);
                agt.rqst.f = 0;
                agt.rqst.x1 = 1;
                agt.rqst.x2 = 1;
                agt.rqst.x3 = 0;
                drv.finish_item(agt.rqst);
                @(posedge agt.vif.clk);
                drv.start_item(agt.rqst);
                agt.rqst.f = 0;
                agt.rqst.x1 = 1;
                agt.rqst.x2 = 1;
                agt.rqst.x3 = 1;
                drv.finish_item(agt.rqst);
                @(posedge agt.vif.clk);
                drv.start_item(agt.rqst);
                agt.rqst.f = 0;
                agt.rqst.x1 = 0;
                agt.rqst.x2 = 0;
                agt.rqst.x3 = 0;
                drv.finish_item(agt.rqst);
                @(posedge agt.vif.clk);
                drv.start_item(agt.rqst);
                agt.rqst.f = 0;
                agt.rqst.x1 = 0;
                agt.rqst.x2 = 0;
                agt.rqst.x3 = 1;
                drv.finish_item(agt.rqst);
                @(posedge agt.vif.clk);
                drv.start_item(

- code: |-
    module example9(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or

- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else if (x2 == 2)
            f = x3;
        else
            f = x3;
    endmodule
    ### Expected Error:
    ### Issue: UHDM-4.1

- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else 
            if ((x3[1] >= 0) && (x3[1] <= 1))
                f = x3;
    endmodule
    ### Extracted Information:
    ### Extracted Instances:
    | File Name | Instance Name | Module Name  |
    |：--------:|:-------------:|:------------:|
    | example5.v | example5 | example5 |
    ### Extracted Interfaces:
    | Port Name | Interface Name |
    |：--------:|:--------------:|
    | x1 | example5_x1 |
    | x2 | example5_x2 |
    | x3 | example5_x3 |
    ### Extracted Objects:
    | Object Name | Object Type | Port Name |
    |：----------:|:-----------:|:--------:|
    | x1 | INPUT | x1 |
    | x2 | INPUT | x2 |
    | x3 | INPUT | x3 |
    | f | OUTPUT | f |
    ### Extracted Parameters:
    | Parameter Name | Parameter Type | Parent |
    |：-------------:|:--------------:|:------:|
    | x1 | INPUT | x1 |
    | x2 | INPUT | x2 |
    | x3 | INPUT | x3 |
    | f | OUTPUT | f |
    ### Extracted Ports:
    | Port Name | Port Type | Parent |
    |：-------:|:---------:|:------:|
    | x1 | INPUT | x1 |
    | x2 | INPUT | x2 |
    | x3 | INPUT | x3 |
    | f | OUTPUT | f |
    ### Extracted Syn

- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    reg [1:0] a;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            a = x1;
        else
            a = x3;
        if (a[0] == 0 && a[1] == 0)
            f = 1;
        else
            f = 0
    endmodule
    ### Testing Variation:
    This variation is an extension of example 4, in which an if block is added to test whether part-select of a packed array is inside a fixed constant range.
    In the following test, the part-select is always inside a fixed range:
    1. run verilog-lint --module example5
    2. if reported, run verilog-lint --module example5 --fix
    3. run verilog-lint --module example5
    ### Expected Output:
    1. verilog-lint reported:
    ```
        example5.v:6:12: (style) Replace 'if (x2 == 1)' with 'if (x2)'.
        example5.v:6:12: (style) Replace 'else' with 'else if (x2 == 0)'.
    ```
    2. verilog-lint fixed:
    ```
        module example5(x1, x2, x3, f);
        input x1, x2, x3;
        output f;
        reg f;
        reg [1:0] a;
        always @(x1 or x2 or x3)
            if (x2)
                a = x1;
            else if (x2 == 0)
                a = x3;
            if (a[0] == 0 && a[1] == 0)
                f = 1;
            else
                f = 0
        endmodule
    ```
    3. verilog-lint reported:
    ```
        example5.v:10:12: (style) Replace 'if (a[0] == 0 && a[1] == 0)' with 'assign f = a[0] == 0 && a[1] == 0'.
    ```
    ### Test Benches
    1. Include file that defines a function:
    ```
    `ifdef EXAMPLE5_TB
    `include "example5_tb.vh"
    `endif
    ```
    2. Test bench that includes the file:
    ```
    `ifdef EXAMPLE5_TB
    `include "example5_tb.v"
    `endif
    ```
    ### File `example5_tb.v`:
    ```
    `ifdef EXAMPLE5_TB
    `include "example5_mod.v"
    
    module example5_tb ();
    reg x1, x2, x3;
    wire f;
    
    example5 example5_i(x1, x2, x3, f);
    
    initial
        begin
            // Test case 1:
            x1 = 0;
            x2 = 1;
            x3 = 0;
            #1
            assert (f == 0)
                else $error("Test case 1 failed!");
            
            // Test case 2:
            x1 = 0;
            x2 = 0;
            x3 = 1;
            #1
            assert (f == 1)
                else $error("Test case 2 failed!");
            
            $finish;
        end
    endmodule
    `endif
    ```
    ### File `example5_tb.vh`:
    ```
    `ifdef EXAMPLE5_TB
    `timescale 1ns / 1ps
    `endif
    
    `ifdef EX

- code: |-
    module example5_1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    wire [7:0] arr_1 = 8'h00;
    wire [7:0] arr_2 = 8'hF0;
    wire [7:0] arr_3 = 8'h93;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else
            f = x3;
        if (arr_1[2:

- code: |-
    module example12(x, f);
    input [10:0] x;
    output f;
    wire f;
    reg f;
    always @(x[9] or x[8] or x[7] or x[6] or x[5] or x[4])
        for (i = 0; i < 5; i

- code: |-
    module example5(x, f);
    input [1:0] x;
    output f;
    reg f;
    always @*
        if (x == 2'b11)
            f = 1'b1;
        else if (x[1] == 1'b0)
            f = 1'b1;
        else
            f = 1'b0;
    endmodule
    
    ### Base Verilog Code:
    module example5(x, f);
    input [1:0] x;
    output f;
    reg f;
    always @*
        case (x)
            default: f = 1'b0;
            2'b11: f = 1'b1;
        endcase
    endmodule
    ### Variation Instruction:
    Add an if block testing whether

- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else if ((x3 & 16'b00000000_00000000_11100000_00000000) == 16'b00000000_00000000_10000000_00000000)
            f = 1;
        else
            f = x3;
    endmodule
    
    ### Verification Steps:
    
    1. Run the testbench:
    
           ./test5.py
    
    2. Observe the following output:
    
            ==============================================================
            Testbench results
            ==============================================================
            # Passed
            0 out of 1 tests failed!
            ==============================================================
    
    
    ### Additional Comments:  
    The modified code should generate as many "0"s as the number of bits in the 
    packed array, because the expression "(x3 & 16'b00000000_00000000_11100000_00000000) == 16'b00000000_00000000_10000000_00000000" is always false.
    
    ### Additional Comments:  
    The packed array x3 is being reduced into a part-select of the packed array:
    
            x3[15:8]
    
    The part-select is being compared to a value that is also a part-select:
    
            x3[15:8] == x3[15:13]
    
    The part-selects are of the same length, but the part-select of x3's range needs to be a constant value. When the compiler converts the constant value to a part-select, it will be:
    
            x3[15:8] == x3[13:11]
    
    The part-select of x3's range is not in the range of the constant part-select:
    
            x3[15:8]!= x3[13:11]
    
    The compiler is not supposed to evaluate the expression:
    
            x3[15:8] == x3[13:11]
    
    The compiler is not supposed to evaluate the expression:
    
            x3[15:8]!= x3[13:11]
    
    The expression is being reduced to "0".
    
    ### Additional Comments:  
    The modified code should generate as many "0"s as the number of bits in the
    packed array, because x3 is being reduced into a part-select of the packed array:
    
            x3[15:8]
    
    The part-select is being compared to a value that is also a part-select:
    
            x3[15:8] == x3[15:13]
    
    The part-selects are of the same length, but the part-select of x3's range needs to be a constant value.  
    When the compiler converts the constant value to a part-select, it will be:
    
            x3[15:8] == x3[13:11]
    
    The part-select of x3's range is not in the range of the constant part-select:
    
            x3[15:8]!= x3[13:11]
    
    The compiler is not supposed to evaluate the expression:
    
            x3[15:8] == x3[13:11]
    
    The compiler is not supposed to evaluate the expression:
    
            x3[15:8]!= x3[13:11]
    
    The expression is being reduced to "0".
    
    
    
    ### Variation Name:
    packed_array_part_select_range_not_constant
    ### Variation Description:
    The modified code is comparing two part-selects with different ranges, where one is constant, and the other is not.
    ### Base Verilog Code

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    package aoi_gate_0;
    wire a[4];
    wire b[3];
    wire[2:0] c;
    aoi_gate aoi(a,b,b,b,b);
    endpackage
    module top;
    import aoi_gate_0::*;
    reg clk;
    initial clk=0;
    always #10 clk=~clk;
    always @(posedge clk)
    begin
    $monitor("clk = %b a[0] = %b a[1] = %b a[2] = %b a[3] = %b b[0] = %b \
     b[1] = %b b[2] = %b c = %b aoi = %b",
    $time,a[0],a[1],a[2],a[3],b[0],b[1],b[2],c,o);
    end
    initial
    begin
    a[0] = 1'bx;
    a[1] = 1'b0;
    a[2] = 1'b1;
    a[3] = 1'bx;
    b[0] = 1'b0;
    b[1] = 1'bx;
    b[2] = 1'b1;
    c = 3'b111;
    end
    aoi_gate aoi(a

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    case (g_a_i[mux_sel][j][k])
       3'b010: g_m_2_i[j][k] = 1'b1;
       3'b111: if (g_m_1_i[j][k] == 1'b0)
                g_m_2_i[j][k] = 1'b1;
              else
                g_m_2_i[j][k] = 1'b0;
       3'b101: if (g_m_1_i[j][k] == 1'b0)
                g_m_2_i[j][k] = 1'b0;
              else
                g_m_2_i[j][k] = 1'b1;
       3'b001: if (g_m_1_i[j][k-1] == 1'b1)
                g_m_2_i[j][k] = 1'b0;
              else
                g_m_2_i[j][k] = 1'b1;
       3'b011: if (g_m_1_i[j][k] == 1'b1)
                g_m_2_i[j][k] = 1'b0;

- code: |-
    // The following code has a case statement on an array
    // accessed using XMR-based hierarchical indexing.
    case(b)
    
    4'b0000: a = 4'b0000;
    4'b0001: a = 4'b0011;
    4'b0010: a = 4'b0110;
    4'b0011: a = 4'b0111;
    4'b0100: a = 4'b1100;
    4'b0101: a = 4'b1111;
    4'b0110: a = 4'b1110;
    4'b0111: a = 4'b1101;
    4'b1000: a = 4'b1010;
    4'b1001: a = 4'b1111;
    4'b1010: a = 4'b1110;
    4'b1011: a = 4'b1101;
    4'b1100: a = 4'b1010;
    4'b1101: a = 4'b1000;
    4'b1110: a = 4'b1001;
    4'b1111: a = 4'b1011;
    endcase
    ### Original Verilog Code:
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(

- code: |-
    ```verilog
    module aoi_gate(o,a1,a2,b1,b2)
    input [1:0] ports;
    input a1,b1,a2,b2;
    output o;
    wire o1,o2;
    and g1(o1,a1,a2);
    and g2(o2,b1,b2);
    
    case(ports)
    2'b00: o1 = 1'b0;
    2'b01: o1 = 1'b1;
    2'b10: o1 = 1'b1;
    2'b11: o1 = 1'b0;
    endcase
    
    case(ports)
    2'b00: o2 = 1'b1;
    2'b01: o2 = 1'b0;
    2'b10: o2 = 1'b0;
    2'b11: o2 = 1'b1;
    endcase
    
    nor g3(o,o1,o2);
    endmodule
    ```

- code: |-
    module aoi_gate(o,a1,a2,b1,b2,a,b,i);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    case(i)
    0: o=1'b0;
    1: o=a[i];
    2: o=b[i];
    3: o=a[i]&b[i];
    4: o=a[i]|b[i];
    5: case(i)
    1:o=a[i]&b[i]&b[i+1];
    9:o=a[i]&b[i]&a[i+1];
    10:o=a[i]&a[i+2]&b[i];
    12:o=a[i]&a[i+2]&b[i+1];
    5: o=a[i]|b[i]|b[i+1];
    9: o=a[i]|b[i]|a[i+1];
    10: o=a[i]|a[i+2]|b[i];
    12: o=a[i]|a[i+2]|b[i+1];
    endcase
    endcase
    endmodule
    
    ### Observations
    The testbench and design are identical to those used in the previous lab. In this case, the input signals a, b, and i are changed to packed arrays and the output is assigned to the out variable.
    ### Test Results:
    ![image1](https://user-images.githubusercontent.com/84025301/123340868-07750780-d517-11eb-9351-b1c4226a965e.png)
    
    ### Observations
    The tests pass for all the cases.
    
    ### Reference
    For more information, refer to the following: \
    [Verilog Tutorial – Case Statement](https://www.allaboutcircuits.com/textbook/digital/chpt-1/verilog-case-statement/) \
    [Verilog Tutorial – Arrays](https://www.allaboutcircuits.com/textbook/digital/chpt-7/arrays-and-slices/)
    
    ## Part 3: Using XMR-based hierarchical index in case inside a case statement
    ### Base Verilog Code:
    module aoi_gate(o,a1,a2,b1,b2,a,b,i,j);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    case(i)
    0: o=1'b0;
    1: o=a[i];
    2: o=b[i];
    3: o=a[i]&b[i];
    4: o=a[i]|b[i];
    5: case(i)
    1:o=a[i]&b[i]&b[i+1];
    9:o=a[i]&b[i]&a[i+1];
    10:o=a[i]&a[i+2]&b[i];
    12:o=a[i]

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    
    assert property (
    @(posedge clk) (
                        (r_state[1]) && (r_state[2]) ||
                        (r_state[2]) && (r_state[3]) ||
                        (r_state[3]) && (r_state[1]) ||
                        (r_state[1]) ||
                        (r_state[2]) ||
                        (r_state[3])
                   )?
                        ( r_packed[4:6] ) :
                        ( r_packed[0:3] )
                    )
    );
    ### Description of the testbench file:
    #### Testbench:
    module aoi_gate_tb;
    reg a1, a2, b1, b2;
    wire o;
    aoi_gate dut(o, a1, a2, b1, b2);
    initial begin
      a1 = 1'b0;
      a2 = 1'b0;
      b1 = 1'b0;
      b2 = 1'b0;
      #10;
      a1 = 1'b1;
      b1 = 1'b1;
      #10;
      a1 = 1'b0;
      b1 = 1'b0;
      #10;
      a1 = 1'b1;
      a2 = 1'b1;
      b2 = 1'b1;
      #10;
      a2 = 1'b0;
      b2 = 1'b0;
      #10;
      a1 = 1'b0;
      a2 = 1'b0;
      b1 = 1'b1;
      b2 = 1'b1;
      #10;
      a1 = 1'b1;
      a2 = 1'b1;
      b1 = 1'b0;
      b2 = 1'b0;
      #10;
      a1 = 1'b0;
      a2 = 1'b0;
      b1 = 1'b1;
      b2 = 1'b1;
      #10;
      a1 = 1'b1;
      a2 = 1'b1;
      b1 = 1'b1;
      b2 = 1'b0;
      #10;
      a1 = 1'b1;
      a2 = 1'b1;
      b1 = 1'b1;
      b2 = 1'b1;
      #10;
      a1 = 1'b1;
      a2 = 1'b1;
      b1 = 1'b0;
      b2 = 1'b0;
      #10;
    end
    endmodule
    #### Output:
    
    ![simulation-2](/assets/images/simulation-2.png)
    
    #### Simulation Screenshot:
    ![simulation-2-1](/assets/images/simulation-2-1.png)
    
    ---
    ### Top 5 Features to learn this Quarter:
    #### 1. 
    #### 2. 
    #### 3. 
    ####

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output [3:0] o;//o is the single output port of the module
    wire [3:0] o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o[0],o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    
    ### Output File:

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    
    module test(a,b,c,d,e,f,g);
    input [7:0] a,b,c,d,e,f,g;
    wire [47:0] ab = { a,c,b,d,e,g,f };
    wire [47:0] ab2 = { a,c,b,d,e,g,f };
    wire [47:0] abc = { ab, g };
    wire [47:0] abc2 = { ab[0:0], g };
    wire [47:0] abcd = { abc, g[0:0] };
    wire [47:0] abcd2 = { abc[0:0], g[0:0] };
    wire [47:0] abcde = { abcd, g[0:0] };
    wire [47:0] abcde2 = { abcd[0:0], g[0:0] };
    wire [47:0] abcdef = { abcde, g[0:0] };
    wire [47:0] abcdef2 = { abcde[0:0], g[0:0] };
    wire [47:0] abcdefg = { abcdef, g[0:0] };
    wire [47:0] abcdefg2 = { abcdef[0:0], g[0:0] };
    wire [47:0] abcdefgh = { abcdefg, g[0:0] };
    
    wire [47:0] abcd_abc = abcd2[2:0];
    wire [47:0] abcde_abc = abcde2[3:0];
    wire [47:0] abcdef_abc = abcdef2[4:0];
    wire [47:0] abcdefg_abc = abcdefg2[5:0];
    wire [47:0] abcdefgh_abc = abcdefgh[6:0];
    
    wire [47:0] abcd_abcd = abcd2[6:2];
    wire [47:0] abcde_abcd = abcde2[7:3];
    wire [47:0] abcdef_abcd = abcdef2[8:4];
    wire [47:0] abcdefg_abcd = abcdefg2[9:5];
    wire [47:0] abcdefgh_abcd = abcdefgh[10:6];
    
    wire [47:0] abcd_abcde = abcde2[10:7];
    wire [47:0] abcde_abcde = abcde2[11:8];
    wire [47:0] abcdef_abcde = abcdef2[12:9];
    wire [47:0] abcdefg_abcde = abcdefg2[13:10];
    wire [47:0] abcdefgh_abcde = abcdefgh[14:11];
    
    wire [47:0] abcd_abcdef = abcdef2[15:12];
    wire [47:0] abcde_abcdef = abcdef2[16:13];
    wire [47:0] abcdef_abcdef = abcdef2[17:14];
    wire [47:0] abcdefg_abcdef = abcdefg2[18:15];
    wire [47:0] abcdefgh_abcdef = abcdefgh[19:16];
    
    wire [47:0] abcd_abcdefg = abcdefg2[19:17];
    wire [47:0] abc

- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    
    
    
    
    // Original verilog code from: http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.zip
    //
    // The aoi_gate module is the basic building block for a
    // AOI array.
    //
    
    
    module aoi_gate(o,a1,a2,b1,b2);
      input a1,a2,b1,b2;
      output o;
    
      wire o2, o1;
    
      and g1(o1,a1,a2);
      and g2(o2,b1,b2);
      nor g3(o,o1,o2);
    endmodule
    
    //
    // AOI_array is the module that constructs the full sized
    // AOI array from an AOI_gate
    //
    
    module aoi_array(o, a);
      parameter width = 8;
      input [width-1:0] a;
      output [width-1:0] o;
    
      wire [width-1:0] o2;
      aoi_gate g [0:width-1] (o2, a[0:width-1]);
    
      aoi_gate g1(o[0], a[1:width], o2[1:width]);
    endmodule
    
    //
    // aoi_array_test is the top level module for the test
    //
    
    module aoi_array_test;
      reg [3:0]  a;
      wire [3:0]  o;
    
      aoi_array i1 (o, a);
    
      initial begin
        $display("AOI_array_test");
        $display("Initial values o=%b", o);
    
        a = 4'b0001;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b0010;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b0100;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b1000;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b1111;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b0011;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b1010;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b1100;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b0111;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b1110;
        #10 $display("a=%b o=%b", a, o);
    
        a = 4'b0000;
        #10 $display("a=%b o=%b", a, o);
    
      end
    endmodule
    
    
    // Original verilog code from: http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.zip
    //
    // The oai_gate module is the basic building block for a
    // OAI

- code: |-
    module aobeh(o,a,b); // Structural AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Structural NOR gate using primitive and packed vector slice
    not g3(o,a1,b1); // o = ~(a1 || b1);
    // Combinational MUX sensitive to NOR output
    always@*
    o[0] = a[0]*b[0]*g3[0] + a[0]*b[1]*g3[1] +
          a[1]*b[0]*g3[0] + a[1]*b[1]*g3[1];
    o[1] = a[1]*b[1]*g3[1];
    endmodule
    ### Unmodified Verilog Code:
    module noteh (o,a,b); // Structural NOT & MUX
    output o;
    input[1:0]a,b;
    wire not_a, not_b;
    not g1(not_a,a), g2(not_b,b);
    // Mux sensitive to NOT outputs
    always@*
    o = a[0]*not_a + a[1]*not_b;
    endmodule
    ### Base Verilog Code:
    module noteh (o,a,b); // Structural NOT & MUX
    output o;
    input[1:0]a,b;
    wire not_a, not_b;
    not g1(not_a,a), g2(not_b,b

- code: |-
    module aoibee1(o,a,b); // AOI BE
    output o;
    input a,b;
    // Structural AND gate using primitive
    and g1(o,a,b);
    o = 1;
    endmodule
    
    ### Base Verilog Code:

- code: |-
    ```verilog
    // Add initial continuous assign to packed vector slice
    module aoibeh2a(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial begin
    o = ~(a1 || b1);
    end
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    //  ^
    //  |
    //  |
    //  |
    //  V
    module aoibeh2b(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial begin
    o = ~(a1 || b1);
    end
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    //  ^
    //  |
    //  |
    //  |
    //  V
    module aoibeh2c(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial o = ~(a1 || b1);
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    //  ^
    //  |
    //  |
    //  |
    //  V
    module aoibeh2d(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial o <= ~(a1 || b1);
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    //  ^
    //  |
    //  |
    //  |
    //  V
    module aoibeh2e(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial o <= ~(a1 || b1);
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    //  ^
    //  |
    //  |
    //  |
    //  V
    module aoibeh2f(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial o <= ~(a1 || b1);
    always

- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    initial
    o = (a & b);
    endmodule
    
    ### Variation:
    Add an initial block with procedural continuous assignment using inside and a packed vector slice.
    ### Base Verilog Code:
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    initial
    o = (a & b)[

- code: |-
    initial begin
    	o = {1'b0,a[0],b[0]};
    end
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    initial begin
    	o = {1'b0,a[0],b[0]};
    end
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule

- code: |-
    module aoibeh2i(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[3:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial begin
    o = 4'b1111;
    end
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    ### Passed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = true,
        blackbox = false,
        keep_hierarchy = false,
        flatten = false,
        ignorename = false,
        cell = "",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Failed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = false,
        flatten = false,
        ignorename = false,
        cell = "",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Passed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = true,
        flatten = false,
        ignorename = false,
        cell = "",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Failed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = false,
        flatten = true,
        ignorename = false,
        cell = "",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Passed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = false,
        flatten = false,
        ignorename = true,
        cell = "",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Failed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = false,
        flatten = false,
        ignorename = false,
        cell = "aoibeh2i",
        lib = "",
        reflib = "",
        paramlist = [],
        moduledir = "",
        topmodule = "",
    )
    ### Passed:
    #(
        output_name = "o",
        input_names = ["a", "b"],
        wirelist = ["a1", "b1"],
        modports = [],
        structural = false,
        blackbox = false,
        keep_hierarchy = false,
        flatten = false,
        ignorename = false,
        cell = "",
        lib = "aoibeh2i",
        reflib = "",
        paramlist

- code: |-
    module aoibehv

- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    initial begin
    o = (a1 && b1); 
    end
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o

- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial o <= ~(a1 || b1); // Continuous Assignment
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    ### Summary
    The initial block can be used to declare continuous assignments to combinational outputs. These can be procedural continuous assignments
    using any of the procedural continuous assignment operators. The assignment in an always block does not overwrite the 
    continuous assignment in the initial block. The assignment in the always block is the final value for a simulation step. 
    The continuous assignment in the initial block is the initial value prior to simulation starts.
    ### Tip:
    The continuous assignment in the initial block does not need to be a procedural assignment. A continuous assignment can be 
    used if the right hand side is a constant. 
    ### Tip:
    Use the initial block instead of a procedural continuous assignment to set a default value for an output. Procedural continuous
    assignments are not needed. Use procedural continuous assignments only when a different value is needed during the simulation.
    ### Tip:
    Use procedural continuous assignments to set a default value for an output. Use a simple initial block only when a different default value is 
    needed.
    ### Tip:
    The procedural continuous assignment statement is equivalent to a procedural assignment

- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    initial begin
    for(int i = 0; i < 2; i++) begin
    o[i] = 0;
    end
    o = 0;
    end
    endmodule
    ### Variation Instruction:
    Add an initial block

- code: |-
    module muxdff_tb();
    wire D0, D1, Q;
    reg Clock;
    reg Sel;
    initial begin
        Clock = 0;
        #150 $finish;
    end
    always #5 Clock = ~Clock;
    initial begin
        D0 = 1'b1;
        D1 = 1'b0;
        Sel = 0;
        #100 $finish;
    end
    module muxdff_tb();
    wire D0, D1, Q;
    reg Clock;
    reg Sel;
    initial begin
        integer i;
        D0 = 1'b0;
        D1 = 1'b0;
        Sel = 1'b0;
        Clock = 0;
        while (i < 4)
        begin
            Sel = i;
            i = i + 1;
        end
        Clock = 1'b1;
    end
    always #5 Clock = ~Clock;
    muxdff MUX(D0, D1, Sel, Clock, Q);
    endmodule
    ### Verification:
    ![](./imgs/muxd

- code: |-
    ```verilog
    module muxdff_packed(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q[D0] <= 1;
        else
            Q[D1] <= 1;
    endmodule
    ```
    ### Modification Method:
    * Extract out the bit-wise operator from the always block and apply the operator to each packed array sub-element.
    ### Example:
    ```verilog
    module muxdff_packed_example(
        input wire D0, D1, Sel, Clock,
        output reg Q
    );
        wire [3:0] XORArray;
        muxdff_packed x (D0, D1, Sel, Clock, XORArray);
    
        assign Q = XORArray[3] | XORArray[2] | XORArray[1] | XORArray[0];
    endmodule
    ```
    ### Expected Result:
    | Test Case | Pass / Fail |
    | --- | --- |
    | Test #1 | Pass |
    | Test #2 | Pass |
    | Test #3 | Pass |
    | Test #4 | Pass |
    | Test #5 | Pass |
    | Test #6 | Pass |
    | Test #7 | Pass |
    | Test #8 | Pass |
    ### Additional Information:
    ### Relevant Files:

- code: |-
    module test();
    reg [2:0] arr [3:0];
    reg [2:0] c, d, e, f, g;
    always @*
        begin
            c = arr[0];
            d = arr[1];
            e = arr[2];
            f = arr[3];
            g = arr[4];
        end
    muxdff m0 (c[0], d[0], 1'b1, g[0], Q0);
    muxdff m1 (c[1], d[1], 1'b1, g[1], Q1);
    muxdff m2 (c[2], d[2], 1'b1, g[2], Q2);
    endmodule
    ### Original Code:
    module test();
    reg [2:0] arr [3:0];
    reg [2:0]

- code: |-
    ```verilog
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    
    wire Q[9:0];
    reg [7:0] Data[9:0];
    
    int i;
    
    initial begin
    	$display("Testing MUX-DFF");
    	for (i = 0; i < 10; i++) begin
    		Data[i] <= i + 1;
    	end
    	
    	#10
    	$display("Initial values:");
    	for (i = 0; i < 10; i++) begin
    		$display("%d: %0d", i, Data[i]);
    	end
    	$display("");
    
    	for(i = 0; i < 10; i++) begin
    		//MUX_DFF_F2(Q, Data[i], Sel, Clock);
    		//MUX_DFF_F3(Q, Data[i], Sel, Clock);
    		muxdff(D0, D1, Sel, Clock, Q);
    		if (i == 0) begin
    			Sel = 0;
    			Clock = 1;
    		end
    		else if (i == 1) begin
    			Sel = 1;
    			Clock = 1;
    		end
    		else begin
    			Sel = 0;
    			Clock = 0;
    		end
    		
    		#1;
    		//Sel = 1;
    		//Clock = 1;
    		//#1;
    		//Sel = 0;
    		//Clock = 1;
    		//#1;
    		//Sel = 0;
    		//Clock = 0;
    		//#1;
    		//Sel = 1;
    		//Clock = 0;
    	end
    	
    	$display("Output values:");
    	for (i = 0; i < 10; i++) begin
    		$display("%d: %0d", i, Q[i]);
    	end
    	$display("");
    end
    
    
    ```
    
    ### Result:
    
    | Clock | Sel |  Q[0] |  Q[1] |  Q[2] |  Q[3] |  Q[4] |  Q[5] |  Q[6] |  Q[7] |  Q[8] |  Q[9] |
    | :---- | :-- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
    | 0     | 0   | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |
    | 1     | 0   | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     |
    | 0     | 0   | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     | 1     |
    | 1     | 0   | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     |
    | 0     | 0   | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     | 2     |
    | 1     | 0   | 3     | 3     | 3     | 3     | 3     | 3     | 3     | 3     | 3     | 3     |
    | 0     | 0   | 3     | 3     | 3     | 3     |

- code: |-
    module muxdff(D0, D1, Sel, Clock, Q[1:0,1:0]);
    input D0, D1, Sel, Clock;
    output Q[1:0,1:0];
    reg Q[1:0,1:0];
    always @(posedge Clock)
        if (!Sel)
            Q[0,0] <= D0;
        else
            Q[0,0] <= D1;
    endmodule
    ### Example Code:
    module tb;
    wire D0, D1, Sel, Clock, Q[1:0,1:0];
    muxdff dut(D0, D1, Sel, Clock, Q);
    initial begin
        D0 = 1'b0;
        D1 = 1'b0;
        Sel = 1'b0;
        Clock = 1'b0;
        #10

- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else

- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    module array_test (Sel, Input, Output);
    input Sel;
    input [511:0] Input;
    output [31:0] Output;
    wire [31:0] Output;
    wire [31:0] Output;
    wire [31:0] Output;
    wire [31:0] Output;
    wire [31:0] Output;
    
    integer i;
    generate
    for (i = 0; i < 64; i = i + 1) begin : i
         muxdff uut(.D0(Input[i]),.D1(Input[63 - i]),.Sel(Sel),.Clock(1'b1),.Q(Output[i]));
        end
    endgenerate
    
    endmodule
    
    ### Expected Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]
    
    ### Actual Output:
    
    D0, D1, Sel, Clock : [inputs]
    Q : [outputs]

- code: |-
    module mux8(D0, D1, D2, D3, D4, D5, D6, D7, Sel, Clock, Q);
    input [7:0] D0, D1, D2, D3, D4, D5, D6, D7;
    input [2:0] Sel;
    input Clock;
    output [7:0] Q;
    reg [7:0] Q;
    int i = 0, j = 0;
    always @(posedge

- code: |-
    module muxdff(D0, D1, Clock, i, Sel, Q);
    input D0, D1, Clock, i, Sel;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel) begin
            i = 0; Q <= D0;
        end else begin
            i++; Q <= D1;
        end
    endmodule
    ### Re-sourced Verilog Code:
    module muxdff(D0, D1, Clock, i, Sel, Q);
    input D0, D1, Clock, i, Sel;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel) begin
            i = 0; Q <= D0;

- code: |-
    module loopvar_muxdff(D0, D1, Sel, Clock, Q);
    localparam N = 10;
    input [N - 1: 0] D0, D1, Sel, Clock;
    output [N - 1: 0] Q;
    logic Q;
    always @(posedge Clock)
        if (!Sel[0])
            Q <= D0[0];
        else
            Q <= D1[0];
    endmodule
    ### Simulation:
        Simulation Run:
        verilog-3 -> runsim:  model sim_m_beh.exe -v 0 -c -m  -w -novopt  -w -p -l
        Warning: Verilog-2005 is not supported. Using Verilog-2001.
        Error: Unable to open file "../Src/loopvar_muxdff.v"
        Error: Unable to open file "../Src/sim_m_beh.v"
        Error: Unable to open file "../tb/tb_loopvar_muxdff.v"
        Error: Unable to open file "loopvar_muxdff.m"
        Error: Unable to open file "sim_m_beh.m"
        Error: Unable to open file "tb_loopvar_muxdff.m"
        Error: Unable to open file "loopvar_muxdff.vhd"
        Error: Unable to open file "sim_m_beh.vhd"
        Error: Unable to open file "tb_loopvar_muxdff.vhd"
        Error: Unable to open file "loopvar_muxdff.v"
        Error: Unable to open file "sim_m_beh.v"
        Error: Unable to open file "tb_loopvar_muxdff.v"
        Error: Unable to open file "loopvar_muxdff.blif"
        Error: Unable to open file "sim_m_beh.blif"
        Error: Unable to open file "tb_loopvar_muxdff.blif"
        Error: Unable to open file "sim_m_beh.ng"
        Error: Unable to open file "loopvar_muxdff.ng"
        Error: Unable to open file "tb_loopvar_muxdff.ng"
        Error: Unable to open file "loopvar_muxdff.vst"
        Error: Unable to open file "sim_m_beh.vst"
        Error: Unable to open file "tb_loopvar_muxdff.vst"
        Error: Unable to open file "loopvar_muxdff.vcd"
        Error: Unable to open file "sim_m_beh.vcd"
        Error: Unable to open file "tb_loopvar_muxdff.vcd"
        Error: Unable to open file "sim_m_beh.log"
        Error: Unable to open file "loopvar_muxdff.log"
        Error: Unable to open file "tb_loopvar_muxdff.log"
        Simulation Error: Run failed.
        Simulation Command: vsim tb_loopvar_muxdff -c -do "run -all; quit"
        Translate Command: translate sim_m_beh.exe sim_m_beh.v sim_m_beh.vlog tb_loopvar_muxdff.v -w
        Translate Command: translate tb_loopvar_muxdff.v tb_loopvar_muxdff.vlog sim_m_beh.v
        Translate Command: translate sim_m_beh.v sim_m_beh.vlog tb_loopvar_muxdff.v -w
        Translate Command: translate sim_m_beh.v sim_m_beh.vlog tb_loopvar_muxdff.v -w
        Translate Command: translate loopvar_muxdff.v loopvar_muxdff.vlog sim_m_beh.v
        Translate Command: translate sim_m_beh.v sim_m_beh

- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @*
    begin
    out = data;
    if (r)
    out =

- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg

- code: |-
    module test_inside_operator (a, b, c, d);
    output a, d;
    input [3:0] b, c;
    wire a;
    wire [2:0] d;
    wire [3:0] b_d_o;
    always @(b, c)
    begin
    if (2 inside {b, c})
        a = 1;
    else
        a = 0;
    b_d_o = {b, d, c};
    end
    assign d = b_d_o[2:0];
    endmodule
    ### Variation Instruction:
    Consider this modified verilog code snippet:
    ```verilog
    module test_inside_operator (a, b, c, d);
    output a, d;
    input [3:0] b, c;
    wire a;
    wire [2:0] d;
    wire [3:0] b_d_o;
    always @(negedge c)
    begin
    if (2 inside {b, c})
        a = 1;
    else
        a = 0;
    b_d_o = {b, d, c};
    end
    assign d = b_d_o[2:0];
    endmodule
    ```
    ### Variation Instruction:
    Simulate the above verilog code snippet.
    ### Hint:
    What will be the waveform of a, d at time 0ns?
    
    ### Hint:
    Simulation time should be 10ns
    ### Hint:
    Simulate the above verilog code snippet.
    ### Hint:
    What will be the waveform of a, d at time 10ns?
    
    ### Hint:
    Simulation time should be 10ns
    ### Hint:
    Simulate the above verilog code snippet.
    ### Hint:
    What will be the waveform of a, d at time 20ns?
    
    ### Hint:
    Simulation time should be 10ns
    ### Hint:
    Simulate the above verilog code snippet.
    ### Hint:
    What will be the waveform of a, d at time 30ns?
    
    ### Hint:
    Simulation time should be 10ns
    ### Hint:
    Simulate the above verilog code snippet.
    ### Hint:
    What will be the waveform of a, d at

- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else if (data inside {5,10,15,25,35,68,80,85, 98, 100})
    out = data;
    end
    endmodule
    ### Variation Instruction:
    Use inside operator inside a procedural block to check array membership in a part-select range.

- code: |-
    module mux_8_1(sel,in,out);    
        input [2:0] sel;
        input [7:0] in;
        output out;
        wire [7:0] out;
        reg[7:0] out;
        always @(*) begin
            case (sel)
                3'b000 : out = in[0  +: 8];
                3'b001 : out = in[8  +: 8];
                3'b010 : out = in[16 +: 8];
                3'b011 : out = in[24 +: 8];
                3'b100 : out = in[32 +: 8];
                3'b101 : out = in[40 +: 8];
                3'b110 : out = in[48 +: 8];
                3'b111 : out = in[56 +: 8];
                default : out = 0;

- code: |-
    module dff_with_reset(data, clock, r, out

- code: |-
    Modify the function which was called to add two numbers.
    ### Source Code:
    ```verilog
    module add(a, b, c);
    input [15:0] a;
    input [15:0] b;
    output [15:0] c;
    reg [15:0] c;
    always @(*)
    begin
    c = a + b;
    end
    endmodule
    module top();
    reg [15:0] a, b, c;
    initial
    begin
    a = 15'b1001000000000010;
    b = 15'b1000000000000000;
    c

- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;

- code: |-
    module dff3_variation(data, clock, out, nreset);
    input clock, data, nreset;
    output [2:0] out;
    reg out;
    always @(posedge clock, negedge nreset)
    begin
    if (!nreset)
    out = 0;
    else
    out[0] = data[0];
    out[1] = data[1];
    out[2] = data[2];
    end
    endmodule
    ### Modified Verilog Output:
    module dff3_variation(data, clock, out, nreset);
    input clock, data, nreset;
    output [2:0] out;
    reg out;
    always @(posedge clock, negedge nreset)
    begin
    if (!nreset)
    out = 0;
    else
    out[0] = data[0];
    out[1] = data[1];
    out[2] = data[2];
    end
    endmodule
    ### Simulation:
    ##### Original:
    ![original](https://github.com/wesleysubiotto/CircuitVerilog/blob/master/images/dff3_original.png)
    ##### Partial:
    ![partial](https://github.com/wesleysubiotto/CircuitVerilog/blob/master/images/dff3_partial.png)
    ##### Variation:
    ![variation](https://github.com/wesleysubiotto/CircuitVerilog/blob/master/images/dff3_variation.png)
    ### Base Verilog Code:
    module shift_left(a, b, c, d, e, f, out);
    input [7:0] a, b, c, d, e, f;
    output [7:0] out;
    wire [7:0] a, b, c, d, e, f;
    assign a = 8'b11110000;
    assign b = 8'b01110000;
    assign c = 8'b00110000;
    assign d = 8'b00010000;
    assign e = 8'b00001111;
    assign f = 8'b

- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    for (integer i = 0; i < 8; i++)
    begin
    for (integer j = i; j < 8; j

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
        if (a[3:1] == 2'b01)
        begin: 3DArraySlice
            if (a[4] == 1'b0)
            begin: RangeInclusion
                xReg <= a & b & c;
            end
            else
            begin: NotRangeInclusion
                yReg <= (b | c) ^ a;
            end
        end: 3DArraySlice

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yReg = yReg;
    always @(a, b, c)
    begin: PartList
        xReg <= a & b & c;
        if (a >= 4'b0111 && a <= 4'b1110) begin
            xReg <= xReg || a;
        end
        if (a < 4'b0011 || a > 4'b1100) begin
            yReg <= yReg || a;
        end
    end
    endmodule
    ### Generate Verilog
    Generated verilog file path is:
    /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    Set active hdl file path to:
    /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    Set active hdl file path to:
    /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    
    INFO: [Common 17-342] -- PARSING TCL: /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    INFO: [Common 17-342] -- READING TCL: /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    INFO: [Common 17-342] -- LOAD TCL: /Users/Jiangshan/Documents/TestBench/TestChip_1/tb_2/simulator/modelsim/modelsim.ini
    
    MODELSIM>
    \end{code}
    
    Any help is highly appreciated!
    
    Answer: You need to change the `$display` statement to read:
    
    \begin{code}
    $display("%t %0d", $time, xReg);
    \end{code}
    
    Or, to get the values of xReg and yReg all in one waveform (and avoid the need to look at the waveform and find the value), change to use `$monitor`:
    
    \begin{code}
    $monitor  "%t %0d %0d", $time, xReg, yReg;
    \end{code}
    
    And add a delay for 10ns, to make the simulator actually run (I think you were seeing only the time on the clock):
    
    \begin{code}
    #10;
    \end{code}
    
    And make sure you are simulating the module in question:
    
    \begin{code}
    vsim work.EventCtlPart
    \end{code}
    
    (or whatever your top-level design module is called).
    
    Here is the complete script file with both of these changes, and the waveform:
    
    \begin{code}
    vlib work
    vmap work work
    vlog -sv../Source/EventCtlPart.sv
    
    vsim -novopt work.EventCtlPart
    
    force -freeze sim:/EventCtlPart/a 1'b0
    force -freeze sim:/EventCtlPart/b 1'b1
    force -freeze sim:/EventCtlPart/c 1'b0
    
    run 100ns
    
    #10;
    $display("%t %0d", $time, xReg);
    $monitor  "%t %0d %0d", $time, xReg, yReg;
    
    run 50ns
    
    run 100ns
    
    #10;
    $

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b, c)
    begin: PartList
        if(c)
        begin: Part
            if (a > 3'b000 & a <= 3'b111) begin: aRange
                xReg <= a & b;
                yReg <= (b | c) ^ a;
            end
            else if (a > 3'b111 & a <= 3'b222) begin: aRange
                xReg <= a & b; 
                yReg <= (b | c) ^ a;
            end
            else if (a > 3'b222 & a <= 3'b333) begin: aRange
                xReg <= a & b; 
                yReg <= (b | c) ^ a;
            end
            else begin: aRange
                xReg <= a & b; 
                yReg <= (b | c) ^ a;
            end
        end
        else begin: Part
            if (a > 3'b000 & a <= 3'b111) begin: aRange
                xReg <= a & b;
                yReg <= (b | c) ^ a;
            end
            else if (a > 3'b111 & a <= 3'b222) begin: aRange
                xReg <= a & b; 
                yReg <= (b | c) ^ a;
            end
            else if (a > 3'b222 & a <= 3'b333) begin: aRange
                xReg <= a & b; 
                yReg <= (b | c) ^ a;
            end

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    if (a)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    else begin
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
        always @(b)
        begin: PartList
            if (b)

- code: |-
    module EventCtlPartArray (output xPart, yPart, input a, b, c);
    reg [0:99] xReg, yReg;
    assign xPart = xReg[0];
    assign yPart = yReg[0];
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        if (a | b)
            if (b & c)
                begin: with
                    xReg[1] <= a | b | c;
                end
            else
                yReg[0] <= (b | c) ^ a;
            else
                xReg[2] <= a & b & c;
                xReg[3] <= a | b | c;
                xReg[4] <= (a < 4'd2)? 1'b0 : 1'b1;
                xReg[5] <= (a & (a >> 2))? 1'b0 : 1'b1;
                xReg[6] <= (a &!a)? 1'b0 : 1'b1;
                xReg[7] <= (a & (a & 1'b1))? 1'b0 : 1'b1;
                xReg[8] <= (a & (a | 1'b0))? 1'b0 : 1'b1;
                xReg[9] <= (a &!a)? 1'b0 : 1'b1;
                xReg[10] <= (a == 1'b1)? 1'b0 : 1'b1;
                xReg[11] <= (a == 1'b0)? 1'b0 : 1'b1;
                xReg[12] <= (a < 1'b1)? 1'b0 : 1

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
    ### Trace for Variation Unit Test:
    xReg = 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    yReg = 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        if (b) begin
            if (c) begin
                yReg <= 1'b1;
            end
            else begin
                yReg <= 1'b0;
            end
        end
        else

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        x

- code: |-
    module EventCtlPart #(parameter N = 15) (output xPart, yPart, input a, b, c);
    reg [N:0] PartList[N:0];
    reg [N:0] xReg[N:0];
    reg [N:0] yReg[N:0];
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        for (int i = 0; i < N; i = i+1)
        begin: loop
            if (i >= 7 && i <= 13)
            begin: PartList
                xReg[i] <= a & b & c;
                yReg[i] <= (b | c) ^ a;
            end
            else
            begin: PartList
                if (i >= 0 && i <= 6)
                begin: PartList
                    xReg[i] <= a & b & c;
                    yReg[i] <= (b | c) ^ a;
                end
            end
        end
    end
    endmodule
    ### Original Code:
    module EventCtlPart (output xPart, yPart,

- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg [1:0] xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
        if(0)
        begin
            if(

- code: |-
    module reg16(ad,d,we,q); // 16-bit register
    input [3:0] ad, d, we; // 4-bit address, data input, write enable
    output [15:0] q; // 16-bit data output
    reg [15:0] q; // Internal 16-bit register
    // Initialize all register bits with 0s
    initial
    q = 16'b0;
    // Assign input 'd' to output 'q' on negative clock edge
    // when 'we' is high
    always@(negedge clk)
    if (we) q[ad] <= d;

- code: |-
    module mux2(out,data,sel);
    input [1:0] data;
    input [0:1] sel;
    output out;
    initial begin : init_mux
     out = data[sel] == 1'b0;
    end
    always @(sel) begin : mux
     out = data[sel] == 1'b0;
    end
    endmodule
    ### Task:
    Modify the following Verilog code by inserting an always block that assigns the output of this module (out) to 
    the input array (data) based on the current value of the control (sel). The "data[sel]" must be the LHS of
    the assignment. Also change the "data[sel

- code: |-
    module test(dout,din

- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;

- code: |-
    ```verilog
    module dff(do,di,clk,sel); // Behavioral D Flip-Flop
    output do[1:0];
    input di[1:0],clk;
    reg do[1:0]; // Output must be reg for procedural assignment
    initial
    do[1:0]={1'b0,1'b0}; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) begin
    case(sel)
    1'b0:do[0]<=di[0];
    1'b1:do[1]<=di[1];
    default:do[1:0]={1'b0,1'b0};
    endcase
    end
    endmodule
    ```
    ### Test Bench:
    ```verilog
    module tb_dff();
    reg di[1:0],clk,sel;
    wire do[1:0];
    dff UUT(do,di,clk,sel);
    initial begin
    di[1:0] = 2'b00;
    clk = 1'b0;
    sel = 1'b0;
    end
    always begin
    #10 clk = ~clk;
    end
    always begin
    #10 sel = ~sel;
    end
    initial begin
    #500 $finish;
    end
    endmodule
    ```
    ### Screenshot Output:
    ![ScreenShot

- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge

- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule
    module test;
    reg [7:0] data_array[0:3];
    
    integer i;
    reg clk;
    dff DFF(.do(data_array[i]),.di(data_array[i+1]),.clk(clk));
    initial begin
    clk=1;
    for(i=0;i<=3;i++)begin
    data_array[i]=i;
    #10;
    end
    clk=~clk;
    end
    endmodule
    ### Expected Result:
    Test Passed
    ### Actual Result:
    Sorry, there was a problem with the build.
    
    [15:49:01] vlog -v2004 -work work DFF.v
    [15:49:07] vlog -v2004 -work work test.v
    [15:49:08] elapsed time: 00:00:01.94

- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input

- code: |-
    module counter(dout, clk);
    output[4:0] dout;
    input clk;
    reg[4:0] dout;
    initial
    dout=0;
    always@(posedge clk)
    dout <= dout + 1'b1;
    endmodule
    ### Test vector for simulation:
    ```VHDL
    //testbench code
    module tb();
    reg [7:0] clk_in;
    wire [4:0] x_out;
    counter dut(.dout(x_out),.clk(clk_in));
    initial
    begin
    $display("------------------------------------------");
    $display("Test vector for Counter with 5 bits");
    $display("------------------------------------------");
    $display("CLK:    DO:    Result");
    $display("--:--    --:    -----");
    clk_in=8'b0110110;
    #30
    clk_in=8'b1110111;
    #30
    clk_in=8'b0111111;
    #30
    clk_in=8'b110

- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output [3:0] do;
    input [3:0] di

- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw[3:0](out[1:0],in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "

- code: |-
    module dff (q,d,clk,rst);
      output q;
      input d,clk,rst;
      reg q;
      always @(posedge clk) begin
        if (rst)
          q <= 0;
        else
          q <=d;
      end
    endmodule
    module tst_dff();
      reg d,clk,rst;
      wire q;
      dff df(q,d,clk,rst);
      initial d=0,clk=0,rst=1;
      initial begin
        #5 rst=0;
      end
      always #5 d=~d;
      always #2 clk=~clk;
      initial $monitor($time, "d = %b, q = %b ",d,q);
      initial #10 $finish;
    endmodule
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
      initial $display("\nTest if the function call's result is set into an array.");
      initial begin
        repeat (3) begin
          $display("in = %b, con = %b\n",in,con);
          $display("out = %b\n",out);
          $display("\n");
          in=~in;
          #5
          con=~con;
        end
        $finish;
      end
    endmodule

- code: |-
    module tst_CMOSsw2();
      reg in[3:0],con; wire out;
      CMOSsw2 cmsw[5:7](out,in,con); // Instantiate CMOS switch
      initial begin in=4'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Simulation Log:
        in = 0000, con = 1, output = 0000
        in = 0001

- code: |-
    module test();
      reg [7:0] a;
      
      initial begin
        for (a = 0; a < 256; a = a + 1) begin
          if(a[7:1]!=CMOSsw1(a[7:1],a[7:1]))
            $error("Error: %d",a[7:1]);
          #2;
        end
        $finish;
      end
    endmodule
    ### Expected Results:
    All passes.
    ### Actual Results:
    All passes.
    ### Tested Version:
    vivado_2017.2
    ### Tested Platform:
    Nexys A7-100T
    ### Tested Scope:
    CMOSsw1
    ### Tested Simulator:
    ModelSim-Altera (v10.5d)
    ### Tested Date:
    2018-05-30
    ### Comments:
    This test passed in ModelSim-Altera (v10.5d). For more information about this test, click on the following link.
    https://github.com/gusmec/Verilog-File-Repo/blob/master/Test_Instructions/CMOSsw1/CMOSsw1_00001.md
    ### Relevant Files:
    CMOSsw1.

- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw[2:0](out[1:0],in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
      initial
      begin
        for(i=0;i<3;i=i+1)
        begin
            $display("in = %b, con = %b, output = %b ",in,con,out

- code: |-
    module tst_CMOSsw1();
      reg in,con;
      wire [1:0] out;
      reg [1:0] out_exp;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      initial begin
        #20
        in = 1'b0;
        con = 1'b1;
        #10
        out_exp = 2'b01;
        if (out[0]!= out_exp[0]) begin
          $display("ERROR!!!!!: out[0] = %b, out_exp[0] = %b", out[0], out_exp[0]);
        end
        if (out[1]!= out_exp[1]) begin
          $display("ERROR!!!!!: out[1] = %b, out_exp[1] = %b", out[1], out_exp[1]);
        end
        #10
        in = 1'b1;
        con = 1'b1;
        #10
        out_exp = 2'b10;
        if (out[0]!= out_exp[0]) begin
          $display("ERROR!!!!!: out[0] = %b, out_exp[0] = %b", out[0], out_exp[0]);
        end
        if (out[1]!= out_exp[1]) begin
          $display("ERROR!!!!!: out[1] = %b, out_exp[1] = %b", out[1], out_exp[1]);
        end
        #10
        in = 1'b0;
        con = 1'b1;
        #10
        out_exp = 2'b00;
        if (out[0]!= out_exp[0]) begin
          $display("ERROR!!!!!: out[0] = %b, out_

- code: |-
    module tst_CMOSsw2();
      reg in,con; wire out;
      reg [15:0] my_array[2];
      my_array[0][1:0] = "00" ;
      my_array[0][4:3] = "10" ;
      my_array[0][7:6] = "01" ;
      my_array[0][9:8] = "11" ;
      my_array[1][1:0] = "01" ;
      my_array[1][4:3] = "11" ;
      my_array[1][7:6] = "00" ;
      my_array[1][9:8] = "10" ;
      
    
      CMOSsw2 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Original Instruction:
    Use inside in final block to check if function call result indexed into an array matches a slice range.
    ### Base Verilog Code:
    module tst_CMOSsw4();
      reg in,con; wire out;
      CMOSsw4 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Variation Instruction:
    Use inside in final block to check if function call result indexed into an array matches a slice range.

- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      reg [10:0] results;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial begin
        #50 // Delay until switch has toggled once
        $display($sformatf("0: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("1: %b",results[0] == cmsw.OUT2));
      end
      initial begin
        #200 // Delay until switch has toggled once
        #50 // Delay until switch has toggled once
        $display($sformatf("2: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("3: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("4: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("5: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("6: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("7: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("8: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("9: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("10: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("11: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("12: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("13: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("14: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("15: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("16: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("17: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("18: %b",results[10] == cmsw.OUT1));
        #50 // Delay until switch has toggled once
        $display($sformatf("19: %b",results[0] == cmsw.OUT2));
        #50 // Delay until switch has toggled once
        $display($sformatf("20: %b, 21: %b, 22: %b, 23: %b, 24: %b, 25: %b, 26: %b, 27

- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw[4:0](out[3:0],in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",(in&con),con,out[3:0]);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Explanation:
    If the 'always' block is uncommented, the code will generate a warning message, saying that the width of the expression on the left is less than the width of the expression on the right.
    As such, this variation will fail.
    However, when the 'always' block is commented as shown above, the function call result will be sliced to the appropriate width to perform the comparison, which will succeed.
    As such, this variation will pass.
    ### Passed Variation:
    The 'always' block is commented out.
    ### Failed Variation:
    The 'always' block is uncommented, which causes a warning message to be generated.
    ### Notes:
    No notes.
    ### Original Author:
    Philip Tovstogan
    ### Current Maintainer:
    Philip Tovstogan
    ### Hardware:
    This test was developed and tested on a VMWare virtual machine running Ubuntu Server 16.04.
    ### Software:
    The test was developed and tested using QuestaSim-10.1c, which comes with the Cadence Design Systems Virtuoso 2016.06.03.
    ### Test Method:
    This test involves two blocks:
    The first block is a verilog module that contains a CMOS switch.
    The second block is a testbench verilog file that instantiates the CMOS switch module once for each variation.
    The testbench creates two inputs and one output.
    It then enables the CMOS switch, toggles the inputs, and monitors the outputs.
    ### Coding:
    The verilog module was written to test a function call with a slice range.
    The testbench file instantiates the CMOS switch four times.
    The testbench creates two inputs and one output.
    It then enables the CMOS switch, toggles the inputs, and monitors the outputs.
    ### Testing:
    The simulated results are displayed on the screen.
    If the results match the expected results, the variation will pass.
    If the results do not match the expected results, the variation will fail.
    ### Results:
    The following results were obtained:
    Failed variation: The 'always' block is uncommented.
    Passed variation: The 'always' block is commented out.
    ### Analysis:
    The CMOS swtich in the verilog module is a 2-input NAND gate.
    As such, when both inputs are low, the output is high.
    When one input is high and the other input is low, the output is low.
    When both inputs are high, the output is low.
    As such, the function call result in the second instance of the CMOS switch is not being sliced to the appropriate width, which results in a mismatch in the verification results.
    ### Conclusion:
    When a function call result is indexed into an array, the code must slice the result to the appropriate width, to avoid mismatching the width of the indexed result.
    ## Reference
    [1] Reference: Slice range on function call to index array (https://support.

- code: |-
    module tst_CMOSsw1();
      reg in,con;wire out;
      CMOSsw1 cmsw[0:3](out,in,con);
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out[3:1]);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Reference Design:
    ![reference1](https://user-images.githubusercontent.com/62727894/128593451-e6a41d77-6f74-4b2b-9b00-f0d8403a150f.png)
    
    ### Synthesised Verilog Code:
    ![synth1](https://user-images.githubusercontent.com/62727894/128593653-a9c50929-c57b-4c63-90c9-23d8b64a41b2.png)
    
    ### Simulation Result:
    ![sim1](https://user-images.githubusercontent.com/62727894/128593675-44566724-f97c-4d51-b98c-fba176179b84.png)
    
    ### Synthesised Verilog Code:
    ![synth2](https://user-images.githubusercontent.com/62727894/128593694-942f845d-4169-446b-942e-a55008397e19.png)
    
    ### Simulation Result:
    ![sim2](https://user-images.githubusercontent.com/62727894/128593679-83f7d34f-d50c-4a3c-b3c4-c64c5c052e70.png)
    
    ### Synthesised Verilog Code:
    ![synth3](https://user-images.githubusercontent.com/62727894/128593707-08d6146c-7f0b-4e33-aa3c-6be948f6c940.png)
    
    ### Simulation Result:
    ![sim3](https://user-images.githubusercontent.com/62727894/128593712-4ff6693c-8771-47d9-a9d3-ac5744fa9a8c.png)
    
    ### Synthesised Verilog Code:
    ![synth4](https://user-images.githubusercontent.com/62727894/128593719-02b13980-431b-4e1f-875f-9827a4d9b042.png)
    
    ### Simulation Result:
    ![sim4](https://user-images.githubusercontent.com/62727894/128593722-a0404f92-c52d-4c1b-bfdd-07bb1509904c.png)
    
    ### Synthesised Verilog Code:
    ![synth5](https://user-images.githubusercontent.com/62727894/128593730-0289c875-7307-41a8-bd17-1254906e99a8.png)
    
    ### Simulation Result:
    ![sim5](https://user-images.githubusercontent.com/62727894/128593725-56

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output logic [2:0] ld
    );
    reg  [2:0] ld_reg;
    reg [2:0] const_operand;
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld_reg[2]),
    .or4_(ld_reg[1]),
    .xor4_(ld_reg[0])
    );
    always_comb
    begin
    case(const_operand)
    [0:0]: ld = ld_reg;
    [1:1]: ld = not(ld_reg);
    [2:2]: ld = ~ld_reg;
    [3:3]: ld = 1'b0;
    endcase
    end
    endmodule
    ### Testbench code:
    module gates4_tb ();
    parameter N = 4;
    logic [N:0] sw = 0;
    logic [2:0] ld;
    gates4 U1 (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    integer i;
    initial
    begin
    for (i = 0; i < N; i = i + 1)
    begin
    	sw[i] = 0;
    end
    ld = 0;
    sw[1] = 1;
    sw[3] = 1;
    wait(1);
    sw[3] = 0;
    sw[2] = 1;
    wait(2);
    sw[2] = 0;
    sw[0] = 1;
    wait(3);
    sw[0] = 0;
    sw[1] = 0;
    sw[3] = 1;
    wait(4);
    sw[3] = 0;
    sw[2] = 0;
    sw[0] = 1;
    wait(5);
    sw[0] = 0;
    sw[1] = 1;
    sw[2] = 1;
    wait(6

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [2:0] x;
    wire and4_, or4_, xor4_;
    gates4 U1	// Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(x),
    .and4_(and4_),
    .or4_(or4_),
    .xor4_(xor4_)
    );
    mda U2 // MDA
    (
    .sw(sw),
    .index(3'b100),
    .x(x)
    );
    mux4 U3 
    (
    .in(x),
    .sel(3'b011),
    .out(ld)
    );
    endmodule
    ### Results:

- code: |-
    module gates4_top_2 (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [3:0] x;
    gates4 U1
    (
    .x(x),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    case (0)
    switch ( 1'b1, 1'b1, 1'b1, 1'b1)
    		x = 4'b1010;
    		x = 4'b0101;
    		x = 4'b1111;
    		x = 4'b1011;
    		x = 4'b1101;
    		x = 4'b0010;
    		x = 4'b0011;
    		x = 4'b0111;
    		x = 4'b1001;
    		x = 4'b1110;
    		x = 4'b0100;

- code: |-
    module gates4 (
    input wire [3:0] x,
    output wire [3:0]

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    
    wire [1:0] prior_input_select;
    mda U2 (.x(prior_input_select),.y(ld[2]),.ld(ld[1]),.xor4(ld[0]));
    endmodule
    ### Modified Verilog Code:
    module gates4_top (
    input wire [3:

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0]),
    .priority_xor4(ld[1]),
    .priority_and4(ld[2]),
    .priority_bit(1'b0)
    );
    endmodule
    ### Changes:
    Added a priority case with inside applied to operand selected via a one-hot index from an MDA and a priority bit set to 0.
    ### Simulation Results:
    ![Circuit simulation result](priorities_onehot_priority_bit_0.png)
    
    #### Variation Instructions - (D)
    Add

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    reg [3:0] mda;
    initial begin
    ld = 0;
    end
    always @(*) begin
    case (mda)
    4'd1: ld = and4_(ld[2]), or4_(ld[1]), xor4_(ld[0]);
    4'd2: ld = and4_(ld[1]), or4_(ld[0]), xor4_(ld[2]);
    4'd3: ld = and4_(ld[0]), or4_(ld[2]), xor4_(ld[1]);
    4'd4: ld = and4_(ld[1]), or4_(ld

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    priority case (index)
    3'b111: ld = and4_[3:0];
    3'b1

- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    reg [2:0] p1;
    // Add case for priority
    p1 = 0;
    // This is the switch statement
    case(sw):
    3'b001: p1 = 3; // Set 'priority' to 3 if sw = 3'b001
    3'b110: p1 = 2; // Set 'priority' to 2 if sw = 3'b110
    3'b101: p1 = 1; // Set


- code: |-
    ```
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule
    ```
    Modifications are:
    * `initial $monitor("t=%0d, en = %b, a = %h, b = %b",$

- code: |-
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule
    
    module or_gate (b,a,en);
    input b;
    input[3:0]a;
    input en;
    output b;
    always @(a,en)
    begin
    if(en)
    begin
    	case(a)
    	4'h1: b <= 1'b1;
    	4'h2: b <= 1'b1;
    	4'h4: b <= 1'b1;
    	4'h8: b <= 1'b1;
    	default: b <= 1'b0;
    	endcase
    end
    end
    endmodule
    
    ### Passing Criteria:
    1. The `inside` check for `a` within a predefined array slice works as expected.
    
    ### Failing Criteria:
    1. The `inside` check for `a` within a predefined array slice does not work as expected.
    
    ## Tutorial Description:
    In this tutorial, we discuss how to use the `inside` function in a module scope to check the value of a signal within an array using the `inside` function.
    
    ### Step: 1 - Use the `inside` Function in a Module Scope
    In this step, we will add an `inside` check for an array slice `a` in a module scope. This will ensure the testbench passes if the value of `a` within the array slice is 1, 2, 4 or 8.
    
    ### Step: 2 - Use the `inside` Function Inside an Always Block
    In this step, we will add an `inside` check for an array slice `a` inside an always block. This will ensure the testbench passes if the value of `a` within the array slice is 1, 2, 4 or 8.
    
    ### Step: 3 - Use the `inside` Function Inside a Case Statement
    In this step, we

- code: |-
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule
    ### Simulation Output:
    ```
    sim> ghdl -r tst_or_gate --vcd=tst_or_gate.vcd
    tst_or_gate.vhdl:25:9:@0ms:(report note): t=0, en = 0, a = 0000, b = 0
    tst_or_gate.vhdl:25:9:@10ns:(report note): t=10, en = 0, a = 0000, b = 0
    tst_or_gate.vhdl:25:9:@20ns:(report note): t=20, en = 0, a = 0001, b = 1
    tst_or_gate.vhdl:25:9:@30ns:(report note): t=30, en = 0, a = 0010, b = 1
    tst_or_gate.vhdl:25:9:@40ns:(report note): t=40, en = 0, a = 0011, b = 1
    tst_or_gate.vhdl:25:9:@50ns:(report note): t=50, en = 0, a = 0100, b = 1
    tst_or_gate.vhdl:25:9:@60ns:(report note): t=60, en = 0, a = 0101, b = 1
    tst_or_gate.vhdl:25:9:@70ns:(report note): t=70, en = 0, a = 0110, b = 1
    tst_or_gate.vhdl:25:9:@80ns:(report note): t=80, en = 0, a = 0111, b = 1
    tst_or_gate.vhdl:25:9:@90ns:(report note): t=90, en = 0, a = 1000, b = 1
    tst_or_gate.vhdl:25:9:@100ns:(report note): t=100, en = 0, a = 1001, b = 1
    tst_or_gate.vhdl:25:9:@110ns:(report note): t=110, en = 0, a = 1010, b = 1
    tst_or_gate.vhdl:25:9:@120ns:(report note): t=120, en = 0, a = 1011, b = 1
    tst_or_gate.vhdl:25:9:@130ns:(report note): t=130, en = 0, a = 1100, b = 1
    tst_or_gate.vhdl:25:9:@140ns:(report note): t=140, en = 0, a = 1101, b = 1
    tst_or_gate.vhdl:25:9:@150ns:(report note): t=150, en = 0, a = 1110, b = 1
    tst_or_gate.vhdl:25:9:@160ns:(report note): t=160, en = 0, a = 1111, b = 1
    tst_or_gate.vhdl:25:9:@170ns:(report note): t=170, en = 0, a = 1000, b = 1
    tst_or_gate.vhdl:2

- code: |-
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule

- code: |-
    ```
    module or_gate(b,a,en);
    parameter N = 4;
    input [N-1:0] a;
    input en

- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      generate
      for (i=0;i<5;i++) begin: \gen_block1 // Changed name
        nor3NMOS nn(in1,in2,in3,b);
      end
      endgenerate
      initial begin
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial begin
        $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b);
      end
      always @(in1 or in2 or in3) #2 inside(\gen_block1); // Changed from b to in[i]
      initial #24 $stop; // Stop simulation
    endmodule
    ### Modified Verilog Code:
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      generate
      for (i=0;i<5;i++) begin: \gen_block1 // Changed name
        nor3NMOS nn(in1,in2,in3,b);
      end
      endgenerate
      initial begin
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial begin
        $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b);
      end
      always @(in

- code: |-
    ```verilog
    module tst_nor2NMOS();
      reg in1,in2; wire b;
      nor2NMOS nn(in1,in2,b);
      initial begin
        in1=1'b0; in2=1'b0; // Corrected: was 1'b1
      end
      always #2 in1=~in1;
      always #3 in2=~in2;
      initial $monitor($time, "in1 = %b, in2 = %b, output = %b ",in1,in2,b);
      initial #24 $stop;
    endmodule
    
    module nor2NMOS(input1,input2,output1);
      input input1,input2;
      output1=~(input1 | input2);
    endmodule
    
    // Generate 2 NOR gates
    genvar i;
    generate
      for (i=0; i<2; i=i+1) begin : gen_block1
        norNMOS1 u1(.\gen_block1[i]);
      end
    endgenerate
    
    module norNMOS1(genvar i, input1,input2,output1);
      input input1,input2;
      output1=~(input1 | input2);
    endmodule
    ```
    ### Simulation

- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      generate
        genvar n,o;
        for(n = 0; n < 3; n = n + 1) begin: \gen_block1
          for(o = 0; o < 2; o = o + 1) begin
            nor3NMOS nn(in1,in2,in3,b);
          end
        end
      endgenerate
    endmodule
    ### Expected Printed Output:
    in1 = 0, in2 = 0, in3 = 0, output = 1
    in1 = 0, in2 = 0, in3 = 1, output = 1
    in1 =

- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      // 1. Escape the name using'character.
      // 2. Use inside operator with a constant index
      genvar  i;  // Declaring loop variable
      generate
        \gen_block1 : for (i=0; i<3; i=i+1) begin : gen_var1
          // Toggle inputs at different rates
          always #2 in1=~in1;
          always #3 in2=~in2;
          always #5 in3=~in3;
          nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
        end : gen_var1
      endgenerate
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ### Simulation Output:
    * in1 = 0, in2 = 0, in3 = 0, output = 1 (0.00 ns)
    * in1 = 1, in2 = 1, in3 = 1, output = 0 (2.00 ns)
    * in1 = 0, in2 = 0, in3 = 1, output = 0 (5.00 ns)
    * in1 = 1, in2 = 1, in3 = 0, output = 0 (10.00 ns)
    * in1 = 0, in2 = 1, in3 = 1, output = 0 (13.00 ns)
    * in1 = 1, in2 = 0, in3 = 0, output = 0 (16.00 ns)
    * in1 = 0, in2 = 1, in3 = 0, output = 0 (19.00 ns)
    * in1 = 1, in2 = 0, in3 = 1, output = 0 (24.00 ns)
    * in1 = 0, in2 = 0, in3 = 1, output = 1 (27.00 ns)
    * in1 = 1, in2 = 1, in3 = 0, output = 1 (32.00 ns)
    * in1 = 0, in2 = 1, in3 = 0, output = 1 (35.00 ns)
    * in1 = 1, in2 = 0, in3 = 1, output = 1 (40.00 ns)
    * in1 = 0, in2 = 0, in3 = 1, output = 1 (43.00 ns)
    * in1 = 1, in2 = 1, in3 = 0, output = 1 (48.00 ns)
    * in1 = 0, in2 = 1, in3 = 1, output = 1 (53.00 ns)
    * in1 = 1, in2 = 0, in3 = 1, output = 1 (60.00 ns)
    * in1 = 0, in2 = 0, in3 = 1, output = 1 (63.00 ns)
    * in1 = 1, in2 = 1, in3 = 0, output = 1 (70.00 ns)
    * in1 = 0, in2 = 1, in3 = 0, output = 1 (73.00 ns)
    * in1 = 1, in2 = 0, in3 = 1, output = 1 (80.00 ns)
    * in1 = 0, in2 = 0, in3 = 1, output = 1 (83.00 ns)
    * in1 = 1, in2 = 1, in3 = 0, output = 1 (90.00 ns)
    * in1 = 0, in2 = 1, in3 = 0, output

- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0;
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b);
      initial begin // Insert a generate block with escaped name
        \gen_block1;
      end
      // Insert a behavioral NOR gate inside the generate block
      generate if (1'b1) begin : \gen_block1
        wire b ; // Create a wire
        nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      end endgenerate
      initial #24 $stop; // Stop simulation
    endmodule
    ### Result:
    After simulation, we are now able to get the output from the escaped generate block.
    ###

- code: |-
    ```verilog
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    always @(posedge clk) // This block will drive appropriate data onto bus using a generate block
    begin
      if (start)
      begin
        // Loop throught the two memory arrays and drive data on interface
        for (indx=0; indx<2; indx=

- code: |-
    ```verilog
    // --- Apply Data... ---
    initial begin: Apply_Data
    	$display("Testing for 3 operands:");
    	for (indx=0; indx<3; indx=indx+1) begin
    		$display("Operand %d:", indx+1);
    		multiplier_result = 0;
    		for (multiplier_result=0; multiplier_result<256; multiplier_result=multiplier_result + 1) begin
    			im_data = multiplier_result;
    			if (inside(multiplier_result, mem1)) begin
    				opnd1 = multiplier_result;
    				$display(" %d", multiplier_result);
    			end
    			if (inside(multiplier_result, mem2)) begin
    				opnd2 = multiplier_result;
    				$display(" %d", multiplier_result);
    			end
    			#1 start = 1;
    			#1 start = 0;
    		end
    		$display("");
    	end
    end
    ```
    ### Example Output:
    ![Multiplier Variation

- code: |-
    ``` Verilog
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    generate
    for( indx=0; indx<3; indx=indx+1 ) begin
    assign databus = im_data inside { [mem1[indx]][7:0], [mem2[indx]][7:0] };
    #2; // Delay to allow the clock to change
    end
    endgenerate
    endmodule
    ```
    ### Simulation Results:
    ![Simulation Results](images/simulation-results-11.png)
    ### Examining the Results:
    ![Examining the Results](images/simulation-results-12.png)
    ![Examining

- code: |-
    ``` VHDL
    initial begin
        $dumpfile("multiplier.vcd");
        $dumpvars; // Dump all variables onto VCD file
      generate
        for (indx=0; indx<3; indx=indx+1) begin
          if (indx[3:0]==0) begin
            mem1[indx]=indx[3:0];
            mem2[indx]=indx[3:0];
          end
          else if (indx[3:0]<16) begin
            mem1[indx]=indx[3:0]-1;

- code: |-
    ``` Verilog
    /*... Figure 8.11... */
    // Apply the operation to the data bus.
    always @(posedge clk) begin
    	if (start) begin
    		opnd1 <= mem1[2];
    		opnd2 <= mem2[2];
    	end
    end
    // --- Placeholder blocks referenced by Figure numbers ---
    // Apply the Multiply operation to the data bus.
    generate
    for ( indx = 0; indx < 3; indx = indx + 1 ) begin: inside_loop
    	if ( indx inside {[0:1]}) begin: inside_generate
    		always @(posedge clk) begin: inside_operation
    			if (start) begin
    				opnd1 <= mem1[indx];
    				opnd2 <= mem2[indx];
    			end
    		end
    	end
    end
    endgenerate
    initial begin: Apply_Data_in_Generate_B1
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Apply_Data_in_Generate_A1
    		mem1[indx] = 8'h01;
    		mem2[indx] = 8'h02;
    	end
    end
    initial begin: Apply_Data_in_Generate_B2
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Apply_Data_in_Generate_A2
    		mem1[indx] = 8'h01;
    		mem2[indx] = 8'h04;
    	end
    end
    initial begin: Apply_Data_in_Generate_B3
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Apply_Data_in_Generate_A3
    		mem1[indx] = 8'h01;
    		mem2[indx] = 8'h08;
    	end
    end
    /*... Figure 8.12... */
    // Begin multiplier operation.
    initial begin: Start_Operation_in_Generate_B1
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Start_Operation_in_Generate_A1
    		@(posedge clk);
    		start <= 1;
    		@(posedge clk);
    		start <= 0;
    	end
    end
    initial begin: Start_Operation_in_Generate_B2
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Start_Operation_in_Generate_A2
    		@(posedge clk);
    		start <= 1;
    		@(posedge clk);
    		start <= 0;
    	end
    end
    initial begin: Start_Operation_in_Generate_B3
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Start_Operation_in_Generate_A3
    		@(posedge clk);
    		start <= 1;
    		@(posedge clk);
    		start <= 0;
    	end
    end
    /*... Figure 8.13... */
    // Provide the expected result.
    initial begin: Provide_Result_in_Generate_B1
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Provide_Result_in_Generate_A1
    		@(posedge clk);
    		expected_result <= 17'h00010002;
    	end
    end
    initial begin: Provide_Result_in_Generate_B2
    	for (indx = 0; indx < 3; indx = indx + 1) begin: Provide_Result_in_Generate_A2
    		@(posedge clk);
    		expected_result <= 17'h00010008;
    	end
    end
    initial begin: Provide_Result_in_Generate_B3
    	for (indx =

- code: |-
    ```
    module Prob_6_8_Mealy (D_in, D_out, clk, rst);
    // Mealy latch with asynchronous and synchronous reset
    input D_in, clk, rst;
    output D_out;
    reg D_out;
    wire [1: 0] Mealy_const;
    assign Mealy_const = 2'b00;
    always @ (posedge clk) if (rst) D_out = 0; else if (D_in inside {Mealy_const}) D_out = 1; else D_out = D_in;
    endmodule
    ```
    ### Result:
    **Original**
    D_in = 0
    D_out = 0
    
    **Modified**
    D_in = 0
    D_out = 1
    
    ### Base Verilog Code:
    module Prob_6_9_Detect_Edge (out, clk, in

- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    parameter STS = {S_0, S_1, S_2, S_3, S_4, S_5, S_6, S_7, S_8};
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = inside(state_Moore, STS);
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state =

- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    
    // Add constant set
    localparam logic [8: 0] Moore_State_Set = {S_0, S_1, S_2, S_3, S_4, S_5, S_6, S_7, S_8};
    // Add local variable
    localparam logic [3: 0] Moore_State_Out = Moore_State_Set[3];
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore inside Moore_State_Set) || (state_Moore inside {S_4, S_8}));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else
    state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_

- code: |-
    ```
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore inside {S_4, S_8}));
    //wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_8; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ```
    ### Code Usage:
    ```
    module prob_6_7_tb ();
    reg D_in,clk, rst;
    wire Detect_Moore, Detect_Mealy;
    Prob_6_7_Mealy prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    Prob_6_7_Moore prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    initial begin
        D_in = 0;
        clk = 0;
        rst = 0;
        # 10 rst = 1;
        # 10 rst = 0;
        repeat (100) begin
            # 0.2 D_in = 0;
            # 0.2 D_in = 1;
        end
        repeat (100) begin
            # 0.2 D_in = 1

- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    parameter state_range = {S_0, S_1, S_2, S_3, S_4, S_5, S_6, S_7, S_8};
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore inside state_range) || (state_Moore inside {S_4, S_8}));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7:

- code: |-
    ```verilog
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    begin
    #35 $stop; // Stop simulation
    $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    end
    endmodule
    ```
    ### Expected Result:
    ```
    > ghdl -r tst_ctr_wt --ieee=synopsys
    ghdl -r tst_ctr_wt --ieee=synopsys
    
    --  CLK=0, En=0, N=15, a=0
    --  CLK=1, En=0, N=15, a=0
    --  CLK=0, En=0, N=15, a=1
    --  CLK=1, En=0, N=15, a=1
    --  CLK=0, En=0, N=15, a=2
    --  CLK=1, En=0, N=15, a=2
    --  CLK=0, En=0, N=15, a=3
    --  CLK=1, En=0, N=15, a=3
    --  CLK=0, En=0, N=15, a=4
    --  CLK=1, En=0, N=15, a=4
    --  CLK=0, En=0, N=15, a=5
    --  CLK=1, En=0, N=15, a=5
    --  CLK=0, En=0, N=15, a=6
    --  CLK=1, En=0, N=15, a=6
    --  CLK=0, En=0, N=15, a=7
    --  CLK=1, En=0, N=15, a=7
    --  CLK=0, En=0, N=15, a=8
    --  CLK=1, En=0, N=15, a=8
    --  CLK=0, En=0, N=15, a=9
    --  CLK=1, En=0, N=15, a=9
    --  CLK=0, En=0, N=15, a=10
    --  CLK=1, En=0, N=15, a=10
    --  CLK=0, En=0, N=15, a=11
    --  CLK=1, En=0, N=15, a=11
    --  CLK=0, En=0, N=15, a=12
    --  CLK=1, En=0, N=15, a=12
    --  CLK=0, En=0, N=15, a=13
    --  CLK=1, En=0, N=15, a=13
    --  CLK=0, En=0, N=15, a=14
    --  CLK=1, En=0, N=15, a=14
    --  CLK=0, En=0, N=15, a=15
    --  CLK=1, En=0, N=15, a=15
    --  CLK=0, En=1, N=15, a=0
    --  CLK=1, En=1, N=15, a=1
    --  CLK=0, En=1, N=15, a=2
    --  CLK=1, En=1, N=15, a=3
    --  CLK=0, En=1, N=15, a=4
    --  CLK=1, En=1, N=15, a=5
    --  CLK=0, En=1, N=15, a=6
    --  CLK=1, En=1, N=15, a=7
    --  CLK=0, En=1, N=15

- code: |-
    module tst_ctr

- code: |-
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ### Expected Output for Verification:
    ```
    **WARNING:** Outputs truncated for clarity.
    
    ```
    # clk=0, En=0, N=15, a=0
    # clk=1, En=0, N=15, a=1
    # clk=0, En=0, N=15, a=0
    # clk=1, En=0, N=15, a=1
    # clk=0, En=0, N=15, a=2
    # clk=1, En=0, N=15, a=3
    # clk=0, En=0, N=15, a=2
    # clk=1, En=0, N=15, a=3
    # clk=0, En=0, N=15, a=4
    # clk=1, En=0, N=15, a=5
    # clk=0, En=0, N=15, a=4
    # clk=1, En=0, N=15, a=5
    # clk=0, En=0, N=15, a=6
    # clk=1, En=0, N=15, a=7
    # clk=0, En=0, N=15, a=6
    # clk=1, En=0, N=15, a=7
    # clk=0, En=0, N=15, a=8
    # clk=1, En=0, N=15, a=9
    # clk=0, En=0, N=15, a=8
    # clk=1, En=0, N=15, a=9
    # clk=0, En=0, N=15, a=10
    # clk=1, En=0, N=15, a=11
    # clk=0, En=0, N=15, a=10
    # clk=1, En=0, N=15, a=11
    # clk=0, En=0, N=15, a=12
    # clk=1, En=0, N=15, a=13
    # clk=0, En=0, N=15, a=12
    # clk=1, En=0, N=15, a=13
    # clk=0, En=0, N=15, a=14
    # clk=1, En=0, N=15, a=15
    # clk=0, En=0, N=15, a=14
    # clk=1, En=0, N=15, a=15
    ```
    ### Expected Output for Verification:
    ```
    # clk=0, En=0, N=15, a=0
    # clk=1, En=0, N=15, a=1
    # clk=0, En=0, N=15, a=0
    # clk=1, En=0, N=15, a=1
    # clk=0, En=0, N=15, a=2
    # clk=1, En=0, N=15, a=3
    # clk=0, En=0, N=15, a=2
    # clk=1, En=0, N=15, a=3
    # clk=0, En=0, N=15, a=4
    # clk=1, En=0, N=15, a=5
    # clk=0, En=0, N=15, a=4
    # clk=1, En=0,

- code: |-
    ```
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ```
    ### Result
    ![result](p1.png)
    
    ### Observation
    * Both the `a` and `N` signals are being sampled in the second waveform.
    
    ### Analyzer:
    * Signal `N` is a parameter in the module.
    * Signal `a` is an output from the module.
    * In the second waveform, Signal `a` is sampled before Signal `N`.
    * According to VHDL 1993 standard, "When an escaped name... appears in an expression, it is not evaluated.
    * Signal `N` is evaluated to 15 first before the second waveform.
    * The escaped name `N` is evaluated as a signal instead of a parameter.
    * When we evaluate an expression for the signal `a`, the escaped name `N` is being substituted with the 15-bits signal `N` and the `inside` operator is applied to the expression.
    * The result is a non-constant expression and it is evaluated as an unknown value.
    * The `a` signal is sampled an unknown value.
    * When the `En` signal is enabled during the second waveform, the `a` signal is sampled by the same unknown value.
    * According to VHDL 2008 standard, "Parameters are replaced during analysis and elaboration by expressions that evaluate to constants... This replacement is also known as parameter substitution."
    * This substitution is performed during the first waveform.
    * The escaped name `N` is replaced by the parameter `N` that is evaluated to 15.
    * The `inside` operator is applied to the expression.
    * This gives the correct result.
    
    ### Final Verilog Code:
    ```
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=15; // Set limit to 15
    En=0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ```
    ### Result
    ![result](p2.png)
    
    ### Observation
    * Both the `a` and `N` signals are being sampled in the second waveform.
    * In the second waveform, Signal `a` is sampled before Signal `N`.
    * Signal `N` is evaluated to 15 first before the second waveform.
    * This gives the correct result.
    
    ### Summary:
    * The escaped name `N` is replaced by the parameter `N` that is evaluated to 15.
    * The `inside` operator is applied to the expression.
    * The `a` signal is sampled an unknown value.
    * When the `En` signal is enabled during the second waveform, the `a` signal is sampled by the same unknown value.
    * According to VHDL 2008 standard, "Parameters are replaced during analysis and elaboration by expressions that evaluate to constants... This replacement is also known as parameter substitution."
    * This substitution is performed during the first waveform.
    * When the escaped name `N` is replaced by the parameter `N` that is evaluated to 15, the `inside` operator is applied to the expression.
    * The `a` signal is sampled by the correct value.
    * When the `En` signal is enabled during the second waveform, the `a` signal is sampled by

- code: |-
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt #(.SZ(4)) c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b,

- code: |-
    module mealy(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w or y)
        case (y)
            A: if (w)
                begin
                    z = 0;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
            B: if (w)
                begin
                    z = 1;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
    module top();
    import sv_rtl_pkg::*;
    parameter N = 2;
    parameter T = 4;
    parameter B = 3;
    initial begin
        $dumpfile("mealy.vcd");
        $dumpvars(0, mealy);
    end
    reg Clock, Resetn;
    reg [N-1:0] w, w_next;
    wire z;
    initial begin
        Clock = 1;
        repeat(10) #10 Clock = ~Clock;
        Resetn = 1;
        repeat(10) #10 Resetn = 1;
    end
    always #10 Clock = ~Clock;
    initial begin
        w = 0;
        $display("Initial w = %b", w);
        repeat(T) begin
            #1;
            w = w_next;
            $display("%t w = %b z = %b", $time, w, z);
        end
        $finish;
    end
    mealy #(N, T) dut(.

- code: |-
    ```
    module mealy_slice(Clock, Resetn, w, z);
    input Clock, Resetn, w[1:0];
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w[0] or w[1] or y)
        case (y)
            A: if (w[0] && w[1])
                begin
                    z = 0;
                    Y = B;
                end
            else if (w[0])
                begin
                    z = 0;
                    Y = A;
                end
            else
                begin
                    z = 1;
                    Y = B;
                end
            B: if (w[0] && w[1])
                begin
                    z = 1;
                    Y = B;
                end
            else if (w[0])
                begin
                    z = 0;
                    Y = A;
                end
            else
                begin
                    z = 1;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
    class mealy_slice_class;
    static logic Clock, Resetn, w[1:0];
    logic z;
    logic y, Y, z;
    parameter A = 0, B = 1;
    always @(w[0] or w[1] or y)
        case (y)
            A: if (w[0] && w[1])
                begin
                    z = 0;
                    Y = B;
                end
            else if (w[0])
                begin
                    z = 0;
                    Y = A;
                end
            else
                begin
                    z = 1;
                    Y = B;
                end
            B: if (w[0] && w[1])
                begin
                    z = 1;
                    Y = B;
                end
            else if (w[0])
                begin
                    z = 0;
                    Y = A;
                end
            else
                begin
                    z = 1;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endclass
    module mealy_slice_instance(Clock, Resetn, w, z);
    input Clock, Resetn, w[1:0];
    output z;
    mealy_slice_class my_inst;
    endmodule
    ### Test Bench:
    module mealy_slice_tb;
    reg Clock, Resetn;
    reg w[1:0];
    wire z;
    initial begin
        Clock = 0;
    end
    always begin
        Clock = ~Clock;
    end
    initial begin
        Resetn = 1;
        w[0] = 0;
        w[1] = 0;
        #2
        w[0] = 1;
        w[1] = 0;
        #2
        w[0] = 0;
        w[1] = 1;
        #2
        w[0] = 0;
        w[1] = 0;
        #2
        w[0] = 1;
        w[1] = 1;
        #2
        w[0] = 1;
        w[1] = 0;
        #2
        w[0] = 0;
        w[1] = 1;
        #2
        w[0] = 1;
        w[1] = 1;
        #2
        $finish;
    end
    mealy_slice_instance mealy_slice_1(Clock, Resetn, w, z);
    endmodule
    ```
    ### Test Bench Result:
    ![image](https://user-images.githubusercontent.com/12651024/160001077-8775cfbf-c700-4167-b74f-a7e6f898c7df.png)
    ### Conclusion:
    The code below is equivalent to

- code: |-
    module mealy(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1, W = 2;
    logic [2:0] w_i = W'(0);
    always @(w or y)
        case (y)
            A: if (W'(w_i) == W'(2'b01))
                begin
                    z = 0;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
            B: if (W'(w_i) == W'(2'b10))
                begin
                    z = 1;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
    ### Snapshot:
    ![Image of mealy_w_inside](mealy_w_inside.PNG)
    ### Synthesis Results:
    #### Base:
    ![Image of mealy_base.png](mealy_base.png)
    #### W_inside:
    ![Image of mealy_w_inside.png](mealy_w_inside.png)
    #### Synthesis Flow:
    ![Image of mealy_synth.png](mealy_synth.png)
    ### Test Bench:
    module tb_mealy();
    logic Clk, Resetn;
    logic w, z;
    logic [1:0] in1;
    logic [1:0] out1;
    logic [2:0] in2;
    logic [2:0] out2;
    
    mealy a1 (
    	.Clock(Clk),
    	.Resetn(Resetn),
    	.w(w),
    	.z(z)
    );
    
    
    initial Clk = 0;
    
    always #10 Clk = ~Clk;
    
    initial begin
    	Resetn = 0;
    	in1 = 2'b00;
    	in2 = 3'b000;
    	w = 0;
    	#100
    	Resetn = 1;
    	#100
    	in1 = 2'b00;
    	w = 1;
    	#100
    	in1 = 2'b01;
    	#100
    	in1 = 2'b10;
    	#100
    	in1 = 2'b11;
    	#100
    	in1 = 2'b01;
    	#100
    	in1 = 2'b00;
    	#100
    	in1 = 2'b01;
    	#100
    	in1 = 2'b00;
    	#100
    	in2 = 3'b100;
    	#100
    	in2 = 3'b101;
    	#100
    	in2 = 3'b110;
    	#100
    	in2 = 3'b111;
    	#100
    	in2 = 3'b010;
    	#100
    	in2 = 3'b011;
    	#100
    	in2 = 3'b001;
    	#100
    	in2 = 3'b000;
    	#100
    	#100
    	#100
    	#100
    	#100
    	w = 0;
    	#100
    	in2 = 3'b101;
    	#100
    	in2 = 3'b100;
    	#100
    	in2 = 3'b001;
    	#100
    	in2 = 3'b000;
    end
    
    always @(in1 or out1)
    	begin
    		out1 = out1 - 1'b1;
    	end
    
    always @(in2 or out2)
    	begin
    		out2 = out

- code: |-
    module mealy(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w or y)
        case (y)
            A: if (w)
                begin
                    z = 0;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
            B: if (w)
                begin
                    z = 1;
                    Y = B;
                end
            else
                begin
                    z = 0;
                    Y = A;
                end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
    class mealy_state;
        localparam N = 2;
        logic [N-1:0] w;
        always @(w)
        begin
            logic [N-2:0] w_n;
            inside {w[1:N-1], w[0]} begin
                A : w_n = '0;
                B : w_n = '0;
                default : w_n = '0;
            end
            w = w_n;
        end
    endclass
    module top;
        mealy_state mealy_inst;
        mealy uut(.Clock,.Resetn,.w(mealy_inst.w),.z);
    endmodule
    ### Original TestBench Code:
    module mealy_tb;
    reg clock, resetn;
    reg w;
    wire z;
    mealy mr (.Clock(clock),.Resetn(resetn),.w(w),.z(z));
    localparam T = 100;
    initial
        begin
            resetn = 0;
            #T resetn = 1;
            #T w = 0;
            #T w = 1;
            #T w = 0;
            #T w = 1;
            #T $finish;
    end
    always #10 clock = ~clock;
    endmodule
    ### Variation TestBench Code:
    module mealy_tb;
    reg clock, resetn;
    reg w;
    wire z;
    mealy_state mealy_inst;
    mealy u

- code: |-
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= y + 1'b1;
      end else begin
      inside
        case (y)
        0 : if (w[0])
          z = 0;
        else
          z = 1;
      1 : if (w[1])

- code: |-
    ```vhdl
    module mux4to1(w0, w1, w1, w3, S, f);
    input w0, w1, w1, w3;
    input [1:0] S; // S is now a 2-bit packed vector
    output f;
    reg f;
    reg [2:0] const = 3'b000; // declared outside mux
    
    always @(w0 or w1 or w2 or w3 or S)
        if (inside(S, const))
            f = w0;
        else if (inside(S, const+1))
            f = w1;
        else if (inside(S, const+2))
            f = w2;
        else if (inside(S, const+3))
            f = w3;
    endmodule
    ```
    ### Output:
    ![](./images/mux4to1.png)
    ### Notes:
    * The inside function returns true if the bit position specified by the 1st argument is equal to the constant value specified by the 2nd argument.
    * The packed vector (const) is declared at module

- code: |-
    ```verilog
    module mux4to1(w0, w1, w1, S, f);
    input w0, w1, w1, S;
    output f;
    reg f;
    const_1 [0:1] sel = 'b01;
    always @(w0 or w1 or w1 or S) begin
        inside(S, sel)
            f =

- code: |-
    ```
    module mux4to1(w0, w1, w1, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    reg [1:0] s_list;
    always @(w0 or w1 or w2 or w3 or S)
        if (inside(S,s_list))
            f = w3;
        else
            f = w1;
    endmodule
    ```
    ### Replay Code:
    ```
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg [1:0] s_list = {1'b0, 1'b0};
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (inside(S,s_list))
            f = w3;
        else
            f = w1;
    endmodule
    ```
    ### Test Vector:
    | w0 | w1 | w2 | w3 | S | f |
    | -- | -- | -- | -- | --| -- |
    | 0  | 1  | 0  | 1  | 00 | 0 |
    | 1  | 0  | 1  | 0  | 00 | 1 |
    | 0  | 0  | 0  | 1  | 01 | 1 |
    | 1  | 1  | 1  | 0  | 01 | 0 |
    | 0  | 0  | 0  | 0  | 11 | 0 |
    | 0  | 0  | 0  | 0  | 10 | 1 |
    | 1  | 1  | 1  | 1  | 11 | 1 |
    | 1  | 1  | 1  | 1  | 10 | 1 |
    
    ### Expected Result
    ![image](https://user-images.githubusercontent.com/66383745/139536347-fbf9f0f4-3398-471c-8f8f-b724e2346b94.png)
    ### Observation Result
    ![image](https://user-images.githubusercontent.com/66383745/139537192-7558338e-30c3-4c28-9236-49931575b647.png)
    ### Pass/Fail:
    FAIL
    ### Explanation for Failure:
    In a case that the signal `f` should be set to `0`, it is not the case because of the signal `S` remains the same as `1'bxx`, where `xx` does not exist in the `s_list`. `f` is set to `1` because of the last statement of the `if

- code: |-
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0]

- code: |-
    ```Verilog
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    // Insert a constant-packed array declared at module scope
    enum{JK,HY}Sv[2:0]={2'b10,2'b01,2'b00};
    inside
    always @(w0 or w1 or w2 or w3 or S)
        if (S inside {Sv})
            f = Sv[S];
    endmodule
    ```
    ### Simulation Result:
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-1.png?raw=true)
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-2.png?raw=true)
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-3.png?raw=true)
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-4.png?raw=true)
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-5.png?raw=true)
    ![image](https://github.com/GoldPiggy/Verilog-Code-Examples/blob/master/Chapter%2009/9.3-2/image/mux4to1-6.png?raw=true)
    
    ### Design Constraints
    - The `inside` operator allows the use of a constant-packed array declared at module scope:
    ###### Module
    ```Verilog
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    // Insert a constant-packed array declared at module scope
    enum{JK,HY}Sv[2:0]={2'b10,2'b01,2'b00};
    always @(w0 or w1 or w2 or w3 or S)
        if (S inside {Sv})
            f = Sv[S];
    endmodule
    ```
    ###### Testbench
    ```Verilog
    module mux4to1_tb();
    reg [1:0] S;
    reg w0, w1, w2, w3;
    wire f;
    mux4to1 u1(w0, w1, w2, w3, S, f);
    initial begin
        $dumpfile("mux4to1.vcd");
        $dumpvars(0,mux4to1);
        $dumpvars(0,mux4to1_tb);
        S  = 2'b00;
        w0 = 1'b0;
        w1 = 1'b0;
        w2 = 1'b0;
        w3 = 1'b0;
        #10
        S  = 2'b01;
        w0 = 1'b1;
        w1 = 1'b0;
        w2 = 1'b0;
        w3 = 1'b0;
        #10
        S  = 2'b10;
        w0 = 1'b0;
        w1 = 1'b1;
        w2 = 1'b0;
        w3 = 1'b0;
        #10
        S  = 2'b10;
        w0 = 1'b0;
        w1 = 1'b0;

- code: |-
    module alu2(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    wire [3:0] A2;
    wire [3:0] A2_const;
    reg [3:0] const_array[4] = {5, 6, 3, 4};
    reg [7:0] i = 8'd0;
    reg [7:0] iter = 8'd0;
    always @ (posedge Clk) begin
        if (reset == 1'b0) begin
            iter <= 8'd0;
        end
        else if (iter < 4) begin
            i <= i + 1;
            if (s == const_array[i]) begin
                iter <= i + 1;
            end
            else begin
                iter <= 8'd0;
            end
        end
    end
    always @(s or A or B)
        case (s)
            0: begin
                F = 4'b0000;
            end
            1: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 0) begin
                    F = B - A2_const;
                end
                else begin
                    F = 4'b1111;
                end
            end
            2: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 1) begin
                    F = A2_const - B;
                end
                else begin
                    F = 4'b1111;
                end
            end
            3: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 2) begin
                    F = A2_const + B;
                end
                else begin
                    F = 4'b1111;
                end
            end
            4: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 3) begin
                    F = A2_const ^ B;
                end
                else begin
                    F = 4'b1111;
                end
            end
            5: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 3) begin
                    F = A2_const | B;
                end
                else begin
                    F = 4'b1111;
                end
            end
            6: begin
                A2 = A;
                A2_const = A[2:1];
                if (iter == 3) begin
                    F = A2_const & B;
                end
                else begin
                    F = 4'b111

- code: |-
    module

- code: |-
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    reg [2:0] mask;
    reg [3:0] var;
    reg [3:0] const [3:0] arr = {8'd12, 8'd14, 8'd13, 8'd11};
    
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: begin
                var <= A;
                F <= B - var;
            end
            2: begin
                var <= B;
                F <= A - var;
            end
            3: begin
                var <= A;
                F <= var + B;
            end
            4: begin
                var <= A;
                F <= var ^ B;
            end
            5: begin
                var <= A;
                F <= var | B;
            end
            6: begin
                var <= A;
                F <= var & B;
            end
            7: F = 4'b1111;
        endcase
    endmodule
    ### Verification:
    - Design Pass/Fail: Pass
    - RTL Validation: Pass
    - Compilation: Pass
    - Simulation: Pass (with warnings)
      - Warnings:
        - Simulation: 1 (Warnings)
        - 1: line 8: Verilog HDL warning at alu.v(8): expression does not conform to its actual type 
        - 2: line

- code: |-
    ```
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    wire [3:0] Ai;
    wire [3:0] Bi;
    reg [3:0] index;
    // Define array of constant ranges
    ALU_ARRAY[2:0] = {3'b100, 3'b010, 3'b001};
    // Insert below line
    inside Ai = A[ALU_ARRAY[s][0][2:0] : ALU_ARRAY[s][0][5:3]];
    // Insert below line
    inside Bi = B[ALU_ARRAY[s][0][2:0] : ALU_ARRAY[s][0][5:3]];
    
    always @(s or Ai or Bi)
        case (s)
            0: F = 4'b0000;
            1: F = Bi - Ai;
            2: F = Ai - Bi;
            3: F = Ai + Bi;
            4: F = Ai ^ Bi;
            5: F = Ai | Bi;
            6: F = Ai & Bi;
            7: F =

- code: |-
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    reg [3:0] A_inside;
    assign A_inside = A[s];
    always @(s or A_inside or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A_inside;
            2: F = A_inside - B;
            3: F = A_inside + B;
            4: F = A_inside ^ B;
            5: F = A_inside | B;
            6: F = A_inside & B;
            7: F = 4'b1111;
        endcase
    endmodule
    ### Screenshot of the Output:
    <img width="1792" alt="Screenshot 2022-

- code: |-
    module Johnson_Counter (count, inside);
    output [3: 0] count;
    output inside;
    reg [3: 0] count;
    reg inside;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule
    
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    wire inside;
    generate
    Johnson_Counter M0 (count, inside);
    endgenerate
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule
    ### Discussion:
    The `inside` signal

- code: |-
    ```verilog
    module Johnson_Counter (count, enable, clock, reset, n);
    parameter N = 8;
    output count;
    input enable;
    input clock, reset;
    reg [2: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    3'b000,
    3'b001,
    3'b011,
    3'b111: count <= {count[1: 0], 1'b1};
    3'b111,
    3'b110,
    3'b100,
    3'b000: count <= {count[1: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule
    
    module t_Johnson_Counter ();
    wire [7: 0] count;
    wire [7: 0] n;
    reg [2: 0] johnson_count [8: 0];
    reg enable;
    reg clock, reset;
    initial begin
    for (int i = 0; i < 9; i = i + 1) begin
    johnson_count[i] = 0;
    end
    end
    integer i;
    generate
    for (i = 0; i < 9; i = i + 1) begin: gen
    Johnson_Counter M0 (johnson_count[i], enable, clock, reset, i);
    end
    endgenerate
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    assert property (@ (posedge clock) (inside({johnson_count[0], johnson_count[1], johnson_count[2], johnson_count[3], johnson_count[4], johnson_count[5], johnson_count[6], johnson_count[7], johnson_count[8]})));
    endmodule
    ```
    ### Variation Instruction:
    Use a generate with for loop to wrap the Johnson

- code: |-
    ```verilog
    module Display_Counter (display, clock);
    output [7: 0] display;
    input clock;
    reg [3: 0] count;
    always @ (posedge clock)
    count <= count + 1;
    always @ (posedge clock)
    if (count < 8'b10000000)
    display <= count;
    else
    display <= 8'b00000001;
    endmodule
    
    module t_Display_Counter ();
    wire [7: 0] display;
    reg clock;
    Display_Counter M0 (display, clock);
    reg [3: 0] count_arr [0: 3];
    initial #500 $finish;
    initial fork
    join
    endmodule
    ```
    ### Reference:
    <a href="https://verificationacademy.com/courses/verilog-hard">https://verificationacademy.com/courses/verilog-hard</a>
    
    **19. Count number of times clock is low and display it on counter.**
    
    ### Base Verilog Code:
    module Display_Counter (display, clock);
    output [7: 0] display;
    input clock;
    reg [3: 0] count;
    always @ (posedge clock)
    count <= count + 1;
    always @ (posedge clock)
    if (count < 8'b10000000)
    display <= count;
    else
    display <= 8'b00000001;
    endmodule
    
    module t_Display

- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    parameter N = 10;
    output [N - 1: 0] count;
    input enable;
    input clock, reset;
    reg [N - 1: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    genvar i;
    generate for (i = 0; i < N; i = i + 1)
    begin
    if (i[0] == 0) begin
    if (i[1] == 0) begin
    if (i[2] == 0) begin
    if (i[3] == 0) begin
    if (i[4] == 0)
    count[i] <= 0;
    else if (i[5] == 0)
    count[i] <= {count[i - 1], 1'b1};
    else
    count[i] <= count[i - 1] + 1;
    end
    else if (i[4] == 0)
    count[i] <= {count[i - 1], 1'b1};
    else
    count[i] <= count[i - 1] + 1;
    end
    else if (i[3] == 0)
    count[i] <= {count[i - 1], 1'b1};
    else
    count[i] <= count[i - 1] + 1;
    end
    else if (i[2] == 0)
    count[i] <= {count[i - 1], 1'b1};
    else
    count[i] <= count[i - 1] + 1;
    end
    else
    count[i] <= count[i - 1] + 1;
    end
    end
    endgenerate
    endcase
    endmodule
    
    module t_Johnson_Counter ();
    wire [10 - 1: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule
    ### Output:
    ```text
    t_Johnson_Counter.v:5: `ifdef does not take arguments.
    t_Johnson_Counter.v:5: Illegal reference to genvar.
    t_Johnson_Counter.v:8: genvar declarations must precede any generate statements.
    t_Johnson_Counter.v:8: generate must be followed by a semicolon.
    t_Johnson_Counter.v:8: Syntax error.
    t_Johnson_Counter.v:8: `ifdef does not take arguments.
    t_Johnson_Counter.v:8: Illegal reference to genvar.
    t_Johnson_Counter.v:11: genvar declarations must precede any generate statements.
    t_Johnson_Counter.v:11: generate must be followed by a semicolon.
    t_Johnson_Counter.v:11: Syntax error.
    t_Johnson_Counter.v:11: `ifdef does not take arguments.
    t_Johnson_Counter.v:11: Illegal reference to genvar.
    t_Johnson_Counter.v:15: genvar declarations must precede any generate statements.
    t_Johnson_Counter.v:15: generate must be followed by a semicolon.
    t_Johnson_Counter.v:15: Syntax error.
    t_Johnson_Counter.v:15: `ifdef does not take arguments.
    t_Johnson_Counter.v:15: Illegal reference to genvar.
    t_Johnson_Counter.v:19: genvar declarations must precede any generate statements.
    t_Johnson_Counter.v:19: generate must be followed by a semicolon.
    t_Johnson_Counter.v:19: Syntax error.
    t_Johnson_Counter.v:19: `ifdef does not take arguments.
    t_Johnson_Counter.v:19: Illegal reference to genvar.
    t_Johnson_Counter.v:23: genvar declarations must precede any generate statements.
    t_Johnson_Counter.v:23: generate must be followed by a semicolon.
    t_Johnson_Counter

- code: |-
    module Johnson_Counter_Mod (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule
    module t_Johnson_Counter_Mod ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter_Mod M0 (count, enable, clock, reset);
    wire [3: 0] counter_array [0: 15];
    initial begin
    counter_array[0] = 0;
    counter_array[1] = 1;
    counter_array[2] = 2;
    counter_array[3] = 3;
    counter_array[4] = 4;
    counter_array[5] = 5;
    counter_array[6] = 6;
    counter_array[7] = 7;
    counter_array[8] = 8;
    counter_array[9] = 9;
    counter_array[10] = 10;
    counter_array[11] = 11;
    counter_array[12] = 12;
    counter_array[13] = 13;
    counter_array[14] = 14;
    counter_array[15] = 15;
    
    end
    always @ (posedge clock, posedge reset)
    if (reset == 1) begin
    enable = 0;
    counter_array[0] = 0;
    counter_array[1] = 1;
    counter_array[2] = 2;
    counter_array[3] = 3;
    counter_array[4] = 4;
    counter_array[5] = 5;
    counter_array[6] = 6;
    counter_array[7] = 7;
    counter_array[8] = 8;
    counter_array[9] = 9;
    counter_array[10] = 10;
    counter_array[11] = 11;
    counter_array[12] = 12;
    counter_array[13] = 13;
    counter_array[14] = 14;
    counter_array[15] = 15;
    
    end
    generate
    for(i = 0; i < 16; i = i + 1)
    begin: Johnson_Counter_Mod_i
    Johnson_Counter_Mod M0 (count, enable, clock, reset);
    assign counter_array[i] = count;
    end
    endgenerate
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork

- code: |-
    ```
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4);
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
        c1=pla(p1, p5, p9); // Flip flop C1
        c2=pla(p3, p6, p2); // Flip flop C2
        c3=pla(p4, p7, p8); // Flip flop C3
        c4=pla(p2, p8, p4); // Flip flop C4
      end
      function [1:0] pla; // PLA-based function
        input wires [1:0] a;
        reg [1:0] out;
        initial begin
          out=a[0];
          $async$and(out, out, a[

- code: |-
    ```
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Declare function call to logic
        function logic_func(logic_index, logic_input);
          logic_func = logic_index? logic_input :!logic_input;
        endfunction: logic_func
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {logic_func(p1,b1),logic_func(p2,b0),logic_func(p3,a1),logic_func(p4,a0),logic_func(p5,b1),logic_func(p6,b0),logic_func(p7,a1),logic_func(p8,a0),logic_func(p9,b1)}); // Corrected input order?
        $async$or$array(mor, {logic_func(c1,p1),logic_func(c2,p2),logic_func(c3,p3),logic_func(c4,p4),logic_func(c4,p5),logic_func(c3,p6),logic_func(c2,p7),logic_func(c1,p8),logic_func(c4,p9)}, {c4,c3,c2,c1}); // Corrected output order?
      end
    endmodule
    ```
    ### Simulator Checks:
    - Checks that the design is stable without errors. (OK)
    ### Compliant Code Examples:
    ```
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Declare function call to logic

- code: |-
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
        c1=mult(p1,p2,p3,p4);
        c3=mult(p5,p6,p7,p8);
        c2=mult(p9,p9,p9,p9);
        //c4=mult(p1,p2,p3,p4);
      end
      function integer mult(input [1:3] p); // Generic multiplication function
        integer r;
        r=p[0]*p[0]+p[1]*p[1]+p[2]*p[2];
        return r;
      endfunction
    endmodule
    ### Simplified Base Code:
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // Improved with function
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      function integer mult(input [1:3] p); // Generic multiplication function
        integer r;
        r=p[0]*p[0]+p[1]*p[1]+p[2]*p[2];
        return r;
      endfunction
      initial begin
        c1=mult({b1,b0,a1,a0}[3:0]);
        c2=mult({b1,b0,a1,a0}[7:4]);
        c3=mult({b1,b0,a1,a0}[11:8]);
        c4=mult({b1,b0,a1,a0}[15:12]);
      end
    endmodule
    ### Simplified Variation Code:
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4);
      input a

- code: |-
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      function automatic [1:9] p; // Flip-flops are not allowed in function definitions
        input [1:9] a;
        begin
          integer i;
          for (i=1; i<10; i=i+1) begin
        	if (a[i]) p=i;
          end
        end
      endfunction
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, p);  // FIXME
        $async$or$array(mor, p, {c4,c3,c2,c1});  // FIXME
      end
    endmodule
    ### Example Command(s):
    ```commandline
    # Create base multiplier
    > read_verilog mltp_a.v
    # Make modification
    > read_verilog mltp_b.v
    > select_object mltp_b a1 a0 b1 b0 c1 c2 c3 c4
    > run_pass -nocheck_design -pre_logical_effort 2
    ```
    ### Expected Results:
    * A new multiplier with flip-flops in its function definition, should be created
    * The multiplier should be synthesized correctly
    
    ### Known Errors:
    This test fails when run with the following error:
    ```
    ERROR: [Common 17-259] Verilog HDL error at mltp_b.v(33): Illegal assignment to 'p', a function.
    ```
    
    ### Coresponding Warnings:
    All warnings have been disabled
    
    ### Corective Action:
    Replace the direct PLA output logic with a function call in the array index used within a `inside` range list as shown in the `mtlp_b` verilog module.
    
    ### Verification Steps:
    1. Run the following command:
       ```commandline
       $ make clean
       $ make synth
       ```
    2. Open Synopsys Design Constraints (SDC) file `mltp.sdc`
    3. Verify the following constraints have been generated:
       ```
       create_generated_clock -add -src a0 -period 3 -name a0
       create_generated_clock -add -src a1 -period 3 -name a1
       create_generated_clock -add -src b0 -period

- code: |-
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
        //Instantiate multiplier using function call
        multiply_array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        // Instantiate PLA using function call
        // $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});
        // $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1});
      end
      // Function to compute 2x2 multiplier
      function [1:0] multiply_array(reg[1:4] in_array[1:9],
                reg[1:0] input_array[1:4], reg[1:0] output_array[1:4]);
        multiply_array = in_array[output_array]&input_array;
      endfunction
    endmodule
    ### Simulation Logic for Base Verilog Code:
    a1=1, a0=1, b1=1, b0=1, c1=1, c2=0, c3=1, c4=0  
    a1=0, a0=0, b1=0, b0=0, c1=0, c2=0, c3=0, c4=0  
    a1=0, a0=0, b1=1, b0=0, c1=0, c2=1, c3=0, c4=0  
    a1=0, a0=0, b1

- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    inside_i #(.constant_list( {1,2,3} ) ) inside_i_inst(.*);
    always @( s ) begin : force_a_1
    if ( inside_i_inst.inside(s, inside_i_inst.constant_list) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ### Interface Definition File:
    ### Generated by VCS
    interface inside_i;
    logic [7:0][1:0] constant_list;
    logic [2:0] s;
    logic [1:0] s_const_list[5:0];
    
    localparam constant_list = '{-32'sd0, '32'sd0, '64'sd0};
    task inside( s, s_const_list );
        if ( inside_i_const_list_size == 0 ) begin
            return 0;
        end
        for (int i = 0 ; i < inside_i_const_list

- code: |-
    ```verilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s inside {1'b1, 1'b0} )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clock

- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s!= 1'b1 )
    begin
    end else begin
    deassign q;
    deassign q_b

- code: |-
    ```verilog
    interface IFC;
    wire s, r;
    const string str1 = "string1";
    modport MP1 ( input s, r,
                  output q );
    endinterface
    ```
    ```verilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( inside {str1} ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ```
    ### Expected Output:
    ```verilog
    Error: (vlog-13069) Illegal reference to "d_ff". It should only appear as a module path.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13205) $fopen failed.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13069) Illegal reference to "d_ff". It should only appear as a module path.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13205) $fopen failed.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    ```
    ### Actual Output:
    ```verilog
    Error: (vlog-13069) Illegal reference to "d_ff". It should only appear as a module path.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13205) $fopen failed.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13069) Illegal reference to "d_ff". It should only appear as a module path.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    Error: (vlog-13205) $fopen failed.
        Time: 0 ps  Iteration: 0  Instance: /d_ff/0
    ```
    ## Pass the Testcase
    
    ### Pre-Condition:
    - Load _d_ff.v_ to the project
    - Add _d_ff.v_ to the compilation unit
    - Add _d_ff_tb.v_ to the compilation unit
    - Add _d_ff_tb.v_ to the elaboration call
    - Open the transcript tab of the project
    ### Step1:
    - Add interface `IFC` to _d_ff_tb.v_
    ### Step2:
    - Add interface instantiation to _d_ff.v_
    ### Step3:
    - Add interface port connection to _d_ff_tb.v_
    
    ### Run the testcase
    
    ```verilog
    module d_ff_tb();
    wire d, q;
    d_ff DUT (
    .d(d),
    .clk(clk),
    .s(s),
    .r(r),
    .q(q),
    .q_b(q_b)
    );
    reg  clk = 0;
    reg  d = 0;
    reg  s = 0;
    reg  r = 0;
    reg  q = 0;
    reg  q_b = 0;
    initial begin
    $monitor("%d", q);
    end
    always begin
    #5;
    clk = ~clk;
    d = 0;
    s = 0;
    r = 0;
    #10
    s = 1;
    #10
    s = 0;
    r = 1;
    #5
    r = 0;
    #10
    s = 1;
    #10
    s = 0;
    r = 1;
    #5
    r = 0;
    #10
    s = 1;
    #10
    s = 0;
    r = 1;
    #5
    r = 0;
    #10
    s = 1;
    #10

- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r inside {1'b1,1'b0} )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ### Note:
    If the `r` is not inside the constant declared in interface scope, the code is in an illegal state.
    ### Actual Result:
    Error
    ### Expected Result:
    Pass
    ### Code:
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r inside {1'b1,1'b0} )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ### Note:
    If the `r` is inside the constant declared in interface scope, the code is in a legal state.
    ### Actual Result:
    Pass
    ### Expected Result:
    Pass
    ### Base Verilog Code:
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge

- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,

- code: |-
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i; // Should be reg i0, i1

- code: |-
    module top();
    generate
    	ttst_ttrimux2_1 u1();
    endgenerate
    initial begin
    	$dumpfile("dump.vcd");
    	$dumpvars(1,top);
    	$dumpvars(1,u1);
    end
    initial #1 $monitor("s = ttst_ttrimux2_1::s");
    initial #1 $monitor("in1 = ttst_ttrimux2_1::i0");
    initial #1 $monitor("in2 = ttst_ttrimux2_1::i1");
    initial #1 $monitor("enable = ttst_ttrimux2_1::e");
    initial #1 $monitor("sel = ttst_ttrimux2_1::s");
    initial #1 $monitor("output = ttst_ttrimux2_1::out");
    initial begin
    	#50 
    	u1.s = 0;
    	#50
    	u1.s = 1;
    	#40 
    u1.e

- code: |-
    module ttst_ttrimux2_1();
    reg e;
    reg [1:0]i;
    reg s;
    wire out;
    // ttrimux2_1 mm(out,e,i,s);
    initial begin
    e=0,i=0,s=0;
    end
    always begin
    end
    initial
    begin
    #2 e =0,i = 2'b00,s = 1'b0;
    #3 e =1,i = 2'b01,s = 1'b1;
    #5 e =0,i = 2'b10,s = 1'b0;
    #7 e =1,i = 2'b10,s = 1'b1;
    #9 e =0,i = 2'b10,s = 1'b1;
    #11 e =1,i = 2'b01,s = 1'b0;
    #12 e =0,i = 2'b10,s = 1'b1;
    #14 e =0,i = 2'b00,s = 1'b0;
    #16 e =1,i = 2'b11,s = 1'b1;
    #18 e =1,i = 2'b00,s = 1'b1;
    #20 e =0,i = 2'b11,s = 1'b1;
    #22 e =1,i = 2'b10,s = 1'b0;
    #24 e =1,i = 2'b11,s = 1'b1;
    #26 e =1,i = 2'b0,s = 1'b1;
    #28 e =0,i = 2'b10,s = 1'b0;
    #30 e =0,i = 2'b11,s = 1'b0;
    e =0; i = 2'b00; s = 1'b0;
    end
    initial
    $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;

- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1

- code: |-
    ```
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clr=%b, pr=%b, di=%b, q=%b ", $time,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    module dffalter(
    output q,
    output qb,
    input di,
    input clk,
    input clr,
    input pr
    );
    reg [7:0] reg;
    initial reg = 8'd0;
    always @ (posedge clk or posedge pr)
    	if (pr) reg[7:0] <= 8'd32;
    	else reg[7:0] <= di;
    endmodule
    package packagedff;
    parameter [7:0] presetval = 8'd32;
    endpackage
    ```
    ### Expected Results:
    The design should simulate as follows:
    ```
    >./bin_verilog/dffalter_tst
    t=0, clr=1, pr=0, di=1, q=1
    t=20, clr=0, pr=1, di=1, q=32
    t=46 $finished
    ```
    ### Actual Results:
    The design fails at simulation with the following errors on the `always #20 pr =1'b0;` line:
    ```
    Error: C:/Users/michael/Documents/GitHub/EE240L-Verilog/Lab7/src/dffalter_tst.sv(20): (vsim-3006)
    Simulation failed.:
    C:/Users/michael/Documents/GitHub/EE240L-Verilog/Lab7/src/dffalter_tst.sv(17): (vlog-2726) HDL error at
    dffalter_tst.sv(17): syntax error near "|=".
    C:/Users/michael/Documents/GitHub/EE240L-Verilog/Lab7/src/dffalter_tst.sv(17): (vlog-2726) HDL error at
    dffalter_tst.sv(17): syntax error near "|=".
    C:/Users/michael/Documents/GitHub/EE240L-Verilog/Lab7/src/dffalter_tst.sv(17): (vlog-2726) HDL error at
    dffalter_tst.sv(17): syntax error near "|=".
    C:/Users

- code: |-
    module dffalter_tst(
    ); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q;
    reg [7:0] pr_r;
    parameter DW = 8;
    parameter SW = 0;
    parameter EW = DW-1;
    wire [DW-1:0] pr_vals = {4'b100,4'b001,4'b000,4'b111,4'b110,4'b011,4'b010,4'b001};
    // dffalter dff(q,q

- code: |-
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clr=%b, pr=%b, di=%b, q=%b ", $time,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    ### Source Code:
    package cnstdff // Package for DFF
    (parameter WIDTH=8); // Width can be modified
    localparam HIGH = WIDTH-1; // This is needed to index correctly in the array
    typedef logic [WIDTH-1:0] dff_t; // Define the base data type for the DFF
    localparam DFF_T_ALT = '{default: 1'bx}; // Alternate DFF type, useful for instantiation
    function automatic dff_t dff_dout(dff_t din, dff_t din_p, logic clear_p, logic preset_p); // Alternate DFF function
    logic [$clog2(WIDTH):0] l = 0;
    dff_t dout = 0;
    localparam DFF_T_ALT_ARG = DFF_T_ALT[WIDTH-1:0]; // Alternate DFF type array, useful for instantiation
    dff_t dout_alt[DFF_T_ALT_ARG] = '{default: 1'bx}; // Alternate DFF output array, useful for instantiation
    for (l=0; l<=HIGH; l=l+1) begin: dff_dout_loop
    // dout_alt[l] = (l==HIGH)? din_p : dout_alt[HIGH-l]; // Alternate DFF function array
    dout = (l==HIGH)? din_p : dout_alt[HIGH-l]; // Alternate DFF function
    end
    return dout;
    endfunction
    endpackage
    ### Base Verilog Code:
    module dffalter
    #(parameter WIDTH=8) // Width can be modified
    (output logic q,qb, input logic di,clk,clr,pr);
    localparam HIGH = WIDTH-1; // This is needed to index correctly in the array
    localparam DFF_T = cnstdff::dff_t; // Define the base data type for the DFF
    localparam DFF_T_ALT = cnstdff::DFF_T_ALT; // Alternate DFF type, useful for instantiation
    localparam IN_Q = "in_q"; // Input port name for initial register value
    localparam IN_QB = "in_qb"; // Input port name for initial register value
    localparam IN_DI = "in_di"; // Input port name for initial register value
    localparam IN_CLK = "in_clk"; // Input port name for initial register value
    localparam IN_CLR = "in_clr"; // Input port name for initial register value
    localparam IN_PR = "in_pr"; // Input port name for initial register value
    // Using a parameterized type to declare the array size
    DFF_T_ALT dout_alt[WIDTH-1:0]; // Declare DFF array
    logic [$clog2(WIDTH):0] l; // This is needed to index correctly in the array
    DFF_T din_p;
    always @(posedge clk) // Changed reset to clock edge
    begin
    // din_p = pr? di : '{default: 1'bx}; // Initial value in preset
    din_p = cnstdff::dff_dout(di, din_p, clr, pr); // Alternate DFF function
    q = d

- code: |-
    module dffalter(output q, qb, input di, clk, clr, pr);
    // parameter WIDTH=32; // Moved to Package
    localparam WIDTH=5; // Modified to get desired width
    // reg [WIDTH-1:0] q0; // Moved to Package
    // reg q0b; // Moved to Package
    // always @(posedge clk) begin q0<=di; q0b<=~di; end // Moved to Package
    // wire [WIDTH-1:0] q1; // Added q1
    // reg [WIDTH-1:0] q1b; // Added q1b
    // wire [2:0] qb; // Modified
    // reg [2:0]

- code: |-
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    reg [3:0] pck[4:0]; // Packed array
    integer i;
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clr=%b, pr=%b, di=%b, q=%b ", $time,clr,pr,di,q); // Changes made
    initial $monitor("t=%0d, q=%b, qb=%b ", $time,q,qb); // Changes made
    initial $monitor("t=%0d, pck=%b, pck[1]=%b, pck[2]=%b ", $time,pck,pck[1],pck[2]); // Changes made
    for (i=0;i<5;i=i+1)
    begin
    initial #10 pck[i]=i; // Initial values
    end
    initial #46 $stop; // Stop simulation
    
    endmodule
    ### Expected Results
    ![Expected Results for this variation](/images/2020-05-18-Verilog-Examples-Variation-5-Expected-Results.png)
    
    ### Possible Error Scenarios for this variation
    - The first monitor, the only one using the signal clr, shows a wrong value as it is using the output signal clr. It should be using the input signal clr instead. The second monitor has the correct clr value.
    - The second monitor, the only one using the signal pr, shows a wrong value as it is using the output signal pr. It should be using the input signal pr instead. The second monitor has the correct pr value.
    - The third monitor, the only one using the signal q, shows a wrong value as it is using the output signal qb. It should be using the input signal qb instead. The second monitor has the correct q value.
    - The fourth monitor, the only one using the signal di, shows a wrong value as it is using the output signal qb. It should be using the input signal di instead. The second monitor has the correct di value.
    - The fifth monitor, the only one using the signal q, shows the correct value.
    - The sixth monitor, the only one using the signal qb, shows the correct value.
    - The seventh monitor, the only one using the signal pck, shows the correct value.
    - The eighth monitor, the only one using the signal pck[1:3], shows the correct value.
    - The ninth monitor, the only one using the signal pck[1], shows the correct value.
    - The tenth monitor, the only one using the signal pck[2], shows the correct value.
    ### Assumptions for this variation
    - The value of the signal q should equal the value of the signal di.
    - The value of the signal qb should equal the value of the signal di.
    - The value of the signal q should equal the value of the signal pr.
    - The value of the signal qb should equal the value of the signal pr.
    - The value of the signal clr should equal 0.
    - The value of the signal pr should equal 1.
    - The value of the signal di should equal 0.
    - The fifth monitor should be the first monitor in the list.
    - The sixth monitor should be the second monitor in the list.
    - The seventh monitor should be the third monitor in the list.
    - The eighth monitor should be the fourth monitor in the list.
    - The ninth monitor should be the fifth monitor in the list.
    - The tenth monitor should be the sixth monitor in the list.
    ### Additional Comments
    This variation was the most challenging for me. Originally I had the code where I set up the packed array being executed inside an always block. I put the always block in a loop because I didn't know how to

- code: |-
    ```vlog
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    ```
    ### Expected Result:
    #### Test Bench
    ```vlog
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;
    
    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    Clock_Gen M2(clk);
    
    initial #1000 $finish;
    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork
    join
    begin // Verify left shift
    s1 = 0; s0 = 1;
    join
    begin // Verify load
    s1 = 0; s0 = 3;
    join
    begin // reset
    s1 = 0; s0 = 0;
    join
    ```
    #### Output
    ```text
    ** Warning (testbench,18): testbench.v(56): 'inside' is a sensitive directive. Use of 'inside' in a sensitivity list is deprecated and may result in simulation failures, errors, or unpredictable behavior.
    VCD info: dumpfile t_Universal_Shift_Reg.vcd opened for output.
    VCD info: dumpfile t_Universal_Shift_Reg.vcd created.
    VCD info: time unit is ns, 1ns period
    PASS 1: Universal_Shift_Reg 
      [==========] 2 test(s) run.
      [  PASSED  ] 2 test(s).
    VCD info: Exiting because the dumpfile has no more than 10 variables in it.
    Testbench done
    $sh vvp -N t_Universal_Shift_Reg t_Universal_Shift_Reg.v
    0: Idle
    3: Load
    1: Shift Left
    2: Shift Right
    $sh gtkwave t_Universal_Shift_Reg.vcd
    ```
    ### Modification Summary:
    Added `inside` directive to `M1` module.
    
    ### Actual Result:
    #### Test Bench
    ```vlog
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;
    
    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In,

- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    
    wire s1_inside [0: 3];
    wire s0_inside [0: 3];
    assign s1_inside = {s1, s0, s1, s0};
    assign s0_inside = {s0, s1, s0, s1};
    
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1_inside, s0_inside})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;
    
    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    Clock_Gen M2(clk);
    
    initial #1000 $finish;
    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join
    
    join
    endmodule
    
    
    ### Base Verilog Code:
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    wire [1: 0] s1, s0;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t

- code: |-
    ```Verilog
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;
    
    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    int i;
    Clock_Gen M2(clk);
    
    initial begin
    $dumpfile("Test_Variation_1.vcd");
    $dumpvars(2, Universal_Shift_Reg);
    end
    initial #1000 $finish;
    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join
    
    join
    endmodule
    ```
    
    ### Result:
    ![Test_Variation_1](./Test_Variation_1.PNG?raw=true "Test Variation 1")
    
    ### Variation Instruction:
    Include the `s1`, `s0` signals in the packed array. Assign the value (0,1,2,3) to those signals.
    ### Result:
    ![Test_Variation_2](./Test_Variation_2.PNG?raw=true "Test Variation 2")
    
    ### Variation Instruction:
    Use `eq` on `s1`, `s0` to compare it to the packed array.
    ### Result:
    ![Test_Variation_3](./Test_Variation_3.PNG?raw=true "Test Variation 3")
    
    ### Variation Instruction:
    Use `not` on `s1`, `s0` to compare it with the packed array.
    ### Result:
    ![Test_Variation_4](./Test_Variation_4.PNG?raw=true "Test Variation 4")
    
    ### Test Plan:
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    ### Base Verilog Code:
    ```Verilog
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-1

- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    wire [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    
    reg [2: 0] s1_s0;
    MSB_Out <= MSB_Out;
    LSB_Out <= LSB_Out;
    always @ (posedge clk) begin
    if (rst) begin
    Data_Out <= 0;
    s1_s0 <= 0;
    end
    else case ({s1, s0})
    0: begin
    Data_Out <= Data_Out; // Idle
    s1_s0 <= s1_s0;
    end
    1: begin
    Data_Out[3:1] <= MSB_In;
    Data_Out[0] <= LSB_Out;
    s1_s0 <= 2'b00;
    end
    2: begin
    Data_Out[3:1] <= Data_Out[3:1];
    Data_Out[0] <= LSB_In;
    s1_s0 <= 2'b01;
    end
    3: begin
    Data_Out <= Data_In;
    s1_s0 <= 2'

- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    output s1, s0;
    wire [3: 0] S1_S0;
    assign S1_S0 = {s1, s0};
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case (S1_S0)
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal

- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
       generate
          if (x[2]==1'b0) begin : inside
             always_comb begin : inside_comb
                // Logic equations for each segment (active high assumed)
                assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
                | ~x[3] & x[2] & ~x[1] & ~x[0]
                | x[3] & x[2] & ~x[1] & x[0]
                | x[3] & ~x[2] & x[1] & x[0];
                assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
                | x[3] & x[1] & x[0]
                | ~x[3] & x[2] & ~x[1] & x[0]
                | x[3] & x[2] & ~x[1] & ~x[0];
                assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
                | x[3] & x[2] & x[1]
                | x[3] & ~x[2] & x[0];
                assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
                | ~x[3] & x[2] & ~x[1] & ~x[0]
                | x[3] & ~x[2] & x[1] & ~x[0]
                | x[2] & x[1] & x[0];
                assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
                | ~x[3] & x[2] & ~x[1]
                | ~x[2] & ~x[1] & x[0];
                assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
                | ~x[3] & ~x[2] & x[1]
                | ~x[3] & x[1] & x[0]
                | x[3] & x[2] & ~x[1] & x[0];
                assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
                | x[3] & x[2] & ~x[1] & ~x[0]
                | ~x[3] & x[2] & x[1] & x[0];
             end : inside_comb
          end : inside
       endgenerate
    endmodule
    ### Explanation:
    * We declare a generate block with escaped name, which allows us to refer to the block (e.g., `inside_comb`) even if we aren't sure what the name of the block is. 
    * We then define the generate block as `if (x[2]==1'b0)` using an indexed part select. 
    * The assignment inside the `if` will only execute if `x[2]==1'b0`, which means that we will only assign to outputs if `x` is less than 8. 
    
    ### Variation: Use a for loop
    ```verilog
    for (int ii=0; ii<3; ii++) begin
        always_comb begin
            if (x[ii]==1'b0) begin
                assign a_to_g[ii+6] = ~x[ii+3] & ~x[ii+2] & ~x[ii+1] & x[ii] // a (segment index 6)
                | ~x[ii+3] & x[ii+2] & ~x[ii+1] & ~x[ii]
                | x[ii+3

- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    
    generate
    generate
    
    inside
    {
    wire [3:0] x_inside_[3:0] = x[3:0];
    assign a_to_g[6] = ~x_inside_[3] & ~x_inside_[2] & ~x_inside_[1] & x_inside_[0] // a (segment index 6)
    | ~x_inside_[3] & x_inside_[2] & ~x_inside_[1] & ~x_inside_[0]
    | x_inside_[3] & x_inside_[2] & ~x_inside_[1] & x_inside_[0]
    | x_inside_[3] & ~x_inside_[2] & x_inside_[1] & x_inside_[0];
    assign a_to_g[5] = x_inside_[2] & x_inside_[1] & ~x_inside_[0] // b (segment index 5)
    | x_inside_[3] & x_inside_[1] & x_inside_[0]
    | ~x_inside_[3] & x_inside_[2] & ~x_inside_[1] & x_inside_[0]
    | x_inside_[3] & ~x_inside_[2] & x_inside_[1] & ~x_inside_[0];
    assign a_to_g[4] = ~x_inside_[3] & ~x_inside_[2] & x_inside_[1] & ~x_inside_[0] // c (segment index 4)
    | x_inside_[3] & x_inside_[2] & x_inside_[1]
    | x_inside_[3] & x_inside_[2] & ~x_inside_[0];
    assign a_to_g[3] = ~x_inside_[3] & ~x_inside_[2] & ~x_inside_[1] & x_inside_[0] // d (segment index 3)
    | ~x_inside_[3] & x_inside_[2] & ~x_inside_[1] & ~x_inside_[0]
    | x_inside_[3] & ~x_inside_[2] & x_inside_[1] & ~x_inside_[0]
    | x_inside_[2] & x_inside_[1] & x_inside_[0];
    assign a_to_g[2] = ~x_inside_[3] & x_inside_[0] // e (segment index 2)
    | ~x_inside_[3] & x_inside_[2] & ~x_inside_[1]
    | ~x_inside_[2] & ~x_inside_[1] & x_inside_[0];
    assign a_to_g[1] = ~x_inside_[3] & ~x_inside_[2] & x_inside_[0] // f (segment index 1)
    | ~x_inside_[3] & ~x_inside_[2] & x_inside_[1]
    | ~x_inside_[3] & x_inside_[1] & x_inside_[0]
    | x_inside_[3] & x_inside_[2] & ~x_inside_[1] & x_inside_[0];
    assign a_to_g[0] = ~x_inside_[3] & ~x_inside_[2] & ~x_inside_[1] // g (segment index 0)
    | x_inside_[3] & x_inside_[2] & ~x_inside_[1] & ~x_

- code: |-
    module hex7seg_le (
    	input wire [3:0] x,
    	output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    	);
    	generate
    		genvar i;
    		for (i = 0; i < 7; i++) begin : __gen_inside
    			wire __inside_x;
    			assign __inside_x = __gen_inside_x[i] ;
    			wire __gen_inside_x;
    			__gen_inside_x[i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    			| ~x[3] & x[2] & ~x[1] & ~x[0]
    			| x[3] & x[2] & ~x[1] & x[0]
    			| x[3] & ~x[2] & x[1] & x[0];
    			wire __inside_b;
    			assign __inside_b = __gen_inside_b[i] ;
    			wire __gen_inside_b;
    			__gen_inside_b[i] = x[2] & x[1] & ~x[0] // b (segment index 5)
    			| x[3] & x[1] & x[0]
    			| ~x[3] & x[2] & ~x[1] & x[0]
    			| x[3] & ~x[2] & ~x[1] & ~x[0];
    			wire __inside_c;
    			assign __inside_c = __gen_inside_c[i] ;
    			wire __gen_inside_c;
    			__gen_inside_c[i] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    			| x[3] & x[2] & x[1]
    			| x[3] & x[2] & ~x[0];
    			wire __inside_d;
    			assign __inside_d = __gen_inside_d[i] ;
    			wire __gen_inside_d;
    			__gen_inside_d[i] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    			| ~x[3] & x[2] & ~x[1] & ~x[0]
    			| x[3] & ~x[2] & x[1] & ~x[0]
    			| x[2] & x[1] & x[0];
    			wire __inside_e;
    			assign __inside_e = __gen_inside_e[i] ;
    			wire __gen_inside_e;
    			__gen_inside_e[i] = ~x[3] & x[0] // e (segment index 2)
    			| ~x[3] & x[2] & ~x[1]
    			| ~x[2] & ~x[1] & x[0];
    			wire __inside_f;
    			assign __inside_f = __gen_inside_f[i] ;
    			wire __gen_inside_f;
    			__gen_inside_f[i] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    			| ~x[3] & ~x[2] & x[1]
    			| ~x[3] & x[1] & x[0]
    			| x[3] & x[2] & ~x[1] & x[0];
    			wire __inside_g;
    			assign __inside_g = __gen_inside_g[i] ;
    			wire __gen_inside_g;
    			__gen_inside_g[i] = ~x[3] & ~x[2] & ~x[1] // g (segment index

- code: |-
    module hex7seg_le_v (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // a (segment index 6)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\x[2]\x[1]\x[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // b (segment index 5)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\x[2]\x[1]\x[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // c (segment index 4)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\x[2]\x[1]\x[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // d (segment index 3)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\x[2]\x[1]\x[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // e (segment index 2)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]] || `inside(\x[3]\x[2]\x[1]\x[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) || `inside(\x[3]\[2]\[1]\[0]) || `inside(\x[3]\x[2]\[1]\[0]) // f (segment index 1)
    | `inside(\x[3]\x[2]\x[1]\x[0]) || `inside([\x[3]\x[2]\x[1]\x[0]][\x[3]\x[2]]

- code: |-
    ```verilog
    module hex7seg_le_inside (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    
    generate
    if (x[3:1]!= 3'b000) begin : x_not_zero
    	assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    	| ~x[3] & x[2] & ~x[1] & ~x[0]
    	| x[3] & x[2] & ~x[1] & x[0]
    	| x[3] & ~x[2] & x[1] & x[0];
    	assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    	| x[3] & x[1] & x[0]
    	| ~x[3] & x[2] & ~x[1] & x[0]
    	| x[3] & x[2] & ~x[1] & ~x[0];
    	assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    	| x[3] & x[2] & x[1]
    	| x[3] & ~x[2] & x[1] & ~x[0];
    	assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    	| ~x[3] & x[2] & ~x[1] & ~x[0]
    	| x[3] & ~x[2] & x[1] & ~x[0]
    	| x[2] & x[1] & x[0];
    	assign a_to_g[2] = ~x[3] & ~x[2] & x[0] // e (segment index 2)
    	| ~x[3] & x[2] & ~x[1]
    	| ~x[2] & ~x[1] & x[0];
    	assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    	| ~x[3] & ~x[2] & x[1]
    	| ~x[3] & x[1] & x[0]
    	| x[3] & x[2] & ~x[1] & x[0];
    	assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    	| x[3] & x[2] & ~x[1] & ~x[0]
    	| ~x[3] & x[2] & x[1] & x[0];
    end else begin
    	assign a_to_g[6] = 1'b1;
    	assign a_to_g[5] = 1'b1;
    	assign a_to_g[4] = 1'b1;
    	assign a_to_g[3] = 1'b1;
    	assign a_to_g[2] = 1'b1;
    	assign a_to_g[1] = 1'b1;
    	assign a_to_g[0] = 1'b1;
    end
    endgenerate
    endmodule
    ```
    ### Previous Version
    ```verilog
    module hex7seg_le_before (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    
    generate
    	if (x[3] == 1'b0 && x[2] == 1'b0 && x[1] == 1'b0) begin : x_not_zero
    		assign a_

- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodule
    ### Modified Code
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);

- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    initial begin
    $dumpfile("updcount_dump.vcd");
    $dumpvars(1,tst_updcounter);
    end
    
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodule
    
    module updcounter(
        output reg [3:0] a,
        input clk,
        input [3:0] N,
        input u_d
    );
        reg [3:0] cnt;
    
        always @(posedge clk) begin
            if(N == cnt) begin
                if(u_d) begin
                    cnt <= 4'b0;
                end
                else begin
                    cnt <= N;
                end
            end
            else if(u_d) begin
                cnt <= cnt + 1;
            end
            else begin
                cnt <= cnt - 1;
            end
        end
        always @(posedge clk) begin
            a <= cnt;
        end
    endmodule
    
    module updcounter2(
        output reg [3:0] a,
        input clk,
        input [3:0] N,
        input u_d
    );
        reg [3:0] cnt;
    
        always @(posedge clk) begin
            if(N == cnt) begin
                if(u_d) begin
                    cnt <= 4'b0;
                end
                else begin
                    cnt <= N;
                end
            end
            else if(u_d) begin
                cnt <= cnt + 1;
            end
            else begin
                cnt <= cnt - 1;
            end
        end
        always @(posedge clk) begin
            a <= cnt;
        end
    endmodule
    
    package counter_pkg;
        parameter RST_X = 2'b10;
    endpackage
    
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    
    updcounter c2(a,clk,N,u_d);
    
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial begin
    $dumpfile("updcount_dump.vcd");
    $dumpvars(1,tst_updcounter);
    end
    
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%

- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    always #2 clk=~clk; // Generate clock
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was

- code: |-
    ```verilog
    module tst_updcounter();//TEST_BENCH
    reg clk;
    reg[3:0]N;
    reg u_d;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    initial
    begin
     forever
      clk = 0;
      #2 clk=~clk; // Generate clock
      end
    end
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodule
    ```
    ### Original Code:
    ```verilog
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34

- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    parameter RST_X = 1'b1;
    generate
    initial
    begin
    #34
    N = 4'b0111;
    u_d = 1'b1;
    clk = 0;
    end
    always #2 clk=~clk;
    always #34 u_d=~u_d;
    endgenerate
    initial $monitor

- code: |-
    ```verilog
    module ALU_COMP (x, comparison, result);
      input [3:0] x;
      output [2:0] result;
      output comparasion;
      assign result = comparison? 1'b1 : 1'b0;
      always @ (x or comparasion) begin
        if (compare) begin
          case (x)
            INSIDE_0: result = 3'b100;
            INSIDE_1: result = 3'b010;
            INSIDE_2: result = 3'b001;
          endcase
        end else begin
          result = 3'b000;
        end
      end
    endmodule
    
    package INSIDE_PACKAGE;
      parameter INSIDE_0 = 4'b0100;
      parameter INSIDE_1 = 4'b0010;
      parameter INSIDE_2 = 4'b0001;
    endpackage
    
    module ALU_ADD (x, y, result);
      input [3:0] x, y;
      output [3:0] result;
      always @ (x or y) begin
        result = x + y;
      end
    endmodule
    
    module ALU_MUL (x, y, result);
      input [3:0] x, y;
      output [7:0] result;
      always @ (x or y) begin
        result = 8'b0;
        for (int i=0; i<4; i++) begin
          result += (x[i]? y : 0'b0) << i;
        end
      end
    endmodule
    
    module ALU_DIV (x, y, result);
      input [3:0] x, y;
      output [3:0] result;
      always @ (x or y) begin
        result = y? x / y : 0;
      end
    endmodule
    
    module ALU (x, y, operation, result);
      input [3:0] x, y, operation;
      output [3:0] result;
      wire [2:0] comparasion;
      wire [3:0] inside_result;
    
      ALU_COMP u_comp (.x(x),.comparasion(comparasion),.result(inside_result));
      ALU_ADD u_add (.x(x),.y(y),.result(result));
      ALU_MUL u_mul (.x(x),.y(y),.result(result));
      ALU_DIV u_div (.x(x),.y(y),.result(result));
    endmodule
    
    module TOP1 (CLK, RST_X);
      input CLK, RST_X;
      reg [3:0] x, y, operation;
      wire [3:0] result;
    
      always @ (posedge CLK or posedge RST_X) begin
        if (RST_X == 0) begin
          operation <= 0;
          x <= 4'b0;
          y <= 4'b0;
        end else begin
          operation <= operation + 1;
          if (operation == 0) begin
            x <= 4'b1000;
            y <= 4'b0100;
          end else if (operation == 1) begin
            x <= inside_result;
            y <= 4'b0010;
          end else begin
            x <= 4'b1000;
            y <= 4'b0001;
          end
        end
      end
    
      ALU u_alu (
       .x(x),
       .y(y),
       .operation(operation),
       .result(result)
      );
    endmodule
    ```
    ### Expect Result:
    ![image](https://user-images.githubusercontent.com/42842621/137656354-1b992418-9db1-40e4-a12f-144cd3330c86.png)
    
    # **Question 3**
    ### Base Verilog Code:
    module TOP1 (CLK, RST_X);
      input

- code: |-
    module TOP1;
    	parameter N = 4;
      parameter N1 = N+1;
    	parameter [N1-1:0] cmp_array [N][N] = { { 4'b1110, 4'b1010, 4'b0110, 4'b0010 }, { 4'b1010, 4'b1110, 4'b0010, 4'b0110 }, { 4'b0110, 4'b0010, 4'b1110, 4'b1010 }, { 4'b0010, 4'b0110, 4'b1010, 4'b1110 } };
      reg [3:0] x;
      wire [3:0] y;
      wire cmp;
      wire [N1-1:0] cmp_result;
    
      assign y = cmp_array[x[3:0]][x[3:0]];
      assign cmp_result = x inside {cmp_array};
    
      always @ (posedge CLK) begin
    	  if (RST_X)
          begin
            x <= 0;
          end
    	  else
    	    if (cmp_result!= 1)
            begin
              x <= x + 1;
            end
      end
    
      assign cmp = (y == x);
    
      initial begin
        $monitor($time, "cmp_result: %b, cmp: %b", cmp_result, cmp);
      end
    endmodule
    ##

- code: |-
    module TOP1 (
      input logic CLK, RST_X,
      output logic LEDG
    );
      logic x;
      always_ff @(posedge CLK) begin
        x <= 1'bx;
        LEDG <= (x inside {2, 3, 4, 5});
      end
      initial begin
        $dumpfile("dump.vcd");
        $dumpvars(0, TOP1);
      end
    endmodule
    
    package TEST;
      parameter WIDTH = 8;
      parameter DATA  = 8'h01;
    endpackage
    
    module TOP1 (
      input logic CLK, RST_X,
      output logic LEDG
    );
      logic x;
      always_ff @(posedge CLK) begin
        x <= 1'bx;
      end
      assign LEDG = 0;
      initial begin
        $dumpfile("dump.vcd");
        $dumpvars(0, TOP1);
      end
    endmodule
    
    ### Simulation:
    $ ghdl -r tb_TOP1 --vcd=dump.vcd --ieee-asserts=disable
    ### Expected Console Output:
       Started:  20:37:37  0:00:00  0:00:00
       Finished: 20:37:38  0:00:00  0:00:00
    
      TB_TOP1..Done
      TB_TOP1..OK
    
      Run Finished: Testbenches (0) | Elapsed time: 00:00:00
    ### Expected Waveform Output:
    ![Expected Waveform Output](./in1.png)
    
    ### Result:

- code: |-
    module TOP1 (CLK, RST_X, OUTP);
    
      input CLK, RST_X;
      output OUTP;
      wire [7:0] inp0 = 8'h50;
      wire [7:0] inp1 = 8'h60;
    
      wire [7:0] x;
      wire [7:0] y;
    
      always @ (posedge CLK) begin
        x <= RST_X? 8'h10 : x + 1;
        y <= RST_X? 8'h20 : y + 1;
      end
    
      wire outp;
      assign outp = inp0 inside {8'h10, 8'h20, 8'h30};
    
      assign OUTP = outp;
    endmodule
    ### Modified Top Module Instantiation:
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut(.CLK(CLK),.RST_X(RST_X));
      initial begin
        CLK = 0;
        forever #5 CLK = ~CLK;
      end
    
      initial begin
        RST_X = 0; #10;
        RST_X = 1;
      end
    endmodule
    ### Modified Package:
    package com_p;
        parameter COMPARE_W = 8;
        parameter COMPARE_L = 3;
        constant comparators [COMPARE_L-1:0][COMPARE_W-1:0] = {8'h10, 8'h20, 8'h30};
    endpackage
    ### Expected Output:
    ### -----------------------------
    ### Output #1 (for `outp` = 1):
    ### -----------------------------
    *X*
    ### -----------------------------
    ### Output #2 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #3 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #4 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #5 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #6 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #7 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #8 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #9 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #10 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #11 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #12 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #13 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #14 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #15 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #16 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #17 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #18 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #19 (for `outp` = 0):
    ### -----------------------------
    X
    ### -----------------------------
    ### Output #20 (for `outp` = 0):
    ###

- code: |-
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut(.CLK(CLK),.RST_X(RST_X));
    
      initial begin
        CLK = 0;
        forever #5 CLK = ~CLK;
      end
    
      initial begin
        RST_X = 0; #10;
        RST_X = 1;
      end
    endmodule
    
    module TOP1(CLK, RST_X);
      input CLK, RST_X;
    
      reg [3:0] x;
      wire valid;
    
      reg [3:0] cmp_x [15:0] = {7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127};
    
      always @(posedge CLK)
        if (RST_X || valid) // if x is valid, display x
          $display("x = %d", x);
    
      always @*
        if (inside(x, cmp_x))
          valid <= 1'b1;
        else
          valid <= 1'b0;
    endmodule
    ### Test Results:
    
    ```
    $ ghdl -r tb_TOP1 --vcd=tb_TOP1.vcd
    x = 7
    x = 15
    x = 23
    x = 31
    x = 39
    x = 47
    x = 55
    x = 63
    x = 71
    x = 79
    x = 87
    x = 95
    x = 103
    x = 111
    x = 119
    x = 127
    
    ghdl> run 15
    
    ghdl> waves tb_TOP1.vcd
    ```

- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    // Declare all variables/regs for the module
    reg [N-1:0] max;
    reg [N-1:0] min;
    function bit test_eq(wire [N-1:0] x, wire [N-1:0] y);
    begin
    repeat(N) test_eq = (x[i] == y[i]);
    return test_eq;
    end
    endfunction
    // Implement the body of the design
    always @(*)
    begin
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    if(x > y)
    max = x;
    else
    max = y;
    if(x < y)
    min = x;
    else
    min = y;
    if(test_eq(max, min))
    eq = 1'b1;
    else
    eq = 1'b0;
    end
    generate
    for(i = 0; i < N; i = i + 1 )
    begin: g
    if((i == max) || (i == min))
    generate
    if(i == max)
    gt = 1'b

- code: |-
    ```
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    // Define local parameter for number of comparator instances
    localparam R = 8;
    // Declare an array of comparators
    // comp_#index# #name# (
    //.x(x),
    //.y(y),
    // );
    
    // Inst

- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output wire [M-1:0] z);
    generate
    if (ENABLE) // Use function result in array index
    always @*
    begin
    z[N-1:0] = 1'b1;
    if(x < 0)
    z[N-1:0] = 1'b0;
    if(y < 0)
    z[N-1:0] = 1'b0;
    if(x > 0)
    z[N-1:0] = 1'b0;
    if(y > 0)
    z[N-1:0] = 1'b0;
    end
    end
    endgenerate
    endmodule
    ### Modification Verification Steps:
    1. Set the Enable input to 1 and run the simulation.
    2. Set the Enable input to 0 and run the simulation.
    ### Expected Results:
    1. The output waveform matches the simulation output image.
    2. The output waveform is set to 1 when the Enable input is set to 0.
    ### Pass/Fail Criteria:
    Passes if the simulation output matches the reference image and the output is 1 when the Enable input is 0. 
    ### Limitations:
    None.
    ### Requirements:
    None.
    ### Reference:
    None.
    ### Test Applications:
    None.
    
    
    ### Expected Output:
    ![Compare

- code: |-
    ```
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    function int f;
      input [3:0] i;
      reg [3:0] temp;
      initial temp = 4'b0001;
      always @(*)
      begin
      if (i < 4)
        begin
        case (i)
          0: temp = 4'b0001;
          1: temp = 4'b0010;
          2: temp = 4'b0100;
          3: temp = 4'b1000;
        endcase
        end
      end
      endfunction
    generate
    assign x_index = x < y? 0 : (x == y? 1 : 2);
    assign y_index = x < y? 2 : (x == y? 1 : 0);
    assign gt = x < y? 1 : (x == y? 0 : 0);
    assign eq = x == y? 1 : 0;
    assign lt = x < y? 1 : (x == y? 0 : 1);
    endgenerate
    endmodule
    ```
    ### Test Bench:
    ```
    module comp_tb;
    reg [3:0] x, y;
    wire gt, eq, lt;
    comp cmp (.x(x),.y(y),.gt(gt),.eq(eq),.lt(lt));
    wire [3:0] x_index, y_index;
    initial
    begin
    x = 4'b0001;
    y = 4'b0001;
    #1 assert(gt == 1'b0);
    #1 assert(eq == 1'b1);
    #1 assert(lt == 1'b0);
    x = 4'b0001;
    y = 4'b0000;
    #1 assert(gt == 1'b1);
    #1 assert(eq == 1'b0);
    #1 assert(lt == 1'b0);
    x = 4'b0001;
    y = 4'b0011;
    #1 assert(gt == 1'b0);
    #1 assert(eq == 1'b0);
    #1 assert(lt == 1'b1);
    x = 4'b0001;
    y = 4'b0000;
    #1 assert(gt == 1'b1);
    #1 assert(eq == 1'b0);
    #1 assert(lt == 1'b0);
    x = 4'b0000;
    y = 4'b0001;
    #1 assert(gt == 1'b0);
    #1 assert(eq == 1'b0);
    #1 assert(lt == 1'b1);
    endmodule
    ```
    ### Simulation:
    ![comp_tb image 1](https://drive.google.com/uc?export=view&id=0ByOc-29M0crmZDg5bjRaQmhKM2M)
    ### Conclusion:
    The approach of generating the constants by using an array index inside the `inside` operator and a function call result inside the `

- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    function [3:0] get_flag;
    input wire [N-1:0] x, y;
    begin
    if(x > y) return 4'b0100;
    else if(x == y) return 4'b0010;
    else return 4'b0001;
    end
    endfunction
    generate
    genvar i

- code: |-
    module dff_aa(q); // Behavioral DFF with async controls and conditional path delay
      output q; 
      reg q;
      // Specify
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1; 
        else q <= di;
    endmodule
    ### Note:
    Do not modify any code outside the `specify` and `endspecify` blocks. The entire `specify` and `endspecify` must be kept intact.
    ### Waveform:
    ![](TestDff.png)
    
    ### File Description:
    - `dff_aa.sv` is the modified file with the changes described above.
    - `run_test.tcl` is the script to run the simulation.
    
    ### Expected Output:
    ![](dff_aa_output.png)
    
    ### Simulation Setup:
    `xrun -sim dff_aa.sv -waves dff_aa.vcd -gui -tclbatch run_test.tcl`
    
    ### Simulation Output:
    ![](simulation_output.png)
    
    - - -
    © 2019

- code: |-
    module mod_aa(out,in);
      output reg out;
      input in;
      always @(posedge in or negedge in) begin
        if (in == 1'b0)
          out = 1'b0;
        else
          out = in;
      end
    endmodule
    ### Original Code:
    module mod_aa(out,in);
      output reg out;
      input in;
      always @(in) begin
        if (

- code: |-
    module DFF_AA(q1,q2,q3,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output [2:0] q1,q2,q3; output [2:0] qb; input [3:0] di,clk,clr,pr;
      reg [2:0] Q; wire [2:0] Y_COND;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 3'b0; // Use non-blocking <=
        else if(pr) q <= 3'b1;
        else q <= di;
      assign {Y_COND} = inside({4'b1100,Y}, {6'b001100,6'b110011}); // inside check
    endmodule
    ### Variation Instruction:

- code: |-
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
    
      output q,qb; input di,clk,clr,pr;
    
      reg [1:0] X[3];
      reg [1:0] Y[3];
      assign q = Y[X[1]][X[2]];
      assign qb = ~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) begin
          X[1] <= 2'b00;
          X[2] <= 2'b00;
          X[3] <= 2'b00;
          Y[1] <= 2'b00;
          Y[2] <= 2'b00;
          Y[3] <= 2'b00;
        end else if(pr) begin
          X[1] <= 2'b01;
          X[2] <= 2'b0;
          X[3] <= 2'b0;
          Y[1] <= 2'b10;
          Y[2] <= 2'b01;
          Y[3] <= 2'b00;
        end else begin
          X[1] <= 2'b00;
          X[2] <= 2'b00;
          X[3] <= 2'b0;
          Y[1] <= 2'b00;
          Y[2] <= 2'b00;
          Y[3] <= 2'b00;
        end
        // check if `X[2]` is inside the packed slice
        if (inside(X[2], 2'b000, 2

- code: |-
    module top(input clk, input rst, input [1:0] sel, output reg [3:0] q, input [3:0] d);
      reg [3:0] X[2:0];
      reg Y;
      initial begin
        $display("... verifying packed array slices...");
        X[0] = 4'b1010;
        X[1] = 4'b0101;
        X[2] = 4'b0010;
        Y = 1'b0;
      end
      always @(posedge clk or posedge rst) begin
        if (rst) begin
          q <= 4'b0;
          $display("rst");
        end else begin
          $display("sel = %b", sel);
          if (sel[0] == 1'b1)
            q <= X[2];
          else if (sel[1] == 1'b1)
            q <= X[1];
          else if (sel[1] ==

- code: |-
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
    ### Interface
    interface addern_i;
    logic [15:0] data;
    endinterface
    ### Variation:
    Add constant index 0 to the signal `data` inside addern using `inside` operator.
    ### Testbench Code:
    module tb;
    logic clk, sreset;
    logic [15:0] x, y;
    logic carryin;
    logic [15:0] s;
    logic carryout;
    addern_i adder_i[2];
    addern adder[2];
    default clocking cb_adder @(posedge clk);
        default input #1 output #1;
        endclocking
    initial begin
        clk = 0;
        sreset = 1;
    end
    
    assign adder_i[1].carryin = 0;
    assign adder_i[0].carryin = 1;
    assign adder_i[1].data = 16'b0000_0000_0000_0101;
    assign adder_i[0].data = 16'b0000_0000_0000_0010;
    always @(posedge clk)
    begin
        x <= adder_i[1].data;
        y <= adder_i[0].data;
        carryin <= adder_i[1].carryin;
        s <= adder_i[1].data + adder_i[0].data;
        carryout <= adder_i[1].carryin | (~adder_i[1].carryin & (adder_i[1].data[15] ^ adder_i[0].data[15]));
        adder_i[0].data <= adder_i[0].data + 1;
        adder_i[1].data <= adder_i[1].data + 1;
    end
    
    initial begin
        forever #2 clk =!clk;
    end
    
    initial begin
        #100 $finish;
    end
    
    initial begin
        wait(!sreset);
        cb_adder.configure(adder_i[0], "adder_i[1].data", "wire", 0);
        cb_adder.configure(adder_i[0], "adder_i[0].data", "wire", 1);
        cb_adder.configure(adder_i[0], "adder_i[1].carryin", "wire", 2);
        cb_adder.configure(adder_i[0], "adder_i[0].carryin", "wire", 3);
        cb_adder.configure(adder[0], "S", "wire", 4);
        cb_adder.configure(adder[0], "carryout", "wire", 5);
        cb_adder.configure(adder[0], "car

- code: |-
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    assign data[0] = {X[15],X[14],X[13],X[12],X[11],X[10],X[9],X[8],X[7],X[6],X[5],X[4],X[3],X[2],X[1],X[0]};
    always @(data[0])
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = data[0][k] ^ data[1][k] ^ C[k];
            C[k+1] = (data[0][k] & data[1][k]) | (C[k] & data[0][k]) | (C[k] & data[1][k]);
        end
        carryout = C[n];
    end

- code: |-
    ```
    interface interface_data;
        logic [7:0] data[7:0];
    endinterface
    
    module top(output logic [7:0] data[7:0]);
        interface_data interface_data1;
    
        genvar i;
        for (i = 0; i < 8; i = i + 1) begin: block_gen
            addern #(.n(8)) addern_inst(
               .carryin(1'b0),
               .X(interface_data1.data[i]),
               .Y(interface_data1.data[i]),
               .S(data[i]),
               .carryout()
            );
        end
    
        initial begin
            interface_data1.data[7] = 8'b0011_1000;
            interface_data1.data[6] = 8'b0011_1000;
            interface_data1.data[5] = 8'b0011_1000;
            interface_data1.data[4] = 8'b0011_1000;
            interface_data1.data[3] = 8'b0011_1000;
            interface_data1.data[2] = 8'b0011_1000;
            interface_data1.data[1] = 8'b0011_1000;
            interface_data1.data[0] = 8'b0011_1000;
        end
    
        initial #1 $finish;
    endmodule
    ```
    ### Result:
    ```
    ghdl -a top.vhdl  --std=08
    ghdl -a interface_data.vhdl
    ghdl -e top
    ghdl -r top --vcd=top.v

- code: |-
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0]

- code: |-
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    // inside operator is applied to array data
    inside data [0:n-1];
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
    ### Simulation:
    The input signals are
    <img src="./fig/18.png" width="500" height="150" />
    
    The output signals are
    <img src="./fig/19.png" width="500" height="150" />
    
    As expected from the original verilog code, `carryout` changes to 1 when any bits in `X` or `Y` are 1.
    
    ### Exercise Summary:
    * Array `data` defined in `module` scope is visible inside the `always` block. Inside `always` block, array `data` is used to access the bit from bit vector `X` or `Y`.
    * Inside `always` block, use `inside` operator to access the array in package-qualified expression.
    
    ### Note:
    The array `data` is created with scope `module`. This means that the array will be visible to the module definition and all instances inside the module. This means that there can be only 1 instance of the array named `data`. This is unlike the case of the signal `S`, where the array `data` is used to access the 1st-index signal or the 2nd-index signal.
    
    ### Reference:
    * Inside Operator
        * [IEEE Std 1800-2017](https://standards.ieee.org/findstds/standard/1800-2017.html) § 23.7.1
    * Using an Array to index a signal or expression
        * [IEEE Std 1800-2017](https://standards.ieee.org/findstds/standard/1800-2017.html) § 23.6.4.2, "Using an Array to Index a Signal or Expression"
    * Arrays of a Package
        * [IEEE Std 1800-2017](https://standards.ieee.org/findstds/standard/1800-2017.html) § 23.5.3
    * Scope of variables defined by a parameter
        * [IEEE Std 1800-2017](https://standards.ieee.org/findstds/standard/1800-2017.html) § 23.5.2.1, "Scope of variables defined by a parameter"
        * [IEEE Std 1800-2012](https://standards.ieee.org/findstds/standard/1800-2012.html) § 18.5.3.1
    * Arrays

- code: |-
    ```VHDL
    module state_Mealy 
    #(parameter
        CODE = ""
      ) 
    (
      input [31:0] data,
      input x,
      output y,
      output reg dcontrol
    );
      initial
      begin
        dcontrol = 0;
      end
    
      import base::*;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
    
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
                 $time, dcontrol, data, x, y, bus);
      end
    
      always @x
      begin
        y = inside({1'b0,CODE[14:13]},1'b0,x);
      end
    
    endmodule
    ```
    ### Original Benchmark: (Mealy Machine)
    ```VHDL
    module state_Mealy 
    #(parameter
        CODE = ""
      ) 
    (
      input [31:0] data,
      input x,
      output y,
      output reg dcontrol
    );
      initial
      begin
        dcontrol = 0;
      end
    
      import base::*;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
    
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
                 $time, dcontrol, data, x, y, bus);
      end
    
      always @x
      begin
        y = outside(inside(CODE[14:13],0,x),1'b0);
      end
    
    endmodule
    ```
    ### Compilation Status:
    ##### Pass:
    ```
    % ghdl -a --std=08 mixed_sim.vhdl
    % ghdl mixed_sim
    % ghdl -a --std=08 state_Mealy.vhdl
    % ghdl state_Mealy
    %./state_Mealy
    time=100 dcontrol=0 data=0 x=1 y=0 bus=0
    time=110 dcontrol=0 data=0 x=0 y=0 bus=0
    time=120 dcontrol=0 data=1 x=0 y=0 bus=0
    time=130 dcontrol=0 data=1 x=1 y=0 bus=0
    time=140 dcontrol=0 data=0 x=0 y=0 bus=0
    time=150 dcontrol=0 data=1 x=1 y=0 bus=0
    time=160 dcontrol=0 data=0 x=0 y=0 bus=0
    time=170 dcontrol=0 data=1 x=1 y=0 bus=0
    time=180 dcontrol=0 data=0 x=0 y=0 bus=0
    time=190 dcontrol=0 data=1 x=1 y=0 bus=0
    time=200 dcontrol=0 data=0 x=0 y=0 bus=0
    time=210 dcontrol=0 data=1 x=1 y=0 bus=0
    time=220 dcontrol=0 data=0 x=0 y=0 bus=0
    time=230 dcontrol=0 data=1 x=1 y=0 bus=0
    time=240 dcontrol=0 data=0 x=0 y=0 bus=0
    time=250 dcontrol=0 data=1 x=1 y=0 bus=0
    time=260 dcontrol=0 data=0 x=0 y=0 bus=0
    time=270 dcontrol=0 data=1 x=1 y=0 bus=0
    time=280 dcontrol=0 data=0 x=0 y=0 bus=0
    time=290 dcontrol=0 data=1 x=1 y=0 bus=0
    time=300 dcontrol=0 data=0 x=0 y=0 bus=0
    time=310 dcontrol=0 data=1 x=1 y=0 bus=0
    time=320 dcontrol=0 data=0 x=0 y=0 bus=0
    time=330 dcontrol=0 data=1 x=1 y=0 bus=0
    time=340

- code: |-
    ```vlog
    module state_Mealy_const (
        input clock,
        input x,
        input [31:0] data,
        output reg [31:0] bus
    );
    const [1:0] state_Mealy = {2'b0,1'b1};
    reg [31:0] data_out;
    reg [1:0] state;
    wire [31:0] bus_out;
    
    always @(posedge clock) begin
        state <= state_Mealy[1:0];
        data_out <= data;
        bus <= bus

- code: |-
    module example_module;
      logic [3:0]

- code: |-
    ```verilog
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    
    package pkg_mixed_sim;
    import pkg_base_sim::state_Mealy;
    string states_mixed_sim[] = state_Mealy[3:0];
    endpackage
    ```
    ### Testbench:
    ```verilog
    module tb_mixed_sim();
      mixed_sim dut();
      initial begin
        fork
          begin
            #100 $finish;
          end
          begin
            #100 $display("\n--End test--\n");
          end
        join_none
      end
    endmodule
    ```
    
    ### Actual Output:
    
    ```verilog
    --End test--
    time=100 dcontrol=0 data=0 x=0 y=1 bus=0
    time=200 dcontrol=0 data=0 x=0 y=1 bus=0
    time=300 dcontrol=1 data=29 x=0 y=1 bus=29
    time=400 dcontrol=1 data=29 x=0 y=1 bus=29
    time=500 dcontrol=0 data=0 x=0 y=1 bus=0
    time=600 dcontrol=0 data=0 x=0 y=1 bus=0
    time=700 dcontrol=0 data=0 x=0 y=1 bus=0
    time=800 dcontrol=1 data=0 x=0 y=1 bus=0
    time=900 dcontrol=1 data=0 x=0 y=1 bus=0
    time=1000 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1100 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1200 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1300 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1400 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1500 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1600 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1700 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1800 dcontrol=1 data=1 x=0 y=1 bus=1
    time=1900 dcontrol=1 data=1 x=0 y=1 bus=1
    time=2000 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2100 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2200 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2300 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2400 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2500 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2600 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2700 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2800 dcontrol=1 data=2 x=0 y=1 bus=2
    time=2900 dcontrol=1 data=2 x=0 y=1 bus=2
    time=3000 dcontrol=1 data=3 x=0 y=1 bus=3
    time=3100 dcontrol=1 data=3 x=0 y=1 bus=3
    time=3200 dcontrol=1 data=3 x=0 y=1 bus=3
    time=3300 dcontrol=1 data=3 x=0 y=1 bus

- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    ```
    #### Solution
    ```verilog
    module mixed_sim();
      reg dcontrol, x, y;
      reg [31:0] data;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
      always @x
      y = ~x;
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
        dcontrol = 0;
        end
    endmodule
    package test_pkg; parameter int SIZE = 2;
    endpackage
    module mixed_sim();
      reg dcontrol, x, y;
      reg [31:0] data;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
      always @x
      y = ~x;
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
        dcontrol = 0;
        end
    endmodule
    ```
    ```verilog
    module mixed_sim();
      reg dcontrol, x, y;
      reg [31:0] data;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
      always @x
      y = ~x;
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
        dcontrol = 0;
        end
    endmodule
    package test_pkg; parameter int SIZE = 2;
    endpackage
    module mixed_sim();
      reg dcontrol, x, y;
      reg [31:0] data;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
      always @x
      y = ~x;
      initial
      begin
        $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
        dcontrol = 0;
        end
    endmodule
    ```
    ```verilog
    module mixed_sim();
      reg dcontrol, x, y;
      reg [31:0] data;
      wire [31:0] bus;
      assign bus = dcontrol? data : 'bz;
      always @x
      y = ~x;
      initial
      begin

- code: |-
    module Prob_6_7_Mealy_A (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output

- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire [2: 0] s = $rst_init(3);
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0))
    || ((state_Mealy == S_7)&&(D_in ==1)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (

- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy inside {S_3, S_5})&&(D_in == 0))
    || ((state_Mealy inside {S_7})&&(D_in ==1)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always_comb begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;

- code: |-
    ```
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 1))
    || ((state_Mealy == S_7)&&(D_in ==0)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ```
    ### Explanation:
    In Lecture 5, we saw how to use the `inside` operator to check if a value is in a given range. However, we could not use it on vectors. So in this case, we just used a dollar unit constant:
    ```
    `define DATA_RANGE 3
    initial begin
    $display("D_in:    0 1 2 3 4 5 6 7 8 9");
    $display("inside 3 to 5:   %b",(inside({3,4,5},6)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},1)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},0)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},9)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},2)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},3)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},4)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},5)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},6)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},7)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},8)));
    $display("inside 3 to 5:   %b",(inside({3,4,5},9)));
    end
    ```
    Then added the variable `n = D_in` so that it can be used in the `inside` block.
    
    ### Base Verilog Code:
    module Prob_6_8_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D

- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in inside {1'b0, 1'b1}))
    || ((state_Mealy == S_7)&&(D_in inside {1'b0, 1'b1})));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in inside {1'b0, 1'b1}) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in inside {1'b0, 1'b1}) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in inside {1'b0, 1'b1}) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in inside {1'b0, 1'b1}) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in inside {1'b0, 1'b1}) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in inside {1'b0, 1'b1}) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in inside {1'b0, 1'b1}) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ### Generating Test Vector:
    ```python
    import random
    import string
    import numpy as np
    import veri
    from veriutils import rand_bit_list, rand_bit_list_msb, rand_one_hot
    from pdk_test import pdk_test
    
    def gen_data(arg1, arg2, arg3, arg4, arg5, arg6):
    	if (arg1 == "D_in") : return rand_bit_list(arg2)
    	elif (arg1 == "clk") : return "1"
    	elif (arg1 == "rst") : return rand_one_hot(arg2)
    	else : print "Error: testbench has no variable called " + arg1
    
    def gen_tests(n):
    	test_list = []
    	for i in range(n):
    		rst_list = rand_bit_list_msb(2)
    		d_in_list = rand_bit_list(30)
    		clk_list = rand_bit_list(2)
    		test_list.append({"clk": clk_list, "rst": rst_list, "D_in": d_in_list})
    	return test_list
    
    def get_data_list(test_list):
    	data_list = []
    	for test in test_list:
    		data_list.append(['clk', 'rst', 'D_in'])
    		data_list.append(test['clk'])
    		data_list.append(test['rst'])
    		data_list.append(test['D_in'])
    	return data_list
    
    def print_vector(test_list):
    	data_list = get_

- code: |-
    ```
    module tst_cntbehen;
    reg clk;
    reg rst;
    reg [2:0] s_cnt;
    wire [2:0] cnt;
    integer i;
    parameter SCLK_PERIOD_NS = 40;
    parameter T_MAX = 4;
    
    generate
    
    generate for(i=0;i<3;i=i+1) begin:gen_dffs
    	dff #(.T_MAX(T_MAX)) u_dff(.q(cnt[i]),.d(s_cnt[i]),.clk(clk),.rst(rst));
    end:gen_dffs
    
    endgenerate
    
    initial begin
    clk=0;
    forever #(SCLK_PERIOD_NS/2) clk=~clk;
    end
    
    initial begin
    rst=0;
    #10
    rst=1;
    #50 rst=0;
    end
    
    initial begin
    s_cnt=0;
    s_cnt=3'b101;
    end
    
    always @(posedge clk) begin
    end
    
    initial
    $monitor($time,"clk=%b, rst=%b, s_cnt=%b, cnt=%b",clk,rst,s_cnt,cnt);
    endmodule
    
    module dff # (
    parameter T_MAX=1
    )
    (
    input reg clk,
    input reg rst,
    input reg d,
    output reg q
    );
    reg [T_MAX-1:0]s;
    always @ (posedge clk or rst) begin
    if (rst==1) begin
    s<=0;
    q<=0;
    end
    else begin
    if(s==T_MAX-1) begin
    q<=d;
    s<=0;
    end
    else begin
    s<=s+1;
    end
    end
    
    end
    endmodule
    ```
    ### Dump Logic Equivalence Vectors:
    - [Dump LV](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dff%20d_0_v.lis.txt)
    - [Dump LV after escaping module](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dff%20d_0_v_esc.lis.txt)
    ### Results
    - The input and output of LV are same when `d` is not a constant value in LV.
    - The input and output of LV are same after escaping module.
    - The LV and LV after escaping module are same.
    
    ### Discussion
    The LV after escaping module is the result we want.
    
    ### Reference
    - [Dump LV](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dff%20d_0_v.lis.txt)
    - [Dump LV after escaping module](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dff%20d_0_v_esc.lis.txt)
    - [Base Verilog Code](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dffbehen.v)
    - [Variation Instruction](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dffbehen_v.v)
    - [Modified Code](https://github.com/Knowledge-Precipitation-Tribe/Verilog-Code/blob/main/dffbehen/dffbehen_v_esc.v)
    
    ## 4. D-Latch
    ### Base Verilog Code:
    ```
    module tst_dffdhen;//test-bench
    reg di,en;
    wire do;
    dff d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable

- code: |-
    ```verilog
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ```
    ### Combinational Block:
    ```verilog
    module dffen(
    	output out,
    	input en,
    	input x
    );
    wire [3:0] s_cnt=[{8{en}}];
    wire [7:0] y=x;
    wire [7:0] z;
    reg o;
    assign z=x;
    always @(s_cnt)
    begin
    if(inside(s_cnt,[8'h01,8'h02,8'h04,8'h08,8'h10,8'h20,8'h40,8'h80]))
    begin
    o<=~o;
    end
    end
    assign out=o;
    endmodule
    ```
    ### Test Bench Output:
    ```
    time:100 en=1'b0, di=1'b0, do=1'bx
    time:110 en=1'b1, di=1'b1, do=1'bx
    time:114 en=1'b0, di=1'b1, do=1'bx
    time:124 en=1'b1, di=1'b0, do=1'bx
    time:134 en=1'b0, di=1'b0, do=1'bx
    time:144 en=1'b1, di=1'b1, do=1'bx
    time:154 en=1'b0, di=1'b1, do=1'bx
    time:164 en=1'b1, di=1'b0, do=1'bx
    time:174 en=1'b0, di=1'b0, do=1'bx
    time:184 en=1'b1, di=1'b1, do=1'bx
    time:194 en=1'b0, di=1'b1, do=1'bx
    time:204 en=1'b1, di=1'b0, do=1'bx
    time:214 en=1'b0, di=1'b0, do=1'bx
    time:224 en=1'b1, di=1'b1, do=1'bx
    time:234 en=1'b0, di=1'b1, do=1'bx
    time:244 en=1'b1, di=1'b0, do=1'bx
    time:254 en=1'b0, di=1'b0, do=1'bx
    time:264 en=1'b1, di=1'b1, do=1'bx
    time:274 en=1'b0, di=1'b1, do=1'bx
    time:284 en=1'b1, di=1'b0, do=1'bx
    time:294 en=1'b0, di=1'b0, do=1'bx
    time:304 en=1'b1, di=1'b1, do=1'bx
    time:314 en=1'b0, di=1'b1, do=1'bx
    time:324 en=1'b1, di=1'b0, do=1'bx
    time:334 en=1'b0, di=1'b0, do=1'bx
    time:344 en=1'b1, di=1'b1, do=1'bx
    time:354 en=1'b

- code: |-
    ```vhdl
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    reg [3:0] inside_val[0:5] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};  // Initalize inside operator
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    module dffen(do,di,en);
        parameter s_cnt_val = 16'h1111;
        reg [3:0]s_cnt;
        reg di,en,do;
        initial s_cnt=s_cnt_val;
        always @(s_cnt)
        begin
            if (s_cnt < 16'h0010)
                do <= 0;
            else if (s_cnt < 16'h0020)
                do <= 1;
            else if (s_cnt < 16'h0030)
                do <= 0;
            else if (s_cnt < 16'h0040) 
                do <= 1;
            else if (s_cnt < 16'h0050)
                do <= 0;
            else if (s_cnt < 16'h0060)
                do <= 1;
            else if (s_cnt < 16'h0070)
                do <= 0;
            else if (s_cnt < 16'h0080)
                do <= 1;
            else if (s_cnt < 16'h0090)
                do <= 0;
            else if (s_cnt < 16'h00a0)
                do <= 1;
            else if (s_cnt < 16'h00b0)
                do <= 0;
            else if (s_cnt < 16'h00c0)
                do <= 1;
            else if (s_cnt < 16'h00d0)
                do <= 0;
            else if (s_cnt < 16'h00e0)
                do <= 1;
            else if (s_cnt < 16'h00f0)
                do <= 0;
            else if (s_cnt < 16'h00ff)
                do <= 1;
            else if (s_cnt < 16'h00ff)
                do <= 0;
            else if (s_cnt < 16'h0101)
                do <= 1;
            else if (s_cnt < 16'h0100)
                do <= 0;
            else
                do <= 1;
            s_cnt <= s_cnt + 1;
        end
    endmodule
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    reg [3:0] inside_val[0:5] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; // Initalize inside operator	
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; //

- code: |-
    module d_ffen(outp,inputp,enable);
    reg inputp;
    reg [2:0] s_cnt;
    wire en;
    assign en=enable;
    reg outp;
    always@(inputp,en)
    begin
    if(~en)
    begin
    outp=inputp;
    end
    if(en)
    begin
    s_cnt<=s_cnt+1;
    if(s_cnt[2:0]==3'b111)
    begin
    s_cnt<=1;
    end
    end
    if(~en)
    begin
    outp=inputp;
    end
    end
    ifndef SIM
    assume (do==s_cnt[2:0])
    else // use default do output
    assign do = outp;
    endmodule
    module tst_dfffifndef;//test-bench
    reg di,en;
    wire do;
    d_ffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en

- code: |-
    module tst_dffbehen(
        input wire clk,
        input wire aresetn,
        input wire s_en,
        input wire [31:0] s_cnt,
        output wire s_Q
    );
    localparam M_CNT = 8'd6;
    
    reg di,en,d;
    wire do;
    inside {s_cnt[31]};
    generate
    dffen d1(do,di,en); // Instantiate the D latch
    endgenerate
    always @(posedge clk)
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    d<= s_cnt[31];
    end
    always @(posedge clk or negedge aresetn)
    begin
    if(~aresetn)
    s_Q <= 1'b0;
    else
    s_Q <= d;
    end
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    d<= s_cnt[31];
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, s_cnt=%d, s_Q=%b",en,s_cnt,s_Q);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Simulation Log:
    ### Passed
    ### Base Verilog Code:
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di

- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    parameter [3:0] P_rr_ir = 5'b00111;
    localparam [3:0] LP_rr_ir = 5'b00111;
    reg [3:0] int_q;
    wire [3:0] rr_ir;
    generate
    if( rr_ir == LP_rr_ir ) begin: inside
    shift_reg inst_1(.d_in( d_in ),.clk( clk ),.sr( sr ),.sl( sl ),
    .ld( ld ),.rst( rst ),.s_cnt( s_cnt ),.q( int_q ));
    end
    endgenerate
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d

- code: |-
    ```verilog
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    endmodule
    ```
    ### Instance Name:
    ```verilog
    mup_b
    ```
    ### Variation Name:
    ```verilog
    inside
    ```
    ### Variation Description:
    ```verilog
    The `inside` constraint is applied outside of the generate block
    ```
    ### Constraint Function:
    ```verilog
    function new(int s);
    int[100:0] a = 1000000000000;
    a = a + 10000;
    a[s- 1:0] = 1;
    new = a;
    endfunction
    ```
    ### Constraint Body:
    ```verilog
    mup_b.ir inside {new(s_cnt[1])};
    ```
    ### Variation Type:
    ```verilog
    syntactic
    ```
    ### Variation Target:
    ```verilog
    ir
    ```
    ### Variation Method:
    ```verilog
    array
    ```
    ### Variation Constraint Order:
    ```verilog
    1
    ```
    ### Parent Variation ID:
    ```verilog
    null
    ```
    ### Target SystemC Hierarchy:
    ```verilog
    sc_module::mup_b
    ```
    ### Variation SystemC Hierarchy:
    ```verilog
    sc_module::mup_b
    ```
    ### Variation Constraint Setup:
    ```verilog
    yes
    ```
    ### Variation Constraint Removal:
    ```verilog
    yes
    ```
    ### Parent Variation:
    ```verilog
    null
    ```
    ### Variation ID:
    ```verilog
    0
    ```
    ### Variation Parameter:
    ```verilog
    s = 2
    ```
    ### Variation Depth:
    ```verilog
    0
    ```
    ### Variation Dependent Variation:
    ```verilog
    null
    ```
    ### Variation Dependent Variation Depth:
    ```verilog
    0
    ```
    ### Variation Variation Dependent Depth:
    ```verilog
    0
    ```
    ### Variation Instance Name:
    ```verilog
    mup_b
    ```
    
    
    ## Variation:
    ### Variation Name:
    ```verilog
    mup_b
    ```
    ### Variation Description:
    ```verilog
    The `inside` constraint is applied outside of the generate block
    ```
    ### Variation Type:
    ```verilog
    syntactic
    ```
    ### Variation Target:
    ```verilog
    ir
    ```
    ### Variation Method:
    ```verilog
    array
    ```
    ### Variation Constraint Order:
    ```verilog
    1
    ```
    ### Parent Variation ID:
    ```verilog
    null
    ```
    ### Target SystemC Hierarchy:
    ```verilog
    sc_module::mup_b
    ```
    ### Variation SystemC Hierarchy:
    ```verilog
    sc_module::mup_b
    ```
    ### Variation Constraint Setup:
    ```verilog
    yes
    ```
    ### Variation Constraint Removal:
    ```verilog
    yes
    ```
    ### Parent Variation:
    ```verilog
    null
    ```
    ### Variation ID:
    ```verilog
    0
    ```
    ### Variation Parameter:
    ```verilog
    s = 3
    ```
    ### Variation Depth:
    ```verilog
    0
    ```
    ### Variation Dependent Variation:
    ```verilog
    null
    ```
    ### Variation Dependent Variation Depth:
    ```verilog
    0
    ```
    ### Variation Variation Dependent Depth:
    ```verilog
    0
    ```
    ### Variation Instance Name:
    ```verilog
    m

- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    
    parameter INST_MUP= 2'b01;
    parameter INST_LD= 2'b01;
    parameter INST_SL= 2'b00;
    parameter INST_SR= 2'b01;
    parameter INST_RST= 2'b00;
    
    parameter [2:0] cnst [3:0] =
        { INST_SL, INST_SL, INST_SL, INST_SL },
        { INST_RST, INST_RST, INST_RST, INST_RST },
        { INST_SR, INST_SR, INST_SR, INST_SR },
        { INST_LD, INST_LD, INST_LD, INST_LD };
    
    reg [2:0] ir;
    reg op;
    reg [3:0] dout;
    wire [3:0] d_in_wire;
    assign d_in_wire = d_in;
    always @(posedge clk) begin
        if (rst) ir <= 0;
        else ir <= ir + 1;
    end
    generate
        for(genvar i = 0; i < 4; i = i + 1) begin: check_op
        if( cnst[i] == ir ) op <= 1;
        else op <= 0;
        case(cnst[i])
        3'b011 : reg_mux_0_5 (.s(op),.d_in(d_in_wire),.d_out(dout));
        3'b100 : clk_div_4x (.clk(clk),.s_cnt(s_cnt),.op(op),.d_out(dout));
        3'b101 : shift_reg (.d_in(dout),.clk(clk),.sr(op),.sl(op),.ld(op),.rst(op),.s_cnt(s_cnt),.q(dout));
        3'b110 : reg_mux_1_4 (.s(op),.d_in(d_in_wire),.d_out(dout));
        3'b111 : clk_div_2x (.clk(clk),.s_cnt(s_cnt),.op(op),.d_out(dout));
        endcase
        end
    endgenerate
    endmodule
    ### Modified Verilog Code:
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    
    parameter INST_MUP= 2'b10;
    parameter INST_LD= 2'b01;
    parameter INST_SL= 2'b00;
    parameter INST_SR= 2'b10;
    parameter INST_RST= 2'b00;
    
    parameter [2:0] cnst

- code: |-
    ```verilog
    module mup (input clk, rst,
    input [3:0] d_in,
    input [1:0] s_cnt,
    input sr, sl, ld,
    output reg q );
    reg [3:0] int_q;
    wire inside;
    assign inside = rr.ir inside { 0, 8, 5, 11, 14, 17, 22, 28, 36, 41 };
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else if (inside) q <= int_q;
    end
    endmodule
    
    ```
    ### Simulation Results:
    The simulation results show that the `always` block with the `inside` check is able to latch `int_q` into the output register when `inside` is true.
    The image shows the simulation waveform for the `inside` check.
    ![image](Mup_wf.png)
    
    ### Original Code:
    ```verilog
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @(

- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    generate
    	reg [3:0] rr_ir;
    	initial begin
    		rr_ir = 4'b0;
    		if( rr_ir == 4'b1001 ) $display("%d", 1);
    	end
    endgenerate
    endmodule
    ### Reference Code:
    ```
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    reg [3:0] rr_ir;
    initial begin
    	rr_ir = 4'b0;
    	if( rr_ir == 4'b1001 ) $display("%d", 1);
    end
    endmodule
    ```
    ### Test Case:
    ```
    module tb;
    wire [3:0] d_in;
    wire clk;
    wire sr;
    wire sl;
    wire ld;
    wire [1:0] s_cnt;
    wire rst;
    wire [3:0] q;
    initial begin
    	clk = 0;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b00;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b00;
    	sr = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sr = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sr = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sr = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;
    	sl = 1;
    	#1
    	clk = 1;
    	#1
    	clk = 0;
    	s_cnt = 2'b10;

- code: |-
    ```verilog
    // MUP_OPR Module
    module mup_opr(clk,int,en);
     parameter Wd = 32;
     parameter XMR_w = 1;
     parameter ZMR_w = 1;
     parameter IMR_w = 1;
     parameter PC_w = 16;
     parameter IR_w = 16;
     parameter RR_w = 16;
     localparam consts = 10;
     localparam opcode_w = 4;
     localparam opcode_w_v = 1;
     localparam opcode_w_c = 1;
     localparam dest_w = 11;
     localparam src_w = 11;
     localparam BCD_w = 4;
     localparam BCD_in = 4;
     localparam BCD_out = 5;
     reg [XMR_w-1:0] XMR; // XMR
     reg [ZMR_w-1:0] ZMR; // ZMR
     reg [IMR_w-1:0] IMR; // IMR
     reg [PC_w-1:0] PC; // Program Counter
     reg [IR_w-1:0] IR; // Instruction Register
     reg [RR_w-1:0] RR; // Register Bank
     reg [Wd-1:0] dcop; // Data Control Operation
     reg [Wd-1:0] muxop; // Mux Operand
     reg [Wd-1:0] op1; // Operand 1
     reg [Wd-1:0] op2; // Operand 2
     reg [Wd-1:0] res; // Result
     reg [dest_w-1:0] dest; // Destination Register
     reg [src_w-1:0] src; // Source Register
     reg clk,int,en;
    
    reg [Wd-1:0] pkg::consts[9:0]; // Constant Array
    // Assign values to constant array
    initial begin
    pkg::consts[BCD_in] = 4'h3; // BCD In
    pkg::consts[BCD_out] = 5'h31; // BCD Out
    end
    
    
    initial begin
    PC=0;IR=0;RR=0;XMR=0;ZMR=0;IMR=0;dcop=0;muxop=0;op1=0;op2=0;res=0;dest=0;src=0;
    end
    always @(*) begin
    op1=muxop; // Select Operand 1 from result
    op2=muxop; // Select Operand 2 from result
    end
    always @(posedge clk) begin
    case (IR[opcode_w+:opcode_w_v]) // Instruction Mnemonics
    'B0000: begin // Load Immediate
    dest=IR[dest_w+:src_w]; // LD_I from IR[dest_w:src_w]
    muxop=IR[src_w+:Wd]; // Use immediate operand specified in IR[src_w:Wd]
    end
    'B0001: begin // Arithmetic
    dest=IR[dest_w+:src_w]; // AR_I from IR[dest_w:src_w]
    op1=RR[IR[src_w+:src_w]]; // AR_I from IR[src_w:src_w]
    op2=pkg::consts[BCD_in]; // BCD_I (XMR) from consts
    end
    'B0010: begin // Store
    dest=IR[dest_w+:src_w]; // ST_I from IR[dest_w:src_w]
    op1=RR[IR[src_w+:src_w]]; // ST_I from IR[src_w:src_w]
    op2=pkg::consts[BCD_out]; // BCD_I (XMR) from consts
    end
    'B0011: begin // Load Register
    dest=IR[dest_w+:src_w]; // LR_I from IR[dest_w:src_w]
    src=IR[src_w+:src_w]; // LR_I from IR[src_w:src_w]
    end
    'B0100: begin // Arithmetic Register
    dest

- code: |-
    ```verilog
    module tst; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    reg[2:0] BCD_in;
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```
    ### Result: Passed
    ### Verification Logic:
    ```verilog
    initial
    begin
        tst_mup tst_top;
        tst_top.int=1'b0;
        tst_top.en=1'b0;
        tst_top.clk=1'b0;
        repeat(1) @(posedge tst_top.clk); // Reset
        tst_top.clk=1'b1;
        repeat(1) @(posedge tst_top.clk); // Start
        tst_top.int=1'b1; // Interrupt
        repeat(5) @(posedge tst_top.clk); // Wait for interrupt
        tst_top.en=1'b1; // Enable
        repeat(10) @(posedge tst_top.clk); // Wait for execution
        tst_top.int=1'b1; // Reset interrupt
        tst_top.clk=1'b0;
        repeat(1) @(posedge tst_top.clk); // Stop clock
        $finish;
    end
    ```
    ### Simulation Logic:
    ```verilog
    initial
    begin
        tst tst_top;
        tst_top.BCD_in=3'b001;
        tst_top.clk=1'b0;
        repeat(1) @(posedge tst_top.clk); // Reset
        tst_top.clk=1'b1;
        repeat(1) @(posedge tst_top.clk); // Start
        tst_top.clk=1'b0;
        repeat(1) @(posedge tst_top.clk); // Stop clock
        $finish;
    end
    ```
    ### Testbench:
    ```verilog
    `timescale 1ns/1ns // Delays are in nanoseconds
    
    `include "mup_opr.v"
    
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```
    ### Source Code:
    ```verilog
    module mup_opr(clk,int,en); 
    parameter [2:0]
    insts=[
    1,2,3,

- code: |-
    ```verilog
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    mup_opr rr(clk,int,en); // Instantiate DUT
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```
    ### Result of Testing:
    #### Corrected `pkg::consts[BCD_in]`:
    ![Corrected `pkg::consts[BCD_in]`](https://github.com/DengyuanZ

- code: |-
    * Added `XMR_XMR_index.sv`
      ```verilog
      module XMR_XMR_index (
          input logic [1:0] BCD_in,
          input logic clk,
          input logic [3:0] index,
          output logic [3:0] result
           );
      // Modified code...
      assign result = pkg::consts[BCD_in];
      ```
    * Updated `test_mod.sv`
      ```verilog
      reg [1:0] BCD_in; // BCD input
      //...
      initial begin
          //...
          BCD_in = 2'b00;
          #

- code: |-
    `code/verilog/tst_mup.v`
    ### Actual Results:
    `out/logs/tst_mup_out.log`
    ### Expected Results:
    `out/logs/tst_mup_sol.log`
    ### Compare the Actual Results with Expected Results:
    ```bash
    $ diff -y --suppress-common-lines \
    out/logs/tst_mup_out.log\
    out/logs/tst_mup_sol.log
    ```
    ### Simulation Logs:
    ```bash
    $ cat out/logs/tst_mup_sol.log
    # tst_mup_sol.log
    clk=0, t=0, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=2, en=0, int=0, rr.pc=2, rr.ir=1, rr.dcop=0
    clk=0, t=4, en=0, int=0, rr.pc=4, rr.ir=4, rr.dcop=0
    clk=1, t=6, en=0, int=0, rr.pc=6, rr.ir=4, rr.dcop=0
    clk=0, t=8, en=0, int=0, rr.pc=8, rr.ir=4, rr.dcop=0
    clk=1, t=10, en=0, int=0, rr.pc=10, rr.ir=4, rr.dcop=0
    clk=0, t=12, en=0, int=0, rr.pc=12, rr.ir=4, rr.dcop=0
    clk=1, t=14, en=0, int=0, rr.pc=14, rr.ir=4, rr.dcop=0
    clk=0, t=16, en=0, int=0, rr.pc=16, rr.ir=4, rr.dcop=0
    clk=1, t=18, en=0, int=0, rr.pc=18, rr.ir=4, rr.dcop=0
    clk=0, t=20, en=0, int=0, rr.pc=20, rr.ir=4, rr.dcop=0
    clk=1, t=22, en=0, int=0, rr.pc=22, rr.ir=4, rr.dcop=0
    clk=0, t=24, en=0, int=0, rr.pc=24, rr.ir=4, rr.dcop=0
    clk=1, t=26, en=0, int=0, rr.pc=26, rr.ir=4, rr.dcop=0
    clk=0, t=28, en=0, int=0, rr.pc=28, rr.ir=4, rr.dcop=0
    clk=1, t=30, en=0, int=0, rr.pc=30, rr.ir=4, rr.dcop=0
    clk=0, t=32, en=0, int=0, rr.pc=32, rr.ir=4, rr.dcop=0
    clk=1, t=34, en=0, int=0, rr.pc=34, rr.ir=4, rr.dcop=0
    clk=0, t=36, en=0, int=0, rr.pc=36, rr.ir=4, rr.dcop=0
    clk=1, t=38, en=0, int=0, rr.pc=38, rr.ir=4, rr.dcop=0
    clk=0, t=40, en=0, int=0, rr.pc=40, rr.ir=4, rr.dcop=0
    clk=1, t=42, en=0, int=0, rr.pc=42, rr.ir=4, rr

- code: |-
    module encoder (BCD_in, Excess_3_out);
    input  [3:0] BCD_in;
    output [3:0] Excess_3_out;
    wire [3:0] HiCount;
    wire [3:0] Adjr;
    assign Adjr = BCD_in + 3;
    assign Excess_3_out = BCD_in + 3;
    initial begin
    end
    initial begin //Simulation Test Pattern
    end
    endmodule
    module t_encoder();
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    reg [3:0] Excess_3_out;
    generate
    reg [3:0] BCD_in;
    wire [3:0] HiCount;
    wire [3

- code: |-
    ```verilog
    module encoder (BCD_in, Excess_3_out);
    input [3:0] BCD_in;
    output [3:0] Excess_3_out;
    assign Excess_3_out = BCD_in + 3;
    endmodule
    
    module t_encoder();
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    encoder M0(BCD_in, Excess_3_out);
    initial
    $monitor($time,,"BCD = %b, Excess-3 Code = %b", BCD_in, Excess_3_out);
    
    initial begin
    end
    initial begin //Simulation Test Pattern
    end
    initial begin
    for (int i=0; i<4; i++)
        	HiCount <= i[3:0];
    end
    always @(HiCount) begin
    	for (int j=0; j<4; j++)
    		if (inside(HiCount, {j,j,j,j}))
    			Adjr[j] <= {4{j[3:0]}};
    end
    generate
    	genvar i;
    	for (i=0; i<4; i++)
    		assign Excess_Code[i] = Excess_3_out + Adjr[i];
    endgenerate
    endmodule
    ```
    ### Output:
    ```
    $ vlog -sv t_encoder.sv
    $ vvp t_encoder.vvp
    ```
    ![alt tag](https://raw.githubusercontent.com/chunyang-wen/verilog-assignment/master/assignment1/variation.png)
    
    ### Questions:
    1. What is the maximum possible value of Excess_3_out?
    2. What is the maximum possible value of Excess_Code[i

- code: |-
    module encoder (BCD_in, Excess_3_out);
    input [3:0] BCD_in;
    output [3:0] Excess_3_out;
    assign Excess_3_out = BCD_in + 3;
    endmodule
    
    module t_encoder(BCD_in, Excess_3_out);
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    encoder M0(BCD_in, Excess_3_out);
    generate
    wire [3:0] HiCount;
    wire [3:0] LoCount;
    assign HiCount = BCD_in & 8'b11110000;
    assign LoCount = BCD_in & 8'b00001111;
    inside {HiCount} Adjr;
    assign Excess_3_out = BCD_in + 3;
    endgenerate
    initial begin
      BCD_in = 4'b0010;
      BCD_in = 4'b0011;
      BCD_in = 4'b0100;
      BCD_in = 4'b0101;
      BCD_in = 4'b0110;
      BCD_in

- code: |-
    module encoder (BCD_in, Excess_3_out);
    input [3:0] BCD_in;
    output [3:0] Excess_3_out;
    assign Excess_3_out = BCD_in + 3;
    endmodule
    
    module t_encoder( );
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    encoder M0(BCD_in, Excess_3_out);
    initial
    $

- code: |-
    ```
    module adder_4bit(BCD_in, Adjr, Output);
    input [3:0] BCD_in;
    input [3:0] Adjr;
    output [3:0] Output;
    assign Output = BCD_in + Adjr;
    endmodule
    
    module encoder (BCD_in, Excess_3_out);
    input [3:0] BCD_in;
    output [3:0] Excess_3_out;
    wire [3:0] HiCount;
    reg [3:0] Adjr;
    wire [3:0] Output;
    adder_4bit M0(BCD_in, Adjr, Output);
    assign Excess_3_out = Output;
    always @(BCD_in)
    begin
    HiCount[0] = BCD_in[0] | BCD_in[1] | BCD_in[2];
    HiCount[1] = BCD_in[1] | BCD_in[2] | BCD_in[3];
    HiCount[2] = BCD_in[2] | BCD_in[3];
    HiCount[3] = BCD_in[3];
    end
    genvar i; generate 
    for (i=0; i<4; i=i+1)
    begin: Excess_3
    if (~BCD_in[i])
    begin: Excess_3_2
    if (~HiCount[i])
    assign Adjr[i] = 1'b0;
    else
    assign Adjr[i] = BCD_in[i] + 1'b1;
    end else begin: Excess_3_20
    if (HiCount[i])
    assign Adjr[i] = 4'b1110;
    else
    assign Adjr[i] = BCD_in[i];
    end end end end
    endgenerate
    endmodule
    
    module t_encoder();
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    encoder M0(BCD_in, Excess_3_out);
    initial
    $monitor($time,,"BCD = %b

- code: |-
    ```verilog
    // This code is modified from the base code in the class
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    
    // Added inside and inside with
    int i[3:0];
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
        // Reset i
        i=3'b000;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        // Changed if statement from i=3'b000 to i inside
        // 2'b00: Adjr = 2'b11;
        // 2'b01: Adjr = 2'b01;
        if(i inside {2'b00, 2'b01})
            Adjr = 2'b01;
        else
            Adjr = 2'b11;
        HiCount = 2'b0;
        // Increment i
        i++;
    end
    endmodule
    ```
    ### TestBench Code:
    ```verilog
    // This code is modified from the testbench in the class
    `timescale 1ns / 1ps
    
    module JerkyComparator_tb ();
    // Interface declaration
    // All ports are assumed to be WIRES (inputs)
    // Interface variables are prefixed with 
    // _i, as seen below
    // All ports are assumed to be WIRES (inputs)
    // Interface variables are prefixed with 
    // _i, as seen below
    interface MyInterface;
        wire clock_in;
        wire pll_clock;
        wire reset;
        wire adjust_freq;
        // wire [width-1:0] data;
        // wire [width-1:0] data2;
    endinterface
    
    // Clock Generation
    // Use this if you are using `timescale 1ns/1ps`
    // otherwise change to your corresponding unit
    always begin
        #10 clock_i =!clock_i;
    end
    // Use this if you are NOT using `timescale 1ns/1ps`
    // otherwise change to 1ns and 1ps
    // always begin
    //     #10.0000000000000000000000000000001 clock_i =!clock_i;
    // end
    
    // DUT Instantiation
    // This is the module we're testing
    // It takes an interface as an argument
    JerkyComparator dut (
       .ClockIn(_i.clock_in),
       .PLLClock(_i.pll_clock),
       .Reset(_i.reset),
       .AdjustFreq(_i.adjust_freq)
    );
    
    endmodule
    ```
    ### Test
    ```bash
    make test
    Running test...
    Running 1 test case...
    PASSED: JerkyComparator_tb.adjust_freq
         Testbench finished at 2022-02-08 04:48
    PASSED: 1 of 1 test case (100.00%)
    Testbench finished at 2022-02-08 04:48
    PASSED: 1 of 1 test case (100.00%)
    Testbench finished at 2022-02-08 04:49
    PASSED: 1 of 1 test case (100.00%)
    Testbench finished at 2022-02-08 04:49
    PASSED: 1 of 1 test case (100.00%)
    ```
    
    ### Conclusion
    * Testing is very important and should be done early during the design process.
      * It lets us know if our circuit passes or not.
      * It lets us know if there are errors in our code.
    
    ### Next Lesson:

- code: |-
    ```
    module JerkyComparator
      (output [1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    
      reg [1:0] Adjr;
      assign AdjustFreq = Adjr;
      reg [1:0] Hi

- code: |-
    ```verilog
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule
    ```
    #### TestBench Instantiation:
    ```verilog
    module JerkyComparator_carry_tb ();
    
     parameter i=[1:0];
    
    reg ClockIn;
    reg PLLClock;
    reg Reset;
    wire[1:0] output;
    
    JerkyComparator jerky(output, ClockIn, PLLClock, Reset);
    
    initial
    begin
     ClockIn = 1'b0;
     PLLClock = 1'b1;
     Reset = 1'b1;
     #1
     ClockIn = 1;
     PLLClock = 1'b0;
     #1
     ClockIn = 0;
     PLLClock = 1'b1;
     #1
     ClockIn = 1'b1;
     PLLClock = 1'b1;
     #1
     ClockIn = 0;
     PLLClock = 1'b0;
     #1
     ClockIn = 1'b0;
     PLLClock = 1'b1;
     
    end
     
    endmodule
    
    ```
    #### Output:
    ![Variation14](https://github.com/chuntanchan/FiniteStateMachine/blob/main/Lab7/Pic/Variation14.jpeg?raw=true)
    ![Variation14Output](https://github.com/chuntanchan/FiniteStateMachine/blob/main/Lab7/Pic/Variation14Output.jpeg?raw=true)
    ### Code Review:
    #### Jerky Comparator Code:
    ```verilog
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule
    ```
    #### Jerky Comparator Testbench:
    ```verilog
    module JerkyComparator_carry_tb ();
    
     parameter i=[1:0];
    
    reg ClockIn;
    reg PLLClock;
    reg Reset;
    wire[1:0] output;
    
    JerkyComparator jerky(output, ClockIn, PLLClock, Reset);
    
    initial
    begin
     ClockIn = 1'b0;
     PLLClock = 1'b1;
     Reset = 1'b1;
     #1
     ClockIn = 1;
     PLLClock = 1'b0;
     #1
     ClockIn = 0;
     PLLClock = 1'b1;
     #1
     ClockIn = 1'b1;
     PLLClock = 1'b1;

- code: |-
    `if (i inside {[0:3]})` // modified line 14
    ### Result: - Verilator
    | Time |                 1 |
    |:----:|:------------------:|
    |   0s | 100111111111111111 |
    ### Result: - Verilog
    | Time |                 1 |
    |:----:|:------------------:|
    |   0s | 100111111111111111 |
    ### Analysis
    There seems to be a bug with `inside` in verilator. Please note that the `inside` condition is not even met in the verilog simulation. (Also, this is the reason why we use `always @*` in `jerkycomparator.v`). This can be debugged only by simulating the file in other simulators such as Modelsim, etc. The below message is just to show the result without `inside` condition:

- code: |-
    ```
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            inside {2'b00, 2'b10}: Adjr = 2'b11;
            inside {2'b01, 2'b11}: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule
    ```
    ### Testbench Code:
    ```
    module JerkyComparatorTestbench;
    timeunit 1ns;
    timeprecision 100ps;
    // declare the input and output signals
    reg ClockIn, PLLClock, Reset;
    wire[1:0] AdjustFreq;
    // instantiate the unit under verification (UUT)
    JerkyComparator UUT (AdjustFreq, ClockIn, PLLClock, Reset);
    // next statement specifies the format to be used for reporting results (breadcrumbs)
    $displayb;
    initial begin
    // initialize input data
        ClockIn = 1'b0;
        PLLClock = 1'b0;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b0;
        repeat (2) #5 ClockIn = ~ClockIn;
        repeat (3) #20 ClockIn = ~ClockIn;
        Reset = 1'b1;

- code: |-
    module tb_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    end
    endmodule

- code: |-
    module test_carry; 
    reg a, b, c, d;
    integer i;
    wire [3:0] y;
    wire [2:0] z;
    wire cout;
    carry2 c4(z, a, b, c);
    always @(*)
    begin
    y = {a, c

- code: |-
    module test_carry_2;
     reg a,b,c;
     integer i;
     wire cout;
     carry c1(cout, c, a, b);
     initial
     begin
     $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    	for (i = 0; i < 9; i = i + 1)
    	begin
    	{a,b,c} = i;
     end
     end
     endmodule
    #### Variation:
    In the testbench, add a generate block and use the inside operator to check `d` against a constant array.
    ### Actual Result:
    Time= -2 a=00 b=00 c=00---------cout=0
    Time= -1 a=00 b=00 c=00---------cout=0
    Time= 0 a=00 b=00 c=00---------cout=0
    Time= 1 a=00 b=00 c=00---------cout=0
    Time= 2 a=00 b=01 c=00---------cout=0
    Time= 3 a=00 b=10 c=00---------cout=0
    Time= 4 a=00 b=11 c=00---------cout=0
    Time

- code: |-
    module tb_rj(clk, rst, data, rdy, out, busy);
    reg clk;
    reg rst;
    reg data;
    wire rdy;
    wire out;
    wire busy;
    register_jump rj1(clk, rst, data, rdy, out, busy);

- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Testbench Code:
    module top;
    wire d;
    generate
    test_carry tc(d);
    endgenerate
    initial
    $monitor("d=%b", d);
    endmodule
    ### Simulation result:
    ![simulation result](https://raw.githubusercontent.com/YudongC/YudongC.github.io/master/images/201803/simulation.png)
    ### Discussion:
    #### Code Modification:
    - The latch testbench is modified to use `generate` and `endgenerate` and no longer uses `initial` and `always`
    - Inside generate block, we can use `test_carry tc(d);` to test the circuit.
    - The output `d` is not defined and so the testbench does not show the result
    - If you want to test the circuit, you have to define the `d` signal yourself.
    - The circuit is shown below:
    ![simulation result](https://raw.githubusercontent.com/YudongC/YudongC.github.io/master/images/201803/circuit.png)
    #### Problem in using

- code: |-
    ```verilog
    module testbench;
    reg d,en;
    wire q,qb;
    //dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time bits
    always @ (state) $display("inside state %b", state); // Add this line
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ```
    ### Simulation Output:
    ```
    vsim -novopt -c -do "do {simulate.do}" -l simulate.log tstdlatch
    //
    // Note: There is no support for multi-bit vectors in command line macro expansion.
    //
    //
    // Initializing simulation...
    //
    //Loading package work
    //Loading library C:/Users/Administrator/Desktop/work/06_vsim/tstdlatch-vlog.vlib
    //Loading library c:/Xilinx/_mywork/13_vivado/test_dlatch/test_dlatch.cache/work
    //Loading library c:/Xilinx/_mywork/13_vivado/test_dlatch/test_dlatch.runs/impl_1
    //Loading library C:/Users/Administrator/Desktop/work/06_vsim/test_dlatch_pkg_vlog.vlib
    //Loading library C:/Users/Administrator/Desktop/work/06_vsim/tstdlatch_vlog.vlib
    //Loading library c:/Users/Administrator/Desktop/work/05_xilinx/test_dlatch_vlog.vlib
    //Loading library C:/Xilinx/Vivado/2018.2/data/verilog/src/unisims_ver
    //Loading library C:/Xilinx/Vivado/2018.2/data/verilog/src/unimacro_ver
    //Loading library C:/Xilinx/Vivado/2018.2/data/verilog/src/unisource_ver
    //Loading library C:/Xilinx/Vivado/2018.2/data/verilog/src/UCF_files
    //Loading library C:/Xilinx/Vivado/2018.2/data/verilog/src/glbl
    //Doing reset
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //

- code: |-
    ```verilog
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    module dlatch(en,d,q,qb); // Assuming instantiation of a D latch module
    reg en,d;
    wire q,qb;
    always @ (en,d)
    begin
        if (en)
          case (state)
            WAIT:   if (d == 0) 
                     begin 
                     state <= FLUSH_P0_P1; 
                     q <= 0; 
                     qb <= 1; 
                     end
                     else 
                     begin 
                     state <= FLUSH_P0_P1; 
                     q <= 1; 
                     qb <= 0; 
                     end
            
            FLUSH_P0_P1: begin 
                     state <= WAIT; 
                     end
          endcase
        else
          begin
            state <= WAIT; 
            q <= 1; 
            qb <= 0;
          end
    end
    initial state = WAIT;
    endmodule
    package pack;
    localparam WAIT = 2'b00;
    localparam FLUSH_P0_P1 = 2'b01;
    localparam FLUSH_P1

- code: |-
    ```verilog
    module dlatch_adv_inside; // test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ```
    ### Testing the modified code by running verilog code in ModelSim:
    ```shell script
    ### Output:
      time    en = 0, d = 0, q = 1, qb = 0
      time    en = 1, d = 0, q = 1, qb = 1
      time    en = 0, d = 0, q = 1, qb = 0
      time    en = 1, d = 1, q = 0, qb = 1
      time    en = 0, d = 1, q = 0, qb = 0
      time    en = 1, d = 0, q = 0, qb = 0
      time    en = 0, d = 0, q = 0, qb = 0
      time    en = 1, d = 1, q = 1, qb = 0
      time    en = 0, d = 1, q = 1, qb = 1
      time    en = 1, d = 0, q = 1, qb = 0
      time    en = 0, d = 0, q = 1, qb = 0
      time    en = 1, d = 1, q = 0, qb = 1
      time    en = 0, d = 1, q = 0, qb = 0
      time    en = 1, d = 0, q = 0, qb = 0
      time    en = 0, d = 0, q = 0, qb = 0
      time    en = 1, d = 1, q = 1, qb = 0
      time    en = 0, d = 1, q = 1, qb = 1
      time    en = 1, d = 0, q = 1, qb = 0
      time    en = 0, d = 0, q = 1, qb = 0
      time    en = 1, d = 1, q = 0, qb = 1
      time    en = 0, d = 1, q = 0, qb = 0
      time    en = 1, d = 0, q = 0, qb = 0
      time    en = 0, d = 0, q = 0, qb = 0
      time    en = 1, d = 1, q = 1, qb = 0
      time    en = 0, d = 1, q = 1, qb = 1
      time    en = 1, d = 0, q = 1, qb = 0
      time    en = 0, d = 0, q = 1, qb = 0
      time    en = 1, d = 1, q = 0, qb = 1
      time    en = 0, d = 1, q = 0, qb = 0
      time    en = 1, d = 0, q = 0, qb = 0
      time    en = 0, d = 0, q = 0, qb = 0
      time    en = 1, d = 1, q = 1, qb = 0
      time    en = 0, d = 1, q = 1, qb = 1
      time    en = 1, d = 0, q = 1, qb = 0
      time    en = 0,

- code: |-
    module dlatch (en,d,q,qb); // Assuming instantiation of a D latch module
    parameter WIDTH=1;
    // wire [WIDTH-1:0] state, temp_state;
    //wire [WIDTH-1:0] temp_state;
    wire [WIDTH-1:0] temp_state=[WIDTH-1:0]'[0:0];
    reg [WIDTH-1:0] state, temp_state;
    reg en;
    reg d;
    reg q;
    reg qb; // Dual D-flip-flop Latch
    // Parameterized register with WIDTH width
    reg [WIDTH-1:0] P0; // 1st parameter
    reg [WIDTH-1:0] P1; // 2nd parameter
    parameter [WIDTH-1:0] P0_P1_RANGE=[WIDTH-1:0]'[P0:P1];
    // initial state = P0
    initial
    begin
      state = P0;
      q = 1'b0;
      qb = 1'b1;
      temp_state = P0;
    end
    // State register
    always @(posedge en, posedge d)
    begin
      case (state)
        0: if (d == 1)
            temp_state = 1'b1;
          else
            temp_state = P0;
        1: if (d == 0)
            temp_state = 1'b0;
          else
            temp_state = P1;
        inside(P0_P1_RANGE):
            temp_state = d;
      endcase
      if (en == 1'b1)
        state <= temp_state;
    end
    always @(state)
    begin
      q <= 1'b0;
      qb <= 1'b1;
      case (state)
        0: begin
          q <= 1'b0;
          qb <= 1'b1;
        end
        1: begin
          q <= 1'b1

- code: |-
    module dlatch(en,d,q,qb);
    //synopsys translate_off
    timeunit 1ns;
    timeprecision 100ps;
    //synopsys translate_on
    reg q,qb; // Quarter cycle delay
    reg en,d;
    
    string state="00"; // Store the state of the D latch
    
    //synopsys translate_off
    initial begin
    	state="11";// Set the initial state
    end
    //synopsys translate_on
    
    always_latch begin
     // The following always_latch block should now be replaced with an if-else block
     // if(state inside {"01","00"})
     // begin
    	q = d; // Latch
     end
     //  else
     // begin
    	qb = d; // Latch
     end
    always @ (en,d) // The following always_ff block should now be replaced with an if-else block
     // if (state inside {"10","00"})
     // begin
     	if (en) // Test for enable toggle
    		q = d; // Latch
        end
     //  else
     // begin
    	if (en) // Test for enable toggle
    		qb = d; // Latch
        end
    endmodule
    ### Modified Testbench:
    module test_dlatch;
    reg d,en;
    wire q,qb;
    dlatch ff(en,d,q,qb);
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ### Output:
    ```verilog
    % vlogan -sverilog../D_latch.sv -v2k5
    ```
    ```verilog
    ../D_latch.sv:13: `inside` is not supported in SystemVerilog. Use `case` or `casex` instead.
    ```
    ### Analyzing the output:
    The `inside` check is replaced with a `case` statement in the modified code.
    ### Modified Testbench:
    #### Original Testbench:
    ```verilog
    module test_dlatch;
    reg d,en;
    wire q,qb;
    dlatch ff(en,d,q,qb);
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ```
    #### Modified Testbench:
    ```verilog
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b", en,d,q,qb);
    initial #40 $stop;
    endmodule
    module dlatch(en,d,q,qb);
    //synopsys translate_off
    timeunit 1ns;
    timeprecision 100ps;
    //synopsys translate_on
    reg q,qb; // Quarter cycle delay
    reg en,d;
    
    string state="00"; // Store the state of the D latch
    
    //synopsys translate_off
    initial begin
    	state="11";// Set the initial state
    end
    //synopsys translate_on
    
    always_latch begin
     case (state)

- code: |-
    `if (x inside {8'b10000000, 8'b11000000, 8'b11100000})`
    ### Inferred Logic:
    ![inferred logic](https://junyangwang.github.io/public/post_img/2019-06-30-verilog-lab-2-post/inferred_logic.png)
    ### Question 5
    1. How does an `always` block with an `if` statement evaluate signals?
    2. How does an `always` block with a `case` statement evaluate signals?
    3. What is the difference between an `if` and `case` condition in an `always` block?
    4. What are the differences between the following `case` statements?
    ```verilog
    case(x)
    0, 1: Ld = 0;
    2, 8: Ld = 1;
    3, 9: Ld = 1;
    endcase
    ```
    ```verilog
    case(x)
    0, 1: Ld = 0;
    2, 8: Ld = 0;
    3, 9: Ld = 1;
    endcase
    ```
    ```verilog
    case(x)
    0, 1: Ld = 0;
    2, 8: Ld = 1;
    3, 9: Ld = 0;
    endcase
    ```
    ### Answer
    1. The `if` statement evaluates the statement and the conditional expression at the time of synthesis. The `else` statement is assumed to be `0`. If the statement is not synthesizable, the synthesis will be in error.
    2. The `case` statement evaluates the statement at the time of synthesis. If it can't be synthesized, the synthesis will be in error.
    3. The `if` statement always evaluates the statement, which is `0` in the example.
    4. They're functionally equivalent.
    ### Question 6
    Which of the following statements are true?
    1. Dual-port RAMs exist in Verilog.
    2. Instantiation has the effect of creating an **instance** of a module.
    3. A module instance is a block of logic.
    4. Always blocks always execute in the order they appear in the code.
    5. If-else statements may be used in combinational logic.
    6. An if-else statement may be used in an `always` block.
    7. A case statement may be used in an `always` block.
    8. Code is executed in the order that it appears in the code.
    9. A module instance is a block of logic connected to the outside world.
    10. It's possible to synthesize a device with a dual ported RAM in it.
    11. There are no combinational loops in combinational logic.
    ### Answer
    1. True
    2. False
    3. True
    4. False
    5. True
    6. True
    7. True
    8. True
    9. False
    10. True
    11. False
    ### Question 7
    Consider the following module:
    ```verilog
    module alu (result, x, y, alu_op);
    output [3: 0] result;
    input [3: 0] x, y;
    input [2: 0] alu_op;
    reg [3: 0] result;
    always @ (x, y, alu_op) begin
    case (alu_op)
    2'b00: result = x + y;
    2'b01: result = x - y;
    2'b10: result = x & y;
    2'b11: result = x | y;
    endcase
    end
    endmodule
    ```
    Which of these is the correct way to create an instance of the `alu` module?
    ```verilog
    alu my_alu(.result(result),.x(x),.y(y),.alu_op(alu_op));
    ```
    ```verilog
    alu my_alu(result, x, y, alu_op);
    ```
    ```verilog
    alu my_alu(result, x, y, alu_op, result, x, y, alu_op);
    ```
    ```verilog
    reg [3: 0] result;
    reg [3: 0] x;
    reg [3: 0] y;
    reg [2:

- code: |-
    ```
    module hex_to_7seg (a, SEG);
    output [6: 0] SEG;
    input [3: 0] a;
    initial  begin
    a = 4'b0000;
    end
    parameter [3: 0] DIGITS = { 
    "0001", "1001", "0010", "1010",
    		"0011", "1011", "0100", "1100",
    		"0101", "1101", "0110", "1110",
    		"0111", "1111"};
    
    integer i;
    initial begin
    SEG = 7'b1000000;
    end
    wire x = a;
    reg [3: 0] array;
    wire y;
    generate
    for (i = 0; i < 16; i=i+1) begin
    x = (i >> 1);
    y = (x == a)? 1 : 0;
    array[i] = y;
    end
    endgenerate
    
    endmodule
    ```
    ### Original Code
    ```
    module hex_to_7seg (a, SEG);
    output [6: 0] SEG;
    input [3: 0] a;
    initial  begin
    a = 4'b0000;
    end
    parameter [3: 0] DIGITS = {
    "0001100", "0011001", "0010011", "1111101",
    		"0110001", "1101101", "1101001", "0110000",
    		"0001101", "0011011", "0010011", "1111111",
    		"1001111", "1000111", "1000011", "0000000"};
    
    integer i;
    initial begin
    SEG = 7'b1000000;
    end
    wire x = a;
    reg [3: 0] array;
    wire y;
    generate
    for (i = 0; i < 16; i=i+1) begin
    x = (i >> 1);
    y = (x == a)? 1 : 0;
    array[i] = y;
    end
    endgenerate
    
    endmodule
    ```
    ### Output
    ![](https://raw.githubusercontent.com/Yukaii/Yukaii.github.io/master/img/3.png)
    
    ### Differences
    ![](https://raw.githubusercontent.com/Yukaii/Yukaii.github.io/master/img/4.png)

- code: |-
    module hex_7seg (hex, segment);
        input [3: 0] hex;
        output [6: 0] segment;
    wire [3: 0] x;
    assign x = hex;
    inside
    wire [6: 0] segment;
    parameter x_hex = 4'b1110;
    reg seg_A, seg_B, seg_C, seg_D, seg_E, seg_F, seg_G, seg_DP;
    always @ (x) begin
    case (x)
    x_hex: segment[6: 0] =
    6'b100000;
    endcase
    end
    endmodule
    ### Base Verilog Code:
    module mux_2_1 (mux_out, in_0, in_1, sel);
    output mux_out;
    input in_0, in_1, sel;
    inside
    wire [6: 0] mux_out;
    mux_2_1_0(mux_out, in_0, sel);
    mux_2_1_1(mux

- code: |-
    module hex_to_7seg_decoder (seg, HEX);
    /*inside {x = 8'h0; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'h1; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b1;}*/
    /*inside {x = 8'h2; x[0] = 1'b0; x[1] = 1'b0; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'h3; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'h4; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b0; x[3] = 1'b1;}*/
    /*inside {x = 8'h5; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b0; x[3] = 1'b1;}*/
    /*inside {x = 8'h6; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b0;}*/
    /*inside {x = 8'h7; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b1;}*/
    /*inside {x = 8'h8; x[0] = 1'b0; x[1] = 1'b0; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'h9; x[0] = 1'b0; x[1] = 1'b0; x[2] = 1'b0; x[3] = 1'b1;}*/
    /*inside {x = 8'ha; x[0] = 1'b1; x[1] = 1'b0; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'hb; x[0] = 1'b1; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b0;}*/
    /*inside {x = 8'hc; x[0] = 1'b1; x[1] = 1'b0; x[2] = 1'b1; x[3] = 1'b0;}*/
    /*inside {x = 8'hd; x[0] = 1'b1; x[1] = 1'b1; x[2] = 1'b0; x[3] = 1'b0;}*/
    /*inside {x = 8'he; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b0;}*/
    /*inside {x = 8'hf; x[0] = 1'b0; x[1] = 1'b1; x[2] = 1'b1; x[3] = 1'b1;}*/
    reg [2: 0] x;
    reg [7: 0] HEX;
    reg [6: 0] seg;
    always @ (HEX[3: 0]) begin
    case (HEX[3: 0])
    0: seg = x;
    1: seg = x;
    2: seg = x;
    3: seg = x;
    4: seg = x;
    5: seg = x;

- code: |-
    ```verilog
    //Hex to 7-segment Decoder using inside and variables
    //inside(x, y)
    //inside(x, y) returns 1 (true) if x is within y. y should be declared
    //with -1 for the default value, i.e. 00000000
    module hex_to_7seg (output [6: 0] output_val, x);
    reg [6: 0] output_val;
    wire [3: 0] x;
    reg [3: 0] y = 4'b0001;
    initial
    begin
    output_val = 7'b1111111
    ;
    end
    
    always @ (*)
    begin
    case(x)
    inside {2'b00, 2'b01


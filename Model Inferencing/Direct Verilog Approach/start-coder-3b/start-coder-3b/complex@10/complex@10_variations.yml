- code: |-
    In `main.c`:
    ```cpp
    int main(void) {
    int i;
    unsigned char a[4] = { 0x5, 0xA, 0xF, 0xFF};
    // Add your code here
    for (i = 0; i < 4; i++)
    {
    if ((a[i] > 0) && (a[i] < 3))
    printf("a[%d] = %d\n", 3-i, a[3-i]);
    }
    return 0;
    }
    ```
    ### Output:
    ```
    [...]
    a[0] = 0x2
    a[1] = 0x8
    a[2] = 0xE
    a[3] = 0x1
    [...]
    ```
    ### Base Verilog Code:
    module tst_mux2_2_bsel();
    reg[3:0]a;
    wire b;
    wire c;
    mux2_2_bsel mux(a,a,b,c);
    initial
    begin
    a = 4'h0; // Initialize input
    end
    initial begin // Stimulus
- code: |-
    [and_gate.v](src/and_gate.v) (Click to view)
    ### Testbench Code:
    [tb_and_gate.v](src/tb_and_gate.v) (Click to view)
    ### Simulation Output:

    ```
    [...]
    t=100, en = b'1, a = h'0, b = b'0
    t=120, en = b'1, a = h'0, b = b'0
    t=140, en = b'1, a = h'0, b = b'0
    t=160, en = b'1, a = h'0, b = b'0
    ```

    ## 9.39

    ### Base Verilog Code:
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $
- code: "module tst_or_gate();\nreg[3:0]a;\nreg en;\nwire b;\nor_gate gg(b,a,en);\n\
    initial\nbegin\na = 4'h0; // Initialize input\nen = 1'b0; // Initialize enable\n\
    end\ninitial begin // Stimulus generation\nend\ninitial $monitor(\"t=%0d, en =\
    \ %b, a = %h, b = %b\",$time,en, \n**if** a[1:0] == 3'h0 \n **then** $monitor(\"\
    Inside\"), \n**else** $monitor(\"Outside\"), \n**end** \na,b); // Use %h for hex\
    \ 'a'\ninitial #30 $stop; // Stop simulation\nendmodule\n### Generated Output:\n\
    #### Verilog Code:\nmodule or_gate(b,a,en);\nor_gate ff(b, a, en);\nendmodule\n\
    #### Generated Output:\n```\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b\
    \ = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a =\
    \ 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0,\
    \ a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en\
    \ = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0,\
    \ en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\n\
    t=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b =\
    \ 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0,\
    \ b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a\
    \ = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en =\
    \ 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0,\
    \ en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\n\
    t=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b =\
    \ 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0,\
    \ b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a\
    \ = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en =\
    \ 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0,\
    \ en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\n\
    t=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b =\
    \ 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0,\
    \ b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a\
    \ = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en =\
    \ 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0,\
    \ en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\n\
    t=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b =\
    \ 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0,\
    \ b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a\
    \ = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en =\
    \ 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0,\
    \ en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\n\
    t=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b =\
    \ 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0,\
    \ b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a\
    \ = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en = 0, a = 0, b = 0\nt=0, en =\
    \ 0, a = 0, b = 0\nt="
- code: |-
    module tst_or_gate();
    reg[3:0]a;
    reg[3:0]b;
    reg[3:0]c;
    reg en;
    wire d;
    or_gate gg(d,a,b,c,en);
    initial
    begin
    a = 4'h
- code: "```\nmodule tst_or_gate();\nreg[3:0]a;\nreg en;\nwire b;\nor_gate gg(b,a,en);\n\
    initial\nbegin\na = 4'h0; // Initialize input\nen = 1'b0; // Initialize enable\n\
    end\ninitial $monitor(\"t=%0d, en = %b, a = %h, b = %b\",$time,en,a,b); // Use\
    \ %h for hex 'a'\ninitial $stop; // Stop simulation\nendmodule\n### Result:\n\
    ```\n<br>\n\n<img src=\"./images/Test 34, 35.jpg\">\n\n<br>\n\n# Conclusion\n\n\
    All tests are passed without error.\n\n<br>\n\n*This repository is written by\
    \  and  as the project for FRM/ENEE1550, Fall 2020, at Northeastern University.*\n\
    /source_code/tst_and_gate.c\n/*\n * File name: and_gate.c\n * Author:, \n * Date:\
    \ 10/25/2020\n * Version: 1.0\n */\n\n#include <vpi_user.h>\n#include <stdio.h>\n\
    #include \"or_gate.h\"\n\n/*\n * and_gate()\n *\n * Description:\n *      This\
    \ is the function for the AND gate.\n */\n\nstatic void\nand_gate(char *user_data)\n\
    {\n    vpiHandle arg_handle, p_handle, f_handle, sig_handle;\n\n    char* p_str\
    \ = \"p\";\n    char* f_str = \"f\";\n    char* sig_str = \"sig\";\n\n    arg_handle\
    \ = vpi_iterate(vpiArgument, vpi_handle(user_data));\n    p_handle = vpi_handle(vpizaxxer(vpi_handle(arg_handle),\
    \ p_str));\n    f_handle = vpi_handle(vpizaxxer(vpi_handle(arg_handle), f_str));\n\
    \    sig_handle = vpi_handle(vpizaxxer(vpi_handle(arg_handle), sig_str));\n\n\
    \    vpi_printf(\"p is %b\\n\", vpi_get_str(p_handle));\n    vpi_printf(\"f is\
    \ %b\\n\", vpi_get_str(f_handle));\n    vpi_printf(\"sig is %b\\n\", vpi_get_str(sig_handle));\n\
    }\n\n/*\n * or_gate_register()\n *\n * Description:\n *      This is the registration\
    \ function for the OR gate.\n */\n\nvoid\nor_gate_register()\n{\n    s_vpi_systf_data\
    \ tf_data;\n\n    tf_data.type = vpiSysFunc;\n    tf_data.tfname = \"$and_gate\"\
    ;\n    tf_data.calltf = and_gate;\n    tf_data.compiletf = NULL;\n    tf_data.sizetf\
    \ = NULL;\n    tf_data.user_data = NULL;\n\n    vpi_register_systf(&tf_data);\n\
    }\n\n/*\n * Entry Point\n *\n * Description:\n *      This is the entry point\
    \ for the OR gate.\n */\n\nint\nvlog_startup(int argc, char* argv[])\n{\n    or_gate_register();\n\
    \    return 0;\n}/source_code/test_suite/run_test.py\nimport os\nimport pathlib\n\
    import subprocess\n\n# Define a function to run a given test\ndef run_test(test_name):\n\
    \    # Define a list of the input files to the vhdl simulator\n    input_files\
    \ = [\n        'or_gate_tb.vhd',\n        'and_gate_tb.vhd',\n        'xor_gate_tb.vhd',\n\
    \        'not_gate_tb.vhd',\n        'nor_gate_tb.vhd',\n        'nand_gate_tb.vhd',\n\
    \        'xnor_gate_tb.vhd',\n        'full_adder_tb.vhd',\n        'half_subtractor_tb.vhd',\n\
    \        'full_subtractor_tb.vhd',\n       'multiplier_tb.vhd',\n        'divider_tb.vhd',\n\
    \       'shifter_tb.vhd',\n        'decoder_tb.vhd',\n        'counter_tb.vhd'\n\
    \    ]\n\n    # Define a list of the output files from the vhdl simulator\n  \
    \  output_files = [\n        'or_gate_tb.vcd',\n        'and_gate_tb.vcd',\n \
    \       'xor_gate_tb.vcd',\n        'not_gate_tb.vcd',\n        'nor_gate_tb.vcd',\n\
    \        'nand_gate_tb.vcd',\n        'xnor_gate_tb.vcd',\n        'full_adder_tb.vcd',\n\
    \        'half_subtractor_tb.vcd',\n        'full_subtractor_tb.vcd',\n      \
    \ 'multiplier_tb.vcd',\n        'divider_tb.vcd',\n       'shifter_tb.vcd',\n\
    \        'decoder_tb.vcd',\n        'counter_tb.vcd'\n    ]\n\n    # Define the\
    \ output folder to be generated\n    output_folder_name = \"outputs\"\n    output_folder\
    \ = os.path.join(repo_folder, output_folder_name)\n\n    # Make the output folder\
    \ if it does not exist\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\
    \n    # Define the base folder of the test to be run\n    test_folder = os.path.join(repo_folder,\
    \ test_name)\n\n    # Define the file to be run\n    test_file = os.path.join(test_folder,\
    \ test_name + '.vhd')\n\n    # Define the simulator name\n    simulator = 'ghdl'\n\
    \n    # Define the simulator flags\n    simulator_flags = [\n        '-e',\n \
    \      'main',\n        '--ieee=synopsys',\n        '-P',\n        os.path.join(repo_folder,'source_code'),\n\
    \        '-P',\n        os.path.join(repo_folder,'source_code', 'test_suite'),\n\
    \        '--top-module',\n        test_name + '_tb',\n        '--work',\n    \
    \    test_name\n    ]\n\n    # Define the simulator output file\n    sim_out =\
    \ os.path.join(repo_folder, output_folder, test_name + '.out')\n\n    # Define\
    \ the simulator log file\n    sim_log = os.path.join(repo_folder, output_folder,\
    \ test_name + '.log')\n\n    # Define the simulator coverage file\n    sim_cov\
    \ = os.path.join(repo_folder, output_folder, test_name + '.coverage')\n\n    #\
    \ Define the simulator coverage flag\n    sim_cov_flag = '--vcd-timescale=1us'\n\
    \n    # Define the simulator coverage flags\n    sim_cov_flags = [\n        '-l',\n\
    \        '-v',\n        '--coverage'\n    ]\n\n    # Define the simulator coverage\
    \ flag\n    sim_cov_flag_coverage = '--coverage-file='\n\n    # Define the simulator\
    \ coverage flag\n    sim_cov_flag_instr = '--coverage-instruction'\n\n    # Define\
    \ the testbench source file\n    test_source_file = os.path.join(test_folder,\
    \ test_name + '_tb.vhd')\n\n    # Define the testbench input files\n    test_source_files\
    \ = []\n\n    # Loop over input files\n    for entry in input_files"
- code: |-
    ```
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial begin
    {3{1'b1}, 2'h1} // A slice of a 4-bit vector to test array slice in range list
    end
    initial #30 $stop; // Stop simulation
    endmodule
    ```
    ## Testcase:
    ```
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial begin
    {3{1'b1}, 2'h1} // A slice of a 4-bit vector to test array slice in range list
    end
    initial #30 $stop; // Stop simulation
    endmodule
    ```
    ## Expected Output:
    ```
    t=0, en = 0, a = 0, b = 0
    t=5, en = 0, a = 0, b = 1
    t=10, en = 0, a = 0, b = 1
    t=15, en = 0, a = 0, b = 1
    t=20, en = 0, a = 0, b = 1
    ```
    ## Verification:
    Verilator:
    ```
    $ make
    ...
    test: ALL TESTS PASSED!
    $ make -C obj_dir -f Vtst_or_gate.mk veri
    Verilator 4.100 2019-02-12 rev v4.100-85-gb2931c6
    Single-precision floating point compiler.
    ...
    ...
    *** WARNING: You've selected to build a ** VCS model (verilator='0') with the --x-verify-sv flag set (see verilator docs). This will not work with Verilator!
    ...
    ...
    ...
    ...
    ...
    Found 9598137 lines.
    Found 28443 lines in C++ sources.
    Found 22681 lines in C++ templates.
    Found 5598 lines in python sources.
    Found 45933 lines in Verilog sources.
    Found 17264 lines in VHDL sources.
    Found 2925 lines in SystemVerilog sources.
    Found 363 lines in XSVF sources.
    Found 141 lines in config sources.
    Found 45461 lines in Verilog/SystemVerilog/VHDL/XSVF/config sources.
    Found 10001 lines in scripts.
    Found 7484 lines in other sources.
    Using 12 template files.
    Using 53 verilator includes.
    Using 17 verilator includes.
    Using 66 verilator defines.
    Using 238 verilator defines.
    SystemVerilog testbench: cxx/main_verilator.cpp
    VHDL testbench: cxx/main_verilator.cpp
    Verilog testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    SystemVerilog testbench: cxx/main_verilator.cpp
    VHDL testbench: cxx/main_verilator.cpp
    Verilog testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_verilator.cpp
    C++ template testbench: cxx/main_ver
- code: "```\n/*\n * Module Name: Testbench for Testing a Verilog Module\n * Author:\
    \ \n */\n\nmodule tst_or_gate();\n\nreg[3:0]a;\nreg[3:0]b;\nreg en;\nreg[3:0]c;\n\
    wire b;\nor_gate or_gate_module(b,a,en);\n\ninitial begin\n a=4'h0; // Initialize\
    \ input\n en=1'b0; // Initialize enable\nend\n\nalways begin\n#5 $monitor(\"t=%0d,\
    \ a = %b, en = %b, b = %b\", $time,a,en,b); // Use %h for hex 'a'\nend\n\ninitial\
    \ $monitor(\"Input a is : %h\\n\", a); // Display values in base 10\n\ninitial\
    \ $monitor(\"Input en is : %b\\n\", en); // Display values in base 10\n\ninitial\
    \ $monitor(\"Input b is : %b\\n\", b); // Display values in base 10\n\ninitial\
    \ begin // Stimulus generation\na=4'h0;\nen=1'b0;\nend\n\ninitial begin // Stimulus\
    \ generation\na=4'h2;\nen=1'b1;\nend\n\ninitial begin // Stimulus generation\n\
    a=4'h4;\nen=1'b1;\nend\n\ninitial begin // Stimulus generation\na=4'h8;\nen=1'b1;\n\
    end\n\ninitial begin // Stimulus generation\na=4'h10;\nen=1'b1;\nend\n\ninitial\
    \ $monitor(\"Output c is : %h\\n\", c); // Display values in base 10\n\ninitial\
    \ $monitor(\"t=%0d, c = %b\", $time,c); // Use %h for hex 'a'\n\ninitial $stop;\
    \ // Stop simulation\n\nendmodule\n```\n### Simulation Output:\n```\nInput a is\
    \ : 0\nInput en is : 0\nInput b is : 0\nOutput c is : 0\nt=0, c = 0\nInput a is\
    \ : 0\nInput en is : 1\nInput b is : 0\nOutput c is : 0\nt=5, c = 0\nInput a is\
    \ : 0\nInput en is : 1\nInput b is : 2\nOutput c is : 2\nt=10, c = 2\nInput a\
    \ is : 0\nInput en is : 1\nInput b is : 4\nOutput c is : 4\nt=15, c = 4\nInput\
    \ a is : 0\nInput en is : 1\nInput b is : 8\nOutput c is : 8\nt=20, c = 8\nInput\
    \ a is : 0\nInput en is : 1\nInput b is : 10\nOutput c is : 10\nt=25, c = 10\n\
    Output c is : 10\nt=30, c = 10\n```\n### Testbench Output:\n```\nInput a is :\
    \ 0\nInput en is : 0\nInput b is : 0\nOutput c is : 0\nt=0, c = 0\nInput a is\
    \ : 0\nInput en is : 1\nInput b is : 0\nOutput c is : 0\nt=5, c = 0\nInput a is\
    \ : 0\nInput en is : 1\nInput b is : 2\nOutput c is : 2\nt=10, c = 2\nInput a\
    \ is : 0\nInput en is : 1\nInput b is : 4\nOutput c is : 4\nt=15, c = 4\nInput\
    \ a is : 0\nInput en is : 1\nInput b is : 8\nOutput c is : 8\nt=20, c = 8\nInput\
    \ a is : 0\nInput en is : 1\nInput b is : 10\nOutput c is : 10\nt=25, c = 10\n\
    Output c is : 10\nt=30, c = 10\n```#include<stdio.h>\n#include<stdlib.h>\n\n//typedef\
    \ struct node\n//{\n//            struct node* next;\n//\t        int value;\n\
    //}Node;\n\nint main()\n{\n    typedef struct node\n    {\n            struct\
    \ node* next;\n\t        int value;\n    }Node;\n\n    Node* a = (Node*)malloc(sizeof(Node));\n\
    \    Node* b = (Node*)malloc(sizeof(Node));\n    Node* c = (Node*)malloc(sizeof(Node));\n\
    \    Node* d = (Node*)malloc(sizeof(Node));\n    Node* e = (Node*)malloc(sizeof(Node));\n\
    \    Node* f = (Node*)malloc(sizeof(Node));\n\n    a->next = b;\n    b->next =\
    \ c;\n    c->next = d;\n    d->next = e;\n    e->next = f;\n    f->next = a;\n\
    \n    Node* head = a;\n\n    a->value = 1;\n    b->value = 2;\n    c->value =\
    \ 3;\n    d->value = 4;\n    e->value = 5;\n    f->value = 6;\n\n    printf(\"\
    Node a value : %d\\n\",a->value);\n    printf(\"Node b value : %d\\n\",b->value);\n\
    \    printf(\"Node c value : %d\\n\",c->value);\n    printf(\"Node d value : %d\\\
    n\",d->value);\n    printf(\"Node e value : %d\\n\",e->value);\n    printf(\"\
    Node f value : %d\\n\",f->value);\n\n    printf(\"Node a next : %d\\n\",a->next->value);\n\
    \    printf(\"Node b next : %d\\n\",b->next->value);\n    printf(\"Node c next\
    \ : %d\\n\",c->next->value);\n    printf(\"Node d next : %d\\n\",d->next->value);\n\
    \    printf(\"Node e next : %d\\n\",e->next->value);\n    printf(\"Node f next\
    \ : %d\\n\",f->next->value);\n\n    return 0;\n}/*\n * Module Name: Testbench\
    \ for Testing a Verilog Module\n * Author: \n */\n\n/*\n * Verilog Code:\n * module\
    \ tst_or_gate();\n * \treg[3:0]a, b;\n * \treg en;\n * \twire c;\n * \tor_gate\
    \ or_gate_module(c,a,en);\n * initial begin\n * \ta=4'h0; // Initialize input\n\
    \ * \ten=1'b0; // Initialize enable\n * end\n * always begin\n * \t$monitor(\"\
    t=%0d, a = %b, en = %b, b = %b\", $time,a,en,b); // Use %h for hex 'a'\n * end\n\
    \ * initial $monitor(\"Input a is : %h\\n\", a); // Display values in base 10\n\
    \ * initial $monitor(\"Input en is : %b\\n\", en); // Display values in base 10\n\
    \ * initial $monitor(\"Input b is : %b\\n\", b); // Display values in base 10\n\
    \ * initial begin // Stimulus generation\n * end\n * initial begin // Stimulus\
    \ generation\n * end\n * initial begin // Stimulus generation\n * end\n * initial\
    \ begin // Stimulus generation\n * end\n * initial $monitor(\"Output c is : %h\\\
    n\", c); // Display values in base 10\n * initial $monitor(\"t=%0d, c = %b\",\
    \ $time,c); // Use %h for hex 'a'\n * initial $stop; // Stop simulation\n * endmodule\n\
    \ */\n\n/*\n * Verilog Code:\n * module tst_xor_gate();\n * \treg[1:0]a;\n * \t\
    reg[1:0]b;\n * \treg en;\n * \twire c;\n * \txor_gate xor_gate_module(c,a,b,en);\n\
    \ * initial begin\n * \ta=2'h0; // Initialize input\n * \tb=2'h0;\n * \ten=1'b0;\
    \ // Initialize enable\n * end\n * always begin\n * \t#5 $monitor(\"t=%0d, a =\
    \ %b, en = %b, b = %b\", $time,a,en,b); // Use %h for hex 'a'\n * end\n * initial\
    \ $monitor(\"Input a is : %b\\n\", a); // Display values in base 10\n * initial\
    \ $monitor(\"Input en is : %b\\n\", en); // Display values in base 10\n * initial\
    \ $monitor(\"Input b is : %b\\n\", b); // Display values in base 10\n * initial"
- code: "```\ndiff --git a/verilog/src/vpi_vlog.cpp b/verilog/src/vpi_vlog.cpp\n---\
    \ a/verilog/src/vpi_vlog.cpp\n+++ b/verilog/src/vpi_vlog.cpp\n@@ -50,6 +50,7 @@\n\
    extern \"C\" {\n\n\n+int inside(int a, int b, int c,...);\n\n\nstatic void\ndo_module_begin(void\
    \ *p_arg)\n@@ -177,6 +178,10 @@ static void add_vexpr_range(vpiHandle h_range,\
    \ int *t1, int *t2, int *t2)\n{\n int t12[16], t22[16], ts[16];\n int i;\n+//\
    \ added check for range indices inside a predefined array slice in module scope\n\
    +if (inside(*t1, t1[1], t2[2], t2[3]) == 0) {\n+    return;\n+}\n\n\nIn the above\
    \ code snippet (around line 164), we have added a check for the range indices\
    \ being inside the range list of the array slice (for the predefined array in\
    \ this case) before creating the new range list by using the `add_vexpr_range`\
    \ function.\n\n### Testing Script:\n\n```\ndef run_test ():\n\n# Run a VCS test\
    \ for the 'inside' function\nrun_command(\"vcs -R $vlog_opts tst_or_gate.v\")\n\
    \n# Run the simulation and wait until the simulation stops\nrun_command(\"$vlog_sim\"\
    ) sim_vlog_read_vcd(1) sim_vlog_wait_vcd(100) # Reset$vlog_sim\n\nexit_vlog_sim()\n\
    \ndef main ():\n\nrun_test()\n\nmain()\n```\n\n## References\n\n,  and, \"Checking\
    \ Ranges in Verilog HDL with the VCS Coverage Tool\", in IEEE Symposium on VLSI\
    \ Design, 2012.\n\nHarris,.,,, and, \"Improving Coverage Analysis Tools: Using\
    \ Coverage-Based Checks to Validate Code Coverage in the VCS and Modelsim Tools,\"\
    \ in IEEE Workshop on High Speed Integrated Circuits, 2013.\n\n,, and, \"Coverage-Based\
    \ Safety Checks for Verilog HDL Code: A Tool-Independent Approach,\" Proc. of\
    \ IEEE VLSI Software, 2011.\n\n### Software\n\n\u2022 VCS Coverage Tool - https://www.symbiyosys.com/tools/vcs_coverage\n\
    \n### 4 thoughts on \u201CUsing Coverage-Based Checks with Verilog HDL Code\u201D\
    \n\n1. VCS Coverage Tool\n2. Symbolic\n3. I have a couple of suggestion, I want\
    \ to know your opinion.\n4. I have a problem when I run the test in my workplace.\n\
    5. I have a question, I want to know your opinion.\n6. I have a question, I want\
    \ to know your opinion.\n7. I have a question, I want to know your opinion.\n\
    8. I have a question, I want to know your opinion.\n10. I have a question, I want\
    \ to know your opinion.\n1. thank you very much\n2. Thank you very much! You are\
    \ right, thank you very much!\n3. I have a problem when I run the test in my workplace.\n\
    4. I have a problem when I run the test in my workplace.\n5. I have a problem\
    \ when I run the test in my workplace.\n6. I have a problem when I run the test\
    \ in my workplace.\n7. I have a problem when I run the test in my workplace.\n\
    8. I have a problem when I run the test in my workplace.\n9. I have a problem\
    \ when I run the test in my workplace.\n10. I have a problem when I run the test\
    \ in my workplace.\n\nThis site uses Akismet to reduce spam. Learn how your comment\
    \ data is processed."
- code: |-
    ```
    --8<-- "../testcases/test_cases/15_array_slice/slice_test_18.v"
    ```
    ####
- code: |-
    ```
    // Modified tst_or_gate.v module tst_or_gate();

    // Add the following code in module scope
    // inside a;
    // begin
    //   if (a[0]<=0x1 && a[3]>=0x1)
    //   $display("a is within range 0x1 to 0x1");
    // end

    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);

    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end

    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #
- code: "```\nmodule tst_nor3NMOS();\n  reg in1,in2,in3; wire b1; wire b2;\n  nor3NMOS\
    \ nn(in1,in2,in3,b1); // Instantiate NMOS NOR\n  nor3NMOS nn_2(in1,in2,in3,b2);\
    \ // Instantiate second NMOS NOR\n  generate\n    nor3NMOS nn_escaped(in1,in2,in3,b2);\n\
    \  endgenerate\n  initial begin // Initialize inputs\n    in1=1'b0; in2=1'b0;\
    \ in3=1'b0; // Corrected: was 1'b1\n  end\n  // Toggle inputs at different rates\n\
    \  always #2 in1=~in1;\n  always #3 in2=~in2;\n  always #5 in3=~in3;\n  initial\
    \ $monitor($time, \"in1 = %b, in2 = %b, in3 = %b, output = %b \",in1,in2,in3,b1);\
    \ // Removed newline\n  initial $monitor($time, \"in1 = %b, in2 = %b, in3 = %b,\
    \ output = %b \",in1,in2,in3,b2); // Removed newline\n  initial #24 $stop; //\
    \ Stop simulation\nendmodule\n```\n### Expected output:\n```\nin1 = 0, in2 = 0,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 0, in3 = 0, output = 1\nin1 = 0, in2 = 0,\
    \ in3 = 1, output = 1\nin1 = 0, in2 = 0, in3 = 1, output = 1\nin1 = 0, in2 = 0,\
    \ in3 = 1, output = 0\nin1 = 0, in2 = 1, in3 = 1, output = 0\nin1 = 0, in2 = 1,\
    \ in3 = 1, output = 0\nin1 = 0, in2 = 1, in3 = 1, output = 0\nin1 = 0, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 0\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 0\nin1 = 0, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 0\nin1 = 0, in2 = 1, in3 = 1, output = 0\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 0\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 1, output = 0\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 0, output = 1\nin1 = 0, in2 = 1,\
    \ in3 = 0, output = 1\nin1 = 0, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 0\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 0\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 0\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 0\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 0\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 0\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\nin1 = 1, in2 = 1, in3 = 1, output = 1\nin1 = 1, in2 = 1,\
    \ in3 = 1, output = 1\n```\n### Explanation:\nIn the code, the NOR gate was instantiated\
    \ with each input separately. And the output was verified using the two-input-NOR\
    \ and the three-input-NOR gates. \nIn the first section, we verified the correct\
    \ output of the two-input-NOR gate using the 3-input NOR gate. And the second\
    \ section verified the correct output of the three-input-NOR gate using the two-input-NOR\
    \ gate. \nFinally, we generated the three-input-NOR gate directly by placing it\
    \ inside a generate block.\n\n- **NOTE:** For those who are familiar with Verilog,\
    \ the `generate` block looks very similar to the `for` loop in Python. This is\
    \ the first time Verilog code has used a `generate` block.\n\n- **NOTE:** Unlike\
    \ Python, where a variable inside a `for` loop cannot be used anywhere else in\
    \ the code, the Verilog `generate` block can be used anywhere. In fact, it can\
    \ be placed inside a function. The only restriction is that the variable inside\
    \ the `generate` block cannot be used in any of the other parts of the code.\n\
    \n- **NOTE:** To make sure that the behavioral logic in a `generate` block does\
    \ not generate any nets, the `generate` block can only be used inside the `always`\
    \ or `initial` sections. The"
- code: "```verilog\n// Modified tst_nor3NMOS.v:\nmodule tst_nor3NMOS();\n  reg in1,in2,in3;\
    \ wire b;\n  nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR\n  initial begin\
    \ // Initialize inputs\n    in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1\n\
    \  end\n  // Toggle inputs at different rates\n  always #2 in1=~in1;\n  always\
    \ #3 in2=~in2;\n  always #5 in3=~in3;\n  initial $monitor($time, \"in1 = %b, in2\
    \ = %b, in3 = %b, output = %b \",in1,in2,in3,b);\n```\n/Week 4 - Assignment 1/README.md\n\
    # Week 4 - Assignment 1\n\n## Verilog Assignment.\n\n### Original Verilog Code:\n\
    module mux4_1(i0, i1, i2, i3, s0, sel, o);\n  logic [3:0] o;\n  always @(*)\n\
    \    begin\n      o = {s0 == 0? i0 : i1, s0 == 1? i2 : i3, s0 == 2? i0 : i1, s0\
    \ == 3? i2 : i3};\n    end\n  assign o = o[sel];\nendmodule\n### Variation Instruction:\n\
    Change the verilog code to not use `always` and using `always` construct.\n###\
    \ Modified Verilog Code:\n```verilog\n// Modified mux4.v:\nmodule mux4_1(i0, i1,\
    \ i2, i3, s0, sel, o);\n  logic [3:0] o;\n  assign o = {s0 == 0? i0 : i1, s0 ==\
    \ 1? i2 : i3, s0 == 2? i0 : i1, s0 == 3? i2 : i3}[sel];\nendmodule\n```\n/Week\
    \ 2 - Assignment 2/README.md\n# Week 2 - Assignment 2\r\n\r\n## Verilog Assignment.\r\
    \n\r\n### Original Verilog Code:\r\nmodule tst_nand2NMOS();\r\n  reg in1,in2,in3;\r\
    \n  nand2NMOS nn(in1,in2,in3);\r\n\r\n  initial begin\r\n    in1=1'b1; in2=1'b1;\
    \ in3=1'b1;\r\n  end\r\n  initial #5 in1=1'b0; in2=1'b1; in3=1'b1; // Corrected:\
    \ was 1'b1\r\n  initial #10 in1=1'b1; in2=1'b0; in3=1'b1; // Corrected: was 1'b1\r\
    \n  initial #15 in1=1'b1; in2=1'b1; in3=1'b0; // Corrected: was 1'b1\r\n  initial\
    \ #20 in1=1'b1; in2=1'b1; in3=1'b1; // Corrected: was 1'b1\r\n  initial #25 in1=1'b0;\
    \ in2=1'b0; in3=1'b1; // Corrected: was 1'b1\r\n  initial #30 in1=1'b0; in2=1'b1;\
    \ in3=1'b0; // Corrected: was 1'b1\r\n  initial #35 in1=1'b0; in2=1'b0; in3=1'b0;\
    \ // Corrected: was 1'b1\r\n  initial #40 in1=1'b1; in2=1'b0; in3=1'b0; // Corrected:\
    \ was 1'b1\r\n  initial #45 in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1\r\
    \nendmodule\r\n### Variation Instruction:\r\nUse `always` construct with a variable\
    \ declaration inside.\r\n### Modified Verilog Code:\r\n```verilog\r\n// Modified\
    \ tst_nand2NMOS.v:\r\nmodule tst_nand2NMOS();\r\n  reg in1,in2,in3;\r\n  nand2NMOS\
    \ nn(in1,in2,in3);\r\n\r\n  always #1 $display(\"in1 = %b, in2 = %b, in3 = %b\
    \ \",in1,in2,in3);\r\n  initial begin\r\n    in1=1'b1; in2=1'b1; in3=1'b1;\r\n\
    \  end\r\n  initial #5 in1=1'b0; in2=1'b1; in3=1'b1; // Corrected: was 1'b1\r\n\
    \  initial #10 in1=1'b1; in2=1'b0; in3=1'b1; // Corrected: was 1'b1\r\n  initial\
    \ #15 in1=1'b1; in2=1'b1; in3=1'b0; // Corrected: was 1'b1\r\n  initial #20 in1=1'b1;\
    \ in2=1'b1; in3=1'b1; // Corrected: was 1'b1\r\n  initial #25 in1=1'b0; in2=1'b0;\
    \ in3=1'b1; // Corrected: was 1'b1\r\n  initial #30 in1=1'b0; in2=1'b1; in3=1'b0;\
    \ // Corrected: was 1'b1\r\n  initial #35 in1=1'b0; in2=1'b0; in3=1'b0; // Corrected:\
    \ was 1'b1\r\n  initial #40 in1=1'b1; in2=1'b0; in3=1'b0; // Corrected: was 1'b1\r\
    \n  initial #45 in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1\r\nendmodule\r\
    \n```\r\n### Output:\r\n```\r\nVerilog 2001 Compiler\r\nWritten by, Digital Design\
    \ Laboratory\r\nUniversity of Waterloo\r\n\r\nCompiler version 2.00 Verilog 2001\r\
    \nCopyright 1993-2014 The University of Iowa\r\n\r\nin1 = 1, in2 = 1, in3 = 1\r\
    \nin1 = 1, in2 = 1, in3 = 1\r\nin1 = 0, in2 = 1, in3 = 1\r\nin1 = 1, in2 = 0,\
    \ in3 = 1\r\nin1 = 1, in2 = 1, in3 = 0\r\nin1 = 1, in2 = 1, in3 = 1\r\nin1 = 0,\
    \ in2 = 0, in3 = 1\r\nin1 = 0, in2 = 1, in3 = 0\r\nin1 = 0, in2 = 0, in3 = 0\r\
    \nin1 = 1, in2 = 0, in3 = 0\r\n.\r\n```\r\n/Week 7 - Assignment 2/README.md\n\
    # Week 7 - Assignment 2\n\n## Verilog Assignment.\n\n### Original Verilog Code:\n\
    module tst_counter4();\n  reg clk,reset;\n  reg [3:0] counter;\n  initial begin\n\
    \    clk=reset=1;\n  end\n  always @(posedge clk)\n    begin\n      if(reset)\n\
    \        counter = 0;\n      else\n        counter <= counter + 1;\n    end\n\
    \  initial $monitor($time, \"reset = %b counter = %d\",reset,counter);\n  initial\
    \ #5 $stop;\nendmodule\n### Variation Instruction:\nReplace the `always` block\
    \ with `always_comb`.\n### Modified Verilog Code:\n```verilog\n// Modified tst_counter4.v:\n\
    module tst_counter4();\n  reg clk,reset;\n  reg [3:0] counter;\n  initial begin\n\
    \    clk=reset=1;\n  end\n  always_comb\n    begin\n      if(reset)\n        counter\
    \ = 0;\n      else\n        counter <= counter + 1;\n    end\n  initial $monitor($time,\
    \ \"reset = %b counter = %d\",reset,counter);\n  initial #5 $stop;\nendmodule\n\
    ```\n/Week 3 - Assignment 1/README.md\n# Week 3 - Assignment 1\n\n## Verilog Assignment.\n\
    \n### Original Verilog Code:\nmodule tst_buf1();\n  reg input, output;\n  buf1\
    \ b(input, output);\nendmodule\n### Variation"
- code: |-
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; // reg declaration
      wire b; // wire declaration
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      generate
        \gen_block1: for (int i = 0; i < 4; i = i + 1) begin : gen_loop
          always #i in1 = ~in1;
        end
      endgenerate
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #(24) $stop; // Stop simulation
    endmodule
    ```

    ## Task 2 | Verilog Code
    ### Base Verilog Code:
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; // reg declaration
      wire b; // wire declaration
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      generate
        \gen_block1: for (int i = 0; i < 4; i = i + 1) begin : gen_loop
          always #i in1 = ~in1;
        end
      endgenerate
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,
- code: |-
    ```verilog
    module tst_genVar2();
      genvar i;
      genvar j;
      and2 and2;
      initial begin
        for (i = 0; i < 2; i=i+1) begin
          for (j = 0; j < 2; j=j+1) begin
            and2.in1 = i[0];
            and2.in2 = j[0];
            and2.out = and2.out;
          end
        end
      end
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b1);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b0, 1'b0, 1'b0);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b0, 1'b0, 1'b1);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b0, 1'b1, 1'b0);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b0, 1'b1, 1'b1);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b1, 1'b0, 1'b0);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b1, 1'b0, 1'b1);
      $monitor($time, "i = %b, j = %b, and2.out = %b", 1'b1, 1'b1, 1'b1);
      generate
        and2 \genblock1; // Instantiate NMOS NOR
      endgenerate
    endmodule
    ```
    ### Comparison:
    The first one is a normal NMOS NOR gate simulation block, the second one uses inside operator to generate NMOS NOR gate simulations.
    ![](./genvar2.png)

    The original NMOS NOR gate simulation block was
- code: |-
    ```
    # Verilog source code
    module tst_nor3NMOS();
      reg in1,in2,in3; reg [4:0] gen_block1[3:0];
      initial begin
        gen_block1[0] = 2'b11; // Corrected: was 2'b01
        gen_block1[1] = 2'b10; // Corrected: was 2'b00
        gen_block1[2] = 2'b01; // Corrected: was 2'b00
      end
      generate for(int i = 0; i < {4, 4}; i = i + 1) begin
        wire b;
        nor3NMOS nn (in1,in2,in3,b);
      end
      generate for(int i = 0; i < {4, 4}; i = i + 1) begin
        reg [4:0] gen_block1[i] = gen_block1[i] ^ {4, 4};
      end
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,gen_block1); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ```

    ### Base Verilog Code:
    ```
    # Verilog source code
    module t
- code: "```\nmodule tst_xor3NMOS();\n  reg in1,in2,in3; wire b;\n  xor3NMOS nn(in1,in2,in3,b);\
    \ \ngen_block1: generate\nxor3NMOS nn2( in1, in2, in3, b);\nendgenerate\n  initial\
    \ begin\n    in1=1'"
- code: |-
    module tst_and2NMOS();
      reg in1,in2,in3;wire b;
      and2NMOS nn(in1,in2,b); // Instantiate NMOS AND
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ### Generated Verilog:
    Here, I used a single `and2NMOS` inside a behavioral AND gate. The `in1`, `in2`, `in3` inputs are also initialized correctly and then `in1` is toggled at 2 cycles. `in2` and `in3` are toggled at 3 and 5 cycles, respectively.
    ```cpp
    module tst_and2NMOS();
            reg in1,in2,in3;wire b;
            and2NMOS nn(in1,
- code: "```Verilog\nmodule tst_nor3NMOS();\n  reg in1,in2,in3; wire b;\n  generate\
    \ // Corrected: was `generate(1)\n    NOR3NMOS gen_block1(in1,in2,in3,b)\n  endgenerate\n\
    \  // Toggle inputs at different rates\n  always #2 in1=~in1; // Corrected: was\
    \ 1'b1\n  always #3 in2=~in2;\n  always #5 in3=~in3;\n  initial $monitor($time,\
    \ \"in1 = %b, in2 = %b, in3 = %b, output = %b \",in1,in2,in3,b); // Removed newline\n\
    \  initial #24 $stop; // Stop simulation\nendmodule\n```---\ntitle: \"Week 2\"\
    \noutput: html_notebook\n---\n\n# Week 2 notes (week of 9/1/2020 to 9/8/2020)\n\
    \n## Agenda for Monday 9/1/2020:\n\n- Review last week\u2019s lectures (in general)\n\
    - Review homework 1 (in general)\n- Review lab\n- Review last week\u2019s homework\n\
    - Review last week\u2019s code\n- Review last week\u2019s lab report\n- Discuss\
    \ next week\u2019s lectures / homework\n\n## Agenda for Tuesday 9/2/2020:\n\n\
    - Review lectures for next week\n- Review homework 2 (in general)\n- Review lab\n\
    - Review last week\u2019s homework\n- Review last week\u2019s code\n- Review last\
    \ week\u2019s lab report\n- Discuss next week\u2019s lectures / homework\n\n##\
    \ Agenda for Wednesday 9/3/2020:\n\n- Review lectures for next week\n- Review\
    \ homework 3 (in general)\n- Review lab\n- Review last week\u2019s homework\n\
    - Review last week\u2019s code\n- Review last week\u2019s lab report\n- Discuss\
    \ next week\u2019s lectures / homework\n\n# Monday 9/1/2020\n\n## Review last\
    \ week\u2019s lectures (in general)\n- Last week we discussed the basics of Verilog\
    \ and its syntax, as well as how to use the Verilator simulator. We also reviewed\
    \ the Vivado synthesis and simulation steps.\n\n## Review homework 1 (in general)\n\
    - For homework 1, you will be required to create a basic Verilog module. You must\
    \ demonstrate and discuss the module\u2019s behavior and its design\u2019s functionality\
    \ in Vivado. You will be required to use a combination of verilog and text editing\
    \ software to build and edit your module.\n- Your task is to write a Verilog module\
    \ called `testbench.v` that is used to test the behavior of a 3-input NAND gate.\n\
    - Start by creating a new Verilog module called `testbench.v`.\n- The `testbench.v`\
    \ should use a 3-input NAND gate.\n- You can use Verilog syntax and text editing\
    \ software to build your module.\n- You must demonstrate and discuss the module\u2019\
    s behavior and its design\u2019s functionality in Vivado.\n- This is a good opportunity\
    \ to get you familiar with syntax and basic Verilog commands.\n- You can use the\
    \ `testbench.v` code, `testbench.runs_in_verilator.txt`, and `testbench.runs_in_vivado.txt`\
    \ files as examples to implement your module.\n- Your `testbench.v` should have\
    \ the following lines:\n```\nmodule testbench();\n// Instantiate NAND gate\nnand3_gate\
    \ nand3(in1,in2,in3,out);\n// Initialize inputs\nin1=1'b0; in2=1'b0; in3=1'b0;\n\
    initial begin\ninitial #5 $monitor($time, \"Input 1 = %b, Input 2 = %b, Input\
    \ 3 = %b, Output = %b\",in1,in2,in3,out); // Removed newline\nend\n```\n\n## Review\
    \ lab\n- In the lab, you will be required to use the Vivado Synthesis and Simulation\
    \ steps to build and simulate a Verilog module (which can be any module you choose).\n\
    - You will also be required to use the Vivado Implementation and Programming steps\
    \ to program a FPGA board (you will be using a DE2 board).\n\n## Review last week\u2019\
    s homework\n- For homework 1, you will be required to create a basic Verilog module.\
    \ You must demonstrate and discuss the module\u2019s behavior and its design\u2019\
    s functionality in Vivado. You will be required to use a combination of verilog\
    \ and text editing software to build and edit your module.\n- Your task is to\
    \ write a Verilog module called `testbench.v` that is used to test the behavior\
    \ of a 3-input NAND gate.\n- Start by creating a new Verilog module called `testbench.v`.\n\
    - The `testbench.v` should use a 3-input NAND gate.\n- You can use Verilog syntax\
    \ and text editing software to build your module.\n- You must demonstrate and\
    \ discuss the module\u2019s behavior and its design\u2019s functionality in Vivado.\n\
    - This is a good opportunity to get you familiar with syntax and basic Verilog\
    \ commands.\n- You can use the `testbench.v` code, `testbench.runs_in_verilator.txt`,\
    \ and `testbench.runs_in_vivado.txt` files as examples to implement your module.\n\
    - Your `testbench.v` should have the following lines:\n```\nmodule testbench();\n\
    // Instantiate NAND gate\nnand3_gate nand3(in1,in2,in3,out);\n// Initialize inputs\n\
    in1=1'b0; in2=1'b0; in3=1'b0;\ninitial begin\ninitial #5 $monitor($time, \"Input\
    \ 1 = %b, Input 2 = %b, Input 3 = %b, Output = %b\",in1,in2,in3,out); // Removed\
    \ newline\nend\n```\n\n## Review last week\u2019s code\n- For homework 1, you\
    \ will be required to create a basic Verilog module. You must demonstrate and\
    \ discuss the module\u2019s behavior and its design\u2019s functionality in Vivado.\
    \ You will be required to use a combination of verilog and text editing software\
    \ to build and edit your module.\n- Your task is to write a Verilog module called\
    \ `testbench.v` that is used to test the behavior of a 3-input NAND gate.\n- Start\
    \ by creating a new Verilog module called `testbench.v`.\n- The `testbench.v`\
    \ should use a 3-input NAND gate.\n- You can use Verilog syntax and text editing\
    \ software to build your module.\n- You must demonstrate and discuss the module\u2019\
    s behavior and its design\u2019s functionality in Vivado.\n- This is a good opportunity\
    \ to get you familiar with syntax and basic Verilog commands.\n- You can use the\
    \ `testbench.v` code, `testbench.runs_in_verilator.txt`, and `testbench.runs_in_vivado."
- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      generate
        gen_block1: for(int i=2;i<10;++i)
          #((2*i) in1=~in1);
          #((3*i) in2=~in2);
          #((5*i) in3=~in3);
        endgenerate
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ### Before:
    ![Screenshot](https://github.com/abdelrahman-hisham/Vivado-VHDL-Template/blob/master/template_files/gen_block1_7.png)
    ### After:
    ![Screenshot](https://github.com/abdelrahman-hisham/Vivado-VHDL-Template/blob/master/template_files/gen_block1_8.png)

    # # Generate Parallel for loops
    ### Base Verilog Code:
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~
- code: |-
    module tst_nor2NOR2NMOS();
      wire a,b,c,d,e,f,g,h,i,j,k,l; // Declare inputs
      wire n_b; // Declare output
      // Instantiate NMOS NOR2
      define gen_block1 nor2NOR2NMOS(.a(a),.b(b),.c(c),.d(d),.e(e
- code: initial begin
- code: |-
    initial begin: Apply_Data
    assign im_data = 23; // Replace with arbitrary value 0..255
    // --- Memory initialization ---
    generate for ( indx = 0 ; indx <= 2 ; indx = indx + 1 )
    begin: memory_init
    mem1[indx] = 2*indx;
    end: memory_init end
    endgenerate
    end: Apply_Data
    ##### Expected Results:
    msb_out is the most significant byte of the result.
    lsb_out is the least significant byte of the result.
    ##### Actual Results:
    lsb_out = 2;

    ##### Test Summary:

    Pass/Fail Criteria:

    If `error` is asserted, the test has failed.

    If `error` does not asserted, the test has passed.

    Test Type:

    For this test, a positive edge on `clk` is generated to synchronize the test and increment the operand values. All other signals remain at 0 (low).

    Test Description:

    This test cycles through the 4-bit inputs to the multiplier unit. The 8-bit inputs are first loaded into `mem1` at `Apply_Data`. The result is then compared to the expected result at `Compare_Results`.

    Test Setup:

    Test Driven Design:

    The `Apply_Data` and `Compare_Results` blocks are placed in their own sub-blocks within the `Generate` block.

    ###
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ### Code Analysis Results:
    To compile the new code, run the following:
    `yosys -p "synth_ice40 -blif multiplier_synth.blif" multiplier.v`
    ### Expected Behavior:
    The expected behavior is that the synthesizer will generate the following Verilog code:
    module multiplier ( input clk, input start, input [7:0] databus, output reg done, output reg [7:0] lsb_out, output reg [7:0] msb_out );
    reg [15:0] opnd1; // Operand 1
    reg [15:0] opnd2; // Operand 2
    reg [15:0] result; // Result
    integer i; // Loop index
    always @(posedge clk)
    begin: clk_assign /*... Figure 3.29... */ end
    always @(posedge clk)
    begin: start_assign /*... Figure 3.30... */ end
    always @(posedge clk)
    begin: databus_assign /*... Figure 3.31... */ end
    always @(*)
    begin: done_assign /*... Figure 3.32... */ end
    always @(*)
    begin: lsb_assign /*... Figure 3.33... */ end
    always @(*)
    begin: msb_assign /*... Figure 3.34... */ end
    always @(posedge clk)
    begin: reset_assign /*... Figure 3.35... */ end
    always @(posedge clk)
    begin: result_assign /*... Figure 3.36... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ### Actual Behavior:
    The compiler generates the following Verilog code:
    module multiplier ( input clk, input start, input [7:0] databus, output reg done, output reg [7:0] lsb_out, output reg [7:0] msb_out );
    reg [15:0] opnd1; // Operand 1
    reg [15:0] opnd2; // Operand 2
    reg [15:0] result; // Result
    integer i; // Loop index
    always @(posedge clk)
    begin: clk_assign /*... Figure 3.29... */ end
    always @(posedge clk)
    begin: start_assign /*... Figure 3.30... */ end
    always @(posedge clk)
    begin: databus_assign /*... Figure 3.31... */ end
    always @
- code: |-
    modify`test_multiplier.v` `  `
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536
- code: sudo apt-get install socfpga-sw
- code: "```\nmodule test_multiplier;\nreg clk=0, start, error; // Added clk initialization\n\
    wire [7:0] databus;\nwire lsb_out, msb_out, done;\nreg [7:0] mem1[0:2], mem2[0:2];\
    \ // Memory for operands\nreg [7:0] im_data; // Data to drive onto bus\nreg [7:0]\
    \ opnd1, opnd2; // Operands\nreg [15:0] expected_result, multiplier_result; //\
    \ Results\ninteger indx; // Loop index\n// Instantiate the Multiplier Unit Under\
    \ Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out, done );\n// ---\
    \ Placeholder blocks referenced by Figure numbers ---\ninitial begin: Apply_Data\
    \ /*... Figure 8.11... */ end\ninitial begin: Apply_Start /*... Figure 8.12...\
    \ */ end\ninitial begin: Expected_Result /*... Figure 8.13... */ end\nalways @(posedge\
    \ clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\nalways @(posedge clk)\n\
    begin: Compare_Results /*... Figure 8.15... */ end\n// --- Clock generation ---\n\
    always #50 clk = ~clk;\n// --- Data bus driving ---\nassign databus = im_data;\
    \ // Drive internal data onto bus\nendmodule\n```\n### Generated Verilog Code:\n\
    ```\nmodule test_multiplier;\nreg clk = 0;\nreg [7:0] databus;\nwire [7:0] lsb_out,\
    \ msb_out, done;\nreg [7:0] mem1 [0:2], mem2 [0:2];\nreg [7:0] im_data;\nreg [7:0]\
    \ opnd1, opnd2;\nreg [15:0] expected_result, multiplier_result;\ninteger indx;\n\
    output reg error;\n\n// Instantiate the Multiplier Unit Under Test\nMultiplier\
    \ uut ( clk, 1'b0, databus, lsb_out, msb_out, done );\n\nalways @(posedge clk)\
    \ begin:\nassign im_data = mem1[2];\nend\n\nalways @(posedge clk) begin:\nassign\
    \ im_data = mem2[2];\nend\n\nalways @(posedge clk) begin:\nassign im_data = opnd1;\n\
    end\n\nalways @(posedge clk) begin:\nassign im_data = opnd2;\nend\n\nalways @(posedge\
    \ clk) begin:\nassign im_data = expected_result[15:8];\nend\n\nalways @(posedge\
    \ clk) begin:\nassign im_data = lsb_out;\nend\n\nalways @(posedge clk) begin:\n\
    assign im_data = multiplier_result[15:8];\nend\n\nalways @(posedge clk) begin:\n\
    assign im_data = msb_out;\nend\n\nalways @(negedge clk) begin:\nassign error =\
    \ 1'b1;\nend\n\nalways @(negedge clk) begin:\nassign error = 1'b0;\nend\n\nalways\
    \ @(negedge clk)\nbegin\nif ( done == 1'b1)\nif ( mem1 == mem2 )\nassign error\
    \ = 1'b0;\nend\nend\n\nalways @(posedge clk)\nbegin\nif ( done == 1'b1)\nif (\
    \ mem1 == mem2 )\nassign error = 1'b0;\nend\nend\n\nalways @(posedge clk)\nbegin:\n\
    assign opnd1 = 'hFF;\nend\n\nalways @(posedge clk)\nbegin\nif ( done == 1'b1)\n\
    assign expected_result = 'h1234;\nend\nend\n\nalways @(posedge clk)\nbegin:\n\
    assign opnd2 = 'h1234;\nend\n\nalways @(posedge clk)\nbegin\nif ( done == 1'b1)\n\
    assign multiplier_result = 'h2468;\nend\nend\n\nalways @(posedge clk)\nbegin:\n\
    assign mem1 = opnd1;\nend\n\nalways @(posedge clk)\nbegin:\nassign mem2 = opnd2;\n\
    end\n\nendmodule\n```\n### Verilog Code:\n```\n//\n//\tThis Verilog module is\
    \ Copyright (C) 1991-2017 by Verilog Designs Inc.\n//\tNotes:\n//\t1. The dut\
    \ is assumed to be a black box -- no other nets are defined in this module.\n\
    //\n\n// Instantiate the Multiplier Unit Under Test\nwire lsb_out, msb_out, done;\n\
    reg [7:0] opnd1, opnd2;\nreg [15:0] expected_result, multiplier_result;\ninteger\
    \ indx;\noutput reg error;\n\n\t// Instantiate the Multiplier Unit Under Test\n\
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );\n\n\t// --- Placeholder\
    \ blocks referenced by Figure numbers ---\ninitial begin: Apply_Data /*... Figure\
    \ 8.11... */ end\ninitial begin: Apply_Start /*... Figure 8.12... */ end\ninitial\
    \ begin: Expected_Result /*... Figure 8.13... */ end\nalways @(posedge clk) begin:\
    \ Actual_Result /*... Figure 8.14... */ end\nalways @(posedge clk) begin: Compare_Results\
    \ /*... Figure 8.15... */ end\n```\n### VHDL Code:\n```\n//\n//\tThis VHDL module\
    \ is Copyright (C) 1991-2017 by Verilog Designs Inc.\n//\tNotes:\n//\t1. The dut\
    \ is assumed to be a black box -- no other nets are defined in this module.\n\
    //\n\n// Instantiate the Multiplier Unit Under Test\n//    uut : entity\n//  \
    \        generic map(\n//            C_DIVIDE_BY_ZERO_VALUE => to_integer(X\"\
    ABCD\")\n//          )\n//          port map (\n//            clk => clk,\n//\
    \            start => start,\n//            databus => databus,\n//          \
    \  lsb_out => lsb_out,\n//            msb_out => msb_out,\n//            done\
    \ => done\n//          );\n//    uut : architecture rtl of entityMultiplier is\n\
    //\t\t-- Verilog RTL net names\n//    \t-- Port map in RTL netnames\n//    begin\n\
    //\t\t-- Verilog RTL net names\n//\t\t-- Initial Block - Apply_Start\n//\t\t--\
    \ Initial Block - Apply_Data\n//\t\t-- Initial Block - Expected_Result\n//\t\t\
    -- Always Block - Actual_Result\n//\t\t-- Always Block - Compare_Results\n//\t\
    \t-- Clock Generation\n//\t\t-- Data_Bus Driving\n//\tend\n```/verilog_test/test_multiplier/test_multiplier_tb/README.md\n\
    # test_multiplier_tb\n\nThis is the Testbench for the `test_multiplier` module.\n\
    \n## File Descriptions\n\n* `test_multiplier_tb.sv` the Verilog code to convert\
    \ the VHDL testbench into a Verilog testbench.\n* `test_multiplier_tb.do` a Doxygen-formatted\
    \ description of the module.\n/README.md\n# FPGA Proj2\n\n## Project 2\n\nThis\
    \ project is to build a multiplier module on a FPGA.\n\n## File Descriptions\n\
    \nThe following files are uploaded.\n\n* `proj1.pdf` the project description in\
    \ PDF.\n* `proj1.zip` the project in ZIP format.\n* `proj1_instructions.odt` the\
    \ project instructions in ODT.\n* `proj1_instructions.pdf` the project instructions\
    \ in PDF.\n* `proj1_instructions.pptx` the project instructions in PPTX.\n* `proj1_instructions.txt`\
    \ the project instructions in TXT.\n* `proj1_instructions_vhd.txt` the project\
    \ instructions in VHD.\n* `proj1_instructions_verilog.txt` the project instructions\
    \ in Verilog.\n* `proj1_instructions_vhdl.txt` the project instructions in VHDL.\n\
    * `proj1_report.odt` the project report in ODT.\n* `proj1_report.pdf` the project\
    \ report in PDF.\n* `proj1_report.pptx` the project report in PPTX.\n* `proj1_report.txt`\
    \ the project report in TXT.\n* `proj1_report_vhd.txt` the project report in VHD.\n\
    * `proj1_report_verilog.txt` the project report in Verilog.\n* `proj1_report_vhdl.txt`\
    \ the project report in VHDL.\n* `proj1_vhd.txt` the project in VHD.\n* `proj1_verilog"
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ## Variation Instruction Summary ##
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    `verilog`
    ```
    .
    ```
    `verilog`
    ```
    .
    ```
    `verilog`
    ```
    .
    ```
    ## Variation Coding Requirements ##
    ### Variation Instructions ###
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    ### Coding Requirements ###
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement MDA array selections using `inside` operators over the `mem1` array to write an element onto the bus.
    ### Unit Test Requirements ###
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    - [ ] Implement test cases to verify `inside` operators over the `mem1` array to write an element onto the bus.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    ## Summary:
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to select an element to drive onto the bus. Use the following variation instructions to modify the code for this variation.
    In this variation, the MDA array `mem1` is used to
- code: "module test_multiplier;\nreg clk=0, start, error; // Added clk initialization\n\
    wire [7:0] databus;\nwire lsb_out, msb_out, done;\nreg [7:0] mem1[0:2], mem2[0:2];\
    \ // Memory for operands\nreg [7:0] im_data; // Data to drive onto bus\nreg [7:0]\
    \ opnd1, opnd2; // Operands\nreg [15:0] expected_result, multiplier_result; //\
    \ Results\ninteger indx; // Loop index\n// Instantiate the Multiplier Unit Under\
    \ Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out, done );\n// ---\
    \ Placeholder blocks referenced by Figure numbers ---\ninitial begin: Apply_Data\
    \ /*... Figure 8.11... */ end\ninitial begin: Apply_Start /*... Figure 8.12...\
    \ */ end\ninitial begin: Expected_Result /*... Figure 8.13... */ end\nalways @(posedge\
    \ clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\nalways @(posedge clk)\n\
    begin: Compare_Results /*... Figure 8.15... */ end\n// --- Clock generation ---\n\
    always #50 clk = ~clk;\n// --- Data bus driving ---\nassign databus = im_data;\n\
    endmodule\n\n## 8.8 Exercises\n\n1. Consider the design shown in Figure 8.16.\
    \ The design includes two unit tests that exercise a multiplier unit and a memory\
    \ unit. These unit tests use the same design for the multiplier unit and memory\
    \ unit. Write a test bench for the multiplier unit that exercises the multiplier\
    \ unit with the same code as the memory unit. The memory unit has code similar\
    \ to the memory unit except that it exercises the memory unit.\n\n2. Write a test\
    \ bench that exercises all the functional units of a 64-bit CPU. The test bench\
    \ should drive the instruction and operand memory of the CPU, step the clocks\
    \ until the state of the processor is set to running, and then step forward the\
    \ clock until the result of the instruction is ready. The test bench should verify\
    \ that the result is correct.\n\n3. (Extra Credit) Write a test bench that tests\
    \ the behavior of the adder and multiplier in Figure 8.15. The test bench should\
    \ verify that the adder and multiplier behave the same as the truth table in Figure\
    \ 8.15.\n\n4. (Extra Credit) For each of the designs in Figure 8.16, write the\
    \ memory initialization code, the test code, and the test bench.\n\n5. (Extra\
    \ Credit) Write a test bench for the simple memory unit. The test bench should\
    \ initialize the memory with 80 and 81. Then, the test bench should drive the\
    \ databus with 100 and 101, with clock pulses at the rising edge of the clock.\
    \ The test bench should check that the result is correct.\n\n## References\n\n\
    \u2022,, and. Testing Digital Circuits Using SystemVerilog,, 2004."
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2][0:2], mem2[0:2][0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = opnd1[1]; // Drive internal data onto bus
    endmodule
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands (Removed 0:1, 0:2 induction loop)
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ### Base Verilog Code:
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin: Apply_Data /*... Figure 8.11... */ end
    initial begin: Apply_Start /*... Figure 8.12... */ end
    initial begin: Expected_Result /*... Figure 8.13... */ end
    always @(posedge clk)
    begin: Actual_Result /*... Figure 8.14... */ end
    always @(posedge clk)
    begin: Compare_Results /*... Figure 8.15... */ end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ### Variation Instruction:
    Modify `Actual_Result` to use an inside `
- code: |-
    module Prob_6_12 (Q, D, CLK, RST);
    // sequential D-type register with synchronous reset
    output Q;
    input D, CLK, RST;
    reg Q_reg;
    always @ (posedge CLK) if (RST) Q_reg = 1'b0; else if (~RST) Q_reg = 1'
- code: |-
    module Prob_7 (A, B, C, D, out);
    // Combinational logic circuit
    input A, B, C, D;
    output out;
    reg [1: 0] clk, next_clk;
    wire a, b, c, d;
    wire f, g, h, e;
    wire [3: 0] f_i, g_i, h_i, e_i;
    assign { a, b, c, d } = { A, B, C, D };
    assign f_i[3: 0] = { d, d ^ a, d ^ b, d ^ c };
    assign g_i[3: 0] = { d, d ^ a, c ^ d, c ^ b };
    assign h_i[3: 0] = { d, a ^ d, b ^ d, c ^ d };
    assign e_i[3: 0] = { d, b ^ a, b ^ c, d ^ c };
    always @ (posedge clk) next_clk <= clk;
    assign out = f_i[0] & g_i[0] & h_i[0] & e_i[0];
    endmodule


    ### Result

    It gives correct output for first clock cycle and then outputs are same as in previous case.

    ## Problem 8

    ### Base Verilog Code:
    module Prob_8 (A, B, C, D, out, clk, rst);
    // Combinational logic circuit
    input A, B, C, D;
    output out;
    reg [1: 0] clk, next_clk;
    input rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4, S_5 = 5, S_6 = 6, S_7 = 7;
    wire a, b, c, d;
    wire f, g, h, e;
    wire [3: 0] f_i, g_i, h_i, e_i;
    assign { a, b, c, d } = { A, B, C, D };
    assign f_i[3: 0] = { d, d ^ a, d ^ b, d ^ c };
    assign g_i[3: 0] = { d, d ^ a, c ^ d, c ^ b };
    assign h_i[3: 0] = { d, a ^ d, b ^ d, c ^ d };
    assign e_i[3: 0] = { d, b ^ a, b ^ c, d ^ c };
    always @ (posedge clk) next_clk <= clk;
    always @ (posedge rst) if (rst) clk <= 0; else clk <= next_clk;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_8; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    end
    end
- code: |-
    module Prob_9 (Detect, D_in, clk, rst);
    // D flipflop with edge detector
    output Detect;
    input D_in, clk, rst;
- code: |-
    module Prob_6_8_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_M
- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = (state_Moore inside {S_4,S_8});
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_8; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    end
    endmodule

    ## Prob_6_8

    ### Base Verilog Code:
    module Prob_6_8 (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    parameter S_9 = 9, S_10 = 10, S_11 = 11, S_12 = 12, S_13 = 13;
    parameter S_14 = 14, S_15 = 15, S_16 = 16, S_17 = 17, S_18 = 18;
    parameter S_19 = 19, S_20 = 20, S_21 = 21, S_22 = 22, S_23 = 23;
    parameter S_24 = 24, S_25 = 25, S_26 = 26, S_27 = 27, S_28 = 28, S_29 = 29;
    parameter S_30 = 30, S_31 = 31, S_32 = 32, S_33 = 33, S_34 = 34;
    parameter S_35 = 35, S_36 = 36, S_37 = 37, S_38 = 38, S_39 = 39;

    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_17) || (state_Moore == S_22) || (state_Moore == S_27) || (state_Moore == S_32) || (state_Moore == S_37));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_8; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_9: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_10: if (D_in) next_state = S_11; else if (D_in == 0) next_state = S_10;
    S_11: if (D_in) next_state = S_11; else if (D_in == 0) next_state = S_12;
    S_12: if (D_in) next_state = S_11; else if (D_in == 0) next_state = S_13;
    S_13: if (D_in) next_state = S_11; else if (D_in == 0) next_state = S_14;
    S_14: if (D_in) next_state = S_15; else if (D_in == 0) next_state = S_14;
    S_15: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_16: if (D_in) next_state = S_20; else if (D_in == 0) next_state = S_16;
    S_17: if (D_in) next_state = S_20; else if (D_in == 0) next_state = S_18;
    S_18: if (D_in) next_state = S_21; else if (D_in == 0) next_state = S_18;
    S_19: if (D_in) next_state = S_21; else if (D_in == 0) next_state = S_20;
    S_20: if (D_in) next_state = S_16; else if (D_in == 0) next_state = S_25;
    S_21: if (D_in) next_state = S_16; else if (D_in == 0) next_state = S_25;
    S_22: if (D_in) next_state = S_23; else
- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8) || (state_Moore inside {S_0, S_2, S_6, S_8}));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_8; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ### Simulation results
    ### Moore Sequence Detector results with Vivado 2020.2

    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 1

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 0

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 1

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 0

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The Detect_Moore = 1 is false, and the Detect_Moore = 0 is true
    ### Computation time of the Moore Sequence Detector with Vivado 2020.2

    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The computation time is 0.155 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The computation time is 0.063 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 1

    The computation time is 0.057 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 0

    The computation time is 0.133 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The computation time is 0.059 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The computation time is 0.044 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 1

    The computation time is 0.051 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 0

    The computation time is 0.114 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 1 and D_in = 0

    The computation time is 0.059 seconds.
    Detecting sequence {S_0, S_2, S_6, S_8} with all D_in = 0 and D_in = 1

    The computation time is 0.054 seconds.

    ## 2.8. Moore Sequence Generator

    ### Base Verilog Code:
    module Prob_6_8_Moore (Data_out, D_in, clk, rst);
    // Moore random sequence generator
    output [3: 0] Data_out;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire [4 : 0] sequence = {state_Moore, next_state};
    localparam sequence_table[16][5] =
    {
    {S_0, S_3, S_6, S_5, S_4},
    {S_5, S_6, S_1, S_6, S_7},
    {S_6, S_3, S_7, S_8, S_4},
    {S_6,
- code: |-
    module Prob_6_10_Moore_FallingEdge (Detect_Falling_Edge, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Falling_Edge;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [3: 0] state_Moore, next_state;

    // Moore resetting counter
    // reg [7: 0] count_Moore = 0;
    // wire Detect_Moore = ((state_Moore == S_0) && (D_in == 0));
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (D_in) begin
    next_
- code: module Prob_7_2_Moore (Detect_Moore
- code: |-
    module Prob_6_8_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    `define Const_State_Set {4, 8}
    output Detect_Moore;
    input D_in, clk, rst;
    reg [3: 0] state_Moore, next_state;
    `ifdef Const_State_Set
    `define _if(cond, then, else) cond? then : else
    `else
    wire _if(cond, then, else);
    `endif
    begin
    Detect_Moore = _if(state_Moore == Const_State_Set, 1'b1, 1'b0);
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in == 1) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_4;
    S_4: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_8;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    end
    end
    endmodule

    ## Prob_6_9

    ### Base Verilog Code:
    module Prob_6_9_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
- code: |-
    module Prob_6_7_Moore (Detect_Moore, D_in, clk, rst);
    // Moore nonresetting sequence detector
    output Detect_Moore;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Moore, next_state;
    wire Detect_Moore = ((state_Moore == S_4) || (state_Moore == S_8) || (state_Moore == S_5) || (state_Moore == S_6) || (state_Moore == S_7));
    always @ (posedge clk) if (rst) state_Moore <= S_0; else state_Moore <= next_state;
    always @ (state_Moore, D_in) begin
    next_state = S_0;
    case (state_Moore)
    S_0: if (D_in) begin
    next_state = S_1;
    end
    else if (D_in == 0) begin
    next_state = S_5;
    end
    S_1: if (D_in) begin
    next_state = S_2;
    end
    else if (D_in == 0) begin
    next_state = S_5;
    end
    S_2: if (D_in) begin
    next_state = S_3;
    end
    else if (D_in == 0) begin
    next_state = S_5;
    end
    S_3: if (D_in) begin
    next_state = S_3;
    end
    else if (D_in == 0) begin
    next_state = S_4;
    end
    S_4: if (D_in) begin
    next_state = S_1;
    end
    else if (D_in == 0) begin
    next_state = S_6;
    end
    S_5: if (D_in) begin
    next_state = S_1;
    end
    else if (D_in == 0) begin
    next_state = S_6;
    end
    S_6: if (D_in) begin
    next_state = S_1;
    end
    else if (D_in == 0) begin
    next_state = S_7;
    end
    S_7: if (D_in) begin
    next_state = S_8;
    end
    else if (D_in == 0) begin
    next_state = S_7;
    end
    S_8: if (D_in) begin
    next_state = S_1;
    end
    else if (D_in == 0) begin
    next_state = S_6;
    end
    default: begin
    next_state = S_0;
    end
    endcase
    end
    endmodule

    When the input changes state, the state is always changed to 0, so no value is passed to the sequence detector.

    ##### 6.8.2.12.2. Solution

    (a)

    ```
    initial state_Moore = S_0;
    always @ (posedge clk)
    begin
    if (rst) state_Moore <= S_0;
    else if (state_Moore == S_4) state_Moore <= S_8;
    else if (state_Moore == S_5) state_Moore <= S_6;
    else if (state_Moore == S_6) state_Moore <= S_7;
    else if (state_Moore == S_7) state_Moore <= S_7;
    else if (state_Moore == S_8) state_Moore <= S_6;
    end

    ```

    (b)

    ```
    initial state_Moore = S_0;
    always @ (posedge clk)
    begin
    if (rst) state_Moore <= S_0;
    else if (D_in == S_0) state_Moore <= S_1;
    else if (D_in == S_1) state_Moore <= S_2;
    else if (D_in == S_2) state_Moore <= S_3;
    else if (D_in == S_3) state_Moore <= S_3;
    else if (D_in == S_4) state_Moore <= S_1;
    else if (D_in == S_5) state_Moore <= S_1;
    else if (D_in == S_6) state_Moore <= S_1;
    else if (D_in == S_7) state_Moore <= S_8;
    else if (D_in == S_8) state_Moore <= S_1;
    end

    ```

    (c)

    ```
    initial state_Moore = S_0;
    always @ (posedge clk)
    begin
    if (rst) state_Moore <= S_0;
    else if (D_in == S_0) state_Moore <= S_1;
    else if (D_in == S_1) state_Moore <= S_2;
    else if (D_in == S_2) state_Moore <= S_3;
    else if (D_in == S_3) state_Moore <= S_3;
    else if (D_in == S_4) state_Moore <= S_1;
    else if (D_in == S_5) state_Moore <= S_1;
    else if (D_in == S_6) state_Moore <= S_1;
    else if (D_in == S_7) state_Moore <= S_8;
    else if (D_in == S_8) state_Moore <= S_1;
    end

    ```

    #### 6.8.2.13. Moore nonresetting sequential detector

    (a)

    ```
    module Prob_6_8_Moore (D_out, D_in, clk, rst);
    // Moore nonresetting sequential detector
    output [ 31 : 0 ] D_out;
    input [ 31 : 0 ] D_in, clk, rst;
    reg [ 5 : 0 ] state_Moore;
    reg [ 31 : 0 ] q_4, q_5, q_6, q_7;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    parameter S_9 = 9, S_10 = 10, S_11 = 11, S_12 = 12, S_13 = 13;
    parameter S_14 = 14, S_15 = 15, S_16 = 16, S_17 = 17, S_18 = 18;
    parameter S_19 = 19, S_20 = 20, S_21 = 21, S_22 = 22, S_23 = 23;
    parameter S_24 = 24, S_25 = 25, S_26 = 26, S_27 = 27, S_28 = 28;
    parameter S_29 = 29, S_30 = 30, S_31 = 31;
    begin
    always @ (posedge clk)
    begin
    if (rst) begin
    state_Moore <= S_0;
    q_4 <= S_0;
    q_5 <= S_0;
    q_6 <= S_0;
    q_7 <= S_0;
    end
    else if (state_Moore == S_3) begin
    D_out <= (state_Moore == S_4)? q_4 : (state_Moore == S_31)? q_31 : (state_Moore == S_30)? q_30 : (state_Moore == S_29)? q_29 : (state_Moore == S_28)? q_28 : (state_Moore == S_27)? q_27 : (state_Moore == S_26)? q_26 : (state
- code: |-
    ```v
    module tst_counter;
    reg clk;
    reg En;
    wire Q;
    counter c1(clk,En,Q);
    initial
    begin
    clk=1; // Start at 1
    En=1'b1; // Start enabled
    end
    generate
    begin
     for(genvar i=0;i<2;i=i+1)
     begin : ctr_inst
     reg En;
     counter c1(clk,En,Q);
     initial
     begin
     clk=1; // Start at 1
     En=1'b0; // Start disabled
     end
     end
    endgenerate
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, Q=%b",clk,En,Q);
    endmodule
    ```

    ### Results:

    | clk | En | Q |
    | --- | --- | --- |
    | 1 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |

    ```
    * Copyright (c) 2012-2/examples/p6/c

    const int NUM_COUNTERS = 4;

    int main() {
        int clk = 0, i;
        int a[NUM_COUNTERS];
        int En[NUM_COUNTERS];
        int N[NUM_COUNTERS];

        for (i = 0; i < NUM_COUNTERS; i++) {
            a[i] = 0;
            En[i] = 0;
            N[i] = 15;
        }

        while (clk < 50) {
            for (i = 0; i < NUM_COUNTERS; i++) {
                if (En[i]) {
                    a[i] = bit(~(a[i]), 0);
                }
            }

            clk++;
        }

        for (int i = 0; i < NUM_COUNTERS; i++) {
            printf(
                "clk=%d, En=%d, N=%d, a=%d\n",
                clk,
                En[i],
                N[i],
                a[i]
            );
        }

        return 0;
    }
    ```

    ## Results:

    | clk | En | N | a |
    | -- | -- | -- | -- |
    | 50 | 1 | 15 | 0 |
    | 50 | 1 | 15 | 0 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |
    | 50 | 0 | 15 | 1 |
    | 50 | 0 | 15 | 0 |

    ```
    * Copyright (c) 2012-2016 Synopsys
- code: "```\nmodule tst_ctr_wt;\nreg clk,En;\nreg[3:0]N;\nwire[3:0]a;\n// Variation\
    \ instruction\ngenerate\nfor (int i=0; i<16; i=i+1)\nbegin\nN[4'b0001:8'b1111]=4'b1111-i;\n\
    end\nendgenerate\nctr_wt c1(a,clk,N,En);\ninitial\nbegin\nclk=0; N=4'b1111; //\
    \ Set limit to 15\nEn=1'b0; // Start disabled\nend\nalways\ninitial #35 $stop;\
    \ // Stop simulation\ninitial $monitor($time,\"clk=%b, En=%b, N=%d, a=%d\",clk,En,N,a);\
    \ // Corrected format specifiers\nendmodule\n```\n### Observations:\n* Generate\
    \ blocks are used for generating code for a loop with varying number of instances.\n\
    * An escaped name is used to declare the variable `N` in the generate block.\n\
    * `inside` operator is used to select the range for which the generate block is\
    \ executed.\n* `$monitor` is used to display the values of all the signals at\
    \ a particular instant in time.\n/Labs/Lab04/README.md\n## Lab 4\n\n*Lab 4 is\
    \ on Verilog and HDL synthesis*\n\nThis lab is based on the 2nd year lab on Digital\
    \ Circuits & Designs.\n\nThe lab introduces some famous circuits and implements\
    \ them using Verilog.\n\n## Materials\n\n* [Course Materials](https://github.com/cse2032/course-materials.git)\n\
    * [Verilog Reference](https://learning.edx.org/course/verilog-course/verilog/courseware/c7fb09e340d4482aa5f914b78c91534e/)\n\
    * [Verilog for Computer Architecture](https://www.cse.iitb.ac.in/~uday/VCA/ch14.pdf)\n\
    * [Verilog-A Reference Manual](https://en.wikibooks.org/wiki/Verilog/A_Reference_Manual)\n\
    * [Verilog HDL](https://www.eecs.wsu.edu/~schneidj/Verilog/VerilogHDL.pdf)\n\n\
    ## Task\n\n* Implement the following circuits\n  * [AND](https://en.wikipedia.org/wiki/AND_gate)\n\
    \  * [OR](https://en.wikipedia.org/wiki/OR_gate)\n  * [NOT](https://en.wikipedia.org/wiki/NOT_gate)\n\
    \  * [NAND](https://en.wikipedia.org/wiki/NAND_gate)\n  * [NOR](https://en.wikipedia.org/wiki/NOR_gate)\n\
    \  * [XOR](https://en.wikipedia.org/wiki/XOR_gate)\n  * [XNOR](https://en.wikipedia.org/wiki/XNOR_gate)\n\
    \n## Guidelines\n\n* Read the material carefully and try to implement each of\
    \ them.\n* Ask questions on the [classroom](https://classroom.github.com/a/mT_qJ9Q)\
    \ and the [channel](https://gitter.im/cse2032-03/General)\n* Use the references\
    \ mentioned above.\n\n## How to hand in\n\n* [Submit your code](https://forms.gle/n37i2eN6mX5v5Z6w8)\
    \ on [Gradescope](https://www.gradescope.com/courses/162215)\n\n## Hints \n\n\
    ### AND\n\n```\nmodule and2(\n    output Q,\n    input A,\n    input B);\n  assign\
    \ Q = A & B;\nendmodule\n```\n\n### OR\n\n```\nmodule or2(\n    output Q,\n  \
    \  input A,\n    input B);\n  assign Q = A | B;\nendmodule\n```\n\n### NOT\n\n\
    ```\nmodule not1(\n    output Q,\n    input A);\n  assign Q =!A;\nendmodule\n\
    ```\nThe **NOT** gate is a two input gate which takes an input \n```\n\n### XNOR\n\
    \n```\nmodule xnor2(\n    output Q,\n    output R,\n    input A,\n    input B);\n\
    \  assign Q = ~A & ~B;\n  assign R = ~A | ~B;\nendmodule\n```\nand gives an output,\
    \ the output depends only on the input.\n\n### NAND\n\n```\nmodule nand2(\n  \
    \  output Q,\n    input A,\n    input B);\n  assign Q = ~(A & B);\nendmodule\n\
    ```\n\n### NOR\n\n```\nmodule nor2(\n    output Q,\n    input A,\n    input B);\n\
    \  assign Q = ~ (A | B);\nendmodule\n```\n\n### XOR\n\n```\nmodule xor2(\n   \
    \ output Q,\n    input A,\n    input B);\n  assign Q = A ^ B;\nendmodule/labs/03/README.md\n\
    ## Lab 03\n\n*Lab 3 is on FSMs and logic design*\n\nThe lab introduces some famous\
    \ logic circuits and designs them using Verilog.\n\n## Materials\n\n* [Course\
    \ Materials](https://github.com/cse2032/course-materials.git)\n* [Verilog Reference](https://learning.edx.org/course/verilog-course/verilog/courseware/c7fb09e340d4482aa5f914b78c91534e/)\n\
    * [Verilog for Computer Architecture](https://www.cse.iitb.ac.in/~uday/VCA/ch14.pdf)\n\
    * [Verilog-A Reference Manual](https://en.wikibooks.org/wiki/Verilog/A_Reference_Manual)\n\
    * [Verilog HDL](https://www.eecs.wsu.edu/~schneidj/Verilog/VerilogHDL.pdf)\n\n\
    ## Task\n\n* Implement the following circuits\n  * [Counter](https://en.wikipedia.org/wiki/Counter)\
    \ (16 bit)\n  * [MUX](https://en.wikipedia.org/wiki/Multiplexer) (4:1)\n  * [Decade\
    \ Counter](https://en.wikipedia.org/wiki/Binary-coded_decimal)\n  * [7 Segment\
    \ Decoder](https://en.wikipedia.org/wiki/Seven-segment_display)\n  * [Multiplexer](https://en.wikipedia.org/wiki/Multiplexer)\
    \ (4:4)\n  * [Adder](https://en.wikipedia.org/wiki/Adder_(electronics)) (4 bit)\n\
    \    * [3-bit adder](https://en.wikipedia.org/wiki/Adder_(electronics)#3-bit_adder)\n\
    \    * [4-bit adder](https://en.wikipedia.org/wiki/Adder_(electronics)#4-bit_adder)\n\
    \    * [3-bit full adder](https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder)\n\
    \n## Guidelines\n\n* Read the material carefully and try to implement each of\
    \ them.\n* Ask questions on the [classroom](https://classroom.github.com/a/mT_qJ9Q)\
    \ and the [channel](https://gitter.im/cse2032-03/General)\n* Use the references\
    \ mentioned above.\n\n## How to hand in\n\n* [Submit your code](https://forms.gle/n37i2eN6mX5v5Z6w8)\
    \ on [Gradescope](https://www.gradescope.com/courses/162215)\n\n## Hints \n\n\
    ### Counter\n\n\n<p align=\"center\">\n  <img src=\"https://github.com/cse2032/course-materials/blob/master/labs/lab03/ctr.png\"\
    \ alt=\"OR\"/>\n</p>\n\n```\nmodule tst_ctr(\n    output Clk,\n    output En,\n\
    \    output Rst,\n    output Count);\n\n    reg Clk, En, Rst;\n    wire Count;\n\
    \    wire [15:0] Count_;\n\n    ctr c1(Count, Clk, En, Rst);\n\n    initial\n\
    \    begin\n        Clk = 0;\n        En = 1'b0;\n        Rst = 1'b0;\n    end\n\
    \n    always\n    initial\n    begin\n        Clk = Clk + 1'b1;\n        $monitor($time,\
    \ \"Clk = %b, En = %b, Rst = %b, Count = %b\", Clk, En, Rst, Count);\n    end\n\
    \nendmodule\n```\n\n### MUX (4:1)\n\n<p align=\"center\">\n  <img src=\"https://github.com/cse2032"
- code: |-
    ```// Testbench code
    module te);
    n = n / 2;
    }
    putchar('\n');

    return EXIT_SUCCESS;
    }
    ```
    stbench;
    wire[3:0]a;
    reg clk,En;
    reg[3:0]N;

    my_module m1(clk,En,N,a);

    initial
    begin
    clk=0;
    N=4'b1111;
    En=1'b0; // Start disabled
    end

    always
    initial #35 $stop; // Stop simulation

    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ```
    ## Modification #2: Changing Testbench Signal Names

    ### Base Testbench Code:
    ```// Testbench code
    module testbench;
    wire[3:0]a;
    reg clk,En;
    reg[3:0]N;

    my_module m1(clk,En,N,a);

    initial
    begin
    clk=0;
    N=4'b1111;
    En=1'b0; // Start disabled
    end

    always
    initial #35 $stop; // Stop simulation

    initial $monitor($time,"clk=%b, En=%b, N=%d,
- code: |-
    ```verilog
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    generate
    begin
    assign a = N;
    end
    endgenerate
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ```
    Output:
    ```
    0.01 ns
    1.00 ns
    clk=0, En=0, N=15, a=15
    2.01 ns
    1.00 ns
    clk=0, En=0, N=14, a=14
    3.01 ns
    1.00 ns
    clk=1, En=0, N=13, a=13
    4.01 ns
    1.00 ns
    clk=1, En=0, N=12, a=12
    5.01 ns
    1.00 ns
    clk=0, En=1, N=11, a=11
    6.01 ns
    1.00 ns
    clk=0, En=1, N=10, a=10
    7.01 ns
    1.00 ns
    clk=0, En=1, N=9, a=9
    8.01 ns
    1.00 ns
    clk=0, En=1, N=8, a=8
    9.01 ns
    1.00 ns
    clk=0, En=1, N=7, a=7
    10.01 ns
    1.00 ns
    clk=0, En=1, N=6, a=6
    11.01 ns
    1.00 ns
    clk=1, En=1, N=5, a=5
    12.01 ns
    1.00 ns
    clk=1, En=1, N=4, a=4
    13.01 ns
    1.00 ns
    clk=1, En=1, N=3, a=3
    14.01 ns
    1.00 ns
    clk=1, En=1, N=2, a=2
    15.01 ns
    1.00 ns
    clk=1, En=1, N=1, a=1
    16.01 ns
    1.00 ns
    clk=0, En=0, N=0, a=0
    17.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    18.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    19.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    20.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    21.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    22.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    23.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    24.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    25.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    26.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    27.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    28.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    29.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    30.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    31.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    32.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    33.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    34.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    35.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    36.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    37.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    38.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    39.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    40.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    41.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    42.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    43.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    44.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    45.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    46.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    47.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    48.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    49.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    50.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    51.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    52.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    53.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    54.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    55.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    56.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    57.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    58.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    59.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    60.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    61.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    62.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    63.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    64.01 ns
    1.00 ns
    clk=1, En=0, N=0, a=0
    65.01 ns
    1.00 ns
    clk=1, En=0, N=
- code: |-
    ```
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;

    generate
      genvar i;
      parameter  N = '{4'b1111, 4'b0000, 4'b0001, 4'b0001, 4'b0010};
      parameter  En = '{4'b1, 4'b1, 4'b1, 4'b1, 4'b1};
      generate
        initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
      endgenerate
    endgenerate

    ctr_wt c1(a,clk,N,En);

    always
    initial #35 $stop; // Stop simulation
    endmodule
    ```
    ### Base Verilog Code:
    ```
    module tst_ctr_wt
- code: |-
    ```systemverilog
    module tst_ctr_wt;
    reg clk, En;
    reg [3:0] N;
    wire [3:0] a;
    ctr_wt c1 (a,clk,
- code: |-
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    generate
    for (wire[0] inside N){
    ctr_wt c1(a,clk,N,En);
    }
    endgenerate
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ### Code Output:
    ```
    ...
    Simulating (be patient)...
    100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
- code: "module tst_ctr_wt;\nreg clk,En;\nreg[3:0]N;\nwire[3:0]a;\ngenerate\nfor (int\
    \ i=15; i>=0; i=i-1)\nwire a_i = $bits(a,i);  // Nested generate block\n// Use\
    \ an inside operator for range selection\nctr_wt c1(i:a,clk,N,En);\nendgenerate\n\
    initial\nbegin\nclk=0; N=4'b1111; // Set limit to 15\nEn=1'b0; // Start disabled\n\
    end\nalways begin $stop end\ninitial $monitor($time,\"clk=%b, En=%b, N=%b, a=%b\"\
    ,clk,En,N,a); // Corrected format specifiers\nendmodule\n### Test File:\nimport\
    \ vunit;\nclass test_ctr_wt extends vunit.VUnitTest;\nprocedure check_ctr_wt;\n\
    reg En, clk;\nreg[3:0] N;\nreg[3:0] a;\nmodel m1 = new tst_ctr_wt;\nfunction check_ctr_wt;\n\
    check(clk=1'b1,En=1'b1,N=4'b1000,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\n\
    check(clk=1'b0,En=1'b0,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0001);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0010);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0100);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b1000);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\ncheck(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\n\
    check(clk=1'b0,En=1'b1,N=4'b1111,a=4'b0000);\nendfunction\nprocedure run;\nassert(check_ctr_wt);\n\
    endprocedure\nbegin\nsetup();\nrun();\nend\nendclass\n### Expected Output:\n10000111100000000000000000000000\n\
    ...\n### Verifications:\nThe test program does not fail.\n### Reference URL:\n\
    https://stackoverflow.com/questions/55021260/how-to-access-a-sub-element-of-a-generate-block-in-verilog-2001-escaped-names/55023813#55023813\n\
    \n#### \n\nJoined:\nJan 4, 2015\nMessages:\n2,019\nLocation:\nBeijing, China\n\
    I think you can use a verilog macro to solve this problem, just like:\n\nmodule\
    \ tst_ctr_wt;\nreg clk,En;\nreg[3:0]N;\nwire[3:0]a;\n#define ctr_wt(i) a##i c1##i(i:a,clk,N,En);\n\
    ctr_wt(0)\nctr_wt(1)\n...\nendmodule\n\n#### \n\nJoined:\nJan 4, 2015\nMessages:\n\
    2,019\nLocation:\nBeijing, China\nThe method you just posted should work too.\n\
    \n#### \n\nJoined:\nJan 4, 2015\nMessages:\n2,019\nLocation:\nBeijing, China\n\
    The test is still right. I think the problem is the way to display the result.\
    \ For example, a should be 0001 while the test expects 0000. The test is wrong\
    \ because it expects 0000 instead of 1.\n\n#### \n\nJoined:\nJan 4, 2015\nMessages:\n\
    2,019\nLocation:\nBeijing, China\nYou can use \\b (binary) and \\d (decimal) to\
    \ display the bits like this:\n\n$monitor(\"clk=%b, En=%b, N=%b, a=%d\", clk,\
    \ En, N, a); The reason is that the output of a is a 4-bit binary number instead\
    \ of a decimal number. The result is still correct. ####  Joined: Jan 4, 2015\
    \ Messages: 2,019 Location: Beijing, China The verilog program does not stop.\
    \ This is caused by the output monitor. As I mentioned above, the output of a\
    \ is a bit vector instead of a decimal number. So you can use another output monitor\
    \ to check the bits of a. And the test is still right. ####  Joined: Jan 4, 2015\
    \ Messages: 2,019 Location: Beijing, China You can also use this form: $display(\"\
    %b %d\", clk, En, N, a);\n\n#### \n\nJoined:\nJan 4, 2015\nMessages:\n2,019\n\
    Location:\nBeijing, China\nIt's not recommended to use the $display command in\
    \ the simulation. It should be used for post-simulation data processing. ####\
    \  Joined: Jan 4, 2015 Messages: 2,019 Location: Beijing, China I think you can\
    \ use a verilog macro to solve this problem, just like: module tst_ctr_wt; reg\
    \ clk,En; reg[3:0]N; wire[3:0]a; #define ctr_wt(i) a##i c1##i(i:a,clk,N,En); ctr_wt(0)\
    \ ctr_wt(1)... endmodule The test is still right. I think the problem is the way\
    \ to display the result. For example, a should be 0001 while the test expects\
    \ 0000. The test is wrong because it expects 0000 instead of 1. ####  Joined:\
    \ Jan 4, 2015 Messages: 2,019 Location: Beijing, China The test is still right.\
    \ I don't think it's wrong. In the test, clk = 1'b0 and En = 1'b1. So the test's\
    \ result of a is 0000. ####  Joined: Jan 4, 2015 Messages: 2,019 Location: Beijing,\
    \ China The verilog program does not stop. This is caused by the output monitor.\
    \ As I mentioned above, the output of a is a bit vector instead of a decimal number.\
    \ So you can use another output monitor to check the bits of a. And the test is\
    \ still right. ####  Joined: Jan 4, 2015 Messages: 2,019 Location: Beijing, China\
    \ You can also use this form: $display(\"%b %d\", clk, En, N, a);\n\n#### \n\n\
    Joined:\nJan 4, 2015\nMessages:\n2,019\nLocation:\nBeijing, China\nIt's not recommended\
    \ to use the $display command in the simulation. It should be used for post-simulation\
    \ data processing. ####  Joined: Jan 4, 2015 Messages: 2,019 Location: Be"
- code: |-
    module tst_ctr_wt_v2;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    genvar i;
    generate
    for(i=0;i<4;i=i+1)
    assign a[i]=N[i];
    endgenerate
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ### Results:
    ```
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=1, En=0,
- code: |-
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    generate
    for(
    begin
    clk=0; N=4'b1111; // Set limit to 15
    end
    endgenerate
    ctr_wt c1(a,inside(clk),inside(N),inside(En));
    initial
    begin
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule

    # VHDL

    The first version of the code used a `gen_if` statement; this is supported in VHDL 2008, and is the preferred way to generate code.

    ## VHDL Code 1

    The code is slightly different from the Verilog example, due to the different syntaxes for declaring arrays.

    module tst_ctr_wt;
    signal clk, En : std_logic;
    signal N: std_logic_vector(3 downto 0);
    signal a: std_logic_vector(3 downto 0);
    component ctr_wt
    generic
      (
        limit : integer := 15
      )
    port
    (
    clk,
    N,
    En,
    a
    );
    end component;

    process
    begin
    clk <= '0';
    N <= (others => '1');
    En <= '0';
    end process;

    generation 1;
    limit: for i in 0 to 15 generate
    process
    begin
    clk <= '0';
    N <= i * 8#1;
    En <= '1';
    end process;
    end for;
    generate
    end generation;

    end tst_ctr_wt;

    ## VHDL Code 2

    This code uses a nested `generate` block with escaped names and apply an inside operator with variable index for range selection.

    module tst_ctr_wt;
    signal clk, En : std_logic;
    signal N: std_logic_vector(3 downto 0);
    signal a: std_logic_vector(3 downto 0);
    component ctr_wt
    generic
      (
        limit : integer := 15
      )
    port
    (
    clk,
    N,
    En,
    a
    );
    end component;

    process
    begin
    clk <= '0';
    N <= (others => '1');
    En <= '0';
    end process;

    generate
    begin
    generate
    process
    begin
    clk <= '0';
    N <= i * 8#1;
    En <= '1';
    end process;
    end generate;
    end generate;
    end generate;

    end tst_ctr_wt;
- code: |-
    ```python
    class table_driven:
        def __init__(self):
            self.fsm_name = "table_driven"

        def get_fsm_code(self):
            fsm_code = ""
            fsm_code += self.fsm_name + ":\n"
            fsm_code += "    input Clock, Resetn, w;\n"
            fsm_code += "    output z;\n"
            fsm_code += "    reg y, Y, z;\n"
            fsm_code += "    parameter A = 0, B = 1;\n"
            fsm_code += "    always @(w or y)\n"
            fsm_code += "        case (y)\n"
            fsm_code += "            A: if (w)\n"
            fsm_code += "                begin\n"
            fsm_code += "                    z = 0;\n"
            fsm_code += "                    Y = B;\n"
            fsm_code += "                end\n"
            fsm_code += "            else\n"
            fsm_code += "                begin\n"
            fsm_code += "                    z = 0;\n"
            fsm_code += "                    Y = A;\n"
            fsm_code += "                end\n"
            fsm_code += "            B: if (w)\n"
            fsm_code += "                begin\n"
            fsm_code += "                    z = 1;\n"
            fsm_code += "                    Y = B;\n"
            fsm_code += "                end\n"
            fsm_code += "            else\n"
            fsm_code += "                begin\n"
            fsm_code += "                    z = 0;\n"
            fsm_code += "                    Y = A;\n"
            fsm_code += "                end\n"
            fsm_code += "    endcase\n"
            fsm_code += "    always @(negedge Resetn or posedge Clock)\n"
            fsm_code += "        if (Resetn == 0) y <= A;\n"
            fsm_code += "        else y <= Y;\n"
            return fsm_code
    ```
    ### Generated FSM Code:
    ```
    table_driven:
        input Clock, Resetn, w;
        output z;
        reg y, Y, z;
        parameter A = 0, B = 1;
        always @(w or y)
            case (y)
                A: if (w)
                    begin
                        z = 0;
                        Y = B;
                    end
                else
                    begin
                        z = 0;
                        Y = A;
                    end
                B: if (w)
                    begin
                        z = 1;
                        Y = B;
                    end
                else
                    begin
                        z = 0;
                        Y = A;
                    end
        endcase
        always @(negedge Resetn or posedge Clock)
            if (Resetn == 0) y <= A;
            else y <= Y;
    ```
    ### Verilog Code:
    ```
    module table_driven(Clock, Resetn, w, z);
        input Clock, Resetn, w;
        output z;
        reg y, Y, z;
        parameter A = 0, B = 1;
        always @(w or y)
            case (y)
                A: if (w)
                    begin
                        z = 0;
                        Y = B;
                    end
                else
                    begin
                        z = 0;
                        Y = A;
                    end
                B: if (w)
                    begin
                        z = 1;
                        Y = B;
                    end
                else
                    begin
                        z = 0;
                        Y = A;
                    end
        endcase
        always @(negedge Resetn or posedge Clock)
            if (Resetn == 0) y <= A;
            else y <= Y;
    endmodule
    ```

    ## Moore FSM
    ### Base Verilog Code:
    module moore(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w or y)
    case (y)
    A: if (w)
        z = 0;
    else
        z = 0;
- code: |-
    ```C++
    class LS115
    {
        public:
            LS115(sc_module_name name);
            ~LS115();
            void SetInput(bool a, bool b);
            void output_out();
        private:
            void update_out();

            bool reset_ = false;
            bool out_ = 0;
            bool clk_ = 0;
            bool rstn_ = 1;
            bool a_ = 0;
            bool b_ = 0;

            bool out_internal = 0;
            bool out_next = 0;
            bool a_internal = 0;
            bool b_internal = 0;
    };
    ```

    ### SV Code:
    ```SystemVerilog
    module 74ls115(a, b, out);

    input a, b;
    output out;
    reg out, O;

    initial clk <= 0, rstn <= 1;

    always @(posedge Clock) clk <= clk;
    always @(posedge Resetn) rstn <= Resetn;

    always @(a or b)
        case (a)
            0: if (b)
                begin
                    O = 1;
                end
            1: begin
                    O = 0;
                end
        endcase

    always @(negedge rstn or posedge Clock)
        if (rstn == 0) out <= 0;
        else out <= O;
    endmodule
    ```
    #include <systemc.h>

    class LS115 {
    private:
        bool reset_ = false;
        bool out_ = 0;
        bool clk_ = 0;
        bool rstn_ = 1;
        bool a_ = 0;
        bool b_ = 0;

        bool out_internal = 0;
        bool out_next = 0;
        bool a_internal = 0;
        bool b_internal = 0;

    public:
        LS115(sc_module_name name);
        ~LS115();
        void SetInput(bool a, bool b);
        void output_out();

    private:
        void update_out();
    };

    class LS115_array {
    private:
        bool reset_ = false;
        bool y_ = 0;
        bool clk_ = 0;
        bool rstn_ = 1;

        bool y_internal = 0;
        bool y_next = 0;

    public:
        LS115_array(sc_module_name name);
        ~LS115_array();
        void SetInput(bool a, bool b);
        void output_y();

    private:
        void update_y();
    };

    class LS115_array_slice {
    private:
        bool
- code: |-
    ```verilog
    module mealy
- code: |-
    ```
    class FSM;
        parameter bool A = 0, B = 1;
        parameter uint FSM_STATE_COUNT;
        parameter FSM_STATE_COUNT;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] FSM_STATE_TYPE;
        typedef logic [FSM_STATE_COUNT-1:0] F
- code: |-
    ```verilog
    class FSM;
    typedef enum logic [1:0] state_e;
    FSM::FSM(FSM* next_ref = 1)
    FSM::FSM(FSM* next_ref = 1)
    {
      this.next = next_ref;
    }
    class FSM;
    typedef enum logic [1:0] state_e;
    FSM::FSM(FSM* next_ref = 1)
    FSM::FSM(FSM* next_ref = 1)
    {
      this.next = next_ref;
    }
    FSM::FSM()
    parameter A = 0, B = 1;
    FSM::FSM()
    {
      $initial begin
        next = new();
        state = A;
      end
      always_comb begin
        case (state)
          A: if (W) begin
            Z = 0;
          end
          B: if (W) begin
            Z = 1;
          end
        endcase
      end
      always @(negedge reset or posedge clock) begin
        if (reset == 0) begin
          state <= A;
        end else begin
          state <= next.state;
        end
      end
      initial begin
        next = new(next);
      end
      always @(posedge next.w) begin
        W = next.w;
        state = next.state;
      end
      always @(posedge clock) begin
        if (clock) begin
          next = new(next);
        end
      end
      FSM::FSM(FSM* next_ref = 1)
      FSM::FSM(FSM* next_ref = 1)
      {
        this.next = next_ref;
      }
    endclass
    ```
    ### Verilator Code:
    ```verilog
    class FSM;
    typedef enum logic [1:0] state_e;
    FSM::FSM(FSM* next_ref = 1)
    FSM::FSM(FSM* next_ref = 1)
    {
      this.next = next_ref;
    }
    class FSM;
    typedef enum logic [1:0] state_e;
    FSM::FSM(FSM* next_ref = 1)
    FSM::FSM(FSM* next_ref = 1)
    {
      this.next = next_ref;
    }
    FSM::FSM()
    parameter A = 0, B = 1;
    FSM::FSM()
    {
      $initial begin
        next = new();
        state = A;
      end
      always_comb begin
        case (state)
          A: if (W) begin
            Z = 0;
          end
          B: if (W) begin
            Z = 1;
          end
        endcase
      end
      always @(negedge reset or posedge clock) begin
        if (reset == 0) begin
          state <= A;
        end else begin
          state <= next.state;
        end
      end
      initial begin
        next = new(next);
      end
      always @(posedge next.w) begin
        W = next.w;
        state = next.state;
- code: |-
    ```
    class dff_inside;
        input Clock, D;
        output Q;
        wire i_q;
        always @(Clock)
            Q <= i_q;
        always @(D or Clock)
            i_q <= D;
    endclass

    module dff(clock, D, Q);
        wire i_clock, i_d;
        wire i_q;
        parameter A = 0, B = 1;
        dff_inside dff_inside_mod(
           .clock(clock),
           .D(D),
           .Q(i_q)
        );
        assign q = i_q;
    endmodule
    ```
    ### Testbench File:
    ```
    module dff_inside_tb;
        reg clock;
        reg D;
        wire Q;

        parameter A = 0, B = 1;

        dff_inside dff_inside_mod(
           .clock(clock),
           .D(D),
           .Q(Q)
        );

        initial begin
            D = 0;
            clock = 0;
            #1;
            while (1) begin
                #1;
                clock = ~clock;
                #1;
                if (clock == 1) begin
                    D = ~D;
                    #100;
                end
            end
        end

        initial begin
            $dumpfile("dff_inside_dump.vcd");
            $dumpvars(0, dff_inside_tb);
            #1000000000;
        end
    endmodule

    module dff_tb;
        initial begin
            fork
                dff_inside_tb;
            join
        end
    endmodule
    ```
    ### Dumping VCD
    <img src="https://raw.githubusercontent.com/namanphy/verilogExamples/master/dff_inside/output.png">
- code: "```\n\n## 3.14\n\n| Original | Modification |\n|:---------|:-------------|\n\
    | ### Base Verilog Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput Clock,\
    \ Resetn, w;  \noutput z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \nalways\
    \ @(w or y)  \n    case (y)  \n        A: if (w)  \n            begin  \n    \
    \            z = 0;  \n                Y = B;  \n            end  \n        else\
    \  \n            begin  \n                z = 0;  \n                Y = A;  \n\
    \            end  \n        B: if (w)  \n            begin  \n               \
    \ z = 1;  \n                Y = B;  \n            end  \n        else  \n    \
    \        begin  \n                z = 0;  \n                Y = A;  \n       \
    \     end  \n    endcase  \nalways @(negedge Resetn or posedge Clock)  \n    if\
    \ (Resetn == 0) y <= A;  \n    else y <= Y;  \nendmodule  \n### Variation Instruction:\
    \  \nRewrite FSM state transition using `inside` with an array slice for `w`,\
    \ placed inside an SV class.  \n### Modified Code:  \n```  \n### Base Verilog\
    \ Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput Clock, Resetn, w;  \noutput\
    \ z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \nalways @(w or y)  \n    case\
    \ (y)  \n        A: if (w)  \n            begin  \n                z = 0;  \n\
    \                Y = B;  \n            end  \n        else  \n            begin\
    \  \n                z = 0;  \n                Y = A;  \n            end  \n \
    \       B: if (w)  \n            begin  \n                z = 1;  \n         \
    \       Y = B;  \n            end  \n        else  \n            begin  \n   \
    \             z = 0;  \n                Y = A;  \n            end  \n    endcase\
    \  \nalways @(negedge Resetn or posedge Clock)  \n    if (Resetn == 0) y <= A;\
    \  \n    else y <= Y;  \nendmodule  \n### Variation Instruction:  \nRewrite FSM\
    \ state transition using `inside` with an array slice for `w`, placed inside an\
    \ SV class.  \n### Modified Code:  \n```\n\n## 3.15\n\n| Original | Modification\
    \ |\n|:---------|:-------------|\n| ### Base Verilog Code:  \nmodule mealy(Clock,\
    \ Resetn, w, z);  \ninput Clock, Resetn, w;  \noutput z;  \nreg y, Y, z;  \nparameter\
    \ A = 0, B = 1;  \nalways @(w or y)  \n    case (y)  \n        A: if (w)  \n \
    \           begin  \n                z = 0;  \n                Y = B;  \n    \
    \        end  \n        else  \n            begin  \n                z = 0;  \n\
    \                Y = A;  \n            end  \n        B: if (w)  \n          \
    \  begin  \n                z = 1;  \n                Y = B;  \n            end\
    \  \n        else  \n            begin  \n                z = 0;  \n         \
    \       Y = A;  \n            end  \n    endcase  \nalways @(negedge Resetn or\
    \ posedge Clock)  \n    if (Resetn == 0) y <= A;  \n    else y <= Y;  \nendmodule\
    \  \n### Variation Instruction:  \nRewrite FSM state transition using `inside`\
    \ with an array slice for `w`, placed inside an SV class.  \n### Modified Code:\
    \  \n```  \n### Base Verilog Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput\
    \ Clock, Resetn, w;  \noutput z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \n\
    always @(w or y)  \n    case (y)  \n        A: if (w)  \n            begin  \n\
    \                z = 0;  \n                Y = B;  \n            end  \n     \
    \   else  \n            begin  \n                z = 0;  \n                Y =\
    \ A;  \n            end  \n        B: if (w)  \n            begin  \n        \
    \        z = 1;  \n                Y = B;  \n            end  \n        else \
    \ \n            begin  \n                z = 0;  \n                Y = A;  \n\
    \            end  \n    endcase  \nalways @(negedge Resetn or posedge Clock) \
    \ \n    if (Resetn == 0) y <= A;  \n    else y <= Y;  \nendmodule  \n### Variation\
    \ Instruction:  \nRewrite FSM state transition using `inside` with an array slice\
    \ for `w`, placed inside an SV class.  \n### Modified Code:  \n```\n\n## 3.16\n\
    \n| Original | Modification |\n|:---------|:-------------|\n| ### Base Verilog\
    \ Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput Clock, Resetn, w;  \noutput\
    \ z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \nalways @(w or y)  \n    case\
    \ (y)  \n        A: if (w)  \n            begin  \n                z = 0;  \n\
    \                Y = B;  \n            end  \n        else  \n            begin\
    \  \n                z = 0;  \n                Y = A;  \n            end  \n \
    \       B: if (w)  \n            begin  \n                z = 1;  \n         \
    \       Y = B;  \n            end  \n        else  \n            begin  \n   \
    \             z = 0;  \n                Y = A;  \n            end  \n    endcase\
    \  \nalways @(negedge Resetn or posedge Clock)  \n    if (Resetn == 0) y <= A;\
    \  \n    else y <= Y;  \nendmodule  \n### Variation Instruction:  \nRewrite FSM\
    \ state transition using `inside` with an array slice for `w`, placed inside an\
    \ SV class.  \n### Modified Code:  \n```  \n### Base Verilog Code:  \nmodule mealy(Clock,\
    \ Resetn, w, z);  \ninput Clock, Resetn, w;  \noutput z;  \nreg y, Y, z;  \nparameter\
    \ A = 0, B = 1;  \nalways @(w or y)  \n    case (y)  \n        A: if (w)  \n \
    \           begin  \n                z = 0;  \n                Y = B;  \n    \
    \        end  \n        else  \n            begin  \n                z = 0;  \n\
    \                Y = A;  \n            end  \n        B: if (w)  \n          \
    \  begin  \n                z = 1;  \n                Y = B;  \n            end\
    \  \n        else  \n            begin  \n                z = 0;  \n         \
    \       Y = A;  \n            end  \n    endcase  \nalways @(negedge Resetn or\
    \ posedge Clock)  \n    if (Resetn == 0) y <= A;  \n    else y <= Y;  \nendmodule\
    \  \n### Variation Instruction:  \nRewrite FSM state transition using `inside`\
    \ with an array slice for `w`, placed inside an SV class.  \n### Modified Code:\
    \  \n```\n\n## 3.17\n\n| Original | Modification |\n|:---------|:-------------|\n\
    | ### Base Verilog Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput Clock,\
    \ Resetn, w;  \noutput z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \nalways\
    \ @(w or y)  \n    case (y)  \n        A: if (w)  \n            begin  \n    \
    \            z = 0;  \n                Y = B;  \n            end  \n        else\
    \  \n            begin  \n                z = 0;  \n                Y = A;  \n\
    \            end  \n        B: if (w)  \n            begin  \n               \
    \ z = 1;  \n                Y = B;  \n            end  \n        else  \n    \
    \        begin  \n                z = 0;  \n                Y = A;  \n       \
    \     end  \n    endcase  \nalways @(negedge Resetn or posedge Clock)  \n    if\
    \ (Resetn == 0) y <= A;  \n    else y <= Y;  \nendmodule  \n### Variation Instruction:\
    \  \nRewrite FSM state transition using `inside` with an array slice for `w`,\
    \ placed inside an SV class.  \n### Modified Code:  \n```  \n### Base Verilog\
    \ Code:  \nmodule mealy(Clock, Resetn, w, z);  \ninput Clock, Resetn, w;  \noutput\
    \ z;  \nreg y, Y, z;  \nparameter A = 0, B = 1;  \nalways @(w or y)  \n    case\
    \ (y)  \n        A: if (w)  \n            begin  \n                z = 0;  \n\
    \                Y = B;  \n            end  \n        else  \n            begin\
    \  \n                z = 0;  \n                Y = A;  \n            end"
- code: |-
    class mealy_variation;
        `timescale 1ns / 1ps
        // state is array index for array of states
        `enum states {A, B} state;
        // parameter can be used to set default parameter for SV class
        parameter A = 0, B = 1;
        // output
        logic y;
        logic z;
        // input
        logic w;
        // input as logic variable
        logic Clock, Resetn;
        // clock is enabled by logic variable
        logic clock_enabled;
        assign clock_enabled = Clock;
        always @(w or y) begin
            case (y)
                A: if (w) begin
                    z = 0;
                    state = B;
                    end
                else
                    begin
                    z = 0;
                    state = A;
                    end
                B: if (w) begin
                    z = 1;
                    state = B;
                    end
                else
                    begin
                    z = 0;
                    state = A;
                    end
            endcase
        end

        // this is the only change
        // state for each state is an array slice
        always @(posedge clock_enabled) begin
            if (Resetn == 0) y <= A;
            else begin
                case (state)
                A: y <= A;
                B: y <= B;
                endcase
            end
        end
    endclass
    module mealy_variation;
        // port that connects to the clock input
        input clock_enabled;
        // w as logic variable
        logic w;
        // w as logic variable
        logic Resetn;
        // instantiate mealy_variation class
        mealy_variation variation(.Clock(clock_enabled),.Resetn(Resetn),.w(w));
        // connect variation z to output
        assign z = variation.z;
    endmodule
    /c/examples/examples.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    #include <string.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
    #include <getopt.h>
    #include <signal.h>
    #include <sys/wait.h>

    #include "examples.h"
    #include "examples-generated.h"

    int main (int argc, char *argv[])
    {
        // Example to read an array into a C array and print it
        uint16_t input_array[2] = {1,2};
        printf("Read in input array: ");
        for (int i = 0; i < 2; i++)
        {
            printf("%d ", input_array[i]);
        }
        printf(".\n");
        printf("Read in the same input using the generated file.\n");
        printf("Read in the same input using the generated file.\n");
        printf("Read in the same input using the generated file.\n");
        uint16_t input_array_generated[2];
        printf("Read in input array: ");
        for (int i = 0; i < 2; i++)
        {
            printf("%d ", input_array_generated[i]);
        }
        printf(".\n");
        printf("You can access the generated array using the generated names.\n");
        for (int i = 0; i < 2; i++)
        {
            uint16_t input_name_gen = input_array[i];
            printf("input_name_gen: %d.\n", input_name_gen);
        }
        // Example to read in a 3D array and print it out
        int num_rows = 3;
        int num_cols = 4;
        int num_depth = 2;
        uint8_t matrix[2][3][4] = {
            {
                {1,2,3,4},
                {5,6,7,8},
                {9,10,11,12}
            },
            {
                {13,14,15,16},
                {17,18,19,20},
                {21,22,23,24}
            }
        };
        for (int i = 0; i < num_rows; i++)
        {
            printf("Row %d: ", i);
            for (int j = 0; j < num_cols; j++)
            {
                printf("Column %d: ", j);
                for (int k = 0; k < num_depth; k++)
                {
                    uint8_t cell = matrix[k][i][j];
                    printf("%d ", cell);
                }
                printf("\n");
            }
            printf("\n");
        }
        return 0;
    }
    /c/docs/CMakeLists.txt
    # Get the root directory.
    get_filename_component(PARENT_DIR ${CMAKE_CURRENT_SOURCE_DIR} DIRECTORY)

    # Configure the config file for the build directory.
    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/doc-config.h.in ${CMAKE_CURRENT_BINARY_DIR}/doc-config.h)

    # Define include directories.
    include_directories(${PARENT_DIR}/include)

    # Define the source file for the documentation generation.
    set(doc_src_files doc.c)

    # Define the header files for the documentation generation.
    set(doc_hdr_files
        ${PARENT_DIR}/include/doc-config.h
        ${CMAKE_CURRENT_BINARY_DIR}/doc-config.h)

    # Set the source for the documentation.
    set(doc_sources ${doc_src_files} ${doc_hdr_files})

    # Add the target for documentation.
    add_custom_target(doc
            ALL
            COMMAND ${CMAKE_C_COMPILER} ${doc_sources} ${doc_hdr_files} -o doc
            WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
            COMMENT "Generating documentation"
            VERBATIM)

    # Add the doc target to the build.
    add_dependencies(build doc)
    /README.md
    # VHDL-Verilog Compiler

    The VHDL-Verilog Compiler is a system that will take a VHDL file and convert it into a Verilog implementation.
    The system is built on the FuseSoC framework.
    It is written in C and C++.

    ## Getting Started

    Start by cloning the repository.

    ```
    git clone https://github.com/SymbiFlow/vlog_comp
    ```

    You will also need the FuseSoC framework.
    FuseSoC is a project that makes it easier to build FPGA bitstreams by describing the hardware as a series of components.
    The framework itself is written in a language called FuseSoC-language (FSL) that is very similar to Verilog.

    ### Prerequisites

    You need to make sure that you have the FSL installed to use the compiler.
    The easiest thing to do is to download and install the FSL-core using pip or conda.

    ```
    pip install fusesoc
    ```

    If you don't want to install the FSL-core using pip or conda, then you will need to get it from the [FSL-core](https://github.com/SymbiFlow/fusesoc-cores) repository.
    To get the FSL-core, run the following commands.

    ```
    git clone https://github.com/SymbiFlow/fusesoc-cores
    cd fusesoc-cores
    git checkout v2.1.1
    make all
    ```

    ## Documentation

    You can read about the project on the [wiki](https://github.com/SymbiFlow/vlog_comp/wiki).

    ## Authors

    * **** - *Initial work* - [sridharkatam](https://github.com/sridharkatam)
    * **** - *Initial work* - [gustavobernal](https://github.com/gustavobernal)

    See also the list of [contributors](https://github.com/SymbiFlow/vlog_comp/contributors) who participated in this project.

    ## License

    This project is licensed under the BSD License - see the [LICENSE.md](LICENSE.md) file for details.

    ## Acknowledgments

    *  for help with the project.
    *  and  from the University of Minnesota for help with getting the project started.
    *  for helping with the project.
    *  for helping with the project.
    *  for helping with the project.
    /c/docs/doc-config.h.in
    /**
     * @file
     * @brief This file is generated from @ref ${CMAKE_CURRENT_SOURCE_DIR}.
     */

    #ifndef __DOC_CONFIG_H__
    #define __DOC_CONFIG_H__

    #define DOC_VERSION "@${FSL_LIBRARY_VERSION_MAJOR}.${FSL_LIBRARY_VERSION_MINOR}"

    #endif
    /c/include/doc-config.h
    /**
     * @file
- code: |-
    ```sv
    /// @file
    ///
    /// @brief A generic FSM implementation.
    ///
    /// @copyright Copyright (c) 2023. All rights reserved.
    ///
    /// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    ///
    /// * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    /// * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    /// * Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
    ///
    /// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    class FSM;
    endclass

    class FSM #(
        parameter type T = int,
        parameter enum class FSM_STATE = FSM_S,
        parameter enum class FSM_TRANSITION = FSM_T,
        parameter enum class FSM_TRANSITION_TYPE = FSM_TT,
        parameter enum class FSM_TYPE = FSM_T,
        parameter string FSM_NAME = "",
        parameter string FSM_INSTANCE_NAME = "",
        parameter enum class FSM_STATE_TYPE = FSM_ST,
        parameter enum class FSM_STATE_TYPE_TYPE = FSM_STT,
        parameter type FSM_STATE_TYPE_TYPE = int,
        parameter type FSM_STATE_TYPE = int,
        parameter enum class FSM_TYPE_TYPE = FSM_TT,
        parameter type FSM_TYPE_TYPE = int,
        parameter boolean FSM_HAS_OUTPUT = 0,
        parameter type FSM_OUTPUT_TYPE = int,
        parameter enum class FSM_OUTPUT_TYPE_TYPE = FSM_OTT,
        parameter boolean FSM_HAS_INOUT = 0,
        parameter type FSM_INOUT_TYPE = int,
        parameter enum class FSM_INOUT_TYPE_TYPE = FSM_IOTT,
        parameter type FSM_INOUT_TYPE_TYPE = int,
        parameter boolean FSM_HAS_CLOCK = 0,
        parameter type FSM_CLOCK_TYPE = int,
        parameter enum class FSM_CLOCK_TYPE_TYPE = FSM_CTT,
        parameter boolean FSM_HAS_RESET = 0,
        parameter type FSM_RESET_TYPE = int,
        parameter enum class FSM_RESET_TYPE_TYPE = FSM_RTT,
        parameter boolean FSM_HAS_INPUT_CONTROL = 0,
        parameter type FSM_INPUT_CONTROL_TYPE = int,
        parameter enum class FSM_INPUT_CONTROL_TYPE_TYPE = FSM_IC_T,
        parameter type FSM_INPUT_CONTROL_TYPE_TYPE = int,
        parameter enum class FSM_OUTPUT_TYPE_TYPE_TYPE = FSM_OTTT,
        parameter enum class FSM_STATE_TYPE_TYPE_TYPE = FSM_STTT,
        parameter type FSM_OUTPUT_TYPE_TYPE_TYPE = int,
        parameter type FSM_STATE_TYPE_TYPE_TYPE = int,
        parameter type FSM_INOUT_TYPE_TYPE_TYPE = int,
        parameter type FSM_OUTPUT_TYPE_TYPE_TYPE = int,
        parameter type FSM_CLOCK_TYPE_TYPE = int,
        parameter type FSM_RESET_TYPE_TYPE = int,
        parameter type FSM_INPUT_CONTROL_TYPE_TYPE = int,
        parameter type FSM_OUTPUT_TYPE_TYPE_TYPE = int,
    ) extends SystemVerilog;

        /// @brief The current state of the FSM.
        ///
        /// @note This should be a valid state according to the FSM specification.
        FSM_STATE state;

        /// @brief The current state of the FSM, a human-readable string version.
        ///
        /// @note This should be a valid state according to the FSM specification.
        string state_string;

        /// @brief The next state, based on the incoming FSM_TYPE.
        ///
        /// @note This should be a valid state according to the FSM specification.
        FSM_TYPE next_state;

        /// @brief The next state as a human-readable string.
        ///
        /// @note This should be a valid state according to the FSM specification.
        string next_state_string;

        /// @brief The next transition, based on the incoming FSM_TRANSITION.
        ///
        /// @note This should be a valid transition according to the FSM specification.
        FSM_TRANSITION next_transition;

        /// @brief The next transition as a human-readable string.
        ///
        /// @note This should be a valid transition according to the FSM specification.
        string next_transition_string;

        /// @brief The next transition type, based on the incoming FSM_TRANSITION_TYPE.
        ///
        /// @note This should be a valid transition type according to the FSM specification.
        FSM_TRANSITION_TYPE transition_type;

        /// @brief The current transition type, a human-readable string version of the transition type.
        ///
        /// @note This should be a valid transition type according to the FSM specification.
        string transition_type_string;

        /// @brief Whether or not the FSM has been reset.
        ///
        /// @note This is used to determine if the FSM is in a valid state.
        /// @note This is typically used to determine if the FSM can execute any transitions.
        boolean has_reset;

        /// @brief The current reset value, based on the incoming FSM_RESET_TYPE.
        ///
        /// @note This should be a valid reset value according to the FSM specification.
        FSM_RESET_TYPE reset_value;

        /// @brief The current reset value as a human-readable string version.
        ///
        /// @note This should be a valid reset value according to the FSM specification.
        string reset_value_string;

        /// @brief The current clock value, based on the incoming FSM_CLOCK_TYPE.
        ///
        /// @note This should be a valid clock value according to the FSM specification.
        FSM_CLOCK_TYPE clock_value;

        /// @brief The current clock value as a human-readable string version.
        ///
        /// @note This should be a valid clock value according to the FSM specification.
        string clock_value_string;

        /// @brief The current input value, based on the incoming FSM_INPUT_CONTROL_TYPE.
        ///
        /// @note This should be a valid input value according to the FSM specification.
        FSM_INPUT_CONTROL_TYPE input_control;

        /// @brief The current input value as a human-readable string version.
        ///
        /// @note This should be a valid input value according to the FSM specification.
        string input_control_string;

        /// @brief The output value, based on the incoming FSM_OUTPUT_TYPE.
        ///
        /// @note This should be a valid output value according to the FSM specification.
        FSM_OUTPUT_TYPE output_value;

        /// @brief The output value as a human-readable string version.
        ///
        /// @note This should be a valid output value according to the FSM specification.
        string output_value_string;

        /// @brief The current FSM_STATE_TYPE, typically this will be the same as the FSM_STATE.
        ///
        /// @note This should be a valid state according to the FSM specification.
        FSM_STATE_TYPE state_type;

        /// @brief The current FSM_STATE_TYPE as a human-readable string.
        ///
        /// @note This should be a valid state according to the FSM specification.
        string state_type_string;

        /// @brief The current FSM_OUTPUT_TYPE_TYPE, typically this will be the same as the FSM_OUTPUT_TYPE.
        ///
        /// @note This should be a valid output value according to the FSM specification.
        FSM_OUTPUT_TYPE_TYPE output_type_type;

        /// @brief The current FSM_OUTPUT_TYPE_TYPE as a human-readable string.
        ///
        /// @note This should be a valid output value according to the FSM specification.
        string output_type_type_string;

        /// @brief The current FSM_INOUT_TYPE_TYPE, typically this will be the same as the FSM_INOUT_TYPE.
        ///
        /// @note This should be a valid state according to the FSM specification.
        FSM_INOUT_TYPE_TYPE inout_type_type;

        /// @brief The current FSM_INOUT_TYPE_TYPE as a human-readable string.
        ///
        /// @note This
- code: |-
    ```
    module regff(D,clk, Q);
        input clk, D;
        output Q;
        reg Q;
        always @(D or clk)
- code: |-
    ```c++
    if (S == 2'b00)
        f = w0;
    else if (S == 2'b01)
        f = w1;
    else
        f = w2;
    ```

    ### Base Verilog Code:
    ```verilog
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else
            f = w2;
    endmodule
    ```

    ### Variation Instruction:
    In the multiplexer, use `inside` to compare `S` with
- code: |-
    ```verilog
    module mux4to1 (w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
    f = (S == 2'b00)? w0 : ((S == 2'b01)? w1 : ((S == 2'b10)? w2 : ((S == 2'b11)? w3 : 0)));
    endmodule
    ```

    ### Base Verilog Code:
    module mux4to1 (w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
    f = (S == 2'b00)? w0 : (S == 2'b01)? w1 : (S == 2'b10)? w2 : (S == 2'b11)? w3 : 0;
    endmodule
    ### Variation Instruction:
    In the multiplexer, if-else statements can be used to simplify the logic of the multiplexer.
    ### Modified Code
- code: |-
    ```
    module mux4to1(w0, w1, w2, w3, S, f);
        input w0, w1, w2, w3;
        input [1:0] S;
        output f;
        reg f;
        wire [1:0] index;
        always @(w0 or w1 or w2 or w3 or S) begin
            index = S;
        end
        always @(index) begin
            f = index == 2'b00? w0 : index == 2'b01? w1 : index == 2'b10? w2 :
- code: |-
    ```
    module adder4(a, b, c, S, f);
    input a, b, c;
    input [3:0] S;
    output f;
    reg f;
    wire S1;
    always @(*)
        S1 = S;
        f = a + b + c + S1;
    endmodule
    ```
    ### Testbench File:
    ```
    `timescale 1ns
- code: |-
    ```
    always @(w0 or w1 or w2 or w3 or S)
        case (S)
            {2'b00..2'b01}:
- code: |-
    module tb;
    reg w0;
    reg w1;
    reg w2;
    reg w3;
    reg S;
    reg f;
- code: |-
    ```
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    int muxS[4];
    always @(w0 or w1 or w2 or w3 or S)
        if (S == muxS[0])
            f = w0;
        else if (S == muxS[1])
            f = w1;
        else if (S == muxS[2])
            f = w2;
        else if (S == muxS[3])
            f = w3;
    endmodule
    ```
    ### Question:
    * Why is it not correct to assign a
- code: |-
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    `inside`

    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule

    ### After Synthesis:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule

    ### After Mapping:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule

    ### After Simulation:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule

    ### After Pipelining:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w3;
    endmodule

    ### After Optimization:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Optimization II:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Synthesis:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Mapping:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Simulation:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Pipelining:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Optimization:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Optimization II:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Synthesis:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Mapping:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Simulation:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Pipelining:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Optimization:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Optimization II:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        f = w0;
    endmodule

    ### After Synthesis:
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg
- code: "library mux4to1 is\n\n## How do you create a VHDL program?\n\n### Base Verilog\
    \ Code:\nmodule mux4to1(w0, w1, w2, w3, S, f);\ninput w0, w1, w2, w3;\ninput [1:0]\
    \ S;\noutput f;\nreg f;\nalways \nbegin\n    if ("
- code: |-
    ```
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        if (S == 2'b00)
            f = w0;
        else if (S == 2'b01)
            f = w1;
        else if (S == 2'b10)
            f = w2;
        else if (S == 2'b11)
            f = w0 | w1;
    endmodule
    ```/Week 05/module_declaration_exercise_2/main.cpp
    #include <iostream>
    #include "my_sum.h"
    #include "my_product.h"

    void printSum(int a, int b) {
        int sum;
        sum = my_sum(a, b);
        std::cout << "result: " << sum << std::endl;
    }

    void printProduct(int a, int b) {
        int prod;
        prod = my_product(a, b);
        std::cout << "result: " << prod << std::endl;
    }

    int main(int argc, char** argv) {
        printSum(10, 30);
        printProduct(10, 30);
    }
    /Week 05/module_declaration_exercise_4/include/my_mult.h
    #include <verilated.h>

    int my_mult(int a, int b, VerilatedClock& clk);
    /Week 12/module_declaration_exercise_5/main.cpp
    #include <iostream>
    #include "my_counter_rtl.h"
    #include "verilated.h"

    using namespace std;

    int main(int argc, char** argv) {
        my_counter_rtl* counter;
        int clk_count, rstn_count;
        bool clk, rstn;
        Verilated::commandArgs(argc, argv);
        Verilated::traceEverOn(true);
        counter = new my_counter_rtl;
        Verilated::traceEverOn(true);
        counter->trace(cout, 99);
        cout << endl;
        rstn = true;
        while (!Verilated::gotFinish()) {
            clk =!clk;
            rstn =!rstn;
            counter->set_clk(clk);
            counter->set_rstn(rstn);
            counter->eval();
            if (counter->get_clk()) {
                clk_count++;
            }
            if (counter->get_rstn()) {
                rstn_count++;
            }
            cout << "clk: " << counter->get_clk() << "\trstn: " << counter->get_rstn() << "\tlatch_out: " << counter->get_latch_out() << endl;
            if (clk_count == 100) {
                clk_count = 0;
                rstn =!rstn;
                counter->set_rstn(rstn);
            }
        }
        delete counter;
    }
    /Week 04/module_declaration_exercise_4/include/my_sum.h
    int my_sum(int a, int b);
    /Week 12/module_declaration_exercise_5/include/my_counter_rtl.h
    #include <verilated.h>

    class my_counter_rtl : public VerilatedClock {
    public:
        my_counter_rtl();
        ~my_counter_rtl();
        void set_clk(bool clk);
        void set_rstn(bool rstn);
        bool get_clk();
        bool get_rstn();
        bool get_latch_out();
        bool do_reset();
    private:
        my_counter my_top;
    };
    /Week 04/module_declaration_exercise_5/include/my_product.h
    int my_product(int a, int b);
    /Week 04/module_declaration_exercise_3/main.cpp
    #include "my_sum.h"
    #include "my_product.h"

    int main(int argc, char** argv) {
        int a = 10;
        int b = 30;
        int sum, prod;
        sum = my_sum(a, b);
        prod = my_product(a, b);
        std::cout << "sum: " << sum << "\t" << "product: " << prod << std::endl;
    }
    /Week 05/module_declaration_exercise_4/build/CMakeFiles/my_mult.dir/cmake_clean.cmake
    file(REMOVE_RECURSE
      "CMakeFiles/my_mult.dir/src/my_mult.cpp.o"
      "libmy_mult.pdb"
      "libmy_mult.so"
    )

    # Per-language clean rules from dependency scanning.
    foreach(lang CXX)
      include(CMakeFiles/my_mult.dir/cmake_clean_${lang}.cmake OPTIONAL)
    endforeach()
    /Week 05/module_declaration_exercise_2/include/my_product.h
    int my_product(int a, int b);
    /Week 04/module_declaration_exercise_4/include/my_counter.h
    class my_counter {
    public:
        my_counter();
        my_counter(int a);
        ~my_counter();
        void set_clk(bool clk);
        bool get_clk();
        void set_rstn(bool rstn);
        bool get_rstn();
        bool get_latch_out();
        bool do_reset();
        int get_count();
    private:
        int a;
        bool clk;
        bool rstn;
        bool latch_out;
    };
    /Week 04/module_declaration_exercise_2/build/CMakeFiles/my_sum.dir/cmake_clean.cmake
    file(REMOVE_RECURSE
      "CMakeFiles/my_sum.dir/src/my_sum.cpp.o"
      "libmy_sum.pdb"
      "libmy_sum.so"
    )

    # Per-language clean rules from dependency scanning.
    foreach(lang CXX)
      include(CMakeFiles/my_sum.dir/cmake_clean_${lang}.cmake OPTIONAL)
    endforeach()
    /Week 05/module_declaration_exercise_5/build/CMakeFiles/my_mult.dir/cmake_clean.cmake
    file(REMOVE_RECURSE
      "libmy_mult.a"
    )
    /Week 12/module_declaration_exercise_5/include/my_counter.h
    class my_counter {
    public:
        my_counter();
        ~my_counter();
        void set_clk(bool clk);
        void set_reset(bool reset);
        void set_latch_out(bool latch_out);
        bool get_clk();
        bool get_reset();
        bool get_latch_out();
        bool do_reset();
    private:
        bool clk;
        bool reset;
        bool latch_out;
    };
    /Week 05/module_declaration_exercise_4/include/my_mult.h
    int my_mult(int a, int b);
    /Week 04/module_declaration_
- code: |-
    ```verilog
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0]
- code: |-
    ```c
    #include <stdio
- code: |-
    ```verilog
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    ```
    ### Execution:
    ```log
    S: 00001111
    A: 10000001
    B: 10100000
    X: 10000001
    Y: 10100000
    F: 00000000
    S: 01000101
    A: 11100000
    B: 10000001
    X: 11100000
    Y: 10000001
    F: 11100101
    ```

    ## Test Cases

    #### Case 1:
    - Operand A is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Operand B is the constant of the range of index `[1, 6]`. (1, 2, 3, 4, 5, 6).
    - Instruction: `S=1111`

    #### Case 2:
    - Operand A is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Operand B is the constant of the range of index `[2, 11]`. (2, 3, 4, 5, 6, 7, 8, 9, 10, 11).
    - Instruction: `S=0000`

    #### Case 3:
    - Operand A is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Operand B is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Instruction: `S=1110`

    #### Case 4:
    - Operand A is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Operand B is the constant of the range of index `[24, 31]`. (24, 25, 26, 27, 28, 29, 30, 31).
    - Instruction: `S=1111`

    #### Case 5:
    - Operand A is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Operand B is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Instruction: `S=0001`

    #### Case 6:
    - Operand A is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Operand B is the constant of the range of index `[24, 31]`. (24, 25, 26, 27, 28, 29, 30, 31).
    - Instruction: `S=1000`

    #### Case 7:
    - Operand A is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Operand B is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Instruction: `S=0111`

    #### Case 8:
    - Operand A is the constant of the range of index `[8, 15]` (8, 9, 10, 11, 12, 13, 14, 15).
    - Operand B is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Instruction: `S=0000`

    #### Case 9:
    - Operand A is the constant of the range of index `[17, 24]`. (17, 18, 19, 20, 21, 22, 23, 24).
    - Operand B is the constant of the range of index `[7, 14]`. (7, 8, 9, 10, 11, 12, 13, 14).
    - Instruction: `S=0110`

    #### Case 10:
    - Operand A is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Operand B is the constant of the range of index `[17, 24]`. (17, 18, 19, 20, 21, 22, 23, 24).
    - Instruction: `S=0000`

    #### Case 11:
    - Operand A is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Operand B is the constant of the range of index `[8, 15]`. (8, 9, 10, 11, 12, 13, 14, 15).
    - Instruction: `S=0001`

    #### Case 12:
    - Operand A is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Operand B is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Instruction: `S=0001`

    #### Case 13:
    - Operand A is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Operand B is the constant of the range of index `[17, 24]`. (17, 18, 19, 20, 21, 22, 23, 24).
    - Instruction: `S=0110`

    #### Case 14:
    - Operand A is the constant of the range of index `[16, 23]`. (16, 17, 18, 19, 20, 21, 22, 23).
    - Operand B is the constant of the range of index `[3, 10]`. (3, 4, 5, 6, 7, 8, 9, 10).
    - Instruction: `S=0111`

    #### Case 15:
    - Operand A is the constant of the range of index `[17, 24]`. (17, 18, 19, 20, 21, 22, 23, 24).
    - Operand B is the constant of the range of index `[16, 23]`. (16, 17, 18, 1
- code: |-
    ```c++
    bool while_1, while_2;
    while_1 = x < y;
    while_2 = x >= y;
    if (while_1 && while_2) {
        x++;
        y++;
        x--;
        y--;
    }
    ```
    ### VHDL Code:
    ```verilog
    module while(x, y);
    input [3:0] x;
    input [3:0] y;
    wire [3:0] x;
    wire [3:0] y;
    always @(*)
        while_1: begin
            while (x < y) begin
                x = x + 1'sd1;
                y = y + 1'sd1;
            end
        end
        while_2: begin
            while (x >= y) begin
                x = x - 1'sd1;
                y = y - 1'sd1;
            end
        end
    endmodule
    ```
    # 4/7/2023
    ### Base Verilog Code:
    ```c++
    while (x < y) {
        x++;
        y++;
    }
    while (x >= y) {
        x--;
        y--;
- code: |-
    **Before**
    ```verilog
    F = A & B;
    ```
    **After**
    ```verilog
    F = instruction_A(A, 1);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 2);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range1 == 1)
        F = A & B;
    else
        F = instruction_A(A, 2);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 3);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range2 == 1)
        F = A & B;
    else
        F = instruction_A(A, 3);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 4);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range3 == 1)
        F = A & B;
    else
        F = instruction_A(A, 4);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 5);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range4 == 1)
        F = A & B;
    else
        F = instruction_A(A, 5);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 6);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range5 == 1)
        F = A & B;
    else
        F = instruction_A(A, 6);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 7);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range6 == 1)
        F = A & B;
    else
        F = instruction_A(A, 7);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 8);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range7 == 1)
        F = A & B;
    else
        F = instruction_A(A, 8);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 9);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range8 == 1)
        F = A & B;
    else
        F = instruction_A(A, 9);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 10);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range9 == 1)
        F = A & B;
    else
        F = instruction_A(A, 10);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 11);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range10 == 1)
        F = A & B;
    else
        F = instruction_A(A, 11);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 12);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range11 == 1)
        F = A & B;
    else
        F = instruction_A(A, 12);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 13);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range12 == 1)
        F = A & B;
    else
        F = instruction_A(A, 13);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 14);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range13 == 1)
        F = A & B;
    else
        F = instruction_A(A, 14);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 15);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range14 == 1)
        F = A & B;
    else
        F = instruction_A(A, 15);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 16);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range15 == 1)
        F = A & B;
    else
        F = instruction_A(A, 16);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 17);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range16 == 1)
        F = A & B;
    else
        F = instruction_A(A, 17);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 18);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range17 == 1)
        F = A & B;
    else
        F = instruction_A(A, 18);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 19);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range18 == 1)
        F = A & B;
    else
        F = instruction_A(A, 19);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 20);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range19 == 1)
        F = A & B;
    else
        F = instruction_A(A, 20);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 21);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range20 == 1)
        F = A & B;
    else
        F = instruction_A(A, 21);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 22);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range21 == 1)
        F = A & B;
    else
        F = instruction_A(A, 22);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 23);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range22 == 1)
        F = A & B;
    else
        F = instruction_A(A, 23);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 24);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range23 == 1)
        F = A & B;
    else
        F = instruction_A(A, 24);
    ```
    **Before**
    ```verilog
    F = instruction_A(A, 25);
    ```
    **After**
    ```verilog
    // This is the critical part, check if the operand A is inside a range array.
    if (A[]range2
- code: |-
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
    ### Variation Instruction:
    Insert `inside` with indexed part select on operand A and check if it lies in a defined constant range array.
    ### Variation Instruction:
    ```
- code: |-
    ```python
    def select_alu_constant_instruction(ir):
        return ir.s in {0,1,2,3} and ir.A in constants_3bit and ir.B in constants_3bit
- code: |-
    `%verilog`
    ```verilog
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
            default: F = 5'b111
- code: |-
    module alu_mod(s, A, B, F);
    input [2:0] s
- code: "module alu(s, A, B, F);\ninput [2:0] s;\ninput [3:0] A, B;\noutput [3:0]\
    \ F;\nreg [3:0] F;\nwire [3:0] A_range = {1'b1, A};\nwire [3:0] B_range = {1'b0,\
    \ B};\n\nlogic inside_A = A_range[1:0] == {1'b0, 2'b11};\nlogic inside_B = B_range[1:0]\
    \ == {1'b0, 2'b11};\n\nalways @(s or A or B)\n    case (s)\n        0: F = 4'b0000;\n\
    \        1: when (inside_A && inside_B) F = B - A;\n        2: when (inside_A\
    \ && inside_B) F = A - B;\n        3: when (inside_A && inside_B) F = A + B;\n\
    \        4: when (inside_A && inside_B) F = A ^ B;\n        5: when (inside_A\
    \ && inside_B) F = A | B;\n        6: when (inside_A && inside_B) F = A & B;\n\
    \        7: F = 4'b1111;\n    endcase\nendmodule\n<img src=\"imgs/inside_3.png\"\
    \ width = \"80%\" style=\"float:middle\" align=center />  \n<img src=\"imgs/inside_4.png\"\
    \ width = \"80%\" style=\"float:middle\" align=center />\n<img src=\"imgs/inside_5.png\"\
    \ width = \"80%\" style=\"float:middle\" align=center />\n\n\n## Design\n\n| Module\
    \  | Inputs  | Outputs | Registers |\n| ------- | ------- | ------- | ---------\
    \ |\n| mem     | A, addr | W       |           |\n| decode  | A       | s, A,\
    \ B |           |\n| mux     | A, B    | s       |           |\n| alu     | s,\
    \ A, B | F       |           |\n| mem_wb  | W       | F       |           |\n\
    | register| d, e    | F       |           |\n| control | s       | op, ALU | \
    \          |\n| PC      | PC, op  | PC      |           |\n\n\n## Results\n\n\
    <img src=\"imgs/result_1.png\" width = \"80%\" style=\"float:middle\" align=center\
    \ />\n<img src=\"imgs/result_2.png\" width = \"80%\" style=\"float:middle\" align=center\
    \ />\n\n## FPGA Simulation\n\n<img src=\"imgs/simulation.png\" width = \"80%\"\
    \ style=\"float:middle\" align=center />\n\n## Testbench Simulations\n\n### ALU\
    \ Testbench\n\n<img src=\"imgs/ALU_Testbench.png\" width = \"80%\" style=\"float:middle\"\
    \ align=center />\n\n### Mem Testbench\n\n<img src=\"imgs/Mem_Testbench.png\"\
    \ width = \"80%\" style=\"float:middle\" align=center />\nfrom flask import Flask,\
    \ request\nimport json\nimport mysql.connector\n\napp = Flask(__name__)\n\n@app.route('/register',\
    \ methods = ['GET', 'POST'])\ndef register():\n    try:\n        user_id = request.json['ID']\n\
    \    except KeyError:\n        return json.dumps('Key Error')\n    con = mysql.connector.connect(\n\
    \    host = \"localhost\",\n    user = \"root\",\n    passwd = \"\",\n    database\
    \ = \"register\"\n    )\n    if request.method == 'GET':\n        cursor = con.cursor()\n\
    \        cursor.execute(\"SELECT * from users WHERE ID = '{}'\".format(user_id))\n\
    \        result = cursor.fetchone()\n    else:\n        cursor = con.cursor()\n\
    \        cursor.execute(\"INSERT INTO users (ID) VALUES ('{}')\".format(user_id))\n\
    \        con.commit()\n        result = \"Successed\"\n    con.close()\n    return\
    \ json.dumps(result)\n\n@app.route('/unregister', methods = ['GET', 'POST'])\n\
    def unregister():\n    try:\n        user_id = request.json['ID']\n    except\
    \ KeyError:\n        return json.dumps('Key Error')\n    con = mysql.connector.connect(\n\
    \    host = \"localhost\",\n    user = \"root\",\n    passwd = \"\",\n    database\
    \ = \"register\"\n    )\n    if request.method == 'GET':\n        cursor = con.cursor()\n\
    \        cursor.execute(\"SELECT * from users WHERE ID = '{}'\".format(user_id))\n\
    \        result = cursor.fetchone()\n    else:\n        cursor = con.cursor()\n\
    \        cursor.execute(\"DELETE FROM users WHERE ID = '{}'\".format(user_id))\n\
    \        con.commit()\n        result = \"Successed\"\n    con.close()\n    return\
    \ json.dumps(result)\n\nif __name__ == '__main__':\n    app.run(debug = True)\n\
    import os\n\nos.system(\"python3 main.py\")\n# Lab 1 - FPGA Basics\n\n## Contents\n\
    \n* [Introduction](#introduction)\n* [FPGA](#fpga)\n* [Verilog](#verilog)\n* [Vivado](#vivado)\n\
    * [Design](#design)\n* [Results](#results)\n* [FPGA Simulation](#fpga-simulation)\n\
    * [Testbench Simulations](#testbench-simulations)\n\n## Introduction\n\nThis lab\
    \ is one of the required labs for ECE 304. It illustrates the basic hardware flow\
    \ of FPGA. In this lab, we need to create a digital circuit that can output the\
    \ result of addition of two 8-bit numbers. The Verilog file is given in [ECE 304\
    \ - Lab 1.zip](https://www.dropbox.com/s/q1i13y361ybk17g/ECE%20304%20-%20Lab%201.zip?dl=0).\n\
    \n## FPGA\n\nA FPGA is a full-chip integrated circuit, which means it contains\
    \ all the components of the complete system (CPU, memory, controller, etc.). It\
    \ is often called \"Field Programmable Gate Array\". The FPGA"
- code: "module t_Johnson_Counter ();\nwire [3: 0] count;\nreg enable;\nreg clock,\
    \ reset;\ngenerate\nbegin:\nJohnson_Counter M0 (count, enable, clock, reset);\n\
    end\nassign count[2: 0] = count;\nendgenerate\ninitial #500 $finish;\ninitial\
    \ begin clock = 0; forever #5 clock = ~clock; end\nendmodule\n### Test Bench Code:\n\
    module testbench (clk_50);\nreg [3: 0] count;\nreg enable;\nreg clk_50;\ninitial\
    \ begin\ncount = 0;\nenable = 1;\n#10 clk_50 = 1;\nend\nprocess (clk_50)\nbegin\n\
    if (clk_50 == 0)\n#100 count = {count[2: 0], 1'b1};\nelse if (count == 4'b1111)\n\
    #100 count = {count[2: 0], 1'b0};\nelse\n#100 count = count + 1'b1;\nend\nend\n\
    endprocess\ninitial\n#1000 $finish;\nendmodule\nmodule tb ();\ngenvar i;\nreg\
    \ clock;\nJohnson_Counter M0 (count, enable, clock, 0);\nreg clk_50;\ntestbench\
    \ TB0 (clk_50);\ninitial clock = 0;\nalways #100 clock = ~clock;\ninitial\n#1000\
    \ $finish;\nendmodule\n## 4. Test\n### Test Result:\nThere are 5 tests to run\
    \ the Johnson counter logic, and the average time of all 5 tests is 209.9355ms\
    \ using the base code. The average time of all 5 tests is 204.0441ms using the\
    \ modified code.\n## 5. Summary\n\nIn this lab, I learned the basic usage of generate\
    \ block and assign block in Verilog programming, and I also learned the basic\
    \ usage methods of using Verilog to implement Johnson Counter logic.\n\n## 6.\
    \ Reference\n\nVerilog Tutorial (Wikibooks, 2019). (n.d.). Retrieved from https://en.wikibooks.org/wiki/Verilog\\\
    _Tutorial/Generate\\_Blocks\n\nVerilog Programming (Wikibooks, 2019). (n.d.).\
    \ Retrieved from https://en.wikibooks.org/wiki/Verilog\\_Programming/Assign\\\
    _Statements\n\nVerilog HDL Programming (Wikibooks, 2019). (n.d.). Retrieved from\
    \ https://en.wikibooks.org/wiki/Verilog\\_HDL\\_Programming/Generate\\_Blocks\\\
    _and\\_Conditional\\_Instantiation\n\nModule (Wikibooks, 2019). (n.d.). Retrieved\
    \ from https://en.wikibooks.org/wiki/Verilog\\_HDL\\_Programming/Modules\n\nVerilog\
    \ HDL Programming (Wikibooks, 2019). (n.d.). Retrieved from https://en.wikibooks.org/wiki/Verilog\\\
    _HDL\\_Programming/Assign\\_Statements\n\nJohnson Counter (Wikibooks, 2019). (n.d.).\
    \ Retrieved from https://en.wikibooks.org/wiki/Verilog\\_HDL\\_Programming/Johnson\\\
    _Counter\n\nVerilog HDL Programming (Wikibooks, 2019). (n.d.). Retrieved from\
    \ https://en.wikibooks.org/wiki/Verilog\\_HDL\\_Programming/Johnson\\_Counter\n\
    \nJohnson Counter (Razdanet.info, 2019). (n.d.). Retrieved from https://www.razdanet.info/vHDL/Johnson\\\
    _Counter.html\n\nJohnson Counter (Wikiwand.org, 2019). (n.d.). Retrieved from\
    \ https://www.wikiwand.com/en/Johnson\\_counter\n\n## Acknowledgements\n\nI would\
    \ like to thank my instructors, Prof.  and Prof.  for helping me to complete this\
    \ lab and giving me good opportunities to learn Verilog. I would also like to\
    \ thank my classmates for giving me help and suggestions.\n#include<iostream>\r\
    \nusing namespace std;\r\nmain()\r\n{\r\n\tint a, b, c, d, e, f;\r\n\tcout<<\"\
    input an integer(5-digit):\";\r\n\tcin>>a;\r\n\n\t\te=b%10;\r\n\t\tb=b/10;\r\n\
    \t\tc=b%10;\r\n\t\tb=b/10;\r\n\t\td=b%10;\r\n\t}\r\n\telse\r\n\t{\r\n\t\td=a%10;\r\
    \n\t\ta=a/10;\r\n\t\tc=a%10;\r\n\t\ta=a/10;\r\n\t\tb=a%10;\r\n\t\ta=a/10;\r\n\t\
    \te=a%10;\r\n\t}\r\n\tif(e==6)\r\n\t\tcout<<\"YES\";\r\n\telse\r\n\t\tcout<<\"\
    NO\";\r\n\tcin>>f;\r\n}\r\n\tif(a>50000||a<10000)\r\n\t\tcout<<\"Invalid\";\r\n\
    \telse\r\n\t{\r\n\t\tb=a%10;\r\n\t\ta=a/10;\r#include <iostream>\r\nusing namespace\
    \ std;\r\nmain()\r\n{\r\n\tint a, b, c, d, e, f, g;\r\n\tcout<<\"Input a 6-digit\
    \ integer:\";\r\n\tcin>>a;\r\n\tif (a>999999||a<100000)\r\n\t\tcout<<\"Invalid\"\
    ;\r\n\telse\r\n\t{\r\n\t\tb=a%10;\r\n\t\ta=a/10;\r\n\t\tc=a%10;\r\n\t\ta=a/10;\r\
    \n\t\td=a%10;\r\n\t\ta=a/10;\r\n\t\te=a%10;\r\n\t\tif(e==6)\r\n\t\t\tcout<<\"\
    YES\";\r\n\t\telse\r\n\t\t\tcout<<\"NO\";\r\n\t}\r\n\tcin>>f;\r\n\tcin>>g;\r\n\
    }\r\n#include <iostream>\r\nusing namespace std;\r\nmain()\r\n{\r\n\tint a, b,\
    \ c, d, e, f, g;\r\n\tcout<<\"Input a 6-digit integer:\";\r\n\tcin>>a;\r\n\tif\
    \ (a>9\n\telse\r\n\t\tcout<<\"NO\";\r\n\tcin>>f;\r\n\tcin>>g;\r\n}\r\n99999||a<100000)\r\
    \n\t\tcout<<\"Invalid\";\r\n\telse\r\n\t{\r\n\t\tb=a%10;\r\n\t\ta=a/10;\r\n\t\t\
    c=a%10;\r\n\t\ta=a/10;\r\n\t\td=a%10;\r\n\t\ta=a/10;\r\n\t\te=a%10;\r\n\t\tif(e==6)\r\
    \n\t\t\tcout<<\"YES\";\r\n\t\telse\r\n\t\t\tcout<<\"NO\";\r\n\t}\r#include<iostream>\r\
    \nusing namespace std;\r\nmain()\r\n{\r\n\tint a, b, c, d, e, f;\r\n\tcout<<\"\
    input an integer(5-digit):\";\r\n\tcin>>a;\r\n\tif(a>50000||a<10000)\r\n\t\tcout<<\"\
    Invalid\";\r\n\telse\r\n\t{\r\n\t\tb=a%10;\r\n\t\ta=a/10;\r\n\t\tc=b%1\n\telse\r\
    \n\t\tcout<<\"NO\";\r\n\tcin>>f;\r\n}\r\n0;\r\n\t\tb=b/10;\r\n\t\td=b%10;\r\n\t\
    \tb=b/10;\r\n\t\te=b%10;\r\n\t}\r\n\tif(e==6)\r\n\t\tcout"
- code: |-
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    generate
    for (i=0; i<4; i=i+1)
    Johnson_Counter M0 (count[i], enable, clock, reset);
    endgenerate
    endmodule

    ### Results:
    1. Johnson Counter:

    ```
    $ vvp t_Johnson_Counter
    $ gtkwave Johnson_Counter_Simulation.vcd
    ```

    2. Johnson Counter:

    ```
    $ vvp t_Johnson_Counter
    $ gtkwave Johnson_Counter_Simulation.vcd
    ```

    ## 10.34 Johnson Counter VHDL Codes

    ### Base VHDL Codes:
    `Johnson_Counter`

    ```
    library ieee;
    use ieee.std_logic_1164.all;
    entity Johnson_Counter is
    port(
    count: out std_logic_vector (3 downto 0);
    enable : in std_logic;
    clock: in std_logic;
    reset : in std_logic);
    end Johnson_Counter;
    architecture Behavioral of Johnson_Counter is
    signal count : std_logic_vector (3 downto 0):= (others =>'0');
    begin
    process(clock,reset)
    begin
    if reset = '1' then
    count <= (others => '0');
    elsif enable = '1' then
    case count is
    when "0000" => count <= "0001";
    when "0001" => count <= "0011";
    when "0011" => count <= "0111";
    when "0111" => count <= "1111";
    when "1111" => count <= "1110";
    when "1110" => count <= "1100";
    when "1100" => count <= "1000";
    when others => count <= "0000";
    end case;
    end if;
    end process;
    end Behavioral;
    ```
    `t_Johnson_Counter`

    ```
    library ieee;
    use ieee.std_logic_1164.all;
    entity t_Johnson_Counter is
    end t_Johnson_Counter;
    architecture Behavioral of t_Johnson_Counter is
    component Johnson_Counter is
    port (
    count: out std_logic_vector (3 downto 0);
    enable : in std_logic;
    clock: in std_logic;
    reset : in std_logic);
    end component;
    signal count : std_logic_vector (3 downto 0):= (others =>'0');
    signal enable: std_logic := '0';
    signal clock: std_logic := '0';
    signal reset : std_logic := '0';
    begin
    johnson_counter: Johnson_Counter port map(count, enable, clock, reset);
    process
    begin
    wait for 500 ns;
    clock <= not clock;
    end process;
    end behavioral;
    ```

    ### Results:
    1. Johnson Counter:

    ```
    $ ghdl -a Johnson_Counter.vhdl
    $ ghdl -e Johnson_Counter
    $ ghdl -r Johnson_Counter --stop-time=100000ns --wave=Johnson_Counter_Simulation.ghw
    $ gtkwave Johnson_Counter_Simulation.ghw
    ```

    2. Johnson Counter:

    ```
    $ ghdl -a Johnson_Counter.vhdl
    $ ghdl -e Johnson_Counter
    $
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    wire [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule
- code: |-
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    generate
    for (i = 0; i < 16; i = i + 1)
    Johnson_Counter Mi (count_o_n[i],
    enable,
    clock,
    reset);
    always @ (posedge clock, posedge reset)
    if (reset == 1) count_o_n <= 0;
    else if (enable)
    case (count_o_n[i])
    4'b0000,
    4'
- code: |-
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    reg [3: 0] arr [0: 3];
    generate
    for (int i = 0; i < 4; i = i + 1)
    Johnson_Counter M (count, enable, clock, reset);
    initial
    begin
    clock = 0;
    forever #5 clock = ~clock;
    end
    assign arr[i] = count;
    initial fork
    join
    endfunction
    endgenerate

    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end initial fork join endmodule ### Implementation Result: When the code is synthesized, the resulting RTL has a static array of the Johnson counter states. The test bench has a for loop to generate the inputs. The generated outputs are compared against the expected results. The synthesized design passes the test. ### Testbench Code: module t_Johnson_Counter (); wire [3: 0] count; reg enable; reg clock, reset; reg [3: 0] arr [0: 3]; generate for (int i = 0; i < 4; i = i + 1) Johnson_Counter M (count, enable, clock, reset); initial begin clock = 0; forever #5 clock = ~clock; end assign arr[i] = count; initial fork join endfunction endgenerate initial #500$finish;
    initial begin
    clock = 0;
    forever #5 clock = ~clock;
    end
    initial fork
    join
    endmodule
    ### Result:
    The test bench has a for loop to generate the inputs. The generated outputs are compared against the expected results. The synthesized design passes the test.

    This module was created using Verilog HDL Designer.
- code: |-
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    generate
    for (i = 0; i < 4; i++) begin : John_Counter
    Johnson_Counter M0 (count[i], enable, clock, reset);
    end
    endgenerate
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    endmodule

    ### Simulation Results:

    #### Johnson Counter Simulation Results

    #### Johnson Counter Simulation Results

    ## 6.3.1 Johnson Counter Simulation Results

    ### 6.3.1.1 Johnson Counter Simulation Results
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000: count <= {count[2: 0], 1'b1};
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork

    ### Verilog Synthesis:
    Before:

    After:

    ### Observation:
    I can see that the synthesis results are not ideal, the `inside` is still not correct even though it is valid.
- code: "module t_Johnson_Counter2();\nparameter N = 4;\nreg [3: 0] count, count_array\
    \ [N];\n\ngenerate\nfor (i = 0; i < N; i++)\nwire [3: 0] count;\nreg enable;\n\
    reg clock, reset;\nJohnson_Counter M0_i (count, enable, clock, reset);\ninitial\
    \ #500 $finish;\ninitial begin clock = 0; forever #5 clock = ~clock; end\ninitial\
    \ fork\njoin\nendmodule\nendgenerate\n\ninitial begin\nfor (i = 0; i < N; i++)\n\
    assign count_array[i] = count;\nend\n\nalways @*\nif (enable)\ncase (count)\n\
    4'b0000,\n4'b0001,\n4'b0011,\n4'b0111,\n4'b1111,\n4'b1110,\n4'b1100,\n4'b1000:\
    \ count <= {count[2: 0], 1'b1};\ndefault: count <= 0;\nendcase\nend\ninitial $finish\
    \ endmodule ### Results:  Original:  Original and Modified both work. Both run\
    \ correctly. Modified:  Original: 3921 output lines 698 input lines (97%) 17.63%\
    \ 1185 input lines 484 output lines (67%) 46.71% ### Variation Instruction: Use\
    \ a generate block to wrap the Johnson counter logic, and use `inside` to check\
    \ `count` inside a static array with constant index. ### Modified Code: module\
    \ t_Johnson_Counter4(); parameter N = 4; reg [3: 0] count_array [N]; reg [3: 0]\
    \ count; generate for (i = 0; i < N; i++) // Generate Johnson Counters wire [3:\
    \ 0] count; reg enable; reg clock, reset; Johnson_Counter M0_i (count, enable,\
    \ clock, reset); initial #500$finish;\ninitial begin\nclock = 0;\nforever #5 clock\
    \ = ~clock;\nend\ninitial fork\njoin\nendmodule\nendgenerate\ninitial begin\n\
    for (i = 0; i < N; i++)\nassign count_array[i] = count;\nend\nalways @*\nif (enable)\n\
    case (count)\n4'b0000,\n4'b0001,\n4'b0011,\n4'b0111,\n4'b1111,\n4'b1110,\n4'b1100,\n\
    4'b1000: count <= {count[2: 0], 1'b1};\ndefault: count <= 0;\nendcase\nend\ninitial\
    \ \\$finish\nendmodule\n### Results:\nOriginal:\nOriginal and Modified both work.\
    \ Both run correctly.\nModified:\nOriginal:\n3921 output lines\n698 input lines\
    \ (97%)\n17.63%\n1185 input lines\n484 output lines (67%)\n46.71%\n\u2022  \xBB\
    \ \xBB 4 weeks ago, # ^ | \_ 0 Thank you!\n \xBB 4 weeks ago, # | \_ +11 For the\
    \ second task, you can also use verilog's $display function. This will print out\
    \ the values at the appropriate points in time. You can also use the $time$ variable\
    \ to get the current time:\n\u2022  \xBB \xBB 4 weeks ago, # ^ | \_ 0 I'll definitely\
    \ try that out. Could you please tell me how I can use $time$ in a for-loop?\n\
    \u2022  \xBB \xBB \xBB 4 weeks ago, # ^ | \_ 0 You can use it normally within\
    \ a module and even a module's always block, but you have to put a \"begin\" in\
    \ the end of the module: module My_Module(); always begin $display(\"Time = %0t\"\
    , $time); end endmodule  You can use $time within the for-loop's condition, but\
    \ you cannot use it in the for-loop's body, however, you can use a variable to\
    \ do so:\nmodule My_Module(); integer i; always begin i = 0; for (i = 0; i < 5;\
    \ i = i + 1) $display(\"Time = %0t, i = %0d\", $time, i); end endmodule \n \xBB\
    \ 4 weeks ago, # | \_ +19  \xBB 4 weeks ago, # ^ | \_ +11 I have just edited my\
    \ answer to include $time.\n \xBB 4 weeks ago, # | \_ +43 When I wrote a Verilog\
    \ implementation of this algorithm that was based on the description of the specification\
    \ in the statement I got pretty confused. It was a small mistake in my code, but\
    \ I was curious how other people solved this task and I found out that there are\
    \ a couple of similar solutions. My solution.\n \xBB 4 weeks ago, # | \_ +31 This\
    \ is actually a very good example of why a well defined specification is always\
    \ better than an unclear one :)\n\u2022  \xBB \xBB 4 weeks ago, # ^ | \_ +31 I\
    \ think this is a good point. Especially because I remember my students getting\
    \ so frustrated with their assignments because of this problem and some of them\
    \ even didn't have any clue how to solve it.\n\u2022  \xBB \xBB \xBB 4 weeks ago,\
    \ # ^ | \_ +3 I was on my third assignment that I couldn't do that simple thing,\
    \ and I spent the whole afternoon writing a random implementation of it (because\
    \ I had no idea how to implement it).\n\u2022  \xBB \xBB \xBB 4 weeks ago, # ^\
    \ | \_ +5 I had a similar experience, but it was with a much more complex task.\
    \ First, I had to write a program that converts a binary string in a form: 1010011110000111100001111011101011110000111100001110101010111,\
    \ which consists of a prefix (1010011110000111100001111011101011110000111100001110101010111),\
    \ then I wrote several tests, and I had the impression that my program worked\
    \ correctly, but I had no idea what it should do in case the input string doesn't\
    \ have the required prefix. I really had to read the statement again.\n\u2022\
    \  \xBB \xBB \xBB 4 weeks ago, # ^ | \_ +26 I was on that assignment too, and\
    \ in the end, at 7:30am, I simply gave up :/ I was on for like 2 hours, I had\
    \ no idea what to do with that string (it was quite long, so I couldn't even find\
    \ the first 10100 in it), so I was completely frustrated and I didn't know what\
    \ to do.\n \xBB 4 weeks ago, # | \_ +16 I don't think that the examples are good\
    \ enough to describe the algorithm. I think an example would be to show how to\
    \ convert a binary number in bcd format to binary in any radix r. Here is a link\
    \ that I wrote and I think is quite clear: https://www.hackerrank.com/challenges/bcd-conversion/forum/comments/368621\n\
    \ \xBB 4 weeks ago, # | \_ +86 I think the task is better expressed as \"given\
    \ a binary string, print the corresponding decimal string\", because the number\
    \ of binary strings is much larger.\n\u2022  \xBB \xBB 4 weeks ago, # ^ | \_ +20\
    \ +1\n \xBB 4 weeks ago, # | \_ +3 I'd also suggest to add the following to the\
    \ statement: \"The result of the operation is equivalent to the operation for\
    \ a string consisting of the same digits, each multiplied by the power of 10 given\
    \ by the index of its corresponding digit. For example, 7832 will be converted\
    \ to 700 + 80 + 302 + 2 = 1108.\"\n \xBB 4 weeks ago, # | \_ 0 Is it possible\
    \ to do the same thing using if-else blocks instead of cases? I tried, but it\
    \ was just confusing.\n\u2022  \xBB \xBB 4 weeks ago, # ^ | \_ +11 I believe cases\
    \ is the only way to do this in ISE.\n\u2022  \xBB \xBB \xBB 4 weeks ago, # ^\
    \ | \_ 0 I think that the way you would write code would depend on the tool you're\
    \ using. In Vivado, you could use if-else blocks, but that tool doesn't support\
    \ cases.\n \xBB 4 weeks ago, # | \_ 0 Can anyone please help me with this question??\
    \ I understand the question and I have a solution to it but I don't know how to\
    \ implement this solution in verilog. Question statement"
- code: |-
    module t_Johnson_Counter_2 (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case ({count[2: 0], 1'b1})
    4'b1: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule
    ### Verilog generated using the new code:
    module t_Johnson_Counter_2 (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case ({count[2
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    initial begin
    clock = 0;
    reset = 1;
    enable = 0;
    end
    initial fork
    join
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1; end
    initial begin reset = 0; enable = 1;
- code: |-
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
      end
    endmodule
    ### Assembled Code:
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4);
      input a1,a0,b1,b0;
      reg c1,c2,c3,c4;
      reg[1:4] mand[1:9];
      reg[1:9] mor[1:4];
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9;
      initial begin
        mand[1]=4'b1010;
        mand[2]=4'b0110;
        mand[3]=4'b1110;
        mand[4]=4'b1001;
        mand[5]=4'b0101;
        mand[6]=4'b1101;
        mand[7]=4'b1011;
        mand[8]=4'b0111;
        mand[9]=4'b1111;
        mor[1]=9'b101000101;
        mor[2]=9'b011101110;
        mor[3]=9'b000011010;
        mor[4]=9'b000000001;
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1});
      end
    endmodule

    # 5) PLA based 2x2 multiplier
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4);
      input a1,a0,b1,b0;
      reg c1,c2,c3,c4;
      reg[1:4] mand[1:9];
      reg[1:9] mor[1:4];
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9;
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1});
      end
    endmodule

    # 6) Array based 2x2 multiplier
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4);
      input a1,a0,b1,b0;
      reg c1,c2,c3,c4;
      reg[1:4] mand[1:9];
      reg[1:9] mor[1:4];
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9;
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010;
        mand[2]=4'b0110;
        mand[3]=4'b1110;
        mand[4]=4'b1001;
        mand[5]=4'b0101;
        mand[6]=4'b1101;
        mand[7]=4'b1011;
        mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101;
        mor[2]=9'b011101110;
        mor[3]=9'b000011010;
        mor[4]=9'b000000001;
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1});
      end
    endmodule

    # 7) 1-bit PLA based 2x2 multiplier (without carry-in)
    module mltp_a(a1,a0,b1,b0,c1,c2);
      input a1,a0,b1,b0;
      reg c1,c2;
      reg[1:4] mand[1:
- code: "```\nmodule mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier\n\
    \    input a1,a0,b1,b0; output c1,c2,c3,c4;\n    reg[1:4] mand[1:9]; // AND plane\
    \ inputs (4 bits wide, 9 product terms)\n    reg[1:9] mor[1:4]; // OR plane inputs\
    \ (9 bits wide, 4 outputs)\n    reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms\n\
    \    reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment\n\n   \
    \ initial begin\n        // Define AND plane connections (input -> product term)\n\
    \        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;\n\
    \        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;\n\
    \        mand[9]=4'b1111;\n        // Define OR plane connections (product term\
    \ -> output)\n        // Format: 9 bits for p1-p9 connections for each output\
    \ c1-c4\n        mor[1]=9'b101000101; // Connections for c1\n        mor[2]=9'b011101110;\
    \ // Connections for c2\n        mor[3]=9'b000011010; // Connections for c3\n\
    \        mor[4]=9'b000000001; // Connections for c4\n        // Instantiate PLA\
    \ using system tasks\n        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});\
    \ // Corrected input order?\n        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9},\
    \ {c4,c3,c2,c1}); // Corrected output order?\n    end\nendmodule\n```\n### Result:\n\
    ```\n# Modified VHDL Code:\nprocedure AND_PLA (a: in std_logic_vector(3 downto\
    \ 0); b: in std_logic_vector(3 downto 0); out: out std_logic_vector(3 downto 0));\n\
    \    begin\n        out(3) := b(0) and b(1) and a(0) and a(1);\n        out(2)\
    \ := b(1) and not b(0);\n        out(1) := not b(1) and b(0);\n        out(0)\
    \ := not b(0) and not b(1) and a(1) and a(0);\n    end procedure;\n\n    procedure\
    \ OR_PLA (a: in std_logic_vector(3 downto 0); b: in std_logic_vector(3 downto\
    \ 0); out: out std_logic_vector(3 downto 0));\n        begin\n            out(3)\
    \ := b(0) or b(1) or a(0) or a(1);\n            out(2) := b(1) or not b(0) or\
    \ a(0) or a(1);\n            out(1) := not b(1) or b(0) or a(0) or a(1);\n   \
    \         out(0) := not b(0) or not b(1) or a(1) or a(0);\n        end procedure;\n\
    \n    function mux(s1, s2, sel) return std_logic is\n    begin\n        if sel\
    \ = '0' then \n            return s1;\n        else\n            return s2;\n\
    \        end if;\n    end function;\nend Vhdl_PLA_Array;\n```\n### Testbench Code:\n\
    ```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_arith.all;\n\
    use ieee.std_logic_textio.all;\n\nentity tb_vhdl_pla_array is\nend tb_vhdl_pla_array;\n\
    \narchitecture tb of tb_vhdl_pla_array is\n\nsignal a, b: std_logic_vector(3 downto\
    \ 0);\nsignal c1, c2, c3, c4: std_logic;\n\nbegin\n\nprocess(a, b)\n    variable\
    \ : std_logic_vector(3 downto 0);\nbegin\n    -- Test 1\n    a <= \"0000\"; b\
    \ <= \"0000\";\n    Vhdl_PLA_Array.AND_PLA(a, b, c1);\n    Vhdl_PLA_Array.OR_PLA(a,\
    \ b, c2);\n    assert c1 = \"0000\" report \"Expected '0000' but got \" & c1 &\
    \ \".\";\n    assert c2 = \"0000\" report \"Expected '0000' but got \" & c2 &\
    \ \".\";\n\n    -- Test 2\n    a <= \"1111\"; b <= \"0101\";\n    Vhdl_PLA_Array.AND_PLA(a,\
    \ b, c1);\n    Vhdl_PLA_Array.OR_PLA(a, b, c2);\n    assert c1 = \"0111\" report\
    \ \"Expected '0111' but got \" & c1 & \".\";\n    assert c2 = \"1010\" report\
    \ \"Expected '1010' but got \" & c2 & \".\";\n\n    -- Test 3\n    a <= \"0111\"\
    ; b <= \"1111\";\n    Vhdl_PLA_Array.AND_PLA(a, b, c1);\n    Vhdl_PLA_Array.OR_PLA(a,\
    \ b, c2);\n    assert c1 = \"1111\" report \"Expected '1111' but got \" & c1 &\
    \ \".\";\n    assert c2 = \"0111\" report \"Expected '0111' but got \" & c2 &\
    \ \".\";\n\n    -- Test 4\n    a <= \"0000\"; b <= \"1111\";\n    Vhdl_PLA_Array.AND_PLA(a,\
    \ b, c1);\n    Vhdl_PLA_Array.OR_PLA(a, b, c2);\n    assert c1 = \"1111\" report\
    \ \"Expected '1111' but got \" & c1 & \".\";\n    assert c2 = \"0000\" report\
    \ \"Expected '0000' but got \" & c2 & \".\";\n\n    -- Test 5\n    a <= \"1111\"\
    ; b <= \"1111\";\n    Vhdl_PLA_Array.AND_PLA(a, b, c1);\n    Vhdl_PLA_Array.OR_PLA(a,\
    \ b, c2);\n    assert c1 = \"1111\" report \"Expected '1111' but got \" & c1 &\
    \ \".\";\n    assert c2 = \"1111\" report \"Expected '1111' but got \" & c2 &\
    \ \".\";\n\n    -- Test 6\n    a <= \"1010\"; b <= \"1010\";\n    Vhdl_PLA_Array.AND_PLA(a,\
    \ b, c1);\n    Vhdl_PLA_Array.OR_PLA(a, b, c2);\n    assert c1 = \"1010\" report\
    \ \"Expected '1010' but got \" & c1 & \".\";\n    assert c2 = \"1010\" report\
    \ \"Expected '1010' but got \" & c2 & \".\";\n\n    -- Test 7\n    a <= \"0101\"\
    ; b <= \"0101\";\n    Vhdl_PLA_Array.AND_PLA(a, b, c1);\n    Vhdl_PLA_Array.OR_PLA(a,\
    \ b, c2);\n    assert c1 = \"0101\" report \"Expected '0101' but got \" & c1 &\
    \ \".\";\n    assert c2 = \"0101\" report \"Expected '0101' but got \" & c2 &\
    \ \".\";\n\n    -- Test 8\n    a <= \"1101\"; b <= \"1101\";\n    Vhdl_PLA_Array.AND_PLA(a,\
    \ b, c1);\n    Vhdl_PLA_Array.OR_PLA(a, b, c2);\n    assert c1 = \"1101\" report\
    \ \"Expected '1101' but got \" & c1 & \".\";\n    assert c2 = \"1101\" report\
    \ \"Expected"
- code: |-
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4);
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      wire [3:0] inside = a0 | (a1 << 3);
      assign c1 = C[inside[0]] && C[inside[1]] && C[inside[2]];
      assign c2 = C[inside[0]] && C[inside[1]] && C[inside[2]] && C[inside[3]];
      assign c3 = C[inside[0]] && C[inside[1]] && C[inside[3]] && C[inside[3]];
      assign c4 = C[inside[1]] && C[inside[2]] && C[inside[3]] && C[inside[3]];
    endmodule
    ```
    ### Verification Result:
    Passed all tests!#include <iostream>

    using namespace std;

    void printArray(int a[], int size) {
        for(int i = 0; i < size; i++) {
            cout << a[i] << " ";
        }
        cout << "\n";
    }

    void merge(int a[], int b[], int n, int m) {
        int i = 0;
        int j = 0;
        int k = 0;
        int temp[n+m];
        while(i < n && j < m) {
            if(b[i] < a[j]) {
                temp[k] = b[i];
                i++;
            } else {
                temp[k] = a[j];
                j++;
            }
            k++;
        }
        while(i < n) {
            temp[k] = a[i];
            k++;
            i++;
        }
        while(j < m) {
            temp[k] = b[j];
            k++;
            j++;
        }
        for(int i = 0; i < m+n; i++) {
            a[i] = temp[i];
        }
    }

    int main() {
        int a[] = {2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72};
        int b[] = {5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80};
        int m = sizeof(b)/sizeof(b[0]);
        int n = sizeof(a)/sizeof(a[0]);
        merge(a,b,n,m);
        printArray(a, n+m);
        return 0;
    }
    #include <iostream>
    #include <string.h>

    using namespace std;

    void printArray(char arr[], int n) {
        for(int i = 0; i < n; i++) {
            cout << arr[i];
        }
        cout << "\n";
    }

    void swap(char *a, char *b) {
        char tmp;
        tmp = *a;
        *a = *b;
        *b = tmp;
    }

    void reverse(char str[], int length) {
        int i = 0;
        int j = length-1;
        while(i < j) {
            swap(&str[i],&str[j]);
            i++;
            j--;
        }
    }

    void reverseWords(char str[]) {
        int stringLength = strlen(str);
        reverse(str, stringLength);
        int wordStart = 0,
                wordEnd = 0;
        while(wordStart < stringLength) {
            if(str[wordStart]!='') {
                wordEnd = wordStart;
                while(str[wordEnd]!='' && wordEnd < stringLength) {
                    wordEnd++;
                }
                reverse(&str[wordStart], wordEnd-wordStart);
                wordStart = wordEnd+1;
            } else {
                wordStart++;
            }
        }
    }

    int main() {
        char str[] = "I love programming";
        reverseWords(str);
        printArray(str, strlen(str));
        return 0;
    }
    #include <iostream>

    using namespace std;

    void printArray(int a[], int size) {
        for(int i = 0; i < size; i++) {
            cout << a[i] << " ";
        }
        cout << "\n";
    }

    void quickSort(int a[], int low, int high) {
        int i = low;
        int j = high;
        int pivot = a[high];
        while(i < j) {
            while(a[i] <= pivot) {
                i++;
            }
            while(a[j] > pivot) {
                j--;
            }
            if(i < j) {
                swap(a[i], a[j]);
            }
        }
        swap(a[i], a[high]);
        if(low < i
- code: |-
    ```Verilog
    ### Verilog Code:
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
      end
    endmodule
    ```
    ### Observations:
    Function calls in the modified code are still functional without error.
    To run the modified code, we need to pass in the additional parameter `-u` to vcs to load the array function definition.

    #### Compile Results:
    ```
    $ vcs -autocompile -u mltp_a.sv -debug_all -l m_a_debug.log
    Note: m_a_debug.log was created.
    ```
    #### Run Results:
    ```
    $ vcs -l m_a_
- code: |-
    ```verilog
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Variation Instruction: Replace direct PLA output logic with a function call in array index used within `inside` range list.
      end
    endmodule
    ```

    ## Vivado Synthesis
    ### Base Verilog Code:
    ```
    # Vivado Synthesis using `make_pla.tcl`
    [synth_design]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_a.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_b.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_c.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_d.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_e.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_f.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_g.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_h.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_i.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_j.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_k.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_l.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_m.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_n.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_o.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_p.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_q.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_r.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_s.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_t.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_u.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_v.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_w.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_x.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_y.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_z.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {make_pla.tcl}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_a_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_b_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_c_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_d_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_e_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_f_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_g_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_h_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_i_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_j_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_k_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_l_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_m_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_n_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_o_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_p_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_q_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_r_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_s_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_t_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_u_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_v_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_w_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_x_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {mltp_y_wrapper.v}]]
    [set_property -name LAUTOMAP_ENABLE false [get_files {ml
- code: |-
    ```
    ### Base Verilog Code:
    module mltp_a_v4(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term
- code: |-
    module mux(a0,b0,s,o);
      input a0,b0,s;
      output o;
      always @(a0 or b0 or s) begin
        o=s?a0:b0;
      endendmodule

    * * *

    ### Base Verilog Code:
    module adder(a,b,c,d,e,f,o,s);
      input a,b,c,d,e,f,s;
      output o;
      reg d,e,f,o;
      always @(a or b or c or d or e or f or s) begin
        d=a xor b xor c xor d xor e xor f;
        e=(a and b) or (b and c) or (c and d) or (d and e) or (e and f) or (f and a);
        f=(not a and b) or
- code: |-
    ```diff
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      // reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
    -  initial begin
    +  initial begin // Declare local variables for procedural assignment
        // Define AND plane connections (input -> product term)
    -    mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
    -    mand[5]=4'b0101; mand[6]=4'b1101
- code: |-
    ```
    ### Base Verilog Code:
    module mltp_b(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
      end
    endmodule
    ```
    ## 4x1 Multiplications
    ### Base Verilog Code:
    ```
    // PLA based 4x1 multiplier
    module mltp_c(a3,a2,a1,a0,b3,b2,b1,b0,c);
      input a3,a2,a1,a0,b3,b2,b1,b0; output c;
      // Declare storage for AND plane
      reg[1:4] mand[1:16]; // AND plane inputs (4 bits wide, 16 product terms)
      reg[1:4] mor[1:4]; // OR plane inputs (4 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16; // Product terms
      reg c; // Output must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b
- code: "```verilog\n// Base Verilog Code: module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4);\
    \ // PLA based 2x2 multiplier\n  input a1,a0,b1,b0; output c1,c2,c3,c4;\n  //\
    \ Declare storage for AND plane and OR plane\n  reg[1:4] mand[1:9]; // AND plane\
    \ inputs (4 bits wide, 9 product terms)\n  reg[1:9] mor[1:4]; // OR plane inputs\
    \ (9 bits wide, 4 outputs)\n  // reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms\n\
    \  // reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment\n  //\
    \ initial begin\n    // Define AND plane connections (input -> product term)\n\
    \    int k = 1;\n    while (k <= 9) begin\n        int i = 0;\n        while (i\
    \ <= 7) begin\n            int j = 0;\n            while (j <= 7) begin\n    \
    \            mand[k] = $bits( a0[7-j] & a1[7-i] & b0[7-j] & b1[7-i] ); \n    \
    \            j = j + 1;\n            end\n            i = i + 1;\n        end\n\
    \        k = k + 1;\n    end\n\n    // Define OR plane connections (product term\
    \ ->"
- code: |-
    always @( s ) begin : force_a_1
    if ( s inside {0,1})
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    ### Generated Verilog Code:
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s inside {0,1})
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    ### Changes Description:
    In the second variant, the condition `s inside {0,1})` in `force_a_1` block is written as `s inside {0,1})`.

    ### Changes Description in Verilator:

    Verilator is used in this repository. You can find the change using
    `git log --pretty=%B -p --since=1.month.ago path/to/verilog_file` command.

    ## Conclusion

    We can see that the modification in the second variant is almost same as the first variant except for the `else` statement after `s inside`.

        echo -e '\e[42m $ \e[49m'
    else
        echo -e '\e[41m $ \e[49m'
    fi
    #!/bin/bash

    if! [ -x "$(command -v verilator)" ]
    then
        echo 'Error: Verilator is not installed.' >&2
        exit 1
    fi

    echo -e '\e[41m $ \e[49m'
    rm -rf./temp_out
    rm -rf./temp_in
    mkdir temp_out
    mkdir temp_in

    filename_arr=("sample_0" "sample_1" "sample_2" "sample_3" "sample_4")

    for filename in ${filename_arr[*]}
    do
        echo "---------------------------------------"
        echo "Test Case: $filename"
        echo "---------------------------------------"

        # create testbench
        if [ "$filename"!= "sample_0" ]
        then
            verilator -I./RTL -I./input -I./verilator --lint-only --sv./vsrc/$filename.sv
            verilator -I./RTL -I./input -I./verilator -Wno-fatal -Wno-UNOPTFLAT --cc --exe -o./temp_out/a./vsrc/$filename.sv./src/clock_generator.sv
          ./temp_out/a -l./temp_out/verilator.log
        else
            verilator -I./RTL -I./input -I./verilator --lint-only --sv./vsrc/$filename.sv
            verilator -I./RTL -I./input -I./verilator -Wno-fatal -Wno-UNOPTFLAT --cc -CFLAGS "-DMULT=2" --exe -o./temp_out/a./vsrc/$filename.sv./src/clock_generator.sv
          ./temp_out/a -l./temp_out/verilator.log
        fi

        # copy testbench files
        cp -af./input/$filename/input/*./temp_in/

        # check simulation result
        echo "Check Result with diff"
        diff -r -q./temp_out/data_out./temp_out/data_in
        if [ $? -ne 0 ]
        then
            echo -e '\e[41m $ \e[49m'
        else
            echo -e '\e[42m $ \e[49m'
        fi

        # clear temporary files
        rm -rf./temp_out
        rm -rf./temp_in
    done

    # check simulation result
    echo "Check Result with diff"
    diff -r -q./temp_out/data_out./temp_out/data_in
    if [ $? -ne 0 ]# 5-bit Counter in System-Verilog:

    ## Problem:
    Implement a 5-bit counter with the following specifications:
      - reset state: 0
      - increment: 1
      - decrement: 0

    ## Verilog Code:
    ```
    module counter_5bit (input logic clk, input logic rst, input logic increment, output logic signed [4:0] counter);
    reg signed [4:0] counter = 0;
    always@(posedge clk) begin : clocked
    case(increment)
    0: begin
    if(!rst)
    begin
    counter <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    counter <= counter + 1;
    end
    end
    endcase
    end
    endmodule
    ```

    ## Variation Instruction:
    Use `signed` operator in the declaration of `counter` variable.

    ## Modified Code:
    ```
    module counter_5bit (input logic clk, input logic rst, input logic increment, output logic signed [4:0] counter);
    reg signed [4:0] counter = 0;
    always@(posedge clk) begin : clocked
    case(increment)
    0: begin
    if(!rst)
    begin
    counter <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    counter <= counter + 1;
    end
    end
    endcase
    end
    endmodule
    ```

    ## Generated Verilog Code:
    ```
    module counter_5bit (input logic clk, input logic rst, input logic increment, output logic signed [4:0] counter);
    reg signed [4:0] counter = 0;
    always@(posedge clk) begin : clocked
    case(increment)
    0: begin
    if(!rst)
    begin
    counter <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    counter <= counter + 1;
    end
    end
    endcase
    end
    endmodule
    ```

    ## Changes Description:
    In the second variant, `signed` operator is used to declare the type of variable `counter` in `always` block.

    ## Changes Description in Verilator:

    Verilator is used in this repository. You can find the change using
    `git log --pretty=%B -p --since=1.month.ago path/to/verilog_file` command.
    n
    ```

    ## Changes Description in Verilator:

    Verilator is used in this repository. You can find the change using
    `git log --pretty=%B -p --since=1.month.ago path/to/verilog_file` command.
    # d-FF in System-Verilog:

    ## Problem:
    Implement a d-FF with the following specifications:
      - reset state: 0
      - Q: 0
      - Set to 1: 1
      - Set to 0: 0

    ## Verilog Code:
    ```
    module d_ff (input logic clk, input logic set, input logic rst, output logic signed [1:0] q, q_b );
    reg signed [1:0] q = 0;
    always@(posedge clk) begin : clocked
    case(set)
    0: begin
    if(!rst)
    begin
    q <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    q <= 1;
    end
    end
    endcase
    end
    assign q_b = q[1:0];
    endmodule
    ```

    ## Variation Instruction:
    Use `signed` operator in the declaration of `q` variable and `q_b` signal.

    ## Modified Code:
    ```
    module d_ff (input logic clk, input logic set, input logic rst, output logic signed [1:0] q, q_b );
    reg signed [1:0] q = 0;
    always@(posedge clk) begin : clocked
    case(set)
    0: begin
    if(!rst)
    begin
    q <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    q <= 1;
    end
    end
    endcase
    end
    assign q_b = q[1:0];
    endmodule
    ```

    ## Generated Verilog Code:
    ```
    module d_ff (input logic clk, input logic set, input logic rst, output logic signed [1:0] q, q_b );
    reg signed [1:0] q = 0;
    always@(posedge clk) begin : clocked
    case(set)
    0: begin
    if(!rst)
    begin
    q <= 0;
    end
    end
    1: begin
    if(!rst)
    begin
    q <= 1;
    end
    end
    endcase
    end
    assign q_b
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside )
    begin
    end
    q_b <= 0;
    end
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    q_b <= 0;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ### Differences:

    **Inside:**
    * There is a new operator `inside`. It checks if the value is inside a constant declared in interface scope.
    **End:**
    * There are 2 changes in  `end` lines.
    * The first `end` is replaced with `end`
    * The second `end` is replaced with `end`
    * It means, if `end` is defined inside a constant, the constant will be ended.
    **Q_B <= 0:**
    * There is a new statement `q_b <= 0;` inserted after `end` lines.
- code: |-
    ```verilog
    always @(posedge clk) begin
    if ( d && r ) {q <= 1'b1; q_b <= 1'b0;}
    else if (!d && r) {q <= 1'b0; q_b <= inside(s, 0);}
    else if ( r && s) {q <= 1'b1; q_b <= 1'b1;}
    else if (!d &&!r) {q <= 1'b0; q_b <= 1'b0;}
    end
    q <= 1'b1;
    end
    ```

    ### Output:

    ```bash
    126-82 126-83 126-84 126-85 126-86
    ```

    ### Original Verilog Code:
    ```verilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @(posedge clk) begin
    if ( d && r ) {q <= 1'b1; q_b <= 1'b0;}
    else if (!d && r) {q <= 1'b0; q_b <= 1'b0;}
    else if ( r && s) {q <=
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else if ( inside_constant )
    begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else
    begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    module d_ff_tb (
    input clk,
    output d,
    input r,
    input s,
    output q,
    output q_b
    );

    parameter s = 1;
    wire q;
    wire q_b;
    wire clk_b;
    d_ff uut_mod (.d(d),.clk(clk),.s(s),.r(r),.clk_b(clk_b),.q(q),.q_b(q_b) );

    parameter r = 1;

    initial begin
    clk = 0;
    d = 0;
    $dumpfile("d_ff.vcd");$dumpvars(0, d_ff);
    end

    always @(posedge clk) begin
    if(clk == 0) begin
    clk = 1;
    end else if (clk == 1) begin
    clk = 0;
    d = r;
    end
    end
    endmodule
    ### Output:
    Error: d_ff_tb.v:26:27: Error: Assertion failed: Assertion failed at d_ff_tb.v:26:27
    Inside the assertion, the input parameter is not a constant and can't be used in the expression.
    ### Verilator Output:
    d_ff_tb.cpp:115
    d_ff_tb: Assertion failed!

    # 7. `inside_constant`
    ### Base Verilog Code:
    module d_ff (input d, clk, s, r, output reg
- code: "module d_ff (input d, clk, s, r, output reg q, q_b );\nalways @( s ) begin\n\
    if ( s inside {1'b1,1'b0} ) //constant declared in a block\nbegin\nend else begin\n\
    deassign q;\ndeassign q_b;\nend\nend\nalways @( r ) begin\nif( r )\nbegin\nend\
    \ else begin\ndeassign q;\ndeassign q_b;\nend\nend\nalways @( posedge clk ) begin\n\
    force s = 1'b0; //constant declared in a block\nend\nendmodule\n### Output:\n\n\
    As the `force` block is inside the `always` block, the constant is valid only\
    \ inside the `force` block.\n\n#### Other Operator Examples:\n\n\u2022 To check\
    \ if the constant is present in an `always` block, use `inside` operator inside\
    \ a `force` block.\n\u2022 To check if the constant is present inside an `always`\
    \ block, use `inside` operator inside a `force` block.\n\nPublished on 19-Nov-2020\
    \ 13:20:37"
- code: |-
    always @( posedge clk ) begin : clocked
    deassign
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( posedge clk ) begin : clocked
    if ( r == 1 )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    endmodule

    ## Example 11

    ### Base Verilog Code:
    module d_ff (input d, clk, s, r, output
- code: |-
    #### module d_ff(input d, clk, s, r, output reg q, q'b q_b );
    #### always @( s ) begin : force_a_1
    #### if ( s )
    #### begin
    #### end else begin
    #### deassign q;
    #### deassign q_b;
    #### end
    #### end
    #### always @( r ) begin : force_a_0
    #### if( r )
    #### begin
    #### end else begin
    #### deassign q;
    #### deassign q_b;
    #### end
    #### end
    #### always @( posedge clk ) begin : clocked
    #### end
    #### endmodule
    #### module d_ff(input d, clk, s, r, output reg q, q'b q_
- code: |-
    always @( clk inside {"CLK0", "CLK1"}) begin : clocked
    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked

    ```

    ### Expected Results:
    ```
    # ** Expected Behavior**
    Error will not be thrown.
    ### Actual Results:
    Error thrown:
    ERROR: No such constant: "clk"
    ```

    ---

    <!-- markdownlint-disable MD041 -->
    ```systemverilog
    module d
- code: |-
    ```
    module d_ff (input d, clk, s, r, output reg q, q_b );
    input a[3:0], b;
    always @(posedge clk) begin : clocked
    if (a == 0)
    q <= 0;
    else if (a inside {0, 1})
    q <= 1;
    else
    q <= a;
    end
    endmodule
    ```
    ### Output:

    ![Inside](image/inside.png)

    # 3. End Of Module

    ## 3.1 How to use `end` keyword?

    `end` keyword is used as an end of module in Verilog code. It is a mandatory keyword and it must be used at the end of module, when you write the code.

    Here is an example of valid `end` keyword usage:
    ```
    endmodule
    ```

    ## 3.2 What is the purpose of `end` keyword?

    The purpose of the `end` keyword in a module is to specify the end of module.

    ## 3.3 Why is `end` keyword mandatory?

    The `end` keyword is mandatory in module code. The `end` keyword is used to specify the end of a module. Without the `end` keyword, the code will be marked as an error.

    # 4. Using If Statements

    ## 4.1 What is an if statement?

    An if statement is a condition that can be used to make decisions in the code. If the condition evaluates to true, the code inside the block is executed, and if it evaluates to false, code inside the else block is executed.

    ## 4.2 How to use an if statement?

    An if statement is used to make decisions in the code by evaluating a condition. The condition can be a simple boolean expression or a complex expression. The if statement must be written inside a module, in a block, and the block must be an `always` block. The if statement must end with a `end` keyword.

    Here is an example of an if statement:
    ```
    if (condition) {
        // code executed when condition evaluates to true
    } else {
        // code executed when condition evaluates to false
    }
    ```

    ## 4.3 Example:
    ### Verilog Code:
    ```
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @(posedge clk) begin : clocked
    if (d == 0)
    q <= 0;
    else if (d == 1)
    q <= 1;
    else
    q <= 0;
    end
    endmodule
    ```
    ### Output:

    ![Inside](image/if.png)

    # 5. Using Case Statements

    ## 5.1 What is a case statement?

    A case statement is a control flow statement that is used to handle multiple conditions in the code. A case statement is used to group conditions into different cases, and to execute code for each case.

    ## 5.2 How to use a case statement?

    A case statement can be used to handle multiple conditions in the code. The syntax of a case statement is as follows:
    ```
    case (value) {
        case_value1:
            // Code to execute when the value matches case_value1
            break;
        case_value2:
            // Code to execute when the value matches case_value2
            break;
       ...
        default:
            // Code to execute when none of the other cases match
    }
    ```
    In a case statement, the `case` keyword is used to open the case block, followed by the `value` to match against. The `:` character is used to separate the case from the block.

    Inside the case, one or more case values can be used to match against the `value`. The `break` statement is used to exit the case block if the value matches. If the value doesn't match, the next case value is checked. If none of the match, the default case is executed.

    Here is an example of a case statement:
    ```
    case (value) {
        case_value1:
            // Code to execute when the value matches case_value1
            break;
        case_value2:
            // Code to execute when the value matches case_value2
            break;
       ...
        default:
            // Code to execute when none of the other cases match
    }
    ```
    ## 5.3 Example:
    ### Verilog Code:
    ```
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @(posedge clk) begin : clocked

    case (d)
    0 : q <= 0;
    1 : q <= 1;
    default : q <= 0;
    endcase
    end
    endmodule
    ```
    ### Output:

    ![Inside](image/case.png)

    # 6. Using For Loops

    ## 6.1 What is a for loop?

    A for loop is a control flow statement that is used to repeat a block of code multiple times. The for loop can be used to execute a block of code for a fixed number of iterations.

    ## 6.2 How to use a for loop?

    A for loop is used to repeat a block of code multiple times. The syntax of a for loop is as follows:
    ```
    for (initialization; condition; increment) {
        // Block of code to be repeated
    }
    ```
    The `for` keyword is used to open the for loop, followed by the initialization that is executed before the loop starts. The `condition` is checked before the loop body is executed. If the condition evaluates to true, the `increment` is executed and the loop body is executed again. If the condition evaluates to false, the loop terminates and the block of code after the for loop is executed.

    The `initialization`, `
- code: |-
    module ttst_ttrimux2_2(); // Assuming this tests a tristate 2-to-2 mux called ttrimux2_2
     reg e;
     reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
     reg s;
     wire out; // Added wire declaration
     // Instantiate MUX in the generate block
     generate
     begin
     tristate_ttrimux2_2 tt_gen(out,e,i,s);
     end
     endgenerate
     initial
     begin
     e =0; i = 2'b00; s = 1'b0; // Added initial's' value
     end
     always
     begin
     end
     initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
     initial #48 $stop;
     endmodule
    The output from this variation should show the correct output:
    ```
    # Testbench for tristate_ttrimux2_2, compiled on 2019-10-25 09:59:10.936818
    # with VeriLog Version 4.2019.q 1864-29093202.
    # Generated by:  <>
    # Using : 3.9.0.202107121655.20210712-1400 (Sat Jul 12 16:55:22 2021)

    #
    # Testbench for design ttst_ttrimux2_2
    #

    #
    # Generated on Fri Oct 23 19:08:59 2020
    #

    timescale 1ns / 1ps


    module ttst_ttrimux2_2;
    reg e;
    reg [1:0]i;
    reg s;
    wire out;
    tristate_ttrimux2_2 mm(out,e,i,s);


    initial
    begin
    e =0;
    i = 2'b00;
    s = 1'b0;
    end

    always
    begin
    end

    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out); initial #48 $stop;

    endmodule
    #
    # Testbench for tristate_ttrimux2_2
    #

    #
    # Generated on Fri Oct 23 19:08:59 2020
    #

    timescale 1ns / 1ps

    module ttst_ttrimux2_2;
    reg e;
    reg [1:0]i;
    reg s;
    wire out;
    generate
    begin
    tristate_ttrimux2_2 mm(out,e,i,s);
    end
    endgenerate

    initial
    begin
    e =0;
    i = 2'b00;
    s = 1'b0;
    end

    always
    begin
    end

    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out); initial #48 $stop;

    endmodule
    **_4.26_** *Generate a testbench for a 3-to-1 tristate multiplexer using the following syntax:*
    ```
    always @ (posedge clk)
    begin
    if (e)
    out <= i;
    else
    out <= ~i;
    end
    ```
    ### Base Verilog Code:
    module ttst_ttrimux3_1(); // Assuming this tests a tristate 3-to-1 mux called ttrimux3_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1, i2; or reg [0:0] i0, i1, i2; or just input wires if MUX takes separate inputs
    reg s;
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    generate
    begin:gen_ttmux
    ttmux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    end
    endgenerate
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ### Output:
    Notice, that s is used to index into the ttMux.

    ## 2. Diverging Verilog Code:
    module d_ttmux2_1_ttmux1_2(); // Assuming this tests a tristate 2-to-2 mux called d_ttmux2_1_ttmux1_2
    reg [1:0]i0;
    reg [1:0]i1;
    reg e0;
    reg e1;
    reg s;
    wire [1:0]out;
    ttmux2_1 mm0(out,e0,i0,s);
    ttmux1_2 mm1(out,e1,i1,s);
    // Initializing mm1 to be the same as mm0
    initial begin e1=e0; i1=i0; end
    initial begin $monitor($time," enable e = %b, s= %b, input i0 = %b, input i1 = %b output out = %b ",e0,s,i0,i1,out); endgenerate endmodule ### Variation Instruction: Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name. ### Modified Code: module d_ttmux2_1_ttmux1_2(); // Assuming this tests a tristate 2-to-2 mux called d_ttmux2_1_ttmux1_2 reg [1:0]i0; reg [1:0]i1; reg e0; reg e1; reg s; wire [1:0]out; generate begin:gen_ttmux ttmux2_1 mm0(out,e0,i0,s); ttmux1_2 mm1(out,e1,i1,s); // Initializing mm1 to be the same as mm0 initial begin e1=e0; i1=i0; end endgenerate initial begin$monitor($time," enable e = %b, s= %b, input i0 = %b, input i1 = %b output out = %b ",e0,s,i0,i1,out); endendmodule ### Output: Notice that we initialized mm1 to be the same as mm0. Now, let's explore what happens if both sides of the muxes diverge. ## 3. Diverging Verilog Code: module d_ttmux2_1_ttmux1_2_ttmux1_2_ttmux1_3(); // Assuming this tests a tristate 2-to-2 mux called d_ttmux2_1_ttmux1_2_ttmux1_2_ttmux1_3 reg [1:0]i0; reg [1:0]i1; reg e0; reg e1; reg e2; reg s; wire [1:0]out; generate begin:gen_ttmux_1 ttmux2_1 mm0(out,e0,i0,s); ttmux1_2 mm1(out,e1,i1,s); ttmux1_2 mm2(out,e2,i1,s); endgenerate initial begin$monitor($time," enable e0 = %b, e1 = %b, e2 = %b, s= %b, input i0 = %b, input i1 = %b output out = %b ",e0,e1,e2,s,i0,i1,out); endendmodule ### Variation Instruction: Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name. ### Modified Code: module d_ttmux2_1_ttmux1_2_ttmux1_2_ttmux1_3(); // Assuming this tests a tristate 2-to-2 mux called d_ttmux2_1_ttmux1_2_ttmux1_2_ttmux1_3 reg [1:0]i0; reg [1:0]i1; reg e0; reg e1; reg e2; reg s; wire [1:0]out; generate begin:gen_ttmux_1 ttmux2_1 mm0(out,e0,i0,s); ttmux1_2 mm1(out,e1,i1,s); ttmux1_2 mm2(out,e2,i1,s); endgenerate initial begin$monitor($time," enable e0 = %b, e1 = %b, e2 = %b, s= %b, input i0 = %b, input i1 = %b output out = %b ",e0,e1,e2,s,i0,i1,out); endendmodule ### Output: Notice that in this case, s determines which muxes are enabled. Now, let's explore what happens when the output of one mux is driven by the input of another mux. ## 4. Inverted Verilog Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire out; ttrimux2_1 mm(out,e,i,s); initial begin e =0; i = 2'b00; s = 1'b0; end endmodule ### Variation Instruction: Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name. ### Modified Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire out; generate begin:gen_ttmux ttrimux2_1 mm(out,e,i,s); end endmodule ### Output: Notice that, now the output is inverted. If you were expecting to see a 0, you would see a 1. Now, let's explore what happens if you have a tristate 2-to-2 mux with an enabled input. ## 5. Enabled Verilog Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire out; ttrimux2_1 mm(out,e,i,s); initial begin e =0; i = 2'b00; s = 1'b0; end endmodule ### Variation Instruction: Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name. ### Modified Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire out; generate begin:gen_ttmux ttrimux2_1 mm(out,e,i,s); end endmodule ### Output: Notice that, now the output is enabled. In case of a tristate 2-to-1 mux, that's a no-op. Now, let's explore what happens if you have a tristate 2-to-1 mux with an enabled input when everything is disabled. ## 6. Tristate-Disabled Verilog Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire out; ttrimux2_1 mm(out,e,i,s); initial begin e =0; i = 2'b00; s = 1'b0; end endmodule ### Variation Instruction: Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name. ### Modified Code: module ttst_ttmux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i; reg s; wire
- code: |-
    module ttst_ttoflipflop(); // Assuming this tests a tristate 2-to-1 flipflop called ttoflop
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    wire out;
    // ttoflop mm(out,e,i,i); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, input i = %b,output out = %b ",e,i,out);
    initial #48
- code: "module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called\
    \ ttrimux2_1\nreg e;\nreg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1;\
    \ or just input wires if MUX takes separate inputs\nreg s;\nwire out; // Added\
    \ wire declaration\n// ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct\
    \ MUX definition\ninitial\nbegin\ne =0; i = 2'b00; s = 1'b0; // Added initial's'\
    \ value\nend\nalways\nbegin\nend\ninitial $monitor(\"enable e = %b, s = %b, input\
    \ i = %b, output out = %b\",e,s,i,out); endmodule ## Using a Testbench Generator\
    \ Module with Generate Variables and Constants ### Base Verilog Code: module ttst_ttrimux2_1();\
    \ // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i;\
    \ // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes\
    \ separate inputs reg s; wire out; // Added wire declaration // ttrimux2_1 mm(out,e,i,s);\
    \ // Instantiation requires correct MUX definition endmodule ### Variation Instruction:\
    \ Rewrite the testbench module to use a function-based generator to drive the\
    \ testbench. ### Modified Code: ### Generate Constant Variables module ttst_ttrimux2_1();\
    \ // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1 reg e; reg [1:0]i;\
    \ // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes\
    \ separate inputs reg s; wire out; // Added wire declaration // ttrimux2_1 mm(out,e,i,s);\
    \ // Instantiation requires correct MUX definition endmodule initial$monitor(\"\
    enable e = %b, s= %b, input i = %b,output out = %b \",e,s,i,out);\nendmodule\n\
    \n\n\n## Synthesis Issues\n\nThe most common issues arise when synthesizing Verilog\
    \ code for FPGA implementations are the following:\n\n\u2022 Sufficiently wide\
    \ data nets. This can be avoided using the [unmapped] attribute on wires, or using\
    \ constant nets to reduce the total net width.\n\u2022 Unconnected wires. This\
    \ can be avoided using the [unmapped] attribute on wires.\n\u2022 Unconnected\
    \ inputs to registers. This can be avoided using initial values on registers.\n\
    \u2022 Unconnected inputs to combinational logic. This can be avoided either by\
    \ using a combinational library cell, by using a flip-flop or by using a $null\
    \ assignment in an initial block. Unmapped wires can be used to connect the combinational\
    \ logic to a register. Wire data types can be used to make it easier to map between\
    \ the two. \u2022 Unconnected inputs to block-level logic. This can be avoided\
    \ either by using a combinational library cell, by using a flip-flop or by adding\
    \ a $null assignment. Unmapped wires can be used to connect the block-level logic\
    \ to the flip-flop.\n\u2022 Combinational logic taking the value stored in a flip-flop\
    \ as input. This can be avoided by using a library cell, by using a flip-flop,\
    \ or by adding a $null assignment. \u2022 Combinational logic with data stored\
    \ in a flip-flop that is not updated in the current time frame. The combination\
    \ of a flip-flop and a $null assignment can be used to ensure that the current\
    \ value of the flip-flop is read during the current time frame.\n\u2022 Combinational\
    \ logic with data stored in a register that is not updated in the current time\
    \ frame. The combination of a register and a $null assignment can be used to ensure\
    \ that the current value of the register is read during the current time frame.\
    \ \u2022 Combinational logic updating the value stored in a flip-flop. A flip-flop\
    \ can be used to update the data value stored in the flip-flop. The data type\
    \ of the flip-flop can be used to ensure that the new value is written to the\
    \ flip-flop. \u2022 Register updating the value stored in a register. A register\
    \ can be used to update the data value stored in the register. The data type of\
    \ the register can be used to ensure that the new value is written to the register.\
    \ \u2022 Combinational logic updating the value stored in a combinational logic.\
    \ A combinational logic can be used to update the data value stored in the combinational\
    \ logic. The data type of the combinational logic can be used to ensure that the\
    \ new value is written to the combinational logic. ## Verilog Code Examples ###\
    \ Single-Cycle Flip-Flop module flipflop(input clk, input din, output reg q);\
    \ // single cycle flip-flop with input data din and clock clk reg q; // output\
    \ register q always @(posedge clk) // update flip-flop q <= din; endmodule ###\
    \ Single-Cycle Multi-Input Flip-Flop module flipflop(input [1:0] din, input clk,\
    \ output reg q); // single cycle multi-input flip-flop with input data din and\
    \ clock clk reg q; // output register q always @(posedge clk) // update flip-flop\
    \ q"
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    generate
    always
    begin
    e =0; s=1'b0; // Added initial's' value
    end
    case (s)
    0:
    i=2'b00;
    1:
    i=2'b01;
    2:
    i=2'b10;
    3:
    i=2'b11;
    endcase
    endgenerate
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    The following image shows the result of all the 4 cases with and without the generate block.

    The result of the test with the generate block is as expected, the `out` signal is tristated. The reason is that tri-stated is a logical state and logic `always` block is executed before the `initial` block in a testbench. The tri-stated output is seen as the default output of the testbench.

    However, the result of the test without the generate block is not as expected and `out` is not tri-stated. The reason is that the tri-stated output of the tristate 2-to-1 multiplexer can be achieved by using a tri-state buffer at the output.

    This explains why the `out` signal was not tri-stated in the modified code using the generate block. The output `out` could have been tri-stated by the tri-state buffer at the output of the 2-to-1 multiplexer.

    ## Differential Signals

    Digital circuits can be used to implement analog circuits since they do not require any particular implementation methodology. However, a digital circuit can also be used to implement an analog model. A digital circuit can also be used to implement an analog circuit.

    In addition to the digital signaling methodology, there is a methodology to implement an analog model called the differential signaling methodology. The differential signaling methodology is used to implement a high speed digital circuit.

    The differential signaling methodology is based on the difference of two signals. The difference of two signals is a signal that tells you the difference between the two signals. In other words, the difference of two signals tells you the amplitude of the differential signal. The difference of two signals is also called the error signal.

    The difference of two signals is represented by a delta symbol ($\triangle$). The delta symbol is used to represent the differential signaling methodology.

    The following image shows the difference of two signals.

    The following image shows the differential signaling methodology.

    The differential signaling methodology is used to implement high speed digital circuits. The following image shows the circuit based on the differential signaling methodology.

    ### Example:

    The following circuit model simulates the digital signaling methodology.

    ### Base Verilog Code:
    module tdigtest_diff();
    reg r0,r1;
    reg [7:0]diff;
    initial
    begin
    r0=1'b0; diff=0;
    r1=1'b0; diff=0;
    end
    always
    begin
    r0=r1; diff=r0-r1; // Difference of two signals
    end
    initial $monitor($time," r0 = %b r1 = %b, diff = %b",r0,r1,diff);
    initial #48 $stop; endmodule ### Modified Verilog Code: module tdigtest_diff(); reg r0,r1; reg [7:0]diff; wire [7:0]diff1; initial begin r0=1'b0; diff=0; r1=1'b0; diff=0; end always begin r0=r1; diff=r0-r1; // Difference of two signals diff1=diff; end initial$monitor($time," r0 = %b r1 = %b, diff = %b, diff1 = %b",r0,r1,diff,diff1); initial #48$stop;
    endmodule

    The following image shows the result of the test.

    ## Analog Modeling of a Signal Source

    Analog and digital circuits cannot be compared directly. There are many factors that affect the accuracy and performance of an analog circuit, such as the size, the complexity, the accuracy of the model, the quality of the model, and the number of transistor gates.

    A model is an abstraction of an analog circuit that can be used to perform a mathematical operation or to measure the characteristics of the analog circuit. In the analog modeling methodology, a model can be used to describe the characteristics of the analog circuit.

    ### Example:

    The following image shows the model for signal source.

    The following image shows the model for a resistor.

    ### Base Verilog Code:
    module tdigtest_siggen();
    reg s;
    wire [31:0]dataout,sdataout;
    reg [31:0]datain;
    reg freq,cnt,cnt1;
    reg [7:0]diff;
    initial
    begin
    cnt=0; dataout=0;
    cnt1=0; datain=0;
    freq=8'h01;
    end
    always
    begin
    if(cnt==29) begin
    if(cnt1==0) begin // Set output
    dataout=1;
    sdataout=dataout[0];
    end
    else begin // Tri-state output
    dataout=0;
    sdataout=0;
    end
    end
    else begin
    dataout=datain[cnt];
    sdataout=dataout[0];
    end
    end
    if(cnt==29) begin
    if(freq==8'hFF) begin
    freq=8'h01;
    end
    else begin
    freq=freq+1;
    end
    end
    end
    always
    begin
    datain=freq*224+cnt1;
    end
    initial $monitor($time," dataout = %b, sdataout = %b",dataout,sdataout);
    initial #48 $stop; endmodule ### Modified Verilog Code: module tdigtest_siggen(); reg s; reg [31:0]dataout,sdataout; reg [31:0]datain; reg [7:0]diff; initial begin cnt=0; dataout=0; cnt1=0; datain=0; end always begin if(cnt==29) begin if(cnt1==0) begin // Set output dataout=1; sdataout=dataout[0]; end else begin // Tri-state output dataout=0; sdataout=0; end end else begin dataout=datain[cnt]; sdataout=dataout[0]; end end if(cnt==29) begin if(freq==8'hFF) begin freq=8'h01; end else begin freq=freq+1; end end end end always begin datain=freq*224+cnt1; end initial$monitor($time," dataout = %b, sdataout = %b",dataout,sdataout); initial #48$stop;
    endmodule

    The following image shows the result of the test.

    ## Analog Modeling of a Transmitter

    The following image shows the circuit to model a transmitter.

    The following model simulates the circuit.

    ### Base Verilog Code:
    module tdigtest_tx();
    reg s;
    wire [31:0]dataout,sdataout;
    reg [31:0]datain;
    reg freq;
    reg [7:0]diff;
    initial
    begin
    dataout=0; sdataout=0;
    datain=0; freq=1;
    end
    always
    begin
    dataout=datain[freq];
    sdataout=dataout[0];
    end
    initial $monitor($time," dataout = %b, sdataout = %b",dataout,sdataout);
    initial #48 $stop; endmodule ### Modified Verilog Code: module tdigtest_tx(); reg s; reg [31:0]dataout,sdataout; reg [31:0]datain; reg freq; reg [7:0]diff; initial begin dataout=0; sdataout=0; datain=0; freq=1; end always begin dataout=datain[freq]; sdataout=dataout[0]; end initial$monitor($time," dataout = %b, sdataout = %b",dataout,sdataout); initial #48$stop;
    endmodule

    The following image shows the result of the test.

    The following image shows the circuit to model a receiver.

    The following model simulates the circuit.

    ### Base Verilog Code
- code: "1 module top_c(input a,b,c,input [1:0]s);\nreg [1:0]i;\nassign i = s;\ninitial\
    \ i = 2'b00;\nalways\nbegin\nend\ninitial $monitor($time,\" enable i = %b, input\
    \ i = %b \",i,s);\ninitial #48 $stop; endmodule Generate begin topmod_1: top_c\
    \ end endgenerate initial s = 1'b0; always begin end initial$monitor($time,\"\
    \ enable s = %b \",s); initial #48$stop;\nendmodule\n\n### Test Behavior:\n\u2022\
    \ The testbench should now correctly display the correct enable and input signal\
    \ values.\n\u2022 The output signal should reflect that of the selected input\
    \ data source.\n\u2022 The output should be indeterminate (undefined) when enable\
    \ is 1 and inputs are unselected.\n\n## 3.5 Using the generate Block with Initial\
    \ Output Signal Assignments\n\nIn the previous section, we introduced the generate\
    \ keyword and the inside operator along with a few examples for how they could\
    \ be used. The generate block introduces a new scoping and visibility mechanism\
    \ which allows it to be used at the top level of a module or in a sequence of\
    \ statements. A generate block may be instantiated multiple times, generating\
    \ the same code multiple times, so it is good practice to name the block as a\
    \ prefix or suffix in order to disambiguate the code. In addition, blocks may\
    \ be nested to create more hierarchical code. Generate blocks are used to create\
    \ multiple instances of a process, block, package, or module. The generate block\
    \ executes at the top level of a module or in a sequence of statements. The generate\
    \ block is used with the generate keyword and the inside operator. The inside\
    \ operator is a bit strange, but it is used so that"
- code: |-
    ```
    generate
    begin
    ttst_ttrimux2_1
    generate
    end generate
    ```

    > Output:
    ![ttst_ttrimux2_1_1.png](ttst_ttrimux2_1_1.png)
    ![ttst_ttrimux2_1_2.png](ttst_ttrimux2_1_2.png)

    # 16.7.11 Timing Controlled Test with Random Inputs

    ### Base Verilog Code:
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ### Variation Instruction:
    Remove the first 2 initial blocks from the testbench and add the following code inside the generate block:
    ```
    initial
    begin
    e =rand_range(0,1); i = rand_range(0,3); s = rand_range(0,1);
    end
    ```
    > Output:
    ![ttst_ttrimux2_1_1.png](ttst_ttrimux2_1_1.png)
    ![ttst_ttrimux2_1_2.png](ttst_ttrimux2_1_2.png)

    # 16.7.12 Timing Controlled Test with Random Inputs

    ### Base Verilog Code:
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ### Variation Instruction:
    Remove the first 2 initial blocks from the testbench and add the following code inside the generate block:
    ```
    initial
    begin
    e =rand_range(0,1); i = rand_range(0,3); s = rand_range(0,1);
    end
    ```
    > Output:
    ![ttst_ttrimux2_1_1.png](ttst_ttrimux2_1_1.png)
    ![ttst_ttrimux2_1_2.png](ttst_ttrimux2_1_2.png)

    # 16.7.13 Timing Controlled Test with Random Inputs

    ### Base Verilog Code:
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ### Variation Instruction:
    Remove the first 2 initial blocks from the testbench and add the following code inside the generate block:
    ```
    initial
    begin
    e =rand_range(0,1); i = rand_range(0,3); s = rand_range(0,1);
    end
    ```
    > Output:
    ![ttst_ttrimux2_1_1.png](ttst_ttrimux2_1_1.png)
    ![ttst_ttrimux2_1_2.png](ttst_ttrimux2_1_2.png)
    # 3.2.1 Introduction to Simulink

    # 3.2.2 Simulink Architecture

    ## Simulink Architecture

    - Simulink software provides two major architecture components:
      - A modeler: A graphical user interface (GUI) that creates a Simulink model of the system to be simulated.
      - A simulator: A library of C-code generators that takes a specified Simulink model and converts it into a suite of C-code functions that are called by the simulator library.

    ## Simulink Components

    - Simulink components are basic building blocks of a Simulink model.
      - Sources: Input and output ports that can either be direct, or indirect.
        - Direct sources are those that communicate directly with the target system.
        - Indirect sources are those that communicate indirectly with the target system.
          - For example, a bus that does not have an active connection to the target system is indirectly communicating through an internal bus that is directly connected to the target system.
      - Sinks: Output ports that send signals to an output device.
      - Integrators: Sources and Sinks that generate new input signals from their past state.
      - Sample and hold: Source and sinks that hold a value for a specified period.
      - Combinational logic: Logic blocks that perform combinational logic functions.
        - XOR, OR, AND, NAND, NOR, NOR, XNOR, etc.
      - Memory blocks: Source and sinks that store values for a specified period.
        - Look up table (LUT)
      - Summing junctions: Source and sinks that sum values that are received at the input.
        - Counter, Counter with Reset.
      - Multipliers: Source and sinks that multiply the input with a specified value.
        - Multiplier, Multiplier with Reset, etc.
      - Summation blocks: Sources and sinks that sum the input values in parallel.
        - Sum, Sum with Reset, etc.
      - Other components:
        - Sources and sinks that represent signal generators.
        - Sources and sinks that represent measurement device.

    ## Simulink Components

    - Sink
      - Sink component with a constant value
      - Sink component with a table lookup
    - Source
      - Source component with a constant value
      - Source component with a table lookup
    - Input port
      - Connector used to connect a Simulink model to a physical object, such as a sensor
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
      - Connector used to connect a Simulink model to a physical object, such as a sensor
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
      - Connector used to connect a Simulink model to a physical object, such as a sensor
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
    - Input ports
      - Connector used to connect a Simulink model to a physical object, such as a sensor
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
    - Output port
      - Connector used to connect a physical device to a Simulink model
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
    - Output ports
      - Connector used to connect a physical device to a Simulink model
      - Connector used to connect a Simulink model to another Simulink model
      - Connector used to connect a Simulink model to a physical device, such as a controller
- code: "module ttst_ttrimux2_1();\nreg e;\nreg [1:0]i; // Should be reg i0, i1; or\
    \ reg [0:0] i0, i1; or just input wires if MUX takes separate inputs\nreg s;\n\
    wire out; // Added wire declaration\n// ttrimux2_1 mm(out,e,i,s); // Instantiation\
    \ requires correct MUX definition\ninitial\nbegin\ne =0; i = 2'b00; s = 1'b0;\
    \ // Added initial's' value\nend\nalways\nbegin\nend\ninitial $monitor($time,\"\
    \ enable e = %b, s= %b, input i = %b,output out = %b \",e,escape$s,i,out); //\
    \ Added escape$s in monitor code\ninitial #48 $stop; endmodule ## 6.2.44 Timing\
    \ Constraints Timing constraints are optional, but they can help to define the\
    \ speed of signals, and the accuracy of timing results for a simulation. Syntax\
    \ of a timing constraint: `time::(event_expression) (event_expression)` Timing\
    \ events to be checked, and their timing relationships. ### Example: initial @(posedge\
    \ clk) #100$display(\"Hey\");\n\n## 6.2.45 Timing Analysis\n\nTo run a timing\
    \ analysis (synthesis) of your design, you need to:\n\n\u2022 Define a timing\
    \ network (clock domain) using the timing module (clockdomain) of the clocking\
    \ library.\n\u2022 Define path constraints for each signal in your design.\n\u2022\
    \ Run the timing analysis.\n\nFor example, you can do the following:\n\n`syn_timing\
    \ -dclk clk_domain -cclk clk -cdly clk_domain -i <design.tcl>`\n\n\u2022 -dclk:\
    \ Design clock domain.\n\u2022 -cclk: Clock signal in the clock domain.\n\u2022\
    \ -cdly: Clock domain delay constraint.\n\u2022 -i: input TCL file.\n\nCheck the\
    \ synthesis report file for the timing results.\n\n## 6.2.46 Timing Profiling\n\
    \nTo run a timing profile of a design, you need to:\n\n\u2022 Define a timing\
    \ network (clock domain) using the timing module (clockdomain) of the clocking\
    \ library.\n\u2022 Define path constraints for each signal in your design.\n\u2022\
    \ Run the timing profile.\n\nNote\n\nYou can\u2019t run a timing profile without\
    \ running a synthesis first.\n\nFor example, you can do the following:\n\n`syn_timing\
    \ -dclk clk_domain -cclk clk -cdly clk_domain -i <design.tcl>`\n\n\u2022 -dclk:\
    \ Design clock domain.\n\u2022 -cclk: Clock signal in the clock domain.\n\u2022\
    \ -cdly: Clock domain delay constraint.\n\u2022 -i: input TCL file.\n\nCheck the\
    \ synthesis report file for the timing results.\n\n## 6.2.47 Timing Summary\n\n\
    To run a timing summary of a design, you need to:\n\n\u2022 Define a timing network\
    \ (clock domain) using the timing module (clockdomain) of the clocking library.\n\
    \u2022 Define path constraints for each signal in your design.\n\u2022 Run the\
    \ timing summary.\n\nFor example, you can do the following:\n\n`syn_timing -dclk\
    \ clk_domain -cclk clk -cdly clk_domain -i <design.tcl>`\n\n\u2022 -dclk: Design\
    \ clock domain.\n\u2022 -cclk: Clock signal in the clock domain.\n\u2022 -cdly:\
    \ Clock domain delay constraint.\n\u2022 -i: input TCL file.\n\nCheck the synthesis\
    \ report file for the timing results.\n\n## 6.2.48 Timing Analyzer\n\nThe timing\
    \ analyzer is a graphical tool for checking the timing of your design.\n\nThe\
    \ timing analyzer contains three views:\n\n\u2022 The Design view displays the\
    \ timing constraints and signals in your design.\n\u2022 The Simulation view displays\
    \ the timing for your design, with the results of a simulation.\n\u2022 The Library\
    \ view displays the available timing constraints.\n\n## 6.2.49 Timing Constraints\n\
    \n#### Constraint Types\n\n`#10 @ (clk_domain.i) 10#100 @ (clk_domain.o) 10#100`\n\
    \n * (clk_domain.i) * 10#100 @ (clk_domain.o) * 10#100\n\n`#10 @ (*) 10#100 @\
    \ (*)`\n\n * @ (*) * 10#100\n\n### Using Constraints\n\nFor timing constraints,\
    \ you can use:\n\n`constraint`\n\n`constraint_delay`\n\n`constraint_event`\n\n\
    `constraint_jitter`\n\n`constraint_non_clock`\n\n`constraint_setup`\n\n`constraint_stable`\n\
    \n`constraint_stretch`\n\n`constraint_transition`\n\nSyntax:\n\n`constraint <constraint_type>\
    \ <constraint_name> { <constraint_property> = <value> ; <constraint_property>\
    \ = <value> ;...}`\n\nConstraint types:\n\n`time::(event_expression) (event_expression)`\n\
    \nClock Domain constraints:\n\n`time::(event_expression) (event_expression)`\n\
    \n### Example:\n\n#### Clock Domain\n\nAssume you have a design with the following\
    \ code:\n\nmodule test(clk, reset);\ninput clk;\ninput reset;\nreg b;\n\nassign\
    \ h = ~b;\n\ninitial\nbegin\n$display(\"initial block\"); b = 1; #10 b = 0; end\
    \ always@(posedge clk) begin if(reset) then b = 1; end else b = h; end initial\
    \ #100$display(\"end block\");\nendmodule\n\nAnd the following constraints:\n\n\
    ```time::(posedge reset) 100 @ (posedge clk)```\n\nYou can run the timing analysis\
    \ as follows:\n\n`syn_timing -dclk clk_domain -cclk clk -cdly clk_domain -i <design.tcl>`\n\
    \nNote that the timing check stops if the timing is not met.\n\n### Using Constraints\
    \ with Paths\n\nYou can use timing constraints with paths.\n\nNote\n\nIt is possible\
    \ to define a path between two signals, but it can\u2019t be used in a timing\
    \ constraint.\n\n`path <path_name> (<property>) <property_value> ;`\n\n`path <path_name>\
    \ (<property>) <property_value> ;`\n\nFor example, if you have the following code:\n\
    \nmodule test(reset);\noutput reg a;\noutput reg b;\nassign a = ~reset;\nassign\
    \ b = ~reset;\n\ninitial\nbegin\n$display(\"initial block\"); b = 1; a = 0; end\
    \ always@(posedge reset) begin a = b; end initial #100$display(\"end block\");\n\
    endmodule\n\nand the following constraints:\n\n```time::(posedge reset) 100@ (posedge\
    \ a)\npath a_to_b a = ~b;\npath a_to_b b = ~a;```\n\nYou can run the timing analysis\
    \ as follows:\n\n`syn_timing -dclk clk_domain -cclk clk -cdly clk_domain -i <design.tcl>`\n\
    \nNote that the timing check stops if the timing is not met.\n\n## 6.2.50 Timing\
    \ Constraints with Constraints File\n\nTiming constraints can be written in a\
    \ constraints file.\n\nYou can define timing constraints in a constraints file\
    \ to use them as part of the design.\n\nTo add timing constraints to a constraints\
    \ file, you can use the following syntax:\n\n`constraint <constraint_type> <constraint_name>\
    \ { <constraint_property> = <value> ; <constraint_property> = <value> ;...}`\n\
    \nWhere:\n\n\u2022 `<constraint_type>` is one of the following:\n`time::(event_expression)\
    \ (event_expression)`\n`constraint_event`\n`constraint_jitter`\n`constraint_setup`\n\
    `constraint_non_clock`\n`constraint_delay`\n\u2022 `<constraint_name>` is a name\
    \ of a timing constraint.\n\u2022 The property `<constraint_property>` is one\
    \ of the following:\n`time_high: <value>`\n`time_low: <value>`\n`time_high_to_low:\
    \ <value>`\n`time_low_to_high: <value>`\n`time_high_to_low_ratio: <value>`\n`time_low_to_high_ratio:\
    \ <value>`\n`time_high_to_low_min: <value>`\n`time_low_to_high_min: <value>`\n\
    `time_high_to_low_max: <value>`\n`time_low_to_high_max: <value>`\n`time_high_to_low_strict:\
    \ <value>`\n`time_low_to_high_strict: <value>`\n\u2022 `<value>` is a time value.\n\
    \nFor example, you can define the following timing constraint:"
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ### Simulation Output:
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 01, s= 00, input i = 01,output out = 01
    enable e = 01, s= 01, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 01, s= 00, input i = 10,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 00
    enable e = 00, s= 00, input i = 00,output out = 0
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    generate
    begin
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out); end endmodule ### Result ### Before: enable e = 0, s= 0, input i = 00,output out = 0 In the original testbench, the enable was being set to 0 in the initial block before the test began. This caused the same result in the sliced output as it did in the DUT. ### After: enable e = 0, s= 0, input i = 00,output out = 0 In the modified testbench, the enable was being set to 0 in the initial block before the test began. This caused the same result in the sliced output as it did in the DUT. However, after the enable was replaced with the generate block, the enable was set to 1 in the initial block because the generate block sets s to 1'b1. This caused a different result in the sliced output. ### Conclusion: The reason the enable was not being reset to 0 in the generate block was because it was not being set using a generate statement. In the original testbench, it was being set using a statement in the initial block. In the modified testbench, it was being set using a statement in the top-level generate block. # 04 - Verilog - Replacing a Constant with a Register (Verilog Basics) ## 04.1 - Summary ### Background: The first time the clock was toggled in this application, an output was toggled as expected, but it was followed by a 100ms delay. The second time the clock was toggled an output toggled as expected. The third time the clock was toggled, no output toggled. ### Initial Problem: The second time the clock toggled, the output toggled, but it was followed by a 100ms delay. ### Solution: The problem was caused by the testbench using a constant value for the delay. The value of the delay should have been a register because the register value is updated each time the clock is toggled. ## 04.2 - Code ### Verilog Code: module delay_test(input clk, output reg out); always @ (posedge clk) begin out<=~out; end endmodule ### Testbench Code: module delay_test(clk,out); reg clk, out; initial begin clk = 0; out = 0; end always begin #100 clk = ~clk; end endmodule ### Solution: The delay was due to the constant value being used for the delay. ### Solution: Instead of using a constant 100 for the delay, use a register and have the register value be updated each time the clock is toggled. ## 04.3 - Result ### Original: ### Modified: # 05 - Verilog - Creating a Sink - Writing a Testbench (Verilog Basics) ## 05.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Testbench Code: module sink_test(clk,out,in); reg clk, out, in; initial begin clk = 1; out = 4'b1111; in = 4'b0000; end always begin #100 clk = ~clk; in = in + 4'b0001; end endmodule ### Result: # 06 - Verilog - Creating a Sink - Writing a Functional Testbench (Verilog Basics) ## 06.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Functional Testbench Code: module sink_test(clk,out,in); reg clk, out, in; initial begin clk = 1; out = 4'b1111; in = 4'b0000; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ## 06.2 - Result: # 07 - Verilog - Creating a Sink - Reading a Functional Testbench (Verilog Basics) ## 07.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Functional Testbench Code: module sink_test(clk,out,in); reg clk, out, in; initial begin clk = 1; out = 4'b1111; in = 4'b0000; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ## 07.2 - Result: ## 07.3 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Functional Testbench Code: module sink_test(clk,out,in); reg clk, out, in; initial begin clk = 1; out = 4'b1111; in = 4'b0000; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ## 07.4 - Result: # 08 - Verilog - Creating a Sink - Reading a Testbench (Verilog Basics) ## 08.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Testbench Code: module sink_test(clk,out,in); reg clk, out, in; initial begin clk = 1; out = 4'b1111; in = 4'b0000; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ## 08.2 - Result: # 09 - Verilog - Creating Sinks in a Design Using a Module (Verilog Basics) ## 09.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Source Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end initial begin clk = 1; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ### Result: # 10 - Verilog - Creating Sinks in a Design Using a Module (Verilog Basics) ## 10.1 - Summary ### Verilog Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end always @ (posedge clk) begin out<=in; end endmodule ### Source Code: module sink_test(clk,out,in); reg [0:3] out; initial begin out = 4'b1111; end initial begin clk = 1; end always begin #100 clk = ~clk; in = in + 4'b0001; end initial begin $monitor(out = out, in = in); end initial $stop; endmodule ### Result: # 1
- code: |-
    ```systemverilog
    // DFF Alteration
    package dffalter;
      logic di, clk, clr, pr;
      always @ (negedge clk) begin
        qb <= q;
        q <= di? ~pr : qb;
      end
    end
    ```
    ## Module 15
    ### Original Verilog Code:
    ```systemverilog
    module dffalter_reg(); // DFF Alteration
    input wire clk;
    input wire di;
    input wire clr;
    input wire pr;
- code: |-
    ```verilog
    module adder_tst();
    reg [3:0]di,do,clk,clr,pr;
    wire q, qb;
    // adder adder(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT

    package mypkg;
    reg [3:0]di[];
    initial
    begin
    di[0]=4;di[1]=5;di[2]=6;di[3]=7;di[4]=8;di[5]=9;di[6]=10;di[7]=11;
    end
    endpackage

    initial
    begin
    clk=1'b1; // Start with preset asserted
    end
    always
    begin
    //clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=
- code: |-
    // Package containing array slices
    package arr_slice;

    typedef logic [31:0] type_array;

    // Custom library function
    function type_array get_slice(type_array in, int i);
    begin
    type_array slice = {in[i]};
    return slice;
    endfunction
    endpackage
    // Testbench
    module dffalter_tst2(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q); // Output using library function initial #46$stop; // Stop simulation

    endmodule
    // DUT
    module dffalter(q,qb,di,clk,clr,pr); // DFF from Altera
    reg q,qb; // Added qb
    input [23:0] di, clr, clk, pr;

    initial begin
    qb=1'b0;
    pr=1'b0;
    end
    always @(posedge clk)
    begin
    qb <= q;
    if (!clr) begin
    qb <= 1'b0;
    end
    if (pr) begin
    qb <= 1'b1;
    end
    if (di) begin
    qb <= 1'b1;
    q <= 1'b1;
    end
    else begin
    q <= 1'b0;
    end
    endmodule
    ### Variation Results:
    No changes in behavior of DFF under given conditions, which is a confirmed behavior of DUT

    ## Conclusion

    The tool generates correct altera verilog code to instantiate the `dffalter` module and the `monitor` and `stop_simulation` statements for testbench as well. However, the tool fails to generate the packed array slice syntax that would be required to test async preset correctly. This leaves it to the user to implement such a test.

    Regardless, the tool is very useful for finding the issues of a module and generating the required Verilog code to instantiate the module with correct values for all inputs. The tool is very useful for verifying the performance of a DUT, and the tool uses the existing DUT modules of the hardware vendor for the verification. The tool is not limited to DFFs and can be used extensively to study the behavior of a DUT.
- code: |-
    ```
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    ### Modified Package:
    // ##################################################################### //
    // # Package: DUT_pkg                          #
    // ##################################################################### //
    package DUT_pkg;
    localparam dff_width=4;
    input [3:0] dff_data; // Packed array of dff_width DFFs
    endpackage
    ### Updated Testbench:
    ```
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    ### Analysis:

    ![1](https://github.com/jason3323/verilog_design_analysis/blob/main/1.PNG)

    ![2](https://github.com/jason3323/verilog_design_analysis/blob/main/2.PNG)

    ![3](https://github.com/jason3323/verilog_design_analysis/blob/main/3.PNG)

    ![4](https://github.com/jason3323/verilog_design_analysis/blob/main/4.PNG)

    ![5](https://github.com/jason3323/verilog_design_analysis/blob/main/5.PNG)

    ![6](https://github.com/jason3323/verilog_design_analysis/blob/main/6.PNG)

    ![7](https://github.com/jason3323/verilog_design_analysis/blob/main/7.PNG)
    <!--stackedit_data:
    eyJoaXN0b3J5IjpbLTEyMjY1MjM1NDFdfQ==
    --># Verilog Design Analysis

    ## Design Analysis

    ### Part 1:
    [Design Analysis 1](https://github.com/jason3323/verilog_design_analysis/blob/main/D1.md)

    ### Part 2:
    [Design Analysis 2](https://github.com/jason3323/verilog_design_analysis/blob/main/D2.md)

    ### Part 3:
    [Design Analysis 3](https://github.com/jason3323/verilog_design_analysis/blob/main/D3.md)

    ### Part 4:
    [Design Analysis 4](https://github.com/jason3323/verilog_design_analysis/blob/main/D4.md)

    ### Part 5:
    [Design Analysis 5](https://github.com/jason3323/verilog_design_analysis/blob/main/D5.md)

    ### Part 6:
    [Design Analysis 6](https://github.com/jason3323/verilog_design_analysis/blob/main/D6.md)

    ### Part 7:
    [Design Analysis 7](https://github.com/jason3323/verilog_design_analysis/blob/main/D7.md)

    ### Part 8:
    [Design Analysis 8](https://github.com/jason3323/verilog_design_analysis/blob/main/D8.md)

    ### Part 9:
    [Design Analysis 9](https://github.com/jason3323/verilog_design_analysis/blob/main/D9.md)

    ### Part 10:
    [Design Analysis 10](https://github.com/jason3323/verilog_design_analysis/blob/main/D10.md)

    ### Part 11:
    [Design Analysis 11](https://github.com/jason3323/verilog_design_analysis/blob/main/D11.md)

    ### Part 12:
    [Design Analysis 12](https://github.com/jason3323/verilog_design_analysis/blob/main/D12.md)**Design Analysis 10**

    ## Topologies

    ### Introduction:

    A topology is a connection between components that describes how they are connected to the rest of the circuit and how they are affected by each other. This analysis can be performed with the use of a circuit schematic. A circuit schematic is a visual representation of a circuit with the purpose of describing the topology of the circuit along with the relationships and interaction between the components and how they work. The purpose of the circuit schematic is for the viewer to examine the layout of a circuit and the relationships and interaction between the components to see how the circuit will work.

    ### Topologies in Verilog:

    #### 1. Serial Topology:
    ![serial](https://github.com/jason3323/verilog_design_analysis/blob/main/10_serial_topology.PNG)

    #### 2. Parallel Topology:
    ![parallel](https://github.com/jason3323/verilog_design_analysis/blob/main/10_parallel_topology.PNG)

    #### 3. Switch-Mode Power Supply Topology:
    ![switch_mode_power_supply](https://github.com/jason3323/verilog_design_analysis/blob/main/10_switch_mode_power_supply_topology.PNG)

    #### 4. A/D Converter Topology:
    ![A/D](https://github.com/jason3323/verilog_design_analysis/blob/main/10_AD_converter_topology.PNG)

    #### 5. Clock Topology:
    ![clock](https://github.com/jason3323/verilog_design_analysis/blob/main/10_clock_topology.PNG)

    ```
    module top();

    // Code for the top module goes here


    endmodule
    ```
    ```
    module top();

    // Code for the top module goes here


    endmodule
    ```**Design Analysis 9**

    ## Verilog Code Replacement

    ### Introduction:

    A verilog code replacement is where a certain block of code in the design is replaced, modified, or replaced with an equivalent block of code. This process is done to improve the ease of understanding and readability of the design. It is often done due to the fact that the original designers may not be familiar with the code of the design they are using. The purpose of the replacement is to make the code more understandable for those who are familiar with the original code.

    ### Replacement Instructions:

    Sometimes, the original developers of a design will not know the exact block of code that they are using in their design. They may not be aware that a specific block of code may be better suited for their needs. Therefore, it may be appropriate to replace the original code with a more appropriate code or the equivalent code for their specific needs. This is usually done when the original code is not appropriate or the exact block of code is not used in the project.

    For example, the original code may be used to implement a DFF design, but the code may be modified to suit a different design. The same applies for code that is used
- code: "module dffalter_tst();\nreg di,clk,clr,pr;\nwire q, qb; // Added qb\n// dffalter\
    \ dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT\npackage dffalter_package;\n\
    // Dont use packed array for slice validation with testbench, use array\nreg[3:0]\
    \ di_array = 4'd0;\ninitial\nbegin\nclr=1'b1;pr=1'b0;clk=1'b0;di_array[0]=1'b0;\
    \ // Start with clear asserted\nend\nalways\nbegin\nclr=1'b0; // Deassert clear\n\
    end\nalways # 4 di_array[0] =~di_array[0]; // Toggle data\nalways #16 pr=1'b1;\
    \ // Assert preset\nalways @(posedge pr) begin\n// Di array index increment\n\
    if (di_array[3] == 1'b1) di_array[3] = 1'b0;\nelse di_array[3] =~ di_array[3];\n\
    // Di array index decrement\nif (di_array[0] == 1'b1) di_array[0] = 1'b0;\nelse\
    \ di_array[0] =~ di_array[0];\nend\nalways #20 pr =1'b0; // Deassert preset\n\
    initial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \", $time,clk,clr,pr,di,q);\n\
    initial #46 $stop; // Stop simulation\nendmodule\n\n## 7.3.1.3.2.4. Modifying\
    \ an Unused Port in a Behavioral Model\xB6\n\n### Base Verilog Code:\nmodule dffalter_tst();\n\
    reg di,clk,clr,pr;\nwire q, qb;\ndffalter dff(q,qb,di,clk,clr,pr);\ninitial\n\
    begin\nclr=1'b1;pr=1'b0;clk=1'b0;di=1'b0;\nend\nalways\nbegin\nclr=1'b0;\nend\n\
    always # 4 di =~di;\nalways #16 pr=1'b1;\nalways #20 pr =1'b0;\ninitial $monitor(\"\
    t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \",$time,clk,clr,pr,di,q);\ninitial\
    \ #46 $stop; endmodule ### Variation Instruction: Replace the dffalter module\
    \ instantiation in the testbench with a module instantiation of a behavioral model\
    \ of the dffalter module. The behavioral model should have a wire named di that\
    \ is driven by another wire which is controlled by the clk signal. The behavioral\
    \ model should also have a wire clk_out that is driven by a clk input. Insert\
    \ the $monitor $display statement and the $stop statement before the end of the\
    \ testbench. ### Modified Code: module dffalter_tst(); reg di,clk,clk_out,clr,pr;\
    \ wire q, qb; initial begin clr=1'b1;pr=1'b0;clk_out=1'b0;clk=1'b0,di=1'b0; end\
    \ always begin clr=1'b0; end always # 4 di =~di; always #16 pr=1'b1; always #20\
    \ pr =1'b0; initial$monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \",$time,clk,clr,pr,di,q);\
    \ initial #46 $stop;\nendmodule\n\nmodule dffalter_bmodel();\ninput clk;\nwire\
    \ clk_out;\nwire [3:0] di;\nreg [0:0] clr;\nreg [0:0] pr;\nreg [0:0] di_state;\n\
    reg [0:0] pr_state;\nreg [0:0] di_out;\nalways @(posedge clk) begin\ndi_state[0]\
    \ =~ di_state[0]; // Toggle data\ndi_out = di_state[0];\nclr = 1'b1;\nend\nalways\
    \ @* begin\nclr = 1'b0; // Deassert clear\nend\nalways @(posedge pr) begin\npr_state[0]\
    \ =~ pr_state[0]; // Toggle preset\nend\nalways @* begin\npr_state = 1'b0; //\
    \ Deassert preset\nend\nassign clk_out = clk;\nassign di = di_out;\nendmodule\n\
    \n## 7.3.1.3.2.5. Modifying an Unused Port in a Behavioral Model with a Single\
    \ Clock\xB6\n\n### Base Verilog Code:\nmodule dffalter_tst();\nreg di,clk,clr,pr;\n\
    wire q, qb;\ndffalter dff(q,qb,di,clk,clr,pr);\ninitial\nbegin\nclr=1'b1;pr=1'b0;clk=1'b0;di=1'b0;\n\
    end\nalways\nbegin\nclr=1'b0;\nend\nalways # 4 di =~di;\nalways #16 pr=1'b1;\n\
    always #20 pr =1'b0;\ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b,\
    \ q=%b \",$time,clk,clr,pr,di,q);\ninitial #46 $stop; endmodule ### Variation\
    \ Instruction: Replace the dffalter module instantiation in the testbench with\
    \ a module instantiation of a behavioral model that uses a single clock signal.\
    \ The behavioral model should have a wire named di that is driven by another wire\
    \ which is controlled by the clk signal. The behavioral model should also have\
    \ a wire clk_out that is driven by a clk input. Insert the $monitor $display statement\
    \ and the $stop statement before the end of the testbench. ### Modified Code:\
    \ module dffalter_tst(); reg di,clk,clk_out,clr,pr; wire q, qb; initial begin\
    \ clr=1'b1;pr=1'b0;clk_out=1'b0;clk=1'b0,di=1'b0; end always begin clr=1'b0; end\
    \ always # 4 di =~di; always #16 pr=1'b1; always #20 pr =1'b0; initial$monitor(\"\
    t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \",$time,clk,clr,pr,di,q); initial #46$stop;\n\
    endmodule\n\nmodule dffalter_bmodel();\ninput clk;\nwire clk_out;\nwire [3:0]\
    \ di;\nreg [0:0] clr;\nreg [0:0] pr;\nreg [0:0] di_state;\nreg [0:0] pr_state;\n\
    reg [0:0] di_out;\nalways @(posedge clk) begin\ndi_state[0] =~ di_state[0]; //\
    \ Toggle data\ndi_out = di_state[0];\nclr = 1'b1;\nend\nassign clk_out = clk;\n\
    assign di = di_out;\nendmodule\n\n## 7.3.1.3.2.6. Modifying a Port in a Behavioral\
    \ Model\xB6\n\n### Base Verilog Code:\nmodule dffalter_tst();\nreg di,clk,clr,pr;\n\
    wire q, qb;\ndffalter dff(q,qb,di,clk,clr,pr);\ninitial\nbegin\nclr=1'b1;pr=1'b0;clk=1'b0;di=1'b0;\n\
    end\nalways\nbegin\nclr=1'b0;\nend\nalways # 4 di =~di;\nalways #16 pr=1'b1;\n\
    always #20 pr =1'b0;\ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b,\
    \ q=%b \",$time,clk,clr,pr,di,q);\ninitial #46 $stop; endmodule ### Variation\
    \ Instruction: Replace the dffalter module instantiation in the testbench with\
    \ a module instantiation of a behavioral model that uses a single clock signal.\
    \ The behavioral model should have a wire named di that is driven by another wire\
    \ which is controlled by the clk signal. The behavioral model should also have\
    \ a wire clk_out that is driven by a clk input. The behavioral model should also\
    \ have a wire pr_out that is driven by another wire which is controlled by the\
    \ pr signal. Insert the $monitor $display statement and the $stop statement before\
    \ the end of the testbench. ### Modified Code: module dffalter_tst(); reg di"
- code: |-
    ```
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
- code: |-
    // Reset implementation
    module dff_rstn(
    input d, // Data input
    input s, // Synchronous reset input
    input r, // Asynchronous reset input
    output reg q, // Data output

    output reg qbar // Output bar (also called qb)
    );

    // Reg-level reset
    reg_rstn rst(
    .q     ( q ),
    .d     ( d ),
    .s     ( s ),
    .r     ( r ));

    // Bar implementation
    comb_dff comb(
    .q     ( q ),
    .d     ( r ));

    assign qbar = comb.qb;

    endmodule
- code: |-
    ```verilog
    package test_pack;
    typedef packed [3:0] array_type;
    array_type pslice = '{1'b0, 1'b0, 1'b0, 1'b0}; // Pre-defined packed array
    endpackage
    module dffalter_tst();
    reg di,clk,clr,pr;
    wire q, qb;
    // New Code Inserted:
    import test_pack::*; // import package
    // End New Code Inserted:
    dffalter dff(q,qb,di,clk,clr,pr);
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    // New Code Inserted:
    always # 10 di=pslice; // Insert inside this statement
    // End New Code Inserted:
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop;
    endmodule
    ```
    Output:
    ```
    t=0, clk=0, clr=1, pr=0, di=0, q=0
    t=4, clk=0, clr=0, pr=0, di=0, q=0
    t=8, clk=0, clr=0, pr=0, di=1, q=0
    t=12, clk=0, clr=0, pr=0, di=1, q=0
    t=16, clk=0, clr=0, pr=1, di=1, q=0
    t=16, clk=1, clr=0, pr=1, di=1, q=0
    t=20, clk=1, clr=0, pr=1, di=0, q=0
    t=20, clk=1, clr=0, pr=1, di=0, q=0
    t=24, clk=1, clr=0, pr=1, di=0, q=0
    t=28, clk=1, clr=0, pr=1, di=1, q=0
    t=28, clk=1, clr=0, pr=1, di=1, q=0
    t=32, clk=1, clr=0, pr=1, di=1, q=0
    t=32, clk=1, clr=0, pr=1, di=1, q=0
    t=36, clk=1, clr=0, pr=1, di=1, q=1
    t=36, clk=0, clr=0, pr=1, di=1, q=1
    t=40, clk=0, clr=0, pr=1, di=1, q=0
    t=44, clk=0, clr=0, pr=1, di=1, q=0
    t=44, clk=1, clr=0, pr=1, di=1, q=0
    t=48, clk=1, clr=0, pr=1, di=0, q=0
    t=48, clk=1, clr=0, pr=1, di=0, q=0
    t=52, clk=1, clr=0, pr=1, di=0, q=0
    t=56, clk=1, clr=0, pr=1, di=1, q=0
    t=56, clk=1, clr=0, pr=1, di=1, q=0
    t=60, clk=1, clr=0, pr=1, di=1, q=0
    t=60, clk=1, clr=0, pr=1, di=1, q=0
    t=64, clk=1, clr=0, pr=1, di=1, q=1
    t=64, clk=0, clr=0, pr=1, di=1, q=1
    t=68, clk=0, clr=0, pr=1, di=1, q=0
    t=72, clk=0, clr=0, pr=1, di=1, q=0
    t=72, clk=1, clr=0, pr=1, di=1, q=0
    t=76, clk=1, clr=0, pr=1, di=0, q=0
    t=76, clk=1, clr=0, pr=1, di=0, q=0
    t=80, clk=1, clr=0, pr=1, di=0, q=0
    t=84, clk=1, clr=0, pr=1, di=1, q=0
    t=84, clk=1, clr=0, pr=1, di=1, q=0
    t=88, clk=1, clr=0, pr=1, di=1, q=0
    t=88, clk=1, clr=0, pr=1, di=1, q=0
    t=92, clk=1, clr=0, pr=1, di=1, q=1
    t=92, clk=0, clr=0, pr=1, di=1, q=1
    t=96, clk=0, clr=0, pr=1, di=1, q=0
    t=100, clk=0, clr=0, pr=1, di=1, q=0
    clk <= ~clk;
    t=104, clk=1, clr=0, pr=1, di=1, q=0
    t=108, clk=1, clr=0, pr=1, di=0, q=0
    t=108, clk=1, clr=0, pr=1, di=0, q=0
    t=112, clk=1, clr=0, pr=1, di=0, q=0
    t=116, clk=1, clr=0, pr=1, di=1, q=0
    t=116, clk=1, clr=0, pr=1, di=1, q=0
    t=120, clk=1, clr=0, pr=1, di=1, q=0
    t=120, clk=1, clr=0, pr=1, di=1, q=0
    t=124, clk=1, clr=0, pr=1, di=1, q=1
    t=124, clk=0, clr=0, pr=1, di=1, q=1
    t=128, clk=0, clr=0, pr=1, di=1, q=0
    t=132, clk=0, clr=0, pr=1, di=1, q=0
    t=132, clk=1, clr=0, pr=1, di=1, q=0
    t=136, clk=1, clr=0, pr=1, di=0, q=0
    t=136, clk=1, clr=0, pr=1, di=0, q=0
    t=140, clk=1, clr=0, pr=1, di=0, q=0
    t=144, clk=1, clr=0, pr=1, di=1, q=0
    t=144, clk=1, clr=0, pr=1, di=1, q=0
    t=148, clk=1, clr=0, pr=1, di=1, q=0
    t=148, clk=1, clr=0, pr=1, di=1, q=0
    t=152, clk=1, clr=0, pr=1, di=1, q=1
    t=152, clk=0, clr=0, pr=1, di=1, q=1
    t=156, clk=0, clr=0, pr=1, di=1, q=0
    t=160, clk=0, clr=0, pr=1, di=1, q=0
    t=160,
- code: "module dffalter_tst(); \nreg di,clk,clr,pr;\nwire q, qb;\n// This is the\
    \ new packed array\npack1_t d_pack_array[0:8] = '{di[7:0], di[15:8], di[23:16],\
    \ di[31:24]};\n// The remaining code is the same\ninitial\nbegin\nclr=1'b1;pr=1'b0;clk=1'b0;di=1'b0;\n\
    end\nalways\nbegin\nclr=1'b0;\nend\nalways # 4 di =~di;\nalways #16 pr=1'b1;\n\
    always #20 pr =1'b0;\ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b,\
    \ q=%b \", $time,clk,clr,pr,di,q);\ninitial #46 $stop;\nendmodule\n### Result:\n\
    ![Figure 19](Images/Fig19.png)\n/Verilog/Module_Instantiation/readme.md\n# Module\
    \ Instantiation\n*The following examples are demonstrating module instantiations\
    \ in Verilog*\n\n### Introduction\nThe syntax for instantiating/using modules\
    \ in Verilog is very similar to that of using IP. A module is instantiated just\
    \ like any other IP, for example:\n<p align=\"center\">\n  <img src=\"Images/Inst.PNG\"\
    >\n</p>\nThe component instantiation is similar in that it references the following\
    \ format:\n<p align=\"center\">\n  <img src=\"Images/Component.PNG\">\n</p>\n\n\
    ### Example 1:\nIn this example we will look at using the `shift_gate` module\
    \ to create a simple shift left implementation. This module implements the basic\
    \ 2-bit left shift, which means if the data is shifted once to the left, it will\
    \ be multiplied by 2 and shifted out the right-most bit. We will have 4 shift_gate\
    \ modules to implement the basic 4-bit shift left operation. We can implement\
    \ the shift left for 4 bits in the following way:\n<p align=\"center\">\n  <img\
    \ src=\"Images/shift_gate_4bit_leftshift.png\">\n</p>\n\n### Example 2:\nIn this\
    \ example we will use the `dec` module to create a simple Decrementer. This module\
    \ implements the basic 4-bit addition with carry. As we look at the module, we\
    \ see it has 2 input ports, in_data and in_carry, to handle the logic of the addition\
    \ and an output port out_data. In this case we only want to show the logic of\
    \ the module, not the instantiation, so the module instantiation is not shown.\
    \ The module will have 4 instances of `inc` modules. We will also need to instantiate\
    \ 4 `dec` module as shown below.\n<p align=\"center\">\n  <img src=\"Images/dec_module.png\"\
    >\n</p>\n\n### Code:\n*The following code is the module that is implementing the\
    \ behavior of the `inc` module. This code is not shown.*\n```verilog\nmodule inc(\n\
    \  input clk,\n  input in_carry,\n  input in_data,\n  output sig,\n  output carry\n\
    );\nreg[3:0] sig;\nreg carry, data;\n\nalways_ff @(posedge clk) begin\n  if (carry)\
    \ begin\n    sig <= sig[3:0] + 4'd1;\n  end else begin\n    sig <= sig + 4'd1;\n\
    \  end\n  if (sig > 4'd15) begin\n    sig <= sig[3:0] - 4'd16;\n    carry <= 1'b1;\n\
    \  end else begin\n    carry <= 1'b0;\n  end\nend\nendmodule\n```\n### Code:\n\
    *The following code is the module that is implementing the behavior of the `dec`\
    \ module. This code is not shown.*\n```verilog\nmodule dec(\n  input clk,\n  input\
    \ in_data,\n  output out_data\n);\nreg[3:0] out_data;\n\nalways_ff @(posedge clk)\
    \ begin\n  out_data <= in_data - 4'd1;\nend\nendmodule\n```\n*The following code\
    \ is the module that is implementing the behavior of the `shift_gate` module.\
    \ This code is not shown.*\n```verilog\nmodule shift_gate(\n  input [3:0] in_data,\n\
    \  input in_shift,\n  output [3:0] out_data\n);\nreg[3:0] out_data;\n\nalways_ff\
    \ @(posedge in_shift) begin\n  out_data <= in_data << 1;\nend\nendmodule\n```\n\
    *The following code is the module that is implementing the behavior of the `dff`\
    \ module. This code is not shown.*\n```verilog\nmodule dff(\n  input clk,\n  input\
    \ enable,\n  input in_data,\n  output out_data\n);\nwire s;\nwire q;\n\nalways_ff\
    \ @(posedge clk) begin\n  if (enable)\n    out_data <= in_data;\nend\n\nalways_ff\
    \ @(posedge s, posedge q) begin\n  if (s) begin\n    out_data <= q;\n  end\nend\n\
    endmodule\n```\n*The following code is the module that is implementing the behavior\
    \ of the `mux` module. This code is not shown.*\n```verilog\nmodule mux(\n  input\
    \ [3:0] sel,\n  input [3:0] in0,\n  input [3:0] in1,\n  output [3:0] out\n);\n\
    wire i0, i1;\n\nassign i0 = {sel? in1[3:0] : in0[3:0]};\nassign i1 = {sel? in0[3:0]\
    \ : in1[3:0]};\n\nassign out = {i0, i1};\nendmodule\n```\n*The following code\
    \ is the module that is implementing the behavior of the `inc_mux` module. This\
    \ code is not shown.*\n```verilog\nmodule inc_mux(\n  input clk,\n  input [3:0]\
    \ in_a,\n  input [3:0] in_b,\n  output [3:0] out_a,\n  output [3:0] out_b\n);\n\
    wire enable;\nwire out_a, out_b;\n\nalways_ff @(posedge clk) begin\n  if (in_b[0]\
    \ && in_b[1] && in_b[2] && in_b[3]) begin\n    enable = 1;\n  end else begin\n\
    \    enable = 0;\n  end\nend\n\nmux mux_a(\n .sel(enable),\n .in0(in_a),\n .in1(out_a),\n\
    \ .out(out_a)\n);\n\ndff dff_a(\n .clk(clk),\n .enable(enable),\n .in_data(in_a),\n\
    \ .out_data(out_a)\n);\nmux mux_b(\n .sel(enable),\n .in0(in_b),\n .in1(out_b),\n\
    \ .out(out_b)\n);\n\ndff dff_b(\n .clk(clk),\n .enable(enable),\n .in_data(in_b),\n\
    \ .out_data(out_b)\n);\nendmodule\n```\n*The following code is the module that\
    \ is implementing the behavior of the `dec_inc` module. This code is not shown.*\n\
    ```verilog\nmodule dec_inc(\n  input clk,\n  input in_c,\n  input in_d,\n  input\
    \ in_e,\n  output out_c,\n  output out_d,\n  output out_e\n);\nwire a, b, c, d,\
    \ e;\n\nassign a = in_c[0] && in_c[1] && in_c[2] && in_c[3];\nassign b = in_d[0]\
    \ && in_d[1] && in_d[2] && in_d[3];\nassign c = in_e[0] && in_e[1] && in_e[2]\
    \ && in_e[3];\n\nassign d = a ^ b ^ c;\nassign e = ~d;\n\ninc_mux inc_mux_a(\n\
    \ .clk(clk),\n .in_a(in_c),\n .in_b(in_d),\n .out_a(out_c),\n .out_b(out_d)\n\
    );\n\nmux mux_a(\n .sel(e),\n .in0(out_c),\n .in1(in_c),\n .out(out_c)\n);\nmux\
    \ mux_b(\n .sel(d),\n .in0(out_d),\n .in1(in_d),\n .out(out_d)\n);\nmux mux_c(\n\
    \ .sel(c),\n .in0(out_e),\n .in1(in_e),\n .out(out_"
- code: |-
    #### Base Module Code:
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di;
    // Inserted Code:
    di[1:0]=2'b10; // Data must be 2 bits for packed array
    always #16 pr=1'b1; // Async preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule

    #### Package Code:
    package dffalter_pkg;
    reg [1:0] di;
    endpackage
    #### Verilog Top Level Code:
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di;
    // Inserted Code:
    di[1:0]=2'b10; // Data must be 2 bits for packed array
    always #16 pr=1'b1; // Async preset
    always #20 pr =1'b0; // Deassert preset
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    ### Variation Result:
    <div class="row">
    <div class="column">[![](/media/2019/11/vlog_pack_async_preset.png)](/media/2019/11/vlog_pack_async_preset.png) </div>
    </div>
    ---
    title: "How to Add a Webpage to an Internet Archive Page"
    date: 2020-08-28T08:10:27-07:00
    abstract: "How to add a webpage to an Internet Archive Page using the Internet Archive's Web API."
    image: /media/2020/08/ia_webapi_thumb.png
    thumbnail: /media/2020/08/ia_webapi_thumb.png
    ---

    In my [previous post](/blog/internet-archive-web-api), I discussed how one could interface with the Internet Archive's Web API to access the Internet Archive's page storage service. This post will follow up on the previous one and discuss how to add a webpage to an existing Internet Archive page using the Web API.

    This post will be about the `posturladd` endpoint of the API, which is documented
    [here](https://archive.org/help/web_api/web_api.php#posturladd).

    ## How to Add a Single Page to an Existing Page

    To add a page to an existing Internet Archive page, the `posturladd` endpoint requires a URL to an existing page stored on the Internet Archive's page storage service. A URL to an existing page is the URL of a page that was previously added to an Internet Archive page using the `posturladd` endpoint. The `posturladd` endpoint will then append the given URL to the existing Internet Archive page.

    The URL used with the `posturladd` endpoint will be the URL to a webpage on the Internet Archive's page storage service. That webpage is already stored on an Internet Archive page, so it should be the URL to that page.

    The URL to a webpage on the Internet Archive's page storage service can be found by making a request for the `geturl` endpoint of the Web API. For example, to get the URL to my old blog post about adding a webpage to an Internet Archive Page using the Web API, I would issue a request to the `geturl` endpoint with the following parameters:

    * `token`: The access token to use to authenticate to the Internet Archive Web API
    * `from-date`: A valid date representing a date in the past. A valid date is any date that can be represented as text using [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). For example, `2019-10-02`
    * `page-id`: The Internet Archive ID of the page to add the URL to. This is the value of the `id` field of the JSON response of the [`getpages`](/blog/internet-archive-web-api) endpoint.
    * `url`: The URL of the webpage to add to the Internet Archive page. I used the following URL to access the blog post about adding a webpage to an Internet Archive page: https://www.matt.ch/blog/2019/internet-archive-page-webapi/

    Here is an example of the request I used:

    ```bash
    curl -X POST https://web.archive.org/web/1/http://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/ -H "Authorization: Bearer <TOKEN>"
    ```

    Here is an example of the response I received:

    ```json
    {
      "url": "https://archive.org/details/internet-archive-page-webapi",
      "archive_url": "https://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/",
      "page_url": "https://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/",
      "title": "How to Add a Webpage to an Internet Archive Page",
      "timestamp": "2019-10-02 16:27:45",
      "description": "How to add a webpage to an Internet Archive page using the Internet Archive's Web API.",
      "tags": [
        "Archive",
        "Internet",
        "Archive",
        "Web",
        "API",
        "Internet",
        "Archive",
        "Web",
        "API",
        "How To",
        "Internet",
        "Archive",
        "Web",
        "API",
        "Add",
        "Webpage",
        "Internet",
        "Archive",
        "Web",
        "API"
      ],
      "url_tags": [
        "https://archive.org/details/internet-archive-page-webapi",
        "https://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/",
        "https://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/",
        "https://www.matt.ch/blog/2019/internet-archive-page-webapi/",
        "https://web.archive.org/web/20191002162745/https://www.matt.ch/blog/2019/internet-archive-page-webapi/"
      ],
      "url_tags_size": 5,
      "url_tags_full": 5,
      "page_id": "44897",
      "page_group_id": "2",
      "page_group_size": 1,
      "page_group_full": 1,
      "parent_id": "1",
      "parent_full": 0,
      "parent_pagegroup_id": "1"
    }
    ```

    ## How to Add Multiple Pages to an Existing Page

    The `posturladd` endpoint of the Web API can handle multiple URLs added to an Internet Archive page. To add multiple URLs to an existing Internet Archive page, the URLs must be added in the
- code: "module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In,\
    \ LSB_In, s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\n\
    input [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nassign MSB_Out = Data_Out[3];\nassign LSB_Out = Data_Out[0];\n\
    always @ (posedge clk) begin\nif (rst) Data_Out <= 0;\nelse case (s1, s0)\n(0,\
    \ 0): Data_Out <= Data_Out; // Idle\n(.T..T): Data_Out <= {MSB_In, Data_Out[3:1]};\
    \ // Shift right\n(0,.T): Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left\n\
    (.T, 0): Data_Out <= Data_In; // Parallel Load\n(.T,.T): Data_Out <= Data_Out;\
    \ // reset-on-the-fly\nendcase\nend\nendmodule\n/*\nTest Plan\nVerify initial\
    \ reset\nVerify idle\nVerify shift right\nVerify shift left\nVerify parallel load\n\
    Verify reset-on-the-fly\n*/\nmodule t_Universal_Shift_Reg();\nwire [3: 0] Data_Out;\n\
    reg [3: 0] Data_In;\nwire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0,\
    \ rst;\ndefparam M2.half_cycle = 5;\n\nUniversal_Shift_Reg M1 (Data_Out, MSB_Out,\
    \ LSB_Out, Data_In, MSB_In, LSB_In, s1,\ns0, clk, rst);\nClock_Gen M2(clk);\n\n\
    initial #1000 $finish;\ninitial fork\nbegin #5 rst = 1; #20 rst = 0;end\nbegin\
    \ #120 rst = 1; #20 rst = 0;end\nbegin #260 rst = 1; #20 rst = 0;end\nbegin #380\
    \ rst = 1; #20 rst = 0;end\njoin\ninitial fork\njoin\nbegin // Verify left shift\n\
    join\nbegin // Verify load\njoin\nbegin // reset\njoin\nmodule Clock_Gen(clk,\
    \ half_cycle);\ninput clk;\ndefparam half_cycle = 5;\noutput reg clk;\nreg half_cycle;\n\
    always #half_cycle clk = ~clk;\nendmodule\nendmodule\n\n## Tips for writing testbenches\
    \ with VeriLog\n\n### How to write a testbench\n\nThe testbench will mostly contain\
    \ the following tasks:\n\n\u2022 A module that needs to be tested\n\u2022 An instance\
    \ of the module being tested\n\u2022 A Clock generator using the defparam system\
    \ task\n\u2022 The $finish task\n\u2022 A reset state\n\u2022 The testbenches\
    \ should start with an initial fork that creates all the necessary objects.\n\u2022\
    \ The fork task should contain all the objects that are not needed in the test.\n\
    \u2022 The initial task should contain any other necessary things, like a reset\
    \ signal and a $finish task.\n\u2022 The fork task should contain all the individual\
    \ tasks that the testbench needs. The tasks can be written out, but it is often\
    \ better to wrap them in an initial task so that they can be started at the same\
    \ time.\n\nThe individual testbenches should follow a similar structure. There\
    \ are a few common components.\n\n#### Common Components\n\nThe following components\
    \ will be used across most of the testbenches. In this section, the components\
    \ will be explained and also the testbenches will be explained. It is recommended\
    \ to have one testbench per component so that the components can be easily reused\
    \ in future testbenches.\n\n\u2022 Clock Generator:\nThe clock generator is used\
    \ to test a clocked module. This can be used to test the reset as well. The testbench\
    \ will also require a reset signal which will be used to determine the initial\
    \ state of the module.\n\nThe clock generator is used to generate a clock signal.\
    \ It can be used to test a clocked module and also to test a reset signal. The\
    \ clock signal is generated using the following code:\n\nmodule Clock_Gen(clk,\
    \ half_cycle);\ninput clk;\ndefparam half_cycle = 5;\noutput reg clk;\nreg half_cycle;\n\
    always #half_cycle clk = ~clk;\nendmodule\n\nThe clock generator has a clock signal\
    \ and half_cycle parameter. The clock signal is the clock that is generated by\
    \ the clock generator. This can be used to test a clocked module. The default\
    \ value for half_cycle is 5. As the clock signal is generated using the code,\
    \ the half_cycle parameter is used to decide the period of the clock signal. For\
    \ example, if the half_cycle is 5 then the clock signal is generated every 5ns.\
    \ The output clk is generated using the code. The output clk is a register in\
    \ the code and it is assigned a value using the following code:\n\nreg half_cycle;\n\
    always #half_cycle clk = ~clk;\n\nclk is the signal that is generated using the\
    \ system task. It is assigned the opposite value of the clk signal. This ensures\
    \ that after every clock edge, the clk signal will have the opposite value. The\
    \ half_cycle parameter is used to ensure that the clock signal is generated at\
    \ the proper speed.\n\n\u2022 Reset:\n\nThe reset task is an optional task that\
    \ is used to set the reset signal. The reset signal is used to determine the initial\
    \ state of the module being tested. This is particularly useful for clocked modules.\
    \ The task is written as follows:\n\ninitial fork\nbegin // Reset the module\n\
    initial rst = 1; // Assert the reset signal\njoin\ninitial rst = 0; // De-assert\
    \ the reset signal\njoin;\n\nThis task will assert the reset signal, de-assert\
    \ it after 5 cycles and then assert it after 25ns.\n\n\u2022 Testbench:\n\nThe\
    \ testbench is the actual executable code written in Verilog. The testbenches\
    \ should start with an initial fork that creates all the necessary objects. The\
    \ fork should contain all the objects that are not needed in the test. The initial\
    \ task should contain any other necessary things, like a reset signal and a $finish\
    \ task. The fork task should contain all the individual tasks that the testbench\
    \ needs. The tasks can be written out, but it is often better to wrap them in\
    \ an initial task so that they can be started at the same time. The individual\
    \ tasks are as follows: 1. The input variables are connected to the corresponding\
    \ output variables that are being tested: module testbench(); input [3: 0] Data_Out;\
    \ output [3: 0] Data_In; initial begin fork join initial Data_In = 0; join end\
    \ fork join endmodule  This testbench connects the two variables using wire declarations.\
    \ \u2022 Testbench: Here is a working testbench for a module that does the following:\
    \ \u2022 Reads the input data from the control signals: module testbench(); input\
    \ [3: 0] Data_Out; output [3: 0] Data_In; reg [3: 0] Data_In; reg MSB_In, LSB_In;\
    \ // Get the input data from the control signals initial Data_In = 0; join initial\
    \ begin fork join initial Data_In <= Data_Out[3]; join end fork join endmodule\
    \  This testbench uses wire declarations. It also uses reg variables. #### Testbenches\
    \ that Verify initial reset The following test benches that verify the initial\
    \ reset: module testbench(); reg rst; initial begin fork join fork join join end\
    \ module  This testbenches does the following: \u2022 Assert the reset signal\
    \ \u2022 De-assert the reset signal \u2022 Assert the reset signal \u2022 De-assert\
    \ the reset signal The testbenches for the other test cases do the same thing.\
    \ The module testbench() has a reg variable rst that is used to connect the reset\
    \ signal to a control signal in the design. The following is the testbench: module\
    \ testbench(); output [3: 0] Data_Out; reg [3: 0] Data_Out; initial fork begin\
    \ initial Data_Out = 0; join initial Data_Out = 10'd12; join initial Data_Out\
    \ = 0; join end module  This testbench does the following: \u2022 Assert the initial\
    \ state \u2022 De-assert the state \u2022 Assert the initial state \u2022 De-assert\
    \ the state The following testbench verifies the reset-on-the-fly: module testbench();\
    \ input [3: 0] Data_Out, Data_In; output [3: 0] Data_Out; initial fork begin initial\
    \ Data_Out = 0; join initial Data_Out = 10'd12; join initial Data_Out = 0; join\
    \ end module  This testbenches does the following: \u2022 Assert the initial state\
    \ \u2022 De-assert the state \u2022 After 20ns, assert the state \u2022 De-assert"
- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;

    // Modify for inside-dollar-unit case with packed array in scope
    // Replace with:
    reg [1: 0] s1_reg;
    reg [1: 0] s0_reg;
    assign s1_reg = s1[1: 0];
    assign s0_reg = s0[1: 0];
    assign s1[3: 0] = s1_reg; // This is the output
    assign s0[3: 0] = s0_reg; // This is the output
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1_reg, s0_reg})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end

    endmodule

    ### Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly

    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5; // 10-12-2004

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst);
    Clock_Gen M2(clk);

    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0;end begin #120 rst = 1; #20 rst = 0;end begin #260 rst = 1; #20 rst = 0;end begin #380 rst = 1; #20 rst = 0;end join initial fork join begin // Verify left shift join begin // Verify load join begin // reset join join endmodule ## Using inside-dollar-unit Modification with packed array in a module parameter This modification to the `test_Universal_Shift_Reg` module is identical to the code developed previously. Only the modified module is shown. ### Base Verilog Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004 input s1, s0, clk, rst; reg [1: 0] s1_reg, s0_reg; module inside_dollar_unit (inside_dollar_unit_output, s1, s0); output [3: 0] inside_dollar_unit_output; input [1: 0] s1, s0; reg [1: 0] inside_dollar_unit_output; reg [3: 0] inside_dollar_unit_local; assign inside_dollar_unit_output = inside_dollar_unit_local; always @ (posedge s1, posedge s0) begin if (s1 == 0) inside_dollar_unit_local <= inside_dollar_unit_local; else inside_dollar_unit_local <= {s1_reg[1: 0], inside_dollar_unit_local[3: 1]}; if (s0 == 0) inside_dollar_unit_local <= inside_dollar_unit_local; else inside_dollar_unit_local <= {inside_dollar_unit_local[2: 0], s0_reg[1: 0]}; end endmodule assign s1_reg = s1[1: 0]; assign s0_reg = s0[1: 0]; assign s1[3: 0] = s1_reg; // This is the output assign s0[3: 0] = s0_reg; // This is the output always @ (posedge clk) begin if (rst) Data_Out <= 0; else case ({s1_reg, s0_reg}) 0: Data_Out <= Data_Out; // Idle 1: Data_Out <= {MSB_In, Data_Out[3: 1]}; // Shift right 2: Data_Out <= {Data_Out[2: 0], LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase end end module ### Variation Instruction: Use `inside_dollar_unit_output` in the code for the `s1_reg` and `s0_reg` control signals. ### Modified Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004 input s1, s0, clk, rst; reg [1: 0] s1_reg, s0_reg; module inside_dollar_unit (inside_dollar_unit_output, s1, s0); output [3: 0] inside_dollar_unit_output; input [1: 0] s1, s0; reg [1: 0] inside_dollar_unit_output; reg [3: 0] inside_dollar_unit_local; assign inside_dollar_unit_output = inside_dollar_unit_local; always @ (posedge s1, posedge s0) begin if (s1 == 0) inside_dollar_unit_local <= inside_dollar_unit_local; else inside_dollar_unit_local <= {s1_reg[1: 0], inside_dollar_unit_local[3: 1]}; if (s0 == 0) inside_dollar_unit_local <= inside_dollar_unit_local; else inside_dollar_unit_local <= {inside_dollar_unit_local[2: 0], s0_reg[1: 0]}; end endmodule assign s1_reg = s1[1: 0]; assign s0_reg = s0[1: 0]; assign s1[3: 0] = s1_reg; // This is the output assign s0[3: 0] = s0_reg; // This is the output always @ (posedge clk) begin if (rst) Data_Out <= 0; else case ({s1_reg, s0_reg}) 0: Data_Out <= Data_Out; // Idle 1: Data_Out <= {MSB_In, Data_Out[3: 1]}; // Shift right 2: Data_Out <= {Data_Out[2: 0], LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase end end module ### Test Plan Verify initial reset Verify idle Verify shift right Verify shift left Verify parallel load Verify reset-on-the-fly module t_Universal_Shift_Reg(); wire [3: 0] Data_Out; reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam M2.half_cycle = 5; // 10-12-2004 Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); // This module is not visible inside
- code: "module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In,\
    \ LSB_In, s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\n\
    input [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nassign MSB_Out = Data_Out[3];\nassign LSB_Out = Data_Out[0];\n\
    always @ (posedge clk) begin\nif (rst) Data_Out <= 0;\nelse case ({s1, s0}) inside\
    \ {2'd1 : 1'd2, 2'd3 : 1'd0}\n0: Data_Out <= Data_Out; // Idle\n1: Data_Out <=\
    \ {MSB_In, Data_Out[3:1]}; // Shift right\n2: Data_Out <= {Data_Out[2:0], LSB_In};\
    \ // Shift Left\n3: Data_Out <= Data_In; // Parallel Load\nendcase\nend\nendmodule\n\
    /*\nTest Plan\nVerify initial reset\nVerify idle\nVerify shift right\nVerify shift\
    \ left\nVerify parallel load\nVerify reset-on-the-fly\n*/\nmodule t_Universal_Shift_Reg();\n\
    wire [3: 0] Data_Out;\nreg [3: 0] Data_In;\nwire MSB_Out, LSB_Out;\nreg MSB_In,\
    \ LSB_In;\nreg s1, s0, rst;\ndefparam M2.half_cycle = 5;\n\nUniversal_Shift_Reg\
    \ M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,\ns0, clk, rst);\n\
    Clock_Gen M2(clk);\n\ninitial #1000 $finish; initial fork begin #5 rst = 1; #20\
    \ rst = 0;end begin #120 rst = 1; #20 rst = 0;end begin #260 rst = 1; #20 rst\
    \ = 0;end begin #380 rst = 1; #20 rst = 0;end join initial fork join begin //\
    \ Verify left shift join begin // Verify load join begin // reset join join join\
    \ join endmodule ### Result of Simulation: The simulation of the verilog code\
    \ with the packed array shows that it is giving the correct output. The verilog\
    \ test bench code has the two following sections: \u2022 The first section generates\
    \ the initial reset signals. \u2022 The second section runs the simulation. \u2022\
    \ The third section prints the output from the generated verilog test bench. In\
    \ order to verify the reset-on-the-fly, the simulation is run three times to reset\
    \ the device after each input. In the test bench code, the initial reset is set\
    \ to 1 for 1000 cycles, and then reset is set to 0 for 1000 cycles, and then back\
    \ to 1 for 1000 cycles. This three-part sequence is called the reset-on-the-fly\
    \ sequence. The simulation shows that the verilog code was reset-on-the-fly. ###\
    \ 2.3.3. Test Bench File:\xB6 module t_Universal_Shift_Reg(); wire [3: 0] Data_Out;\
    \ reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst;\
    \ defparam M2.half_cycle = 5; Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out,\
    \ Data_In, MSB_In, LSB_In, s1, s0, clk, rst); Clock_Gen M2(clk); initial #1000$finish;\n\
    initial fork\nbegin #5 rst = 1; #20 rst = 0; end\nbegin #120 rst = 1; #20 rst\
    \ = 0; end\nbegin #260 rst = 1; #20 rst = 0; end\nbegin #380 rst = 1; #20 rst\
    \ = 0; end"
- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    wire [7: 0] s_in_pack;
    wire s1, s0, clk, rst;
    assign s_in_pack = {{s1, s0}, clk, rst};
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case (s_in_pack)
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    Clock_Gen M2(clk);

    initial #1000 $finish;

    initial fork begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork begin #100 rst = 1; #20 rst = 0;end
    begin #140 rst = 1; #20 rst = 0;end
    begin #220 rst = 1; #20 rst = 0;end
    begin #300 rst = 1; #20 rst = 0;end
    join
    initial fork begin #100 rst = 1; #20 rst = 0;end
    begin #140 rst = 1; #20 rst = 0;end
    begin #220 rst = 1; #20 rst = 0;end
    begin #300 rst = 1; #20 rst = 0;end
    join
    initial fork begin #100 rst = 1; #20 rst = 0;end
    begin #140 rst = 1; #20 rst = 0;end
    begin #220 rst = 1; #20 rst = 0;end
    begin #300 rst = 1; #20 rst = 0;end
    join
    initial fork begin #100 rst = 1; #20 rst = 0;end
    begin #140 rst = 1; #20 rst = 0;end
    begin #220 rst = 1; #20 rst = 0;end
    begin #300 rst = 1; #20 rst = 0;end
    join
    initial fork begin #100 rst = 1; #20 rst = 0;end
    begin #140 rst = 1; #20 rst = 0;end
    begin #220 rst = 1; #20 rst = 0;end
    begin #300 rst = 1; #20 rst = 0;end
    join

    join

    endmodule

    ## Using inside

    The inside keyword is a new feature of Verilog 2001. It can only be used inside the dollar unit scope and has the following syntax:

    inside expr

    It is not possible to use inside on an expression that has multiple components, such as a concatenation.

    The inside keyword will be useful when using multiple instances of the same primitive in your code. In the example below, we are using it on both an instance of the `Clock_Gen` and an instance of the `Universal_Shift_Reg` modules.

    module t_Universal_Shift_Reg_D();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;

    universal_shift_reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    clock_gen M2(clk, inside 1);

    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0;end begin #120 rst = 1; #20 rst = 0;end begin #260 rst = 1; #20 rst = 0;end begin #380 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst = 1; #20 rst = 0;end begin #140 rst = 1; #20 rst = 0;end begin #220 rst = 1; #20 rst = 0;end begin #300 rst = 1; #20 rst = 0;end join initial fork begin #100 rst =
- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;

    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b1;

    defparam t1.half_cycle = 5;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst);

    initial #1000 $finish;

    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join

    join
    endmodule
    ### Final Code:
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;

    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b1;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b1;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b0;
    defparam M1.s1_mask = 1'b0;
    defparam M1.s0_mask = 1'b1;

    defparam t1.half_cycle = 5;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst);

    initial #1000 $finish;

    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #
- code: "module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In,\
    \ LSB_In, s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\n\
    input [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nwire [1: 0] s1s0;\nassign s1s0 = {s1, s0};\nassign MSB_Out\
    \ = Data_Out[3];\nassign LSB_Out = Data_Out[0];\nalways @ (posedge clk) begin\n\
    if (rst) Data_Out <= 0;\nelse case (s1s0)\n(0,0): Data_Out <= Data_Out; // Idle\n\
    (1,0): Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right\n(1,1): Data_Out <=\
    \ {Data_Out[2:0], LSB_In}; // Shift Left\n(0,1): Data_Out <= Data_In; // Parallel\
    \ Load\nendcase\nend\nendmodule\n/*\nTest Plan\nVerify initial reset\nVerify idle\n\
    Verify shift right\nVerify shift left\nVerify parallel load\nVerify reset-on-the-fly\n\
    */\nmodule t_Universal_Shift_Reg();\nwire [3: 0] Data_Out;\nreg [3: 0] Data_In;\n\
    wire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0, rst;\ndefparam M2.half_cycle\
    \ = 5;\n\nUniversal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In,\
    \ LSB_In, s1,\ns0, clk, rst);\nClock_Gen M2(clk);\n\ninitial #1000 $finish;\n\
    initial fork\nbegin #5 rst = 1; #20 rst = 0;end\nbegin #120 rst = 1; #20 rst =\
    \ 0;end\nbegin #260 rst = 1; #20 rst = 0;end\nbegin #380 rst = 1; #20 rst = 0;end\n\
    join\ninitial fork\njoin\nbegin // Verify left shift\njoin\nbegin // Verify load\n\
    join\nbegin // reset\njoin\n\njoin\nendmodule\n#2017-05-09 \n\nWhile reading VHDL\
    \ 2008 book, I read that you can use `inside` on any net, not just `s1`, `s0`\
    \ in my code. However, I tried to use it on the S1 and S0 nets, to get a packed\
    \ array of the values, and it didn't work.\n\n### Base Verilog Code:\nmodule Universal_Shift_Reg\
    \ (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In, LSB_In, s1, s0, clk, rst);\n\
    output [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\ninput [3: 0] Data_In;\ninput\
    \ MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\ninput s1, s0, clk, rst;\n\
    assign MSB_Out = Data_Out[3];\nassign LSB_Out = Data_Out[0];\nalways @ (posedge\
    \ clk) begin\nif (rst) Data_Out <= 0;\nelse case ({s1, s0})\n0: Data_Out <= Data_Out;\
    \ // Idle\n1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right\n2: Data_Out\
    \ <= {Data_Out[2:0], LSB_In}; // Shift Left\n3: Data_Out <= Data_In; // Parallel\
    \ Load\nendcase\nend\nendmodule\n/*\nTest Plan\nVerify initial reset\nVerify idle\n\
    Verify shift right\nVerify shift left\nVerify parallel load\nVerify reset-on-the-fly\n\
    */\nmodule t_Universal_Shift_Reg();\nwire [3: 0] Data_Out;\nreg [3: 0] Data_In;\n\
    wire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0, rst;\ndefparam M2.half_cycle\
    \ = 5;\n\nUniversal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In,\
    \ LSB_In, s1,\ns0, clk, rst);\nClock_Gen M2(clk);\n\ninitial #1000 $finish; initial\
    \ fork begin #5 rst = 1; #20 rst = 0;end begin #120 rst = 1; #20 rst = 0;end begin\
    \ #260 rst = 1; #20 rst = 0;end begin #380 rst = 1; #20 rst = 0;end join initial\
    \ fork join begin // Verify left shift join begin // Verify load join begin //\
    \ reset join initial fork begin #10 M2.half_cycle + 1$fs $finish;join endmodule\
    \ ### Variation Instruction: Use `inside` on the `s1`, `s0` control signals and\
    \ check them against a packed array declared inside the dollar unit scope. ###\
    \ Modified Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\
    \ MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out;\
    \ input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004\
    \ input s1, s0, clk, rst; wire [1: 0] s1s0; assign s1s0 = {s1, s0}; assign MSB_Out\
    \ = Data_Out[3]; assign LSB_Out = Data_Out[0]; always @ (posedge clk) begin if\
    \ (rst) Data_Out <= 0; else case (s1s0) (0,0): Data_Out <= Data_Out; // Idle (1,0):\
    \ Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right (1,1): Data_Out <= {Data_Out[2:0],\
    \ LSB_In}; // Shift Left (0,1): Data_Out <= Data_In; // Parallel Load endcase\
    \ end endmodule /* Test Plan Verify initial reset Verify idle Verify shift right\
    \ Verify shift left Verify parallel load Verify reset-on-the-fly */ module t_Universal_Shift_Reg();\
    \ wire [3: 0] Data_Out; reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In,\
    \ LSB_In; reg s1, s0, rst; defparam M2.half_cycle = 5; Universal_Shift_Reg M1\
    \ (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); Clock_Gen\
    \ M2(clk); initial #1000$finish;\n\ninitial fork\nbegin #5 rst = 1; #20 rst =\
    \ 0;end\nbegin #120 rst = 1; #20 rst = 0;end\nbegin #260 rst = 1; #20 rst = 0;end\n\
    begin #380 rst = 1; #20 rst = 0;end\njoin\n\ninitial fork\njoin\n\nbegin // Verify\
    \ left shift\njoin\nbegin // Verify load\njoin\nbegin // reset\njoin\n\njoin\n\
    \nendmodule\n#2017-05-10 \n\nIs this variation still valid? I'm getting an error\
    \ when trying to use `inside` on the S1 and S0 nets and then checking them against\
    \ a packed array.\n\n### Base Verilog Code:\nmodule Universal_Shift_Reg (Data_Out,\
    \ MSB_Out, LSB_Out, Data_In,\nMSB_In, LSB_In, s1, s0, clk, rst);\noutput [3: 0]\
    \ Data_Out;\noutput MSB_Out, LSB_Out;\ninput [3: 0] Data_In;\ninput MSB_In, LSB_In;\n\
    reg [3: 0] Data_Out"
- code: |-
    ```verilog
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    Clock_Gen M2(clk);

    initial #1000 $finish;
    initial fork
    begin #5 rst = 1; #20 rst = 0;end
    begin #120 rst = 1; #20 rst = 0;end
    begin #260 rst = 1; #20 rst = 0;end
    begin #380 rst = 1; #20 rst = 0;end
    join
    initial fork
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join

    join
    endmodule

    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case (s0) // 10-12-2004
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    s0 <= s1;
    endcase
    end
    endmodule
    ```---
    layout: default
    title: "Chapter 01: The Basics"
    date: 2018-04-10 13:21
    categories:
    - DSP
    - Digital Signal Processing
    tags:
    - Digital Signal Processing
    - DSP
    - Digital Signal Processing for Beginners
    - Digital Signal Processing Courses
    description: "Chapter 01: The Basics"
    ---

    ### Chapter 01: The Basics

    #### What is a Digital Signal?

    The most basic digital signal is a pulse. A digital signal can be either a square wave or a sawtooth.

    **square wave**

    ![Square wave signal](/assets/images/Digital_Signal_Processor_Book/01-01.png)

    **Sawtooth wave**

    ![Sawtooth wave signal](/assets/images/Digital_Signal_Processor_Book/01-02.png)

    #### Digital Signal Processing

    The goal of DSP is to create an electronic system that converts a digital signal into a digital signal so that it can be understood by the human brain.

    ![DSP](/assets/images/Digital_Signal_Processor_Book/01-03.png)

    In the picture above, we have a digital signal in which we want to process.

    In the picture above, you can see that the signal is digital. It is analog in nature.
    In the picture above, you can see that there is a lot of information in the signal.

    Now, the signal is a digital signal. The signal is in the form of digital information.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    #### What Is a Digital Signal Processor (DSP)?

    A DSP is a special type of electronic system that is built for the purpose of converting a digital signal into a digital signal.

    Basically a DSP is a circuit that is built like a microcontroller that takes a digital signal as input and converts it to a digital signal as output.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    #### What Is a Digital Signal Processor (DSP)?

    A digital signal processor (DSP) is a special type of electronic system that is built for the purpose of converting a digital signal into a digital signal.

    Basically, a digital signal processor (DSP) is a circuit that is built like a microcontroller that takes a digital signal as input and converts it to a digital signal as output.

    #### What Is a Digital Signal Processor (DSP)?

    A digital signal processor (DSP) is a special type of electronic system that is built for the purpose of converting a digital signal into a digital signal.

    Basically, a digital signal processor (DSP) is a circuit that is built like a microcontroller that takes a digital signal as input and converts it to a digital signal as output.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    The goal of DSP is to convert the digital signal into something that is easier to be understood by human.

    In the picture below, the first picture shows a circuit that performs multiplication and the second picture shows the circuit that performs a digital signal processor.

    ![Digital Signal Processor Circuit](/assets/images/Digital_Signal_Processor_Book/01-04.png)

    The picture above shows a circuit that performs multiplication and the picture above shows the circuit that performs a digital signal processor.

    The first picture shows a circuit that performs multiplication and the second picture shows the circuit that performs a digital signal processor.

    The first picture shows a circuit that performs multiplication and the second picture shows the circuit that performs a digital signal processor.

    The first picture shows a circuit that performs multiplication and the second picture shows the circuit that performs a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal process

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a digital signal processor.

    The first picture shows a circuit that is built for performing multiplication and the second picture shows a
- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk;

    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always begin // reset
    if (rst) Data_Out <= 0;
    end
    always @ (posedge clk) begin
    if (~rst) Data_Out <= Data_Out;
    else case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
- code: |-
    module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,
    MSB_In, LSB_In, s1, s0, clk, rst);
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out; // 10-12-2004
    input s1, s0, clk, rst;
    input [1: 0] ins;
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) Data_Out <= 0;
    else case (ins)
    0: case ({s1, s0})
    0: Data_Out <= Data_Out; // Idle
    1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift Right
    2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left
    3: Data_Out <= Data_In; // Parallel Load
    endcase
    endcase
    end
    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;
    reg [1: 0] ins;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In,
    s1, s0, clk, rst, ins);
    Clock_Gen M2(clk);

    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0; end begin #120 rst = 1; #20 rst = 0; end begin #260 rst = 1; #20 rst = 0; end begin #380 rst = 1; #20 rst = 0; end join initial fork begin #5 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end begin #120 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end begin #260 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end begin #380 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end join initial fork join join begin // Verify left shift join join begin // Verify load join join begin // reset join join endmodule ### Variation Instruction: Use `inside` on the `s1`, `s0` control signals and check them against a packed array declared inside the dollar unit scope. ### Modified Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004 input s1, s0, clk, rst; input [1: 0] ins; assign MSB_Out = Data_Out[3]; assign LSB_Out = Data_Out[0]; always @ (posedge clk) begin if (rst) Data_Out <= 0; else case (ins) 0: case ({s1, s0}) 0: Data_Out <= Data_Out; // Idle 1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift Right 2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase endcase end end endmodule /* Test Plan Verify initial reset Verify idle Verify shift right Verify shift left Verify parallel load Verify reset-on-the-fly */ module t_Universal_Shift_Reg(); wire [3: 0] Data_Out; reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam M2.half_cycle = 5; reg [1: 0] ins; Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst, ins); Clock_Gen M2(clk); initial #1000$finish; initial fork
    begin
    #5 rst = 1;
    #20 rst = 0;
    end

    begin #120 rst = 1; #20 rst = 0; end

    begin #260 rst = 1; #20 rst = 0; end

    begin #380 rst = 1; #20 rst = 0; end
    join

    initial fork

    begin #5 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end

    begin #120 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end

    begin #260 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end

    begin #380 ins = 3; #20 ins = 1; #20 ins = 2; #20 ins = 0; end
    join

    initial fork
    join
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join
    endmodule ### Variation Instruction: Use `inside` on the `s1`, `s0` control signals and check them against a packed array declared inside the dollar unit scope. ### Modified Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004 input s1, s0, clk, rst; input [1: 0] ins; assign MSB_Out = Data_Out[3]; assign LSB_Out = Data_Out[0]; always @ (posedge clk) begin if (rst) Data_Out <= 0; else case (ins) 0: case ({s1, s0}) 0: Data_Out <= Data_Out; // Idle 1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift Right 2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase endcase end end endmodule /* Test Plan Verify initial reset Verify idle Verify shift right Verify shift left Verify parallel load Verify reset-on-the-fly */ module t_Universal_Shift_Reg(); wire [3: 0] Data_Out; reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam M2.half_cycle = 5; reg [1: 0] ins; Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst, ins); Clock_Gen M2(clk); initial #1000$finish; initial fork
    begin
    #5 rst = 1;
    #20 rst = 0;
    end

    begin #120 rst = 1; #20 rst = 0; end

    begin #260 rst = 1; #20 rst = 0; end

    begin #380 rst =
- code: |-
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    wire s1, s0, rst;

    Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1,
    s0, clk, rst);
    Clock_Gen M2(clk);

    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0; end begin #120 rst = 1; #20 rst = 0; end begin #260 rst = 1; #20 rst = 0; end begin #380 rst = 1; #20 rst = 0; end join initial fork join begin // Verify left shift join begin // Verify load join begin // reset join end end endmodule ### Base Verilog Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; input s1, s0, clk, rst; assign MSB_Out = Data_Out[3]; assign LSB_Out = Data_Out[0]; always @ (posedge clk) begin if (rst) Data_Out <= 0; else case ({s1, s0}) 0: Data_Out <= Data_Out; // Idle
- code: |-
    module sat_cnt (
    input wire clk,
    input wire reset,
    output reg [1:0] cntr
    );
    assign cntr = reset? 0 : (clk & ~reset)? cntr + 1 : cntr;
    endmodule

    ### 7.2.9. Example 8: Saturating Counter
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    generate
    for (i = 0; i < 7; i++) begin
    assign a_to_g[i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    end
    endgenerate
    endmodule

    ##
- code: "module hex7seg_le(\ninput wire [3:0] x,\noutput wire [6:0] a_to_g\n);\nreg\
    \ [6:0] led_state;\nwire inside_check = (0 <= x) && (x < 7); // This is inside\
    \ the 7-segment number system.\nassign a_to_g = inside_check? led_state[x] : 1'b1;\n\
    generate\nforall (0,6)\nassign led_state[0] = ~x[3] & ~x[2] & ~x[1] & x[0];\n\
    assign led_state[5] = x[2] & x[1] & ~x[0];\n// Insert this part select after \"\
    assign led_state[6] = ~x[3] & ~x[2] & x[1] & ~x[0];\"\nassign led_state[6] = inside_check?\
    \ led_state[x]: 1'b1;\nendgenerate\nendmodule\n### Results:\n```\n-bash-3.2$ csim-rv64-1.11\
    \ hex7seg_le.v hex7seg_le_tb.v\nhex7seg_le_tb\nVCD file hex7seg_le_tb.vcd written.\n\
    \n================================================================================================================\n\
    ================================================================================================================\n\
    ================================================================================================================\n\
    Testing hex7seg_le with initial value x=0000...\nInitial value of x00000000 in\
    \ hex7seg_le:\n\tx = x00000000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0001...\nInitial value of x00010000 in\
    \ hex7seg_le:\n\tx = x00010000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0002...\nInitial value of x00020000 in\
    \ hex7seg_le:\n\tx = x00020000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0003...\nInitial value of x00030000 in\
    \ hex7seg_le:\n\tx = x00030000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0004...\nInitial value of x00040000 in\
    \ hex7seg_le:\n\tx = x00040000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0005...\nInitial value of x00050000 in\
    \ hex7seg_le:\n\tx = x00050000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0006...\nInitial value of x00060000 in\
    \ hex7seg_le:\n\tx = x00060000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0007...\nInitial value of x00070000 in\
    \ hex7seg_le:\n\tx = x00070000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0008...\nInitial value of x00080000 in\
    \ hex7seg_le:\n\tx = x00080000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0009...\nInitial value of x00090000 in\
    \ hex7seg_le:\n\tx = x00090000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000a...\nInitial value of x000a0000 in\
    \ hex7seg_le:\n\tx = x000a0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000b...\nInitial value of x000b0000 in\
    \ hex7seg_le:\n\tx = x000b0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000c...\nInitial value of x000c0000 in\
    \ hex7seg_le:\n\tx = x000c0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000d...\nInitial value of x000d0000 in\
    \ hex7seg_le:\n\tx = x000d0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000e...\nInitial value of x000e0000 in\
    \ hex7seg_le:\n\tx = x000e0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000f...\nInitial value of x000f0000 in\
    \ hex7seg_le:\n\tx = x000f0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0000...\nInitial value of x00000000 in\
    \ hex7seg_le:\n\tx = x00000000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0001...\nInitial value of x00010000 in\
    \ hex7seg_le:\n\tx = x00010000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0002...\nInitial value of x00020000 in\
    \ hex7seg_le:\n\tx = x00020000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0003...\nInitial value of x00030000 in\
    \ hex7seg_le:\n\tx = x00030000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0004...\nInitial value of x00040000 in\
    \ hex7seg_le:\n\tx = x00040000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0005...\nInitial value of x00050000 in\
    \ hex7seg_le:\n\tx = x00050000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0006...\nInitial value of x00060000 in\
    \ hex7seg_le:\n\tx = x00060000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0007...\nInitial value of x00070000 in\
    \ hex7seg_le:\n\tx = x00070000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0008...\nInitial value of x00080000 in\
    \ hex7seg_le:\n\tx = x00080000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=0009...\nInitial value of x00090000 in\
    \ hex7seg_le:\n\tx = x00090000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000a...\nInitial value of x000a0000 in\
    \ hex7seg_le:\n\tx = x000a0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000b...\nInitial value of x000b0000 in\
    \ hex7seg_le:\n\tx = x000b0000\n\tinside_check=1\n================================================================================================================\n\
    Testing hex7seg_le with initial value x=000c...\nInitial value of x000c0000 in\
    \ hex7seg_le:\n\tx = x000c0000\n\tinside_check=1\n================================================================================================================"
- code: |-
    ```module hex7seg_le (input wire [3:0] x, output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g); // Logic equations for each segment (active high assumed) assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & x[2] & ~x[1] & x[0] | x[3] & ~x[2] & x[1] & x[0]; assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5) | x[3] & x[1] & x[0] | ~x[3] & x[2] & ~x[1] & x[0] | x[3] & x[2] & ~x[1] & ~x[0]; assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4) | x[3] & x[2] & x[1] | x[3] & x[2] & ~x[0]; assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & ~x[2] & x[1] & ~x[0] | x[2] & x[1] & x[0]; assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2) | ~x[3] & x[2] & ~x[1] | ~x[2] & ~x[1] & x[0]; assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1) | ~x[3] & ~x[2] & x[1] | ~x[3] & x[1] & x[0] | x[3] & x[2] & ~x[1] & x[0]; assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0) | x[3] & x[2] & ~x[1] & ~x[0] | ~x[3] & x[2] & x[1] & x[0]; endmodule

    ```

    **Explanation**

    When you specify a part select for x, it will only look at the indices of x. The value of x will not be used. If you don't want this, you have to do some other logic to prevent the value of x from being used.

    You can do this using an indexed part select:

    ```
    `ifdef x[0]
    ...
    `endif

    ```

    but because it's `ifdef`, it's always evaluated, so you have to do the following:

    ```
    `ifdef x[0]
    assign a_to_g[0] = x[0] & ~x[1] & ~x[2] & ~x[3]
    `endif
    `ifdef x[1]
    assign a_to_g[0] = ~x[0] & x[1] & ~x[2] & ~x[3]
    `endif
    `ifdef x[2]
    assign a_to_g[0] = ~x[0] & ~x[1] & x[2] & ~x[3]
    `endif
    `ifdef x[3]
    assign a_to_g[0] = ~x[0] & ~x[1] & ~x[2] & x[3]
    `endif

    ```

    And so on. You can do this using a generate block, which will be evaluated only once, and then the value of x will not be used, but will only be used to make sure that the output gets assigned correctly.

    But you can also do this using a case, like so:

    ```
    case (x)
    3'b 0:    a_to_g[0] = 1'b0;
    3'b 1:    a_to_g[0] = 1'b1;
    3'b 2:    a_to_g[0] = 1'b0;
    3'b 3:    a_to_g[0] = 1'b1;
    3'b 4:    a_to_g[0] = 1'b0;
    3'b 5:    a_to_g[0] = 1'b1;
    3'b 6:    a_to_g[0] = 1'b0;
    3'b 7:    a_to_g[0] = 1'b1;
    3'b 8:    a_to_g[0] = 1'b0;
    3'b 9:    a_to_g[0] = 1'b1;
    default:  a_to_g[0] = 1'b0;
    endcase

    ```

    As you can see, this is much less compact, but it's more direct and the value of x is not used at all.

    If you want a more compact form but more readable, you can add a special case of the default, like so:

    ```
    case (x)
    3'b 0:    a_to_g[0] = 1'b0;
    3'b 1:    a_to_g[0] = 1'b1;
    3'b 2:    a_to_g[0] = 1'b0;
    3'b 3:    a_to_g[0] = 1'b1;
    3'b 4:    a_to_g[0] = 1'b0;
    3'b 5:    a_to_g[0] = 1'b1;
    3'b 6:    a_to_g[0] = 1'b0;
    3'b 7:    a_to_g[0] = 1'b1;
    3'b 8:    a_to_g[0] = 1'b0;
    3'b 9:    a_to_g[0] = 1'b1;
    default:  a_to_g[0] = 1'b0;
    endcase

    ```

    Again, this is longer but still much more readable.

    But of course, if you want to make it even shorter, you can also just write the logic in the generate block, without using any case statements at all:

    ```
    generate
    for (i=0; i<10; i=i+1) begin : case_part

        if (i==0)
            a_to_g[0] = 1'b0;
        else if (i==1)
            a_to_g[0] = 1'b1;
        else if (i==2)
            a_to_g[0] = 1'b0;
        else if (i==3)
            a_to_g[0] = 1'b1;
        else if (i==4)
            a_to_g[0] = 1'b0;
        else if (i==5)
            a_to_g[0] = 1'b1;
        else if (i==6)
            a_to_g[0] = 1'b0;
        else if (i==7)
            a_to_g[0] = 1'b1;
        else if (i==8)
            a_to_g[0] = 1'b0;
        else if (i==9)
            a_to_g[0] = 1'b1;

    end : case_part
    endgenerate

    ```

    Now, if you really want to be super-compact, you can use a function, like so:

    ```
    module hex7seg(input wire [3:0] x, output reg [6:0] a_to_g);

        logic [3:0] x; // the value of x is not used, just used to make sure the outputs are correct
        assign x = x;
        function logic [3:0] digit(input  logic digit);
            case (digit)
                0:  return '0;
                1:  return '1;
                2:  return
- code: "module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g\n);\n\
    // Logic equations for each segment (active high assumed)\nassign a_to_g[2:0]\
    \ = x[1:0] // b (segment index 5)\n| ~x[3] & x[2] & ~x[1] & ~x[0]\n| x[3] & x[2]\
    \ & ~x[1] & x[0]\n| x[3] & ~x[2] & x[1] & x[0];\ngenerate\nfor (i = 0; i < 4;\
    \ i = i+1) begin: inside\nassign a_to_g[6+i] = ~x[3] & ~x[2] & ~x[1] & x[0] //\
    \ a (segment index 6)\n| ~x[3] & x[2] & ~x[1] & ~x[0]\n| x[3] & x[2] & ~x[1] &\
    \ x[0]\n| x[3] & ~x[2] & x[1] & x[0];\nend\nendgenerate\nendmodule`\nNote: I could\
    \ not find an answer to this question on the Web site for Verilog/SystemVerilog.\n\
    \n### 4.6.4.4.3.\_Nested Generate Blocks\n\nA generate block may contain a nested\
    \ generate block. This is called a nested generate block.\n\nThe body of a nested\
    \ generate block is executed every time the outer generate block is executed.\
    \ The bodies of nested generate blocks are executed if the current value of the\
    \ generate parameter is matched. Note that this does not indicate that the code\
    \ in the nested generate block will be executed once for each match. The code\
    \ will be executed once for each time the outer generate block is executed. For\
    \ example:\n\n```module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g\n\
    );\n// Logic equations for each segment (active high assumed)\ngenerate\nfor (i\
    \ = 0; i < 4; i = i+1) begin: inside\ngenerate\nfor (j = 0; j < 2; j = j+1) begin:\
    \ inside_inside\nassign a_to_g[6+i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment\
    \ index 6)\n| ~x[3] & x[2] & ~x[1] & ~x[0]\n| x[3] & x[2] & ~x[1] & x[0]\n| x[3]\
    \ & ~x[2] & x[1] & x[0];\nend\nendgenerate\nend\nendgenerate\nendmodule\n```\n\
    \nThe result of the example above is the same as that of the first example:\n\n\
    #### Problem 10\n\nThis is a slightly expanded version of the previous example.\n\
    \n```module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g\n);\n\
    // Logic equations for each segment (active high assumed)\ngenerate\nfor (i =\
    \ 0; i < 4; i = i+1) begin: inside\ngenerate\nfor (j = 0; j < 2; j = j+1) begin:\
    \ inside_inside\ngenerate\nfor (k = 0; k < 2; k = k+1) begin: inside_inside_inside\n\
    assign a_to_g[6+i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)\n| ~x[3]\
    \ & x[2] & ~x[1] & ~x[0]\n| x[3] & x[2] & ~x[1] & x[0]\n| x[3] & ~x[2] & x[1]\
    \ & x[0];\nend\nendgenerate\nend\nendgenerate\nend\nendgenerate\nendmodule\n```\n\
    \nThis program will result in the program hanging since a_to_g[6] is a combination\
    \ of 6 other wires.\n\n### 4.6.4.4.4.\_Generate Blocks with Conditionals\n\nThere\
    \ is a special form of conditional that can be used in a generate block. This\
    \ conditional is called the \u201Cif_else\u201D conditional. The syntax of this\
    \ conditional is:\n\n```generate\nif (generate_condition)\ngen_statement\nelse\n\
    gen_statement\nendgenerate\n```\n\nThe condition may be any expression that evaluates\
    \ to a Boolean value. The statements inside the generate block will be generated\
    \ only if the condition is true.\n\nThe following example shows how to use this\
    \ conditional:\n\n```module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0]\
    \ a_to_g\n);\n// Logic equations for each segment (active high assumed)\ngenerate\n\
    for (i = 0; i < 4; i = i+1) begin: inside\ngenerate\nif (x[2] == 1)\nassign a_to_g[6+i]\
    \ = 1'b0;\nelse\nassign a_to_g[6+i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment\
    \ index 6)\n| ~x[3] & x[2] & ~x[1] & ~x[0]\n| x[3] & x[2] & ~x[1] & x[0]\n| x[3]\
    \ & ~x[2] & x[1] & x[0];\nend\nendgenerate\nendgenerate\nendmodule\n```\n\nSometimes,\
    \ it is useful to use the generate conditional to break out of the current generate\
    \ block. The syntax is:\n\n```generate\nif (generate_condition)\ngen_statement_1\n\
    else if (generate_condition_1)\ngen_statement_2\nelse if (generate_condition_2)\n\
    gen_statement_n\nelse\ngen_statement_n+1\nendgenerate\n```\n\nThe condition may\
    \ be any expression that evaluates to a Boolean value. The statements inside the\
    \ generate block will be generated only if the condition is true. When the condition\
    \ is false, the generation of statements is terminated and processing moves to\
    \ the next conditional.\n\nThis example uses the if_else conditional to break\
    \ out of a generate block:\n\n```module hex7seg_le (\ninput wire [3:0] x,\noutput\
    \ wire [6:0] a_to_g\n);\n// Logic equations for each segment (active high assumed)\n\
    generate\nfor (i = 0; i < 4; i = i+1) begin: inside\ngenerate\nif (x[2] == 1)\n\
    assign a_to_g[6+i] = 1'b0;\nelse if (x[1] == 1)\nassign a_to_g[6+i] = 1'b0;\n\
    else\ngen_statement\nend\nendgenerate\nendgenerate\nendmodule\n```\n\n## 4.6.5.\_\
    Generate and Parametric Simulation\n\nGenerates are used to simulate models that\
    \ depend on parameters. Using generates and parameters, you can simulate models\
    \ that relate to different parameter values. For example, we can use a generate\
    \ to simulate 6 different models. To do this, we must use a different parameter\
    \ for each model, and we must use a different name for each model \u2014 for example,\
    \ model_1, model_2, model_3, etc.\n\nFirst, we declare the generate block. Then,\
    \ we use the generate keyword to open a new parameter scope. Inside the parameter\
    \ scope, we can reference the generate parameter to create the new parameter name.\
    \ Finally, we close the parameter scope by including the end generate keyword.\
    \ To see an example of this, consider the following code:\n\n```module test_pkg;\n\
    \nreg [3:0] reg1;\nreg [4:0] reg2;\n\ngenerate\n\nalways @(posedge clk) begin\n\
    generate\n\nassign reg1 = 0;\nassign reg2 = 0;\nend\nendgenerate\n\nendmodule\n\
    ```\n\nIn this example, we have a module named test_pkg that contains a register\
    \ named reg1 and a register named reg2. Note that the generate blocks are nested.\
    \ The first generate block contains two assign statements that set the value of\
    \ reg1 to 0, and the value of reg2 to 0. The second generate block contains two\
    \ assign statements that set the value of reg1 to 1, and the value of reg2 to\
    \ 1.\n\nThe result of running this code is shown here:\n\n```model_1\nmodel_2\n\
    ```\n\nThese are the names of the models that are created. The model_1 name is\
    \ derived from the first generate block, and the model_2 name is derived from\
    \ the second generate block.\n\nGenerates are"
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
            genvar i;
            generate
    for (i = 0; i < 7; i = i + 1)
    begin : a_to_g_check
    if (x[i] < 0)
    $display("segment %d has a negative number",i); end endgenerate endmodule ### Output:  Verilog Code: module hex7seg_le ( input wire [3:0] x, output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g); // Logic equations for each segment (active high assumed) assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & x[2] & ~x[1] & x[0] | x[3] & ~x[2] & x[1] & x[0]; assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5) | x[3] & x[1] & x[0] | ~x[3] & x[2] & ~x[1] & x[0] | x[3] & x[2] & ~x[1] & ~x[0]; assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4) | x[3] & x[2] & x[1] | x[3] & x[2] & ~x[0]; assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & ~x[2] & x[1] & ~x[0] | x[2] & x[1] & x[0]; assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2) | ~x[3] & x[2] & ~x[1] | ~x[2] & ~x[1] & x[0]; assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1) | ~x[3] & ~x[2] & x[1] | ~x[3] & x[1] & x[0] | x[3] & x[2] & ~x[1] & x[0]; assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0) | x[3] & x[2] & ~x[1] & ~x[0] | ~x[3] & x[2] & x[1] & x[0]; endmodule Variation Instruction: Add inside check for `x` using an indexed part select, placed in a generate block with escaped name. Modified Code: module hex7seg_le ( input wire [3:0] x, output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g); // Logic equations for each segment (active high assumed) assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & x[2] & ~x[1] & x[0] | x[3] & ~x[2] & x[1] & x[0]; assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5) | x[3] & x[1] & x[0] | ~x[3] & x[2] & ~x[1] & x[0] | x[3] & x[2] & ~x[1] & ~x[0]; assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4) | x[3] & x[2] & x[1] | x[3] & x[2] & ~x[0]; assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3) | ~x[3] & x[2] & ~x[1] & ~x[0] | x[3] & ~x[2] & x[1] & ~x[0] | x[2] & x[1] & x[0]; assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2) | ~x[3] & x[2] & ~x[1] | ~x[2] & ~x[1] & x[0]; assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1) | ~x[3] & ~x[2] & x[1] | ~x[3] & x[1] & x[0] | x[3] & x[2] & ~x[1] & x[0]; assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index
- code: "module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g // Outputs\
    \ for segments a,b,c,d,e,f,g\n);\n// Logic equations for each segment (active\
    \ high assumed)\ngenerate\nfor (i = 0; i < 7; i = i+1) begin\nassign a_to_g[i]\
    \ = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)\n| ~x[3] & x[2] & ~x[1]\
    \ & ~x[0]\n| x[3] & x[2] & ~x[1] & x[0]\n| x[3] & ~x[2] & x[1] & x[0]\n| (i ==\
    \ 6)? x[3] : 0;\nend\nendgenerate\nendmodule\n### Variation Instruction:\nSplit\
    \ the code into three verilog files. The first is the source file for your top\
    \ level module, here called \u2018hex7seg_le.v\u2019. The second file is the sub\
    \ module that drives the LED segments, called \u2018hex7seg_le_led_segs.v\u2019\
    . The third file is the \u2018hex7seg_le_testbench.v\u2019 file that will test\
    \ the hex7seg_le module.\n### Sub Modules - Source File:\nmodule hex7seg_le_led_segs\
    \ (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g\n\
    );\n// Logic equations for each segment (active high assumed)\nassign a_to_g[6]\
    \ = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)\n| ~x[3] & x[2] & ~x[1]\
    \ & ~x[0]\n| x[3] & x[2] & ~x[1] & x[0]\n| x[3] & ~x[2] & x[1] & x[0];\nassign\
    \ a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)\n| x[3] & x[1] & x[0]\n\
    | ~x[3] & x[2] & ~x[1] & x[0]\n| x[3] & x[2] & ~x[1] & ~x[0];\nassign a_to_g[4]\
    \ = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)\n| x[3] & x[2] & x[1]\n\
    | x[3] & x[2] & ~x[0];\nassign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment\
    \ index 3)\n| ~x[3] & x[2] & ~x[1] & ~x[0]\n| x[3] & ~x[2] & x[1] & ~x[0]\n| x[2]\
    \ & x[1] & x[0];\nassign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)\n| ~x[3]\
    \ & x[2] & ~x[1]\n| ~x[2] & ~x[1] & x[0];\nassign a_to_g[1] = ~x[3] & ~x[2] &\
    \ x[0] // f (segment index 1)\n| ~x[3] & ~x[2] & x[1]\n| ~x[3] & x[1] & x[0]\n\
    | x[3] & x[2] & ~x[1] & x[0];\nassign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment\
    \ index 0)\n| x[3] & x[2] & ~x[1] & ~x[0]\n| ~x[3] & x[2] & x[1] & x[0];\nendmodule\n\
    ### Testbench File:\n\n```\n`timescale 1 ns / 1 ps\nmodule hex7seg_le_tb #(\n\
    parameter int NUM_BITS = 4\n) (\ninput wire clk,\ninput wire rst_n,\ninput wire\
    \ [3:0] x,\noutput wire [NUM_BITS+6:0] a_to_g\n);\nreg [3:0] x;\nwire [NUM_BITS:0]\
    \ hex;\nhex7seg_le hex7seg (\n.x(x),\n.a_to_g(a_to_g)\n);\nassign hex[NUM_BITS]\
    \ = 1'b1;\nalways @(posedge clk) begin\nif (rst_n) x = 4'b0000;\nelse x <= x +\
    \ 1'b1;\nend\nendmodule\n```\n### Top Level Source File:\n\n```module hex7seg_le\
    \ #(\nparameter int NUM_BITS = 4\n) (\ninput wire clk,\ninput wire rst_n,\ninput\
    \ wire [3:0] x,\noutput wire [NUM_BITS+6:0] a_to_g\n);\nwire [NUM_BITS+6:0] a_to_g_from_sub_module;\n\
    hex7seg_le_led_segs hex7seg_le_led_segs (\n.x(x),\n.a_to_g(a_to_g_from_sub_module)\n\
    );\nassign a_to_g = a_to_g_from_sub_module;\nendmodule\n```\n### Main File:\n\
    #include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n\
    #include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n#define GPIO_BASE\
    \ 0x20200000\n#define GPIO_INPUT(g) (g * 4U)\n#define GPIO_OUTPUT(g) (g * 4U +\
    \ 1U)\n#define GPIO_SETDATAOUT_OFFSET 0x1c\n#define GPIO_SETDATAIN_OFFSET 0x18\n\
    \ntypedef struct {\nuint32_t gpfsel[6U];\nuint32_t reserved1;\nuint32_t gpfset[2U];\n\
    uint32_t gpclrl[2U];\nuint32_t gpclear[2U];\nuint32_t gpset[2U];\nuint32_t reserved2[2U];\n\
    uint32_t gpdir[2U];\nuint32_t reserved3;\nuint32_t gppud;\nuint32_t reserved4;\n\
    uint32_t gppudclk[2U];\nuint32_t reserved5[2U];\n} gpio_t;\n\nvoid set_gpio_direction(gpio_t\
    \ *gpio, uint8_t gpio_num, uint8_t direction) {\nif (direction == 1) {\ngpio->gpfsel[gpio_num\
    \ / 10U] =\ngpio->gpfsel[gpio_num / 10U] | (3U << ((gpio_num % 10U) * 3U));\n\
    }\nelse {\ngpio->gpfsel[gpio_num / 10U] =\ngpio->gpfsel[gpio_num / 10U] & ~(7U\
    \ << ((gpio_num % 10U) * 3U));\n}\n}\n\nvoid set_gpio_value(gpio_t *gpio, uint8_t\
    \ gpio_num, uint8_t value) {\nif (value == 1) {\n*(gpio->gpset + (gpio_num / 32U))\
    \ = 1U << (gpio_num % 32U);\n}\nelse {\n*(gpio->gpclr + (gpio_num / 32U)) = 1U\
    \ << (gpio_num % 32U);\n}\n}\n\nvolatile gpio_t *gpio;\n\nint main(int argc, char\
    \ *argv[]) {\nuint8_t array[4];\nint fd, i, j;\nuint8_t *ptr, val;\n\nif ((fd\
    \ = open(\"/dev/mem\", O_RDWR | O_SYNC)) == -1) {\nprintf(\"Fail to open /dev/mem\\\
    n\");\nreturn -1;\n}"
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign {a_to_g[6], a_to_g[5:4], a_to_g[3:2], a_to_g[1:0]} =

    // a (segment index 6)
    | ~x[3] & ~x[2] & ~x[1] & x[0]
    // b (segment index 5)
    | x[2] & x[1] & ~x[0]
    // c (segment index 4)
    | ~x[3] & ~x[2] & x[1] & ~x[0]
    // d (segment index 3)
    | x[3] & ~x[2] & ~x[1] & x[0]
    // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | x[3] & x[2] & ~x[0]
    // g (segment index 0)
    | ~x[3] & x[2] & ~x[1] & ~x[0];

    endmodule
    ### Results:
    All pass.

    ## 2.10.25

    ### Base Verilog Code:
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    generate
    for ( i = 6; i >= 0; i = i-1 ) begin
    assign a_to_g[i] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[i] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[i] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[i] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[i] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[i] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[i] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
    end
    endgenerate
    endmodule


    The result is the same as before, but the code is much clearer.

    ## 3 Disadvantages of Indexed Part Select

    The indexed part select is an elegant and very useful method for generating logic equations for all outputs of a module. However, it is not the only method that can be used to generate logic equations. There are a few disadvantages that should be considered.

    ### 3.1 More Complex Code

    Compared to the original code, the modified code is more complex and longer. The difference in length is not insignificant. However, the original code has not been modified much. Because some of the variables have not been changed, they are still declared with the same data types as before. The only thing that has been changed is the initialization of the arrays. The new code initializes the array before the generate block.

    ### 3.2 Less Easily Maintenable

    The generate block itself is more difficult to maintain than the original code. Since it can be more difficult to read and understand the original code, developers who need to maintain the code for long periods of time may consider writing the code without the generate block. On the other hand, the generated code is easy to maintain. If some logic equations are changed, the generate block can be used to update the code easily.

    ### 3.3 Performance Degradation

    Since generating logic equations with the generate block requires extra time, it has been observed that there is a certain performance drop in the generated code.

    ## 4 Summary

    Although the indexed part select is a convenient method for generating logic equations for outputs of a module, it is not the only method. Some developers may find that some methods are easier and more elegant than others. However, some methods, such as the generate block, have a number of disadvantages that can affect their usability.
- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    initial begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #
- code: "module updcounter();\nparameter WIDTH = 4;\nparameter MAX = 8;\n//reg[WIDTH-1:0][MAX-1:0]\
    \ a_mem [0:11];\nreg[WIDTH-1:0][MAX-1:0] a_mem [0:7];\nreg[WIDTH-1:0] N;\nreg\
    \ u_d; // Up or down flag\nreg[WIDTH-1:0] a_reg; // Register used in increment/decrement\n\
    input clk;\ninput rst_x;\ninput rst_i;\noutput reg[WIDTH-1:0] a;\nalways @(posedge\
    \ clk or posedge rst_x) begin\nif (rst_i) begin\na_mem[N-1:0] <= (N-1) {1'b0,\
    \ 1'b0, 1'b0};\nN <= (WIDTH) {N[WIDTH-1:0], 1'b0};\nend\nelse begin\nif (u_d)\
    \ // Increment register\na_reg <= a_reg + 1'b1; // Increment\n// Generate address\n\
    else\na_reg <= a_reg - 1'b1; // Decrement\n// Generate address\na_mem[N-1:0] <=\
    \ a_reg;\nif (u_d && a_reg == (N-1))\nN <= N + 1; // Increase limit\nif (!u_d\
    \ && a_reg == 0)\nN <= N - 1; // Decrease limit\nend\n// Generate output signal\n\
    a <= a_mem[N-1];\nend\nendmodule\n\n\nI've tested the above code with this testbench\
    \ code:\n\nmodule tst_updcounter();\nreg clk,u_d;\nreg[3:0]N;\nwire[3:0]a;\nupdcounter\
    \ c2(a,clk,N,u_d);\ninitial\nbegin\nN = 4'b0111; // Set limit N=7\nu_d = 1'b1;\
    \ // Start counting up (Corrected: was 1'b0)\nclk = 0;\nend\nalways #2 clk=~clk;\
    \ // Generate clock\nalways #34 u_d=~u_d; // Change direction every 34 time units\n\
    initial $monitor ($time,\"clk=%b, N=%d, u_d=%b, a=%d\",clk,N,u_d,a); // Display\
    \ values\ninitial #64 $stop; // Stop simulation endmodule  The behavior should\
    \ be \"counter\" but the output is 0. What part of the code/architecture is incorrect\
    \ or inappropriate? \u2022 I do not see a problem with the top level code, but\
    \ I'm not certain about the bottom level code. \u2013 user28715 Aug 30 '13 at\
    \ 20:46 \u2022 @user28715: In general, the bottom level code should work as well.\
    \ Are you sure you have your input signal assignments correct? \u2013 TonyM Aug\
    \ 30 '13 at 20:47 \u2022 Please post your code as text. No images. \u2013. Aug\
    \ 30 '13 at 23:11 \u2022 @TonyM: It would be simpler if I modified my code in\
    \ the question. It seems the initial values for u_d and a_mem are the issue. It\
    \ works with initial values of 0 as u_d and a_mem. \u2013 user28715 Aug 30 '13\
    \ at 23:15 \u2022 @user28715: The values of u_d and a_mem are not the issue. The\
    \ problem is that the clock is not gating correctly. I've re-written the code\
    \ to simplify the structure and address the issue. Please verify that the code\
    \ works as you desire. \u2013 TonyM Aug 30 '13 at 23:35 ## 1 Answer Here are some\
    \ comments: 1. You do not need to have the rst_x and rst_i signals. I don't see\
    \ any reason to have them. 2. There is no point in the generate block. It is going\
    \ to give you the same result as your if-else statement. I've removed the generate\
    \ block and you still get the results you want. 3. The first time you run the\
    \ simulation, it's going to start at 0 and then go up because u_d is true. It's\
    \ going to be 0000 by the time you hit the first 34 time steps. It's going to\
    \ take a minute for it to go up to 1111, then it will go to 0000 again because\
    \ u_d is false. However, when it hits 1111, it will never go down because u_d\
    \ is false. I would try to make your code a little more complicated so you can\
    \ see what's going. \u2022 1. I agree on not needing those. \u2013 TonyM Aug 30\
    \ '13 at 23:50 \u2022 2. I am wondering if this is a problem with the code from\
    \ the question or my understanding of the question. \u2013 user28715 Aug 30 '13\
    \ at 23:51 \u2022 3. I've modified the testbench code and it works. I don't understand\
    \ how to make it work. \u2013 user28715 Aug 30 '13 at 23:53 \u2022 I edited my\
    \ answer as I found out that the clock was not gating properly. \u2013 TonyM Aug\
    \ 30 '13 at 23:59 \u2022 @user28715: I have edited the code to address the issues\
    \ you mentioned. Please verify that it works as you desired. \u2013 TonyM Aug\
    \ 31 '13 at 0:01 \u2022 OK. I see it. That makes sense. \u2013 user28715 Aug 31\
    \ '13 at 1:44 I don't see any problem with the top level code, but I'm not certain\
    \ about the bottom level code. What part of the code/architecture is incorrect\
    \ or inappropriate? Well, the architecture is correct but the behavior is not.\
    \ At the top level, the behavior is as expected. Here is a modified version of\
    \ your code: module updcounter(); parameter WIDTH = 4; parameter MAX = 8; reg[WIDTH-1:0][MAX-1:0]\
    \ a_mem [0:7]; reg[WIDTH-1:0] N; reg u_d; // Up or down flag reg[WIDTH-1:0] a_reg;\
    \ // Register used in increment/decrement input clk; input rst_x; input rst_i;\
    \ output reg[WIDTH-1:0] a; always @(posedge clk or posedge rst_x) begin if (rst_i)\
    \ begin a_mem[N-1:0] <= (N-1) {1'b0, 1'b0, 1'b0}; N <= (WIDTH) {N[WIDTH-1:0],\
    \ 1'b0}; end else begin if (u_d) // Increment register a_reg <= a_reg + 1'b1;\
    \ // Increment // Generate address else a_reg <= a_reg - 1'b1; // Decrement //\
    \ Generate address a_mem[N-1:0] <= a_reg; if (u_d && a_reg == (N-1)) N <= N +\
    \ 1; // Increase limit if (!u_d && a_reg == 0) N <= N - 1; // Decrease limit end\
    \ end // Generate output signal a <= a_mem[N-1]; end endmodule The behavior is\
    \ not changed if I use an initial value of 4'b0111 for N and a_reg = 0. The output\
    \ is still 0. But the behavior is changed if N is initialized to 0 and a_reg is\
    \ initialized to 3. The output is now 3. I don't know what is the problem. How\
    \ should I modify the code? Please help! \u2022 I think the problem is with the\
    \ initialization of a_reg. I suggest you use $random for this purpose, since it\
    \ is not necessary to have a value of 3 for testing. \u2013\_ Aug 31 '13 at 2:13\n\
    \u2022 I see what you mean. The problem is a_reg is not initialized properly.\
    \ It should be 0. \u2013\_user28715 Aug 31 '13 at 14:50\n\u2022 @user28715: That\
    \ is true. But this is incorrect. You can initialize a_reg to any number. It is\
    \ a_reg = (WIDTH) {WIDTH[WIDTH-1:0], 1'b0}; \u2013\_TonyM Aug 31 '13 at 14:53\n\
    \u2022 @user28715: This is a bug in FPGA design. There is a timing constraint\
    \ called \"setup\" which limits the delay between the assertion of the reset signal\
    \ and the assertion of the clock signal. This timing constraint is different from\
    \ the clock period. The reset signal is sampled at the end of the clock period.\
    \ When you initialize a register"
- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,rst_x; // Corrected: Added reset for external `RST_X` signal
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,rst_x);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    rst_x = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34 rst_x=~rst_x; // Change direction every 34 time units
    **generate
    begin
    always #8 rst_x=~rst_x;
    end**
    initial $monitor
    ($time,"clk=%b, N=%d, rst_x=%b, a=%d",clk,N,rst_x,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodule
    ### Verilog Compilation:
    $iverilog -o test_updcounter.out test_updcounter.v $./test_updcounter.out
    ### Result:
    ```
    34.000000 ns  clk=0  N=7  rst_x=1  a=0
    34.000000 ns  clk=1  N=7  rst_x=1  a=1
    34.000000 ns  clk=0  N=7  rst_x=1  a=2
    34.000000 ns  clk=1  N=7  rst_x=1  a=3
    34.000000 ns  clk=0  N=7  rst_x=1  a=4
    34.000000 ns  clk=1  N=7  rst_x=1  a=5
    34.000000 ns  clk
- code: "module tst_updcounter(RST_X);//TEST_BENCH\nreg clk;\nreg[3:0]N;\nreg[3:0]a;\n\
    wire[3:0]b;\nupdcounter c2(b,clk,N,a);\nreg init=1;\nalways_ff @(posedge clk)\n\
    begin\nif(!init) begin\nN = 4'b0111;\na = 4'b0000;\nb = 4'b0000;\nend\nend\nalways\
    \ #34 a=~a;\nalways #34 b=~b;\n//always #15 u_d=~u_d; // Change direction every\
    \ 15 time units\ninitial clk=0;\nalways #RST_X+2 init=~init;\ninitial $monitor\n\
    ($time,\"clk=%b, N=%d, b=%d, a=%d\",clk,N,b,a); // Display values\ninitial #64\
    \ $stop; // Stop simulation\nendmodule\n\n## 3.30.4. Example: Design With Multiple\
    \ CLOCKs#\n\n## 3.30.5. Example: Design With Multiple RESETs#\n\n## 3.30.6. Example:\
    \ Design With Multiple INPUTs#\n\n## 3.30.7. Example: Design With Multiple OUTPUTs#\n\
    \n3.31.3.10.1. How to define a function with a return value?\n\n\u2022 In general,\
    \ functions in Verilog do not return a value. The only place where you can use\
    \ return is in a function that is used as an argument to another function. More\
    \ about returning values below.\n3.31.3.11. What are the advantages of using Verilog\u2019\
    s $display function?\n3.31.3.12. How many arguments are allowed to a function?\n\
    3.31.3.13. How is the clock frequency of the FPGA calculated?\n3.31.3.14. How\
    \ many instructions can be specified in a single clock cycle?\n3.31.3.15. What\
    \ is a variable declaration?\n3.31.3.16. What is the difference between the $read\
    \ and $write functions?\n\n3.31.4.1. How are the I/O ports of the FPGA defined?\n\
    \n\u2022 The FPGA has two sets of I/O ports:\n\u2022 The set of general purpose\
    \ I/O ports (GPIO)\n\u2022 The set of I/O ports connected to the PS/2 (or USB)\
    \ ports\n3.31.4.2. What is the difference between a reg and wire?\n\u2022 Wire\
    \ is the data type used for input and output.\n\u2022 Reg is the data type used\
    \ for internal storage.\n3.31.4.3. What are the inputs of the programmable logic\
    \ unit?\n3.31.4.4. What is the difference between an input and an output?\n3.31.4.5.\
    \ What is the difference between a reg and an always_ff block?\n\n3.31.5.1. What\
    \ is the difference between a reg and a wire?\n\u2022 Wires are for input and\
    \ output signals.\n\u2022 Regs are for internal storage.\n3.31.5.2. What is the\
    \ difference between a reg and a assign?\n\u2022 Assigns are for output only.\n\
    \u2022 Regs are for internal storage.\n3.31.5.3. What is the difference between\
    \ a wire and an assign?\n\u2022 Assigns are for output only.\n\u2022 Wires are\
    \ for input and output signals.\n3.31.5.4. What is the difference between a reg\
    \ and an always_ff block?\n\u2022 Always_ff blocks are for internal storage.\n\
    \u2022 Regs are for input and output signals.\n3.31.5.5. What is the difference\
    \ between a reg and an always block?\n\u2022 Always blocks are for output only.\n\
    \u2022 Regs are for internal storage.\n\n## 3.31.6. Example: Design With Multiple\
    \ OUTPUTs#\n\n3.38.1.1. What are the advantages of using Verilog\u2019s $display\
    \ function?\n\u2022 $display is used to display the value of a variable at the\
    \ end of a simulation.\n\u2022 It can be used to monitor the values of all variables\
    \ in the simulation, which can be very useful in debugging.\n3.38.1.2. What is\
    \ the difference between a reg and a wire?\n\u2022 Wires are for input and output\
    \ signals.\n\u2022 Regs are for internal storage.\n3.38.1.3. What is the difference\
    \ between a reg and a assign?\n\u2022 Assigns are for output only.\n\u2022 Regs\
    \ are for internal storage.\n3.38.1.4. What is the difference between a wire and\
    \ an assign?\n\u2022 Assigns are for output only.\n\u2022 Wires are for input\
    \ and output signals.\n3.38.1.5. What is the difference between a reg and an always_ff\
    \ block?\n\u2022 Always_ff blocks are for internal storage.\n\u2022 Regs are for\
    \ input and output signals.\n3.38.1.6. What is the difference between a reg and\
    \ an always block?\n\u2022 Always blocks are for output only.\n\u2022 Regs are\
    \ for internal storage.\n\n## 3.31.7. Example: Design With Multiple INPUTs#\n\n\
    \u2022 Regs are for internal storage.\n3.38.1.1. What are the advantages of using\
    \ Verilog\u2019s $display function?\n\u2022 $display is used to display the value\
    \ of a variable at the end of a simulation.\n\u2022 It can be used to monitor\
    \ the values of all variables in the simulation, which can be very useful in debugging.\n\
    3.38.1.2. What is the difference between a reg and a wire?\n\u2022 Wires are for\
    \ input and output signals.\n\u2022 Regs are for internal storage.\n3.38.1.3.\
    \ What is the difference between a reg and a assign?\n\u2022 Assigns are for output\
    \ only.\n\u2022 Regs are for internal storage.\n3.38.1.4. What is the difference\
    \ between a wire and an assign?\n\u2022 Assigns are for output only.\n\u2022 Wires\
    \ are for input and output signals.\n3.38.1.5. What is the difference between\
    \ a reg and an always_ff block?\n\u2022 Always_ff blocks are for internal storage.\n\
    \u2022 Regs are for input and output signals.\n3.38.1.6. What is the difference\
    \ between a reg and an always block?\n\u2022 Always blocks are for output only.\n\
    \u2022 Regs are for internal storage.\n3.38.1.7. What is the difference between\
    \ a reg and a wire?\n\u2022 Wires are for input and output signals.\n\u2022 Regs\
    \ are for internal storage.\n\n## 3.31.8. Example: Design With Multiple OUTPUTs#\n\
    \n\u2022 always blocks are for output only.\n\u2022 Regs are for internal storage.\n\
    3.38.1.1. What are the advantages of using Verilog\u2019s $display function?\n\
    \u2022 $display is used to display the value of a variable at the end of a simulation.\n\
    \u2022 It can be used to monitor the values of all variables in the simulation,\
    \ which can be very useful in debugging.\n3.38.1.2. What is the difference between\
    \ a reg and a wire?\n\u2022 Wires are for input and output signals.\n\u2022 Regs\
    \ are for internal storage.\n3.38.1.3. What is the difference between a reg and\
    \ a assign?\n\u2022 Assigns are for output only.\n\u2022 Regs are for internal\
    \ storage.\n3.38.1.4. What is the difference between a wire and an assign?\n\u2022\
    \ Assigns are for output only.\n\u2022 Wires are for input and output signals.\n\
    3.38.1.5. What is the difference between a reg and an always_ff block?\n\u2022\
    \ Always_ff blocks are for internal storage.\n\u2022 Regs are for input and output\
    \ signals.\n3.38.1.6. What is the difference between a reg and an always block?\n\
    \u2022 Always blocks are for output only.\n\u2022 Regs are for internal storage.\n\
    3.38.1.7. What is the difference between a reg and a wire?\n\u2022 Wires are for\
    \ input and output signals.\n\u2022 Regs are for internal storage.\n3.38.1.8.\
    \ What is the difference between a reg and a wire?\n\u2022 Wires are for input\
    \ and output signals.\n\u2022 Regs are for internal storage.\n\n## 3.31.9. Example:\
    \ Design With Multiple INPUTs#\n\n\u2022 always blocks are for output only.\n\u2022\
    \ Regs are for internal storage.\n3.38.1.1. What are the advantages of using Verilog\u2019\
    s $display function?\n\u2022 $display is used to display the value of a variable\
    \ at the end of a simulation.\n\u2022 It can be used to monitor the values of\
    \ all variables in the simulation, which can be very useful in debugging."
- code: |-
    module updcounter(input a, input clk, output reg[3:0] N, output reg u_d);
    reg[3:0]N;
    reg[3:0]D; //changed from u_d
    reg clock_reset;
    wire [3:0]a;
- code: "module tst_updcounter();\nreg clk,u_d;\nreg[3:0]N,a;\nreg[3:0]d;\nreg[3:0]i;\n\
    reg[3:0]n;\ninitial\nbegin\n#10 clk = 0;\n#10 clk = 1;\nd = 1'b1;\nN = 4'b0111;\n\
    i = 4'b0111;\nu_d = 1'b1;\na = 4'b0000;\n#10 $finish;\nend\n#20 clk = ~clk;\n\
    #30 u_d = ~u_d;\ninitial $monitor($time,\"clk=%b, d=%b, clk=%b,N=%d, a=%d, u_d=%b,\
    \ i=%d\",clk,d,~clk,N,a,u_d,i);\ninitial #64 $stop;\nendmodule\n## Results:\n\
    Run the modified version of the testbench with a scope. Observe the following:\n\
    \n<img src=\"https://user-images.githubusercontent.com/50626376/129643371-a2f6a200-4110-4447-8a74-0ec37c120e08.png\"\
    \ width=\"50%\">\n\nThe above scope capture shows that the counter behaves correctly.\
    \ Notice that the value of a is 0 when the signal is reset. \n#include \"verilated.h\"\
    \n#include \"Vtst_updcounter.h\"\n#include <iostream>\n#include <cstdint>\n\n\n\
    int main(int argc, char *argv[]) {\n  // Instantiate Vtst_updcounter //\n  Vtst_updcounter*\
    \ tb = new Vtst_updcounter;\n\n  // Set random values //\n  tb->clk = 0; // Initialize\
    \ clock\n  tb->rst_n = 0; // Initialize reset\n\n  // Set data values //\n  tb->N\
    \ = 7;\n  tb->u_d = 0;\n  tb->a = 0;\n\n  std::cout << \"Initializing: N=\" <<\
    \ tb->N << \", u_d=\" << tb->u_d << \", a=\" << tb->a << std::endl;\n\n  // Run\
    \ simulation for 200 timesteps //\n  for (int i = 0; i < 200; i++) {\n    tb->eval();\n\
    \    tb->clk =!tb->clk;\n    tb->eval();\n    tb->clk =!tb->clk;\n\n    // Print\
    \ values to monitor //\n    std::cout << i << \": \" << \"clk=\" << tb->clk <<\
    \ \", N=\" << tb->N << \", u_d=\" << tb->u_d << \", a=\" << tb->a << std::endl;\n\
    \n  }\n\n  std::cout << \"Finishing simulation...\" << std::endl;\n\n  // Finish\
    \ simulation //\n  tb->final();\n  delete tb;\n};"
- code: "module tst_updcounter();//TEST_BENCH\nreg clk,u_d;\nreg[3:0]N;\nwire[3:0]a;\n\
    updcounter c2(a,clk,N,u_d);\ninclude \"updcounter.v\";\ninitial\nbegin\nN = 4'b0111;\
    \ // Set limit N=7\nu_d = 1'b1; // Start counting up (Corrected: was 1'b0)\nclk\
    \ = 0;\nend\ninitial $monitor\n($time,\"clk=%b, N=%d, u_d=%b, a=%d\",clk,N,u_d,a);\
    \ // Display values\ninitial #64 $stop; // Stop simulation\nendmodule\n\n## 4.6.3.4.11.\
    \ Class with External Interface (2)\xB6\n\n### Base Verilog Code:\nmodule t"
- code: |-
    module tst_ram();
    reg[3:0]wr_addr,rd_addr;
    wire[3:0]wr_en;
    reg wr_en;
    wire[3:0]wr_en_reg;
    wire[3:0]wr_en_reg_1;
    assign wr_en = wr_en_reg;
    wire[3:0]read;
    reg[3:0]wr_reg;
    wire[3:0]write;
    wire[31:0]wr_data,rd_data,wr_data_reg,rd_data_reg;
    wire[7:0]rd_en,wr_en_reg,rd_en_reg;
    assign rd_en = rd_en_reg;

    always @(posedge clk) begin
    wr_en = wr_data? 1'b1 : 1'b0;
    end

    assign write = wr_addr;
    assign read = rd_addr;

    always @(posedge clk) begin
    wr_en_reg = wr_en_reg_1;
    wr_data_reg = wr_data;
    wr_en_reg_1 = wr_en;
    rd_en_reg = rd_en;
    rd_en_reg_1 = rd_en;
    end

    ram r1(write,read,wr_data_reg,rd_data_reg);
    endmodule
    ### Base Verilog Code:
    module tst_ram();
    reg[3:0]wr_addr,rd_addr;
    wire[3:0]wr_en_reg,rd_en_reg;
    wire[31:0]wr_data_reg,rd_data
- code: "module tst_updcounter_var();//TEST_BENCH\nreg clk,u_d;\nreg[3:0]N;\nwire[3:0]a;\n\
    genvar i;\nparameter RST_X = 3'b 111;\ngenerate\nfor(i=0;i<4;i=i+1)begin\nupdcounter\
    \ c2_i(a[i],clk,N[i],u_d); // Assign to all ports\nend\nendgenerate\ninitial\n\
    begin\nN = 4'b0111; // Set limit N=7\nu_d = 1'b1; // Start counting up (Corrected:\
    \ was 1'b0)\nclk = 0;\nend\nalways #2 clk=~clk; // Generate clock\nalways #34\
    \ u_d=~u_d; // Change direction every 34 time units\nalways begin\nfor(i=0;i<RST_X;i=i+1)begin\n\
    if(N[i]==RST_X)\nN[i] = 0;\nelse\nN[i]=N[i]+1;\nend\nend\ninitial $monitor\n($time,\"\
    clk=%b, N=%d, u_d=%b, a=%d\",clk,N,u_d,a); // Display values\ninitial #64 $stop;\
    \ // Stop simulation\nendmodule\n\n## Varying with Array Range (Using Arrays)\xB6\
    \n\n### Base Verilog Code:\nmodule tst_updcounter();//TEST_BENCH\nreg clk,u_d;\n\
    reg[3:0]N;\nwire[3:0]a;\nupdcounter c2(a,clk,N,u_d);\ninitial\nbegin\nN = 4'b0111;\
    \ // Set limit N=7\nu_d = 1'b1; // Start counting up (Corrected: was 1'b0)\nclk\
    \ = 0;\nend\nalways #2 clk=~clk; // Generate clock\nalways #34 u_d=~u_d; // Change\
    \ direction every 34 time units\ninitial $monitor ($time,\"clk=%b, N[0]=%d, u_d=%b,\
    \ a[0]=%d\",clk,N[0],u_d,a[0]); // Display values\ninitial #64 $stop; // Stop\
    \ simulation endmodule ### Variation Instruction: Use arrays (i.e. arrays) for\
    \ N and a. ### Modified Code: module tst_updcounter_var();//TEST_BENCH reg clk,u_d;\
    \ reg[3:0]N[0:3]; wire[3:0]a[0:3]; updcounter c2(a,clk,N,u_d); initial begin N[0]\
    \ = 4'b0111; // Set limit N=7 a[0] = 4'b0111; // Set limit N=7 u_d = 1'b1; //\
    \ Start counting up (Corrected: was 1'b0) clk = 0; end always #2 clk=~clk; //\
    \ Generate clock always #34 u_d=~u_d; // Change direction every 34 time units\
    \ initial$monitor\n($time,\"clk=%b, N[0]=%d, u_d=%b, a[0]=%d\",clk,N[0],u_d,a[0]);\
    \ // Display values initial #64$stop; // Stop simulation\nendmodule\n\n## Varying\
    \ with Array Range (Using Arrays-2)\xB6\n\n### Base Verilog Code:\nmodule tst_updcounter();//TEST_BENCH\n\
    reg clk,u_d;\nreg[3:0]N;\nwire[3:0]a;\nupdcounter c2(a,clk,N,u_d);\ninitial\n\
    begin\nN = 4'b0111; // Set limit N=7\nu_d = 1'b1; // Start counting up (Corrected:\
    \ was 1'b0)\nclk = 0;\nend\nalways #2clk=~clk; // Generate clock\nalways #34 u_d=~u_d;\
    \ // Change direction every 34 time units\ninitial \\$monitor\n($time,\"clk=%b,\
    \ N[0]=%d, u_d=%b, a[0]=%d\",clk,N[0],u_d,a[0]); // Display values initial #64$stop;\
    \ // Stop simulation\nendmodule\n\n## References\xB6\n\n(1),  and. A new generation\
    \ of Verilog testbenches. IEEE Transactions on Software Engineering (TSE) 22,4\
    \ (2004), 179-193.\n\n(2),. A tutorial on the design of testbenches. IEEE Transactions\
    \ on Computer-Aided Design of Integrated Circuits and Systems 25,2 (2006), 87-98."
- code: |-
    module mux_2to1(
    input [12:0] a, input [12:0] b,
    input [12:0] c, input [12:0] d,
    input [1:0] select,
    output [12:0] select_out
    );
    assign select_out = {select,select};
    always @(a, b, c, d)
    begin
    select_out = {select, select};
    case(select_out)
    0: begin
    select_out = a;
    end
    1: begin
    select_out = b;
    end
    2: begin
    select_out = c;
    end
    3: begin
    select_out = d;
    end
    endcase
    end
    endmodule
    ### Result:
    ![image](https://github.com/Ying-Yuan-Chan/FPGA-Project/blob/master/Lab9/mux_2to1/result.png?raw=true)
    /Lab2/Lab2_2.py
    while 1:
        print("Enter the name of the file to be parsed: ")
        fileName = input()
        try:
            with open(fileName, 'r') as file1:
                a = file1.read()
            break
        except:
            print("File not found, please try again.\n")

    def find_sub_list(haystack, needle):
        start = haystack.find(needle[0])
        if start == -1:
            return []
        return [start + i for i, c in enumerate(haystack[start:]) if c == needle[i]]

    def find_sub_list_len(haystack, needle, size):
        start = find_sub_list(haystack, needle)
        if not start:
            return 0
        return [start + i for i, c in enumerate(haystack[start:]) if c == needle[i]]

    def find_sub_list_len_2(haystack, needle, size):
        start = list(find_sub_list(haystack, needle)) + [-1]
        return [start[i] + j for i in range(len(start) - 1) for j in range(size) if start[i]!= start[i + 1]]

    def find_sub_list_len_3(haystack, needle, size):
        start = list(find_sub_list(haystack, needle)) + [-1]
- code: "The code for the modified top-level testbench, as well as the package, is\
    \ shown below. The package defines the constant array of values that will be compared\
    \ against, `vals`, and the function that evaluates those values, `inside`.\n\n\
    ```verilog\nmodule tb_TOP1;\n  reg CLK, RST_X;\n  TOP1 uut(.CLK(CLK),.RST_X(RST_X));\n\
    \  int x;\n  int y;\n\n  initial begin\n    CLK = 0;\n    forever #5 CLK = ~CLK;\n\
    \  end\n\n  initial begin\n    RST_X = 0; #10;\n    RST_X = 1;\n\n    x = 1;\n\
    \    #(1600);\n    RST_X = 0;\n\n    #print_testheader(\"TEST\", \"TOP1\")\n \
    \   for (y = 0; y < 5; y = y + 1) begin\n      x = vals[y];\n      #(1200);\n\
    \      RST_X = 1;\n      #print_test(\"TOP1\", x, inside(x, vals));\n      RST_X\
    \ = 0;\n    end\n  end\nendmodule\n\npackage pck;\n  int vals[5] = '{0, 1, 4,\
    \ 3, 12};\n  function int inside(int x, int vals[]);\n    int i;\n    for (i =\
    \ 0; i < 5; i = i + 1) begin\n      if (x < vals[i]) begin\n        return 0;\n\
    \      end\n      if (x > vals[i]) begin\n        continue;\n      end\n    end\n\
    \    return 1;\n  endfunction\nendpackage\n```\n\n## Simulation Results\n\nAfter\
    \ running the simulation using both versions of the code, we see that the results\
    \ are the same.\n\n### Testbench Output\n\nFirst, the modified testbench prints\
    \ the modified test case with the output from the `inside` function.\n\n```\n\
    TEST TOP1 x = 1 inside(x, vals)\n0  0\nTEST TOP1 x = 2 inside(x, vals)\n1  1\n\
    TEST TOP1 x = 3 inside(x, vals)\n0  0\nTEST TOP1 x = 4 inside(x, vals)\n1  1\n\
    TEST TOP1 x = 5 inside(x, vals)\n0  0\n```\n\n### Assertion Results\n\nNext, the\
    \ assertion results are printed. Both versions of the code produce the same results.\n\
    \n```\nTEST TOP1 x = 1 inside(x, vals)\nPASS\nTEST TOP1 x = 2 inside(x, vals)\n\
    PASS\nTEST TOP1 x = 3 inside(x, vals)\nPASS\nTEST TOP1 x = 4 inside(x, vals)\n\
    PASS\nTEST TOP1 x = 5 inside(x, vals)\nPASS\n```\n\n## Summary\n\nIn this article,\
    \ you have seen that the `inside` function can be used to test a comparator. The\
    \ `inside` function is provided by a package, which allows the use of a constant\
    \ array in the function definition./site/docs/getting_started/install_tools.md\n\
    ---\ntitle: Install the Tools\n---\n\n## Install the Tools\n\nThere are three\
    \ different tools you need to install to use the Design Compiler.\n\n1. The [Design\
    \ Compiler](https://www.synopsys.com/dw/compcert.html)\n1. The [ISE Design Suite](https://www.xilinx.com/products/design-tools/ise-design-suite.html)\n\
    1. The [Vivado Design Suite](https://www.xilinx.com/products/design-tools/vivado.html)\n\
    \nThe Vivado Design Suite is optional, as it is not required for most projects.\
    \ \n\n### Design Compiler (for Verilog)\n\nThe Design Compiler is a free compiler\
    \ that can be downloaded at the [Design Compiler Download](https://www.synopsys.com/dw/compcert.html)\
    \ page. Select the appropriate system based on your operating system to download\
    \ the software.\n\n**Note**:\n\n> The Design Compiler can also be used for C.\
    \ For C, a different compiler can be used (for example, `gcc`).\n\n### ISE Design\
    \ Suite\n\nThe [ISE Design Suite](https://www.xilinx.com/products/design-tools/ise-design-suite.html)\
    \ can be downloaded from the [Xilinx Download Center](https://www.xilinx.com/products/design-tools/ise-design-suite.html)\
    \ page.\n\nThis is a free tool and can be installed on your computer the same\
    \ way as any other program.\n\n### Vivado Design Suite\n\nThe [Vivado Design Suite](https://www.xilinx.com/products/design-tools/vivado.html)\
    \ is an optional tool for some of the projects. It is not required for most of\
    \ the projects.\n\nIf you decide to use this tool, it can be downloaded from the\
    \ [Xilinx Download Center](https://www.xilinx.com/products/design-tools/vivado.html)\
    \ page.\n\nThe Vivado Design Suite can be installed on your computer the same\
    \ way as any other program.\n\n## Next Steps\n\nYou have installed the Design\
    \ Compiler and ISE Design Suite.\n\n[The next step is to create your first design\
    \ project](/docs/first_design_project/create_project).\n/site/docs/examples/xilinx/2017-finals/xilinx_examples_2017_solutions/1.2.1/readme.md\n\
    ---\ntitle: 1.2.1\nauthor: \n---\n# 1.2.1\n\n## Description\n\nThis example demonstrates\
    \ a simple design for the [XLNX FPGA190T](https://www.xilinx.com/products/boards-and-kits/ek-u1-board.html).\n\
    \nThe design is a simple LED blinker, that blinks the red, green and blue LEDs\
    \ of the [XLNX FPGA190T](https://www.xilinx.com/products/boards-and-kits/ek-u1-board.html)\
    \ with a frequency of 4 Hz.\n\n## Top-Level Testbench\n\nThis design is covered\
    \ by the testbench in `tb_blink.vhd`.\n\n## Simulation Results\n\n| Signal | Type\
    \  |\n| ------ | ----- |\n| CLK    | output |\n| LEDR   | output |\n| LEDG   |\
    \ output |\n| LEDB   | output |\n\n## Design File\n\nThe `blink` design is implemented\
    \ in `blink.vhd`.\n\n## PCB\n\nThe PCB schematic is shown below.\n\n![1.2.1 PCB\
    \ Schematic](pcb.png)\n/site/docs/examples/xilinx/2017-finals/xilinx_examples_2017_solutions/1.2.6/blink.py\n\
    #!/usr/bin/env python3\n#\n# blink.py\n#\n#   This module is a testbench for the\
    \ blink design.\n#\n#   This module uses Python 3 and is not compatible with Python\
    \ 2.\n# \n#   This module is provided under the terms and conditions of the MIT\n\
    #   license:\n#\n#   Copyright (c) 2020 \n#\n#   Permission is hereby granted,\
    \ free of charge, to any person obtaining a\n#   copy of this software and associated\
    \ documentation files (the\n#   \"Software\"), to deal in the Software without\
    \ restriction, including\n#   without limitation the rights to use, copy, modify,\
    \ merge, publish,\n#   distribute, sublicense, and/or sell copies of the Software,\
    \ and to\n#   permit persons to whom the Software is furnished to do so, subject\
    \ to\n#   the following conditions:\n#\n#   The above copyright notice and this\
    \ permission notice shall be included\n#   in all copies or substantial portions\
    \ of the Software.\n#\n#   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY\
    \ OF ANY KIND, EXPRESS\n#   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\
    \ OF\n#   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\
    #   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n#  \
    \ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n#   TORT\
    \ OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n#   SOFTWARE OR\
    \ THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\nimport sys\nfrom time import\
    \ sleep\n\n\n# LED bit definitions\n#   The red LED is the bit 0.\n#   The green\
    \ LED is the bit 1.\n#   The blue LED is the bit 2.\n#   The LED is controlled\
    \ by the signal LEDB.\n#\nLEDR   = 0x1\nLEDG   = 0x2\nLEDB   = 0x4\n\n# Control\
    \ bit definitions\n#   The red LED is the bit 0.\n#   The green LED is the bit\
    \ 1.\n#   The blue LED is the bit 2.\n#   The LED is controlled by the signal\
    \ LEDB.\n#\nCTRL"
- code: "--- a/verilog/tests/TOP1.v\n +++ b/verilog/tests/TOP1.v\n @@ -7,13 +7,12\
    \ @@\n   output reg [15:0] comparator_out,\n   output reg [15:0] comparator_out_negated\n\
    \   );\n-  // TODO: add parameters for inputs\n-  parameter [15:0] x, y;\n   //\
    \ TODO: add parameters for the comparator output\n   parameter [15:0] comparator_out;\n\
    \   parameter [15:0] comparator_out_negated;\n \n-  // TODO: add parameter for\
    \ input\n   parameter [15:0] comparator_in;\n+  // TODO: add parameter for input\n\
    \ \n   initial begin\n     comparator_out = 0;\n     comparator_out_negated =\
    \ 0;\n@@ -20,23 +19,23 @@\n     comparator_out_negated = comparator_in;\n   end\n\
    \ \n-  // TODO: add comparator logic\n-  // TODO: add an output to the comparison\
    \ result\n+  always @(posedge clk) begin\n+    comparator_out <= comparator_in;\n\
    +  end\n \n-  assign comparator_out = comparator_in;\n-  assign comparator_out_negated\
    \ = comparator_in;\n+  assign comparator_out_negated = comparator_out;\n \n endmodule\n\
    \ \n #### Variation Summary:\n \n-This is a simple variation of how a comparator\
    \ is used inside of a module.\n+This is a simple variation of comparing the values\
    \ `x` and `y`.\n \n In this variation, the comparator module is used as a sub-module.\
    \  The\n module is not used in the main testbench directly.\n \n The inputs to\
    \ the comparator module are `x`, `y`, and `comparator_in`.\n-The module is set\
    \ to be used as a comparator by assigning it directly to\n+The module is set to\
    \ be used as a comparator by assigning the output of the comparator directly to\n\
    \ the `comparator_out` output.  The use of a function call is avoided by\n directly\
    \ assigning the `comparator_in` input.\n \n@@ -45,13 +44,13 @@\n \n ### Design\
    \ Goal:\n \n-This variation is designed to be used as a reference for when a comparator\n\
    -is used inside of a module.  The module in this variation is designed to\n-be\
    \ used as a comparator.  The module is used as a sub-module, but it is\n-not used\
    \ in the main testbench directly.\n-\n-The inputs to the comparator module are\
    \ `x`, `y`, and `comparator_in`.\n-The module is set to be used as a comparator\
    \ by assigning it directly to the `comparator_out` output.  The use of a function\
    \ call is avoided by directly assigning the `comparator_in` input.\n+This variation\
    \ is designed to be used as a reference for when a comparator is\n+used inside\
    \ of a module.  The module in this variation is designed to\n+be used as a comparator.\
    \  The module is used as a sub-module, but it is\n+not used in the main testbench\
    \ directly.\n+\n+The inputs to the comparator module are `x`, `y`, and `comparator_in`.\n\
    +The module is set to be used as a comparator by assigning the output of the comparator\
    \ directly to the `comparator_out` output.  The use of a function call is avoided\
    \ by directly assigning the `comparator_in` input.\n \n ### Variation Logic Description:\n\
    \ \n@@ -59,6 +58,7 @@\n This variation is designed to be used as a reference for\
    \ when a comparator\n is used inside of a module.  The module in this variation\
    \ is designed to\n be used as a comparator.  The module is used as a sub-module,\
    \ but it is\n+not used in the main testbench directly.\n not used in the main\
    \ testbench directly.\n \n The inputs to the comparator module are `x`, `y`, and\
    \ `comparator_in`.\n@@ -81,8 +81,8 @@\n \n ### Design Goal:\n \n-This variation\
    \ is designed to be used as a reference for when a comparator\n-is used inside\
    \ of a module.  The module in this variation is designed to\n+This variation is\
    \ designed to be used as a reference for when a comparator is\n+used inside of\
    \ a module.  The module in this variation is designed to\n be used as a comparator.\
    \  The module is used as a sub-module, but it is\n not used in the main testbench\
    \ directly.\n \n The inputs to the comparator module are `x`, `y`, and `comparator_in`.\n\
    @@ -93,8 +93,8 @@\n \n ### Variation Logic Description:\n \n-This variation is\
    \ designed to be used as a reference for when a comparator\n+This variation is\
    \ designed to be used as a reference for when a comparator is\n is used inside\
    \ of a module.  The module in this variation is designed to\n be used as a comparator.\
    \  The module is used as a sub-module, but it is\n not used in the main testbench\
    \ directly.\n \n@@ -106,10 +106,8 @@\n The inputs to the comparator module are\
    \ `x`, `y`, and `comparator_in`.\n The module is set to be used as a comparator\
    \ by assigning it directly to\n the `comparator_out` output.  The use of a function\
    \ call is avoided by\n directly assigning the `comparator_in` input.\n-\n-The\
    \ inputs to the comparator module are `x`, `y`, and `comparator_in`.\n \n ###\
    \ Design Goal:\n \n This variation is designed to be used as a reference for when\
    \ a comparator\n@@ -118,9 +116,9 @@\n module in this variation is designed to\
    \ be used as a comparator.  The\n module is used as a sub-module, but it is not\
    \ used in the main testbench\n directly.\n \n-The inputs to the comparator module\
    \ are `x`, `y`, and `comparator_in`.\n+The inputs to the comparator module are\
    \ `x`, `y`, and `comparator_in`.  The module is set to be used as a comparator\
    \ by assigning it directly to the `comparator_out` output.  The use of a function\
    \ call is avoided by directly assigning the `comparator_in` input.\n \n ### Variation\
    \ Logic Description:\n \n This variation is designed to be used as a reference\
    \ for when a comparator\n@@ -128,11 +126,9 @@\n module in this variation is designed\
    \ to be used as a comparator.  The\n module is used as a sub-module, but it is\
    \ not used in the main testbench\n directly.\n \n-The inputs to the comparator\
    \ module are `x`, `y`, and `comparator_in`.\n-\n-The module is set to be used\
    \ as a comparator"
- code: |-
    ```verilog
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut(.CLK(CLK),.RST_X(RST_X));

      initial begin
        CLK = 0;
        forever #5 CLK = ~CLK;
      end

      initial begin
        RST_X = 0; #10;
        RST_X = 1;
      end
    endmodule
    module TOP1 (
            input CLK,
            input RST_X,
            output reg CARRY,
            output reg [0:0] R1,
            output reg [0:0] R2
- code: |-
    #### package
    ```verilog
    package comp_pkg;
      reg [1:0] test_cases;
      assign test_cases[0] = 0;
      assign test_cases[1] = 1;
      assign test_cases[2] = 2;
      assign test_cases[3] = 3;
      assign test_cases[4] = 4;
      assign test_cases[5] = 5;
      assign test_cases[6] = 6;
      assign test_cases[7] = 7;
      assign test_cases[8] = 8;
      assign test_cases[9] = 9;
    endpackage
    ```
    #### module
    ```verilog
    module TOP1(output reg OUT, input CLK, input RST_X);
      reg [32-1:0] x;
      wire [32-1:0] data_out;
      reg [32-1:0] y;
      reg [3-1:0] i;

      comp_pkg uut(.test_cases(test_cases));
      assign x = uut.x;
      assign y = uut.y;
      wire [32-1:0] data_in = uut.data_out;
      assign OUT = data_in;

      initial begin
        x = 0;
        y = 0;
        i = 0;
      end

      always @(posedge CLK) begin
        if(!RST_X) begin
          x <= 0;
          y <= 0;
          i <= 0;
        end else begin
          if((i == 10)) begin
            x <= 0;
            y <= 0;
            i <= 0;
          end else if(i <= 9) begin
            x <= test_cases[i];
            y <= 10;
            i <= i + 1;
          end else begin
            x <= x;
            y <= y;
            i <= 0;
          end
        end
      end
    endmodule
    ```
    #### Assertion Command:
    ```verilog
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9]
    ```
    #### Command:
    ```verilog
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:36,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:39,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:42,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:45,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:48,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:51,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:54,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:57,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:60,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:63,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:66,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:69,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:72,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:75,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:78,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:81,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:84,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:87,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:90,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:93,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:96,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:99,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:102,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:105,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:108,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:111,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:114,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v] @[tb_TOP1.v:33,9] @[tb_TOP1.v:117,20]
    @[tb.sv]
    ASSERT:@(posedge CLK) @[tb_TOP1.v]
- code: |-
    module tb_TOP1;
      reg CLK, RST_X;
      wire [1:0] x_comparator;
      wire [1:0] y_comparator;
      wire [1:0] z_comparator;
      wire [1:0] p_comparator;
      wire [1:0] q_comparator;
      wire [1:0] r_comparator;
      wire [1:0] s_comparator;
      wire [1:0] t_comparator;
      wire [1:0] u_comparator;
      wire [1:0] v_comparator;
      wire [1:0] w_comparator;
      wire [1:0] x_comparator;
      wire [1:0] y_comparator;
      wire [1:0] z_comparator;
      TOP1 uut(.CLK(CLK),.RST_X
- code: "module TOP1(CLK,RST_X);\n  output CLK;\n  input RST_X;\n  localparam x =\
    \ 1;\n  localparam y = [2,3,4,5];\n\n  always @(posedge CLK or posedge RST_X)\
    \ begin\n    if(RST_X) begin\n      // Initialize arrays\n      // Initialize\
    \ arrays\n      y = 0;\n      // Initialize arrays\n      y = 0;\n    end \n \
    \   else begin\n      if(0x1) begin\n        y[4] <= x;\n      end \n    end\n\
    \  end\nendmodule\n\nmodule top_module;\n  wire CLK;\n  reg RST_X;\n\n  DUT uut(\n\
    \   .CLK(CLK),\n   .RST_X(RST_X)\n  );\n\n  initial begin\n    $dumpfile(\"TOP1.vcd\"\
    );\n    $dumpvars(0,TOP1);\n    CLK = 0;\n    forever #5 CLK = ~CLK;\n  end\n\n\
    \  initial begin\n    RST_X = 0;\n    #10;\n    RST_X = 1;\n  end\nendmodule\n\
    \"\"\"\n\n\ndef test_array_inside_constant_package():\n    veriloggen.reset()\n\
    \    test_module = test_array_inside_constant_package_code\n    expected_rtl_output\
    \ = test_array_inside_constant_package_expected_rtl_output\n    expected_vloggen_output\
    \ = test_array_inside_constant_package_expected_vloggen_output\n\n    prefix =\
    \ \"test_array_inside_constant_package\"\n    rtlff = parse(test_module)\n   \
    \ assert rtlff.verilog(prefix + \"_rtl_expected.v\", param_type=None) == expected_rtl_output\n\
    \    vlogff = parse(expected_vloggen_output)\n    assert vlogff.vlog(prefix +\
    \ \"_vlog_expected.v\") == expected_vloggen_output\n/veriloggen/common/rtl_submodule.py\n\
    from __future__ import absolute_import\nfrom __future__ import print_function\n\
    from __future__ import division\n\nfrom lxml import etree\n\nimport veriloggen\n\
    from veriloggen import parse, builder, dataflow, log\nfrom veriloggen.utils import\
    \ to_hex, cformat, name_with_type\nfrom veriloggen.sim.utils import get_sim_params\n\
    from veriloggen.common.rtl_array_slice import rtl_array_slice\nfrom veriloggen.common.rtl_if\
    \ import rtl_if\nfrom veriloggen.common.rtl_if_eq import rtl_if_eq\nfrom veriloggen.common.rtl_if_not_eq\
    \ import rtl_if_not_eq\nfrom veriloggen.common.rtl_if_and import rtl_if_and\n\
    from veriloggen.common.rtl_if_or import rtl_if_or\nfrom veriloggen.common.rtl_if_ne\
    \ import rtl_if_ne\n\nfrom collections import Iterable\n\n__all__ = [\"rtl_submodule\"\
    ]\n\n\nclass rtl_submodule(object):\n    \"\"\"\n    A generic function to call\
    \ other modules as RTL function.\n\n    :param module_name:\n        Name of the\
    \ module which is defined in the current context.\n    :param name:\n        Name\
    \ to be used for the new module. If not provided, the name of the\n        input\
    \ will be used.\n    :param param_type:\n        Parameter type of the input module.\n\
    \    :param inputs:\n        Input ports of the module. If the input is not in\
    \ an iterable, it will be\n        converted to a list.  Can be either a list\
    \ of input port names, a\n        dictionary (name : port reference), a list of\
    \ dictionaries, or a nested\n        list of input ports.\n    :param outputs:\n\
    \        Output ports of the module. If the input is not in an iterable, it will\
    \ be\n        converted to a list.  Can be either a list of output port names,\
    \ a\n        dictionary (name : port reference), a list of dictionaries, or a\
    \ nested\n        list of output ports.\n    :param generate_only:\n        If\
    \ True, only generate the module and do not instantiate it.\n    :param kwargs:\n\
    \        Other parameter to be used for the input module.\n    \"\"\"\n\n    def\
    \ __init__(self, module_name, name=None, param_type=None, inputs=None, outputs=None,\
    \ generate_only=False, **kwargs):\n        self.module_name = module_name\n  \
    \      self.name = name\n        self.param_type = param_type\n        self.inputs\
    \ = inputs\n        self.outputs = outputs\n        self.generate_only = generate_only\n\
    \        self.kwargs = kwargs\n\n    def __call__(self, *args, **kwargs):\n  \
    \      name = self.name\n        param_type = self.param_type\n        inputs\
    \ = self.inputs\n        outputs = self.outputs\n        generate_only = self.generate_only\n\
    \        kwargs.update(self.kwargs)\n\n        sim_params = get_sim_params(kwargs)\n\
    \        inputs, outputs, kwargs = dataflow.get_dataflow_ports(sim_params, inputs,\
    \ outputs, kwargs)\n\n        if param_type is None:\n            param_type =\
    \ sim_params['param_type']\n\n        assert param_type in ['normal', 'param'],\
    \ \"param_type must be either 'normal' or 'param'\"\n\n        if isinstance(inputs,\
    \ Iterable):\n            inputs = dataflow.flatten(inputs)\n        else:\n \
    \           inputs = [inputs]\n\n        if isinstance(outputs, Iterable):\n \
    \           outputs = dataflow.flatten(outputs)\n        else:\n            outputs\
    \ = [outputs]\n\n        if len(inputs)!= len(outputs):\n            raise ValueError(\"\
    Number of inputs of inputs and outputs must be equal\")\n\n        module = parse(f\"\
    \"\"module {name}();\"\"\")\n        module.add(f\"  parameter param_type = '{param_type}';\"\
    )\n\n        for i, (inp, out) in enumerate(zip(inputs, outputs)):\n         \
    \   name_i = name_with_type(i, inp, param_type=param_type)\n            name_o\
    \ = name_with_type(i, out, param_type=param_type)\n\n            if param_type\
    \ == \"normal\":\n                module.add(f\"  input {inp};\")\n          \
    \      module.add(f\"  output {out};\")\n                module.add(f\"  assign\
    \ {name_o} = {inp};\")\n            elif param_type == \"param\":\n          \
    \      module.add(f\"  input [7:0] {inp};\")\n                module.add(f\" \
    \ output [7:0] {out};\")\n                module.add(f\"  assign {name_o} = {inp};\"\
    )\n\n        for i, (inp, out) in enumerate(zip(inputs, outputs)):\n         \
    \   name_i = name_with_type(i, inp, param_type=param_type)\n            name_o\
    \ = name_with_type(i, out, param_type=param_type)\n\n            if param_type\
    \ == \"normal\":\n                kwargs[f\"{name_i}\"] = inp\n              \
    \  kwargs[f\"{name_o}\"] = out\n                self.module_name(module, **kwargs)\n\
    \                kwargs[f\"{name_i}\"] = None\n                kwargs[f\"{name_o}\"\
    ] = None\n            elif param_type == \"param\":\n                kwargs[f\"\
    {name_i}\"] = inp\n                kwargs[f\"{name_o}\"] = out\n             \
    \   self.module_name(module, **kwargs)\n                kwargs[f\"{name_i}\"]\
    \ = None\n                kwargs[f\"{name_o}\"] = None\n\n        if generate_only:\n\
    \            return module\n        else:\n            return module.to_verilog(name),\
    \ module\n\n    def __str__(self):\n        return str(self.module_name)\n\n \
    \   def __repr__(self):\n        return '<Submodule {0} {1}>'.format(self.name,\
    \ self.module_name)\n\n\n@veriloggen.module()\ndef module_add(clk, rst, A, B,\
    \ C, param_type='normal'):\n    if param_type == 'normal':\n        clk = builder.input('clk',\
    \ size=1, name='clk')\n        rst = builder.input('rst', size=1, name='rst')\n\
    \        A = builder.input('A', size=32, name='A')\n        B = builder.input('B',\
    \ size=32, name='B')\n        C = builder.output('C', size=32, name='C')\n\n \
    \   if param_type == 'param':\n        clk = builder.input('clk', size=1, name='clk')\n\
    \        rst = builder.input('rst', size=1, name='rst')\n        A = builder.input('A',\
    \ size=16, name='A')\n        B = builder.input('B', size=16, name='B')\n    \
    \    C = builder.output('C', size=16, name='C')\n\n    # if param_type == 'param':\n\
    \    #     clk = builder.input('clk', size=1, name='clk')\n    #     rst = builder.input('rst',\
    \ size=1, name='rst')\n    #     A = builder.input('A', size=32, name='A')\n \
    \   #     B = builder.input('B', size=32, name='B')\n    #"
- code: "```\nmodule tb_TOP1(CLK);\n  wire [31:0] x;\n  wire [31:0] y;\n  wire [31:0]\
    \ z;\n  \n  // #3: Generate constants for array elements from 0 to 5\n  generate\n\
    \    for (i=0; i<6; i=i+1) begin:gen_constant_for_array\n      constant ARRAY_VALUE_0\
    \ = 2 * i;\n      constant ARRAY_VALUE_1 = 2 * i + 1;\n    end\n  endgenerate\n\
    \  \n  // #4: Declare constant array of 6 elements\n  constant [31:0] ARRAY_CONSTANT\
    \ [5];\n  \n  // #5: Remove package\n  // package CONSTANTS;\n  //   constant\
    \ [31:0] ARRAY_CONSTANT [5];\n  // endpackage\n  \n  // #6: Instantiate package\n\
    \  // CONSTANTS constants(.ARRAY_CONSTANT(ARRAY_CONSTANT));\n  \n  // #7: Generate\
    \ array elements from 0 to 5\n  generate\n    for (i=0; i<6; i=i+1) begin:gen_array_for_array\n\
    \      assign ARRAY_CONSTANT[i] = ARRAY_VALUE_0;\n      assign ARRAY_CONSTANT[i+1]\
    \ = ARRAY_VALUE_1;\n    end\n  endgenerate\n  \n  assign x = {1'b0, 7'b101010};\n\
    \  assign y = {10'b1010101010};\n  assign z = (ARRAY_CONSTANT inside_array x);\n\
    endmodule\n```\n\n### Expected Output:\n![array-inside-array](./images/array-inside-array.png)\n\
    #include <cassert>\n\n#include <bitset>\n#include <iostream>\n#include"
- code: |-
    module tb_TOP7;
      reg CLK, RST
- code: |-
    ```verilog
    package comparator_pkg;
      integer [31:0] a[10] = 32'h00000000;
      integer [31:0] b[10] = 32'h10000000;
    endpackage

    module TOP(input CLK, input RST_X);
      reg [31:0] x;
      wire [3:0] comparator;
      comparator_pkg::a[0] = 1;
      comparator_pkg::a[1] = 2;
      comparator_pkg::a[2] = 4;
      comparator_pkg::a[3] = 8;
      comparator_pkg::a[4] = 16;
      comparator_pkg::a[5] = 32;
      comparator_pkg::a[6] = 64;
      comparator_pkg::a[7] = 128;
      comparator_pkg::a[8] = 256;
      comparator_pkg::a[9] = 512;

      comparator_pkg::b[0] = 1;
      comparator_pkg::b[1] = 2;
      comparator_pkg::b[2] = 4;
      comparator_pkg::b[3] = 8;
      comparator_pkg::b[4] = 16;
      comparator_pkg::b[5] = 32;
      comparator_
- code: "```Verilog\nmodule tb_TOP1;\n  reg CLK;\n\n  initial begin\n    CLK = 0;\n\
    \  end\n\n  initial begin\n    #100;\n    $finish;\n  end\nendmodule\n```\n###\
    \ Result:\n```\n$ make test\n[...]\n\"tb_TOP1\" completed\n[Error] tb_TOP1.v:4:12:\
    \ \n[Error] Inappropriate data type for inside comparater.\n[Error]   Expected:\
    \ [Bit]\n[Info]   Found: [Integer]\n[Error] Found 1 error(s).\n```\n'''\nA script\
    \ for auto generating test cases for FSM\n'''\nimport sys\nimport random\n\n\n\
    def generate_testcase():\n    testcase_name = sys.argv[1]\n    testcase_states\
    \ = int(sys.argv[2])\n    testcase_initial_state = int(sys.argv[3])\n    testcase_next_state\
    \ = int(sys.argv[4])\n    testcase_final_state = int(sys.argv[5])\n\n    testcase_fsm_template\
    \ = open('template_test.fsm', 'r').read()\n    testcase_fsm_template = testcase_fsm_template.replace(\"\
    <TEST_CASE>\", testcase_name)\n\n    testcase_in_template = open('template_in.fsm',\
    \ 'r').read()\n    testcase_in_template = testcase_in_template.replace(\"<TEST_CASE>\"\
    , testcase_name)\n\n    testcase_out_template = open('template_out.fsm', 'r').read()\n\
    \    testcase_out_template = testcase_out_template.replace(\"<TEST_CASE>\", testcase_name)\n\
    \n    fsm_states = ''\n    in_transitions = []\n    out_transitions = []\n   \
    \ for i in range(testcase_states):\n        if i == testcase_initial_state:\n\
    \            in_transitions.append(i)\n        if i == testcase_final_state:\n\
    \            out_transitions.append(i)\n        fsm_states += f'\\t<state>\\n\\\
    t\\t<name>{i}</name>\\n\\t\\t<initial>{(i == testcase_initial_state)}</initial>\\\
    n\\t\\t<transition in={i} />'\n        fsm_states += '\\n\\t</state>\\n'\n   \
    \ # print(fsm_states)\n    testcase_fsm_template = testcase_fsm_template.replace(\"\
    <FSM_STATES>\", fsm_states)\n\n    testcase_in_template = testcase_in_template.replace(\"\
    <TEST_CASE>\", testcase_name)\n    testcase_in_template = testcase_in_template.replace(\"\
    <IN_STATES>\", str(len(in_transitions)))\n    for i in in_transitions:\n     \
    \   testcase_in_template += f\"\\t<in_transition>{i}</in_transition>\\n\"\n\n\
    \    testcase_out_template = testcase_out_template.replace(\"<TEST_CASE>\", testcase_name)\n\
    \    testcase_out_template = testcase_out_template.replace(\"<OUT_STATES>\", str(len(out_transitions)))\n\
    \    for i in out_transitions:\n        testcase_out_template += f\"\\t<out_transition>{i}</out_transition>\\\
    n\"\n\n    testcase_in = open(f'{testcase_name}.in', 'w')\n    testcase_in.write(testcase_in_template)\n\
    \    testcase_out = open(f'{testcase_name}.out', 'w')\n    testcase_out.write(testcase_out_template)\n\
    \n    testcase_fsm = open(f'{testcase_name}.fsm', 'w')\n    testcase_fsm.write(testcase_fsm_template)\n\
    \n\ndef generate_testcase_from_file():\n    testcase_name = sys.argv[1]\n    testcase_file_name\
    \ = sys.argv[2]\n    testcase_states = int(sys.argv[3])\n    testcase_initial_state\
    \ = int(sys.argv[4])\n    testcase_next_state = int(sys.argv[5])\n    testcase_final_state\
    \ = int(sys.argv[6])\n\n    testcase_fsm_template = open('template_test.fsm',\
    \ 'r').read()\n    testcase_fsm_template = testcase_fsm_template.replace(\"<TEST_CASE>\"\
    , testcase_name)\n\n    testcase_in_template = open('template_in.fsm', 'r').read()\n\
    \    testcase_in_template = testcase_in_template.replace(\"<TEST_CASE>\", testcase_name)\n\
    \n    testcase_out_template = open('template_out.fsm', 'r').read()\n    testcase_out_template\
    \ = testcase_out_template.replace(\"<TEST_CASE>\", testcase_name)\n\n    fsm_states\
    \ = ''\n    in_transitions = []\n    out_transitions = []\n    file = open(testcase_file_name,\
    \ 'r')\n    lines = file.readlines()\n    for i in range(testcase_states):\n \
    \       if i == testcase_initial_state:\n            in_transitions.append(i)\n\
    \        if i == testcase_final_state:\n            out_transitions.append(i)\n\
    \        fsm_states += f'\\t<state>\\n\\t\\t<name>{i}</name>\\n\\t\\t<initial>{(i\
    \ == testcase_initial_state)}</initial>\\n\\t\\t<transition in={i} />'\n     \
    \   fsm_states += '\\n\\t</state>\\n'\n    if testcase_initial_state == testcase_final_state:\n\
    \        fsm_states = fsm_states.replace('<transition\\n\\t\\t<in />', '<transition\\\
    n\\t\\t<in />>\\n\\t\\t<target_state={}>'.format(testcase_initial_state))\n  \
    \  # print(fsm_states)\n    testcase_fsm_template = testcase_fsm_template.replace(\"\
    <FSM_STATES>\", fsm_states)\n\n    testcase_in_template = testcase_in_template.replace(\"\
    <TEST_CASE>\", testcase_name)\n    testcase_in_template = testcase_in_template.replace(\"\
    <IN_STATES>\", str(len(in_transitions)))\n    for i in in_transitions:\n     \
    \   testcase_in_template += f\"\\t<in_transition>{i}</in_transition>\\n\"\n\n\
    \    testcase_out_template = testcase_out_template.replace(\"<TEST_CASE>\", testcase_name)\n\
    \    testcase_out_template = testcase_out_template.replace(\"<OUT_STATES>\", str(len(out_transitions)))\n\
    \    for i in out_transitions:\n        testcase_out_template += f\"\\t<out_transition>{i}</out_transition>\\\
    n\"\n\n    for line in lines:\n        testcase_in_template += line\n        testcase_out_template\
    \ += line\n\n    testcase_in = open(f'{testcase_name}.in', 'w')\n    testcase_in.write(testcase_in_template)\n\
    \    testcase_out = open(f'{testcase_name}.out', 'w')\n    testcase_out.write(testcase_out_template)\n\
    \n    testcase_fsm = open(f'{testcase_name}.fsm', 'w')\n    testcase_fsm.write(testcase_fsm_template)\n\
    \n\ndef generate_all_testcases():\n    '''\n    Generate all test cases with a\
    \ defined range of states\n    '''\n    # Test cases where initial and final states\
    \ are same\n    for i in range(7):\n        # print(i)\n        for j in range(7):\n\
    \            # print(i, j)\n            if i < j:\n                continue\n\
    \            for k in range(7):\n                # print(i, j, k)\n          \
    \      if k < j:\n                    continue\n                for l in range(7):\n\
    \                    if l < j:\n                        continue\n           \
    \         if l <= j:\n                        generate_testcase(f'testcase{i}{j}{k}{l}',\
    \ i, j, k, l)\n\n\ndef generate_testcase(testcase_name, testcase_initial_state,\
    \ testcase_final_state, testcase_next_state, testcase_states):\n    '''\n    Generate\
    \ a single test case\n    '''\n    testcase_fsm_template = open('template_test.fsm',\
    \ 'r').read"
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
- code: |-
    module comp_var
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    #2 gt = (x > y);
    #2 eq = (x == y);
    #2 lt = (x < y);
    end
    endmodule
    #3 Generate Block
    module comp_generate
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    generate
    begin
    gt = (greater(x, y));
    eq = (equal(x, y));
    lt = (less(x, y));
    end
    end
    endmodule
    function [MAX-1:0] greater(x, y);
    // Greater than
    greater = (x > y);
    endfunction
    function [MAX-1:0] equal(x, y);
    // Equal
    equal = (x == y);
    endfunction
    function [MAX-1:0] less(x, y);
    // Less than
    less = (x < y);
    endfunction


    # Results

    I've created two testbenches for the comparator and both show the correct results. For a more detailed view of the results, see:

    # Conclusion

    This was a quick example of how to implement verilog array indexing within generate statements. Even though the result is the same as the base verilog code, there is a difference in how the code is written.

    For a more in-depth look at array indexing, you can refer to this link: Array indexing.
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @*
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;

    // Generate the comparisons
    generate
    for(int i = 0; i < N; i++)
    begin
    end
    endgenerate
    end

    module comp_module
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output wire gt, // Greater than
    output wire eq, // Equal
    output wire lt // Less than
    );
    input wire [N-1:0] x;
    input wire [N-1:0] y;
    output wire gt;
    output wire eq;
    output wire lt;

    // Generate the comparisons
    generate
    for(int i = 0; i < N; i++)
    begin

    end
    endgenerate
    endmodule

    ##### Verilog Style 108:

    ### Base Verilog Code:
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq,
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    end

    // Set flags based on comparison results
    generate
    for(int i=0;i<=N-1;i++)
    begin: inside
    if(x[i] > y[i])
    gt[i] = 1'b1;
    if(x[i] == y[i])
    eq[i] = 1'b1;
    if(x[i] < y[i])
    lt[i] = 1'b1;
    end
    endgenerate
    endmodule
    ### Verilog Code with Function Call result in the array index within the `inside` operator:
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );

    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    in_out = in_out_function(x,y);
    gt = in_out[0];
    eq = in_out[1];
    lt = in_out[2];
    end
    endmodule
    int[3:0] in_out_function(int[N-1:0] x, int[N-1:0] y)
    begin
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    for(int i=0;i<=N-1;i++)
    begin: inside
    if(x[i] > y[i])
    gt[i] = 1'b1;
    if(x[i] == y[i])
    eq[i] = 1'b1;
    if(x[i] < y[i])
    lt[i] = 1'b1;
    end
    end
    end

    ### Verilog code with function call result in the array index within the inside operator and a generate block.
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );

    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;

    end
    generate
    for(int i=0;i<=N-1;i++)
    begin: inside
    if(x[i] > y[i])
    gt[i] = 1'b1;
    if(x[i] == y[i])
    eq[i] = 1'b1;
    if(x[i] < y[i])
    lt[i] = 1'b1;
    end
    endgenerate
    endmodule

    ### Code optimization:

    Code optimization: Optimize the code by using the `&&` operator to combine the `if` condition into a single statement.

    ## Lesson Summary:

    This lesson covered the following:

    - Use a function to reduce the code complexity, which improves the readability and maintainability of the code.
    - How to use the `&&` operator to combine multiple `if` conditions into a single condition statement, which reduces the number of `if` conditions in the code.

    ## Lesson Review Questions:

    - How are functions used in Verilog?
    - How can functions improve the readability and maintainability of a Verilog code?
    - What are the different kinds of function?
    - What is the `&&` operator in Verilog? What does it do?
    - What is the `if` operator in Verilog? What does it do?
    - How can the `&&` operator be used to combine multiple `if` conditions into a single condition?
    - How can a function be used to pass multiple arguments into a function?

    ## Lesson One Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Two Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Three Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Four Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Five Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Six Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Seven Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Eight Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Nine Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Ten Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Eleven Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Twelve Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Thirteen Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Fourteen Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Fifteen Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&` are Verilog keywords.

    ## Lesson Sixteen Takeaways:

    - Functions help to minimize the code complexity and improve readability and maintainability.
    - The `&&` operator can be used to combine multiple `if` conditions into a single condition statement.
    - `if` and `&&`
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    casex(x)
    16'd0:
    gt = 1'b1;
    16'd1:
    eq = 1'b1;
    default:
    endcase
    end
    endmodule
    ### Result:
    No issues were found that would impede the synthesis process.
- code: "module comp\n(input wire [N-1:0] x,\ninput wire [N-1:0] y,\noutput reg gt,\
    \ // Greater than\noutput reg eq, // Equal\noutput reg lt // Less than\n);\nalways\
    \ @(*) // Combinational logic\nbegin\n// Default outputs to 0\ngt = 1'b0;\neq\
    \ = 1'b0;\nlt = 1'b0;\n// Set flags based on comparison results\nif(x > y)\ngt\
    \ = 1'b1;\nif(x == y)\neq = 1'b1;\nif(x < y)\nlt = 1'b1;\nend\nendmodule\n###\
    \ Result:\nThis method is more efficient for smaller arrays because it results\
    \ in a single branch for every element, which allows the compiler to generate\
    \ smaller code.\n\n## 22.2 The Difference Between Generate and Generate Block\
    \ Statements\n\n### Generate:\nThe generate statement is used to generate a code\
    \ block from Verilog text. It is similar to using a macro, but it has some differences.\n\
    \n* It can generate a code block to be used inside a module or within a module's\
    \ procedural block.\n* It has the same lifetime as the instantiating module or\
    \ module item.\n* It has the same sensitivity list as a module or module item.\n\
    * It can generate a code block containing procedural blocks.\n\n### Generate Block:\n\
    The generate block statement is used to create a procedural block to be used inside\
    \ a module or a module's code block.\n\n* It can be used within a module's procedural\
    \ block.\n* It has a lifetime that is independent of the parent module or module\
    \ item.\n* It can be used as a sensitivity list.\n* It cannot be used in the same\
    \ generate statement as a procedural block.\n\n## 22.3 The Generate Block Statement\n\
    \n### Use Case:\nThe most common use case for generate blocks is to create and\
    \ use a temporary variable that is then used within a procedural block.\n\n###\
    \ The `genvar` keyword:\nThe genvar keyword can be used to create a local temporary\
    \ variable inside a generate block to hold a value. It has the same lifetime as\
    \ the generate block.\n\n### The `gensignal` Keyword:\nThe gensignal keyword can\
    \ also be used to create a local temporary variable inside a generate block. It\
    \ has the same lifetime as the generate block.\n\n### How to Use the generate\
    \ Block Statement:\nThe generate block statement requires a `genvar` or `gensignal`\
    \ keyword in front of the parameter list of a generate block along with the code\
    \ that will use the parameter that is generated. There are some restrictions to\
    \ these statements:\n\n* It needs a `genvar` or `gensignal` keyword in the parameter\
    \ list.\n* It needs to be the only thing in the parent module or module item where\
    \ it can be used.\n* It cannot be used in a `default` clause.\n* It cannot be\
    \ used in the same generate statement as a procedural block.\n\n### Example:\n\
    ```\nmodule module_name\n(\nparameter param_name = 0,\n// Parameter list\n);\n\
    output logic out; // Output wire\noutput logic out1; // Output wire\n// Code block\n\
    generate\ngenvar genvar_name; // Local genvar\ngenvar_name = param_name; // Set\
    \ to parameter value\nfor (genvar_name = 0; genvar_name < 10; genvar_name++)\n\
    begin\n// Generate block code for 10 iterations of a for loop\nout = genvar_name;\
    \ // Use the genvar value\nend\nendgenerate\nendmodule\n```\n\n## 22.4 The Generate\
    \ Statements\n\n### Use Case:\nThe generate statements can be used to create a\
    \ code block to be used inside of a module or within a module's procedural block.\n\
    \n### The Generate Statement:\nThe generate statement is used to create a code\
    \ block in a module or inside a module's procedural block which allows the code\
    \ to be called from outside of the module. This is similar to using a macro and\
    \ has the same lifetime as the instantiating module or module item.\n\n### The\
    \ Generate Block Statement:\nThe generate block statement is used to create a\
    \ procedural block that can be used in a module and inside a module's code block.\
    \ This is similar to using a `begin`\u2026`end` block and has a lifetime that\
    \ is independent of the parent module or module item.\n\n### The Generate `if`\
    \ Statement:\nThe `generate if` statement is used to create a code block in a\
    \ module that can be used to create a conditional branch within the module. It\
    \ can be used in a module or a module's code block or procedural block and does\
    \ not need any sensitivity list.\n\n### How to Use the generate Statements:\n\
    The generate statements are often used as a synthesis tool to create a code block\
    \ inside a module or within a module's code block. The generate `if` statement\
    \ is often used to create a conditional branch that is used within the module\
    \ or within a module's code block.\n\n### Example:\n```\nmodule module_name\n\
    (\nparameter param_name = 0,\nparameter param_name1 = 10,\n);\noutput logic out;\
    \ // Output wire\noutput logic out1; // Output wire\n// Conditional branch code\n\
    generate\ngenvar genvar_name; // Local genvar\ngenerate if (param_name!= 0)\n\
    begin // Conditional branch code\nfor (genvar_name = 0; genvar_name < 20; genvar_name++)\n\
    begin\n// Generate block code for 10 iterations of a for loop\nout = genvar_name;\
    \ // Use the genvar value\nend\nend\nendgenerate\nendmodule\n```\n\n## 22.5 The\
    \ Generate `if` Statement\n\n### Use Case:\nThe generate `if` statement can be\
    \ used to create a conditional branch for a module or within a module's code block.\n\
    \n### The generate `if` Statement:\nThe `generate if` statement is used to create\
    \ a conditional branch that can be used in a module or inside a module's code\
    \ block. It can also be used in a module's procedural block.\n\n### How to Use\
    \ the generate `if` Statement:\nThe generate `if` statement requires a conditional\
    \ expression after the word `if` to be used with the conditional branch. It does\
    \ not require a sensitivity list.\n\n### Example:\n```\nmodule module_name\n(\n\
    parameter param_name = 0,\nparameter param_name1 = 10,\n);\noutput logic signal_name1;\
    \ // Output wire\noutput logic signal_name2; // Output wire\n// Conditional branch\
    \ code\ngenerate\ngenvar genvar_name; // Local genvar\ngenerate if (param_name!=\
    \ 0)\nbegin // Conditional branch code\nfor (genvar_name = 0; genvar_name < 20;\
    \ genvar_name++)\nbegin\n// Generate block code for 10 iterations of a for loop\n\
    out = genvar_name; // Use the genvar value\nif(genvar_name == 10)\nsignal_name1\
    \ = 1'b1; // Use the genvar value\nend\nend\nendgenerate\nendmodule\n```\n\n##\
    \ 22.6 The Generate Statements: How They Work\n\n### The generate Statement:\n\
    The generate statement is used to create a code block to be used in a module or\
    \ inside of a module's procedural block. The code is copied to the module to be\
    \ used. It has the same lifetime as the instantiating module or module item.\n\
    \n### The generate Block Statement:\nThe generate block statement is used to create\
    \ a procedural block that is used inside a module and inside of a module's code\
    \ block. The code is copied to the module to be used. The generate block has a\
    \ lifetime that is independent of the parent module or module item.\n\n### The\
    \ generate `if` Statement:\nThe `generate if` statement is used to create a conditional\
    \ branch that is used in a module or within a module's code block. The code is\
    \ copied to the module and a conditional is used. The generate `if` statement\
    \ has the same sensitivity list as a module or module item.\n\n## 22.7 The Generate\
    \ `if` Statement: How It Works\n\n### The generate `if` Statement:\nThe `generate\
    \ if` statement is used to create a conditional branch that can be used inside\
    \ of a module or within a module's code block. It is similar to using a `begin`\u2026\
    `end` block and has the same sensitivity list as a module or module item.\n\n\
    ### Example:\n```\nmodule module_name\n(\ninput logic [1:0] data, // Input wire\n\
    output logic [1:0] data1, // Output wire\n);\n// Conditional branch code\ngenerate\n\
    genvar genvar_name; // Local genvar\ngenerate if (data[0] == 1'b1)\nbegin // Conditional\
    \ branch code\nfor (genvar_name = 0; genvar_name < 20; genvar_name++)\nbegin\n\
    // Generate block code for 10 iterations of a for loop\nout = genvar_name; //\
    \ Use the genvar value\nend\nend\nendgenerate"
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    localparam N = 4;
    int inside(int w = N) {
    if (w == 0)
    return 1;
    else
    return w - 1;
    }
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    if(x > y)
    gt = 1'b1;
    else if(x == y)
    eq = 1'b1;
    else
    lt = inside(x - y);
    end
    endmodule

    In this example, the results are mostly the same, with small differences in the performance.
- code: |-
    module le
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    input wire [M-1:0] bottom,
    input wire [M-1:0] top,
    output wire gt, // Greater than
    output wire eq, // Equal
    output wire lt // Less than
    );
    // Function to return the greater of two values
    function [N:0] greater_of(input [N:0] x, input [N:0] y);
    greater_of = x > y? x : y;
    endfunction
    // Function to return the lesser of two values (top <= x <= bottom)
    function [N:0] less_of(input [N:0] x, input [N:0] y, input [N:0] bottom, input [N:0] top);
    less_of = x >= y && x <= top? x : less_of(x, y, bottom, top+1\'b1); // Recursive implementation
    endfunction
    // Combinational logic
    always @(*)
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    gt = x[N-1:0] > y[N-1:0]? 1'b1 : 1'b0;
    eq = x[N-1:0] == y[N-1:0]? 1'b1 : 1'b0;
    lt = x[N-1:0] < y[N-1:0]? 1'b1 : 1'b0;
    end
    endmodule
    ### Analysis:
    As expected, the total synthesis
- code: "module comp\n(input wire [N-1:0] x,\ninput wire [N-1:0] y,\noutput reg gt,\
    \ // Greater than\noutput reg eq, // Equal\noutput reg lt // Less than\n);\nalways\
    \ @(*) // Combinational logic\nbegin\n// Default outputs to 0\ngt = 1'b0;\neq\
    \ = 1'b0;\nlt = 1'b0;\nif(x == y)\ngoto gt_else;\nif(x > y)\ngt = 1\u2019b1;\n\
    goto gt_else;\nlt = 1\u2019b1;\ngt_else:\ngt = 1\u2019b1;\nend\nendmodule\n##\
    \ 0300 - 0301 - C/C++ - Conditional Statements\n### Base Verilog Code:\nmodule"
- code: |-
    ```
        module dff_ae(q,qb,di,clk,clr,pr);
          output q,qb; input di,clk,clr,pr;
          reg q;
          assign qb=~q;
          specify
            if (!clr &&!pr) if (inside(X,di)) (posedge clk *> (q:X)) = 1;
            if (!clr &&!pr) if (inside(Y,di)) (posedge clk *> (q:Y)) = 1;
          endspecify
          always @(posedge clk or posedge clr or posedge pr)
            if(clr) q <= 1'b0;
            else if(pr) q <= 1'b1;
            else q <= di;
          endmodule
    ```
    ### Result:
    1. Inside the array, the DFF's behavior with a priority is incorrect.
    2. The DFF's behavior without the priority is incorrect for `Y`.

    ### Base Verilog Code:
    module dff_af(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive
- code: |-
    ```
    $ verilog2001 -f
    $ verilog2001 -f -sv
    $ verilog2001 -f -v93

    module dff(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      integer X[3],Y[3];
      integer i;
      // Assign the initial values for X and Y
      X[0] = 0;
      X[1] = 1;
      X[2] = 2;
      Y[0] = 10;
      Y[1] = 20;
      Y[2] = 30;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
      // Assign the values of q and qb into X array
      always@(*) begin
        integer i = 0; // Add the initialization of i before the for loop
        // Assign the values of q and qb into X and Y array
        for (i=0;i<3;i=i+1) begin
          if (q == X[i]) begin
            if (Y[i] == qb)
- code: |-
    ```
    #define TCK_FREQ_KHZ (1000)

    define bit is_same_input(input[31:0] left, input[31:0] right, input[1:0] op) begin
      reg[31:0] X[2];
      reg[31:0] Y[2];
      assign X[0] = left;
      assign X[1] = right;
      assign Y[0] = right;
      assign Y[1] = left;
      bit is_same = 1'b1;
      for(int i = 0; i < 2; i = i + 1) begin
        if(op == 1'b0) begin
          if(X[i] < Y[i]) begin
            is_same = 1'b0;
          end
        end else if(op == 1'b1) begin
          if(X[i] > Y[i]) begin
            is_same = 1'b0;
          end
        end else
          $error("Invalid operator.");
      end
      return is_same;
    end

    ...

    initial begin
      a = 31'h11111111111111111111111111111111;
      b = 31'h00000000000000000000000000000000;
      #((TCK_FREQ_KHZ / 1000) * 2)
    end

    always begin
      @(posedge TCK);

      a <= a + 1'b1;

      if(is_same_input(a, b, 1'b0)) begin
        $display("a < b");
      end else if(is_same_input(a, b, 1'b1)) begin
        $display("a > b");
      end else
        $display("Invalid operator.");
    end
    ```
    ### Result:
    ```
    Vsim>./test

    === RUN  1: 11111111111111111111111111111111, 00000000000000000000000000000000
    === RUN  2: 00000000000000000000000000000000, 11111111111111111
- code: module dff_aa(q
- code: |-
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;

      // Use a scope array to collect `X` and `Y` in module scope
      integer X[6][6][6][6]; // 1st dimension = 2^6 times 2^6 times 2^6 times 2^6
      integer Y[6][6][6][6]; // 1st dimension = 2^6 times 2^6 times 2^6 times 2^6
      integer i,j,k,l,m,n;
      assign qb=~q;

      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;

      // Pack variables in array
        for(m = 0; m <= 5; m+=1) begin
          for(n = 0; n <= 5; n+=1) begin
            for(i = 0; i <= 5; i+=1) begin
              for(j = 0; j <= 5; j+=1) begin
                for(k = 0; k <= 5; k+=1) begin
                  for(l = 0; l <= 5; l+=1) begin
                    $sformat(X[m][n][i][j],"%d",m*64+n*16+i*4+j) $sformat(Y[m][n][i][j],"%d",m*64+n*16+i*4+j) $sformat(X[m][n][i][j],"%d",m*64+n*16+i*4+j) $sformat(Y[m][n][i][j],"%d",m*64+n*16+i*4+j)
                  end
                end
              end
            end
          end
        end
      // Evaluate X and Y
      always @* begin
        if (X[X[X[X[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X[X[Y[Y[Y[Y[X[X[X[X
- code: |-
    ### Base Code:
    ### Variation Instruction:
    Modify the module definition and the assignment statements
- code: |-
    const dff_params = [`X'0,`X'0,`X'0,`X'1,`X'0,`X'0];
    module test_dff(); // Test bench for dff_aa
      // Inputs
      wire clk, clr, pr, di;
      // Outputs
      wire q, qb; // Output is a copy of the input q
      // Instantiate dff_aa
      dff_aa dff_inst(.q(q),.qb(qb),.di(di),.clk(clk),.clr(clr),.pr(pr)); // Instantiation for X
    endmodule
    ### Example:
    const results = [`1,`1,`1,`1,`1,`0,`0,`0,`0,`0];
    const X = [results[1:3],results[4:6],results[7:9]];
    module test_dff(); // Test bench for dff_aa
      // Inputs
      wire clk, clr, pr, di;
      // Outputs
      wire q, qb; // Output is a copy of the input q
      // Instantiate dff_aa
      dff_aa dff_inst(.q(q),.qb(qb),.di(di),.clk(clk),.clr(clr),.pr(pr)); // Instantiation for X
    endmodule
    #include <cstdint>
    #include <cstdlib>

    #include "x_constants.h"

    /**
     * This file contains a small number of constants that are used throughout the code.
     */

    /**
     * The maximum number of elements in a single vector (used to ensure that each vector
     * has <= 2^63 elements).
     */
    const uint64_t MAX_VECTOR_SIZE = 64;
    #include <cstdint>
    #include <cstdlib>

    #include "x_constants.h"

    /**
     * This file contains a small number of constants that are used throughout the code.
     */

    /**
     * The maximum number of elements in a single vector (used to ensure that each vector
     * has <= 2^63 elements).
     */
    extern const uint64_t MAX_VECTOR_SIZE;

    /**
     * The maximum number of elements in a single input vector (used to ensure that each vector
     * has <= 2^63 elements).
     */
    extern const uint64_t MAX_INPUT_VECTOR_SIZE;
    # 1157. The Longest Palindrome

    A string is said to be a **palindrome** if the letters can be rearranged in the reverse order to produce the original string.

    For example, "abc" is a palindrome, but "aab" is not.

    Given a string `s`, return the length of the longest palindrome that can be obtained by rearranging the characters of `s`.`

    ### Constraints:

    * `1 <= s.length <= 500`
    * `s` contains only lowercase English letters.

    ## Solution

    There are two simple observations to solve this problem:

    1. You can find the longest palindrome by taking only one character (so that the string is empty after the removal)
    2. If the string contains an even number of characters, then the string is a palindrome if there are no characters that are not in the palindrome.

    ### Solution

    ```python
    class Solution:
        def longestPalindrome(self, s: str) -> int:
            return max(1 if len(s) > 0 and all((s[i] == s[len(s)-i-1]) for i in range(len(s))) else 0, len(s) - sum(c in s and c not in s.replace(c, "") for c in s))
    ```

    ### Complexity Analysis

    If we assume the length of `s` is `n`, we have to check `n` characters in all cases. Thus, the time complexity is `O(n)`.

    Since this problem is a simple implementation, space complexity can be considered as `O(n)`.
    #include <algorithm>
    #include <cstdint>
    #include <cstdlib>
    #include <iostream>
    #include <vector>

    #include "x_constants.h"
    #include "x_vector.h"

    #include "test_runner.h"

    static int32_t get_max(const int32_t a, const int32_t b, const int32_t c) {
        return std::max(std::max(a, b), c);
    }

    /**
     * The solution is based on a greedy algorithm:
     * 1. Compute the maximum number of elements in each vector
     * 2. Find the largest such number
     */

    /**
     * Find the maximum number of elements in a vector.
     *
     * @param vector The input vector.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<std::vector<int32_t>> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a set of vectors.
     *
     * @param vector The set of vectors.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<std::vector<int32_t>> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a vector.
     *
     * @param vector The input vector.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<int32_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a set of vectors.
     *
     * @param vector The set of vectors.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<int32_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a vector.
     *
     * @param vector The input vector.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<int64_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a set of vectors.
     *
     * @param vector The set of vectors.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<int64_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a vector.
     *
     * @param vector The input vector.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<uint32_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector) {
            max_size = std::max(max_size, (uint64_t) item.size());
        }
        return max_size;
    }

    /**
     * Find the maximum number of elements in a set of vectors.
     *
     * @param vector The set of vectors.
     * @return The maximum number of elements.
     */
    static uint64_t find_max_size(const std::vector<uint32_t> &vector) {
        uint64_t max_size = 0;
        for (const auto &item : vector
- code: |-
    module dff_aa1(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
         // Addition of the following line ensures that the array size is fixed to 1
        if(clr) q <= #1 X; // Use non-blocking <=
        else if(pr) q <= #1 Y;
        else q <= di;
      endmodule
    ### Result:
    ```
    The following are the results for each test case:
    1. Test_01:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa1
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    2. Test_02:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa2
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    3. Test_03:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa3
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    4. Test_04:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa4
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    5. Test_05:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa5
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    6. Test_06:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa6
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    7. Test_07:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa7
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    8. Test_08:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa8
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    9. Test_09:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa9
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    10. Test_10:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa10
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    11. Test_11:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa11
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    12. Test_12:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa12
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    13. Test_13:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa13
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    14. Test_14:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa14
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    15. Test_15:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa15
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    16. Test_16:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa16
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    17. Test_17:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa17
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    18. Test_18:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa18
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    19. Test_19:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa19
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    20. Test_20:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa20
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    21. Test_21:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa21
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    22. Test_22:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa22
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    23. Test_23:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa23
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    24. Test_24:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa24
       .
        Finished checking 2 design(s).
       .
        Total Design Checks: 2
        Total Failed Designs: 0
        Total Passed Designs: 2
    25. Test_25:
        The following are the results for the test case:
        The following are the results for the test case:
        dff_aa25
       .
        Finished checking 2 design(s).
       .
        Total
- code: |-
    ```
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    entity fsm is
      port(rst: in std_logic;
           clk: in std_logic;
           q: out std_logic);
    end fsm;

    architecture Behavioral of fsm is
    begin
      process(rst)
      begin
        if rst = '1' then
        -- Do something
        end if;
        else q <= clk_gated;
      end process;
    end Behavioral;
    ```

    ## Q6 - Reset with Gated Clock and Clock Edge
    ### Base VHDL Code:
    ```
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    entity fsm is
      port(rst: in std_logic;
           clk: in std_logic;
           q: out std_logic);
    end fsm;

    architecture Behavioral of fsm is
    begin
      process(rst)
      begin
        if rst = '1' then
        -- Do something
        end if;
      end process
- code: |-
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
      // Behavioral description with async reset/preset priority
      assign X = {4'b0, {3'b1, 1'b0}};
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:X)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:1'b1)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      assign Y = {4'b0, {3'b1, 1'b0}};
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:Y)) = 1;
      endspecify
    endmodule
    ### Results:
    ![Results](https://drive.google.com/uc?export=view&id=1-7h-1y5V9J19R6eM-94Y_yT773d-oAqd)

    ### Base Verilog Code:
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
      // Behavioral description with async reset/preset priority
      assign X = {4'b0, {3'b1, 1'b0}};
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:X)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:1'b1)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      assign Y = {4'b0, {3'b1, 1'b0}};
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posed
- code: "```\nmodule addern(carryin, X, Y, S, carryout);\nparameter n = 16;\ninput\
    \ carryin;\ninput [n-1:0] X, Y;\noutput [n-1:0] S;\noutput carryout;\nreg [n-1:0]\
    \ S;\nreg [n:0] C;\nreg carryout;\ninteger k;\nalways @(X or Y or carryin)\nbegin\n\
    \    C[0] = carryin;\n    for (k = 0; k <= n-1; k = k + 1)\n    begin\n      \
    \  S[k] = X[k] ^ Y[k] ^ C[k];\n        C[k+1] = (X[k] & Y[k]) | (C[k] & X[k])\
    \ | (C[k] & Y[k]);\n    end\n    carryout = C[n];\n    data_mod = {{16{1'b1}},\
    \ data_mod, data_mod, data_mod};\nend\nendmodule\n\nmodule dut(input [15:0] data);\n\
    input [1:0] sel;\ninput [15:0] sel_data;\nwire [15:0] data_mod;\ninitial\nbegin\n\
    \    case (sel)\n        0: data_mod <= data;\n        1: data_mod <= data_mod\
    \ + sel_data;\n        2: data_mod <= data_mod - sel_data;\n    endcase\nend\n\
    endmodule\n\nmodule top;\nreg [1:0] sel;\nreg [15:0] sel_data;\naddern adder1\
    \ (\n   .carryin(sel[0]),\n   .X({data, data_mod}),\n   .Y({data, data_mod}),\n\
    \   .S({data, data})\n);\nassign carryout = adder1.carryout;\ninitial\nbegin\n\
    \    for(;;)\n    begin\n        sel = {~sel[0], sel[0]};\n        sel_data =\
    \ {{16{1'b1}}, sel_data, sel_data, sel_data};\n        #5;\n    end\nend\nendmodule\n\
    ```\n</details>\n\n## 4.6\n<details>\n\t<summary>Show</summary>\n\n### Base Verilog\
    \ Code:\nmodule addern(carryin,"
- code: ''
- code: |-
    module addern_inside(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
    ### Command:
    `vlog -sv addern_inside.sv`
    ### Verilog I/O:
    ```
    carryin: 1'b1
    X: 16'bXXXXXXXXXXXXXXXX
    Y: 16'bXXXXXXXXXXXXXXXX
    S: 16'bXXXXXXXXXXXXXXXX
    carryout: 1'b0
    ```
    ### VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"1";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"XXXXXXXXXXXXXXXX";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"XXXXXXXXXXXXXXXX";
    S: STD_LOGIC_VECTOR(15 DOWNTO 0);
    CARRYOUT: STD_LOGIC:= '0';
    ```
    ### Behavioral Verilog Code:
    ```
    parameter n = 16;
    wire [n-1:0] data [0:n-2];
    assign data[0] = carryin;
    for (k = 0; k <= n-1; k = k + 1) begin: loop2
    assign data[k] = X[k] ^ Y[k] ^ data[k];
    assign data[k+1] = (X[k] and Y[k]) | (data[k] and X[k]) | (data[k] and Y[k]);
    end
    assign carryout = data[n];
    ```
    ### VHDL Code:
    ```
    parameter n = 16;
    signal data : std_logic_vector(15 down to 0);
    data := "0000000000000000";
    data(0) <= carryin;
    for k in 0 to n-2 generate
    data(k) <= X(k) xor Y(k) xor data(k);
    data(k+1) <= (X(k) and Y(k)) or (data(k) and X(k)) or (data(k) and Y(k));
    end generate;
    carryout <= data(n);
    ```
    ### Final Result:

    Base Verilog Code

    Verilog I/O:
    ```
    carryin: 1'b1
    X: 16'bXXXXXXXXXXXXXXXX
    Y: 16'bXXXXXXXXXXXXXXXX
    S: 16'bXXXXXXXXXXXXXXXX
    carryout: 1'b0
    ```
    VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"1";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"XXXXXXXXXXXXXXXX";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"XXXXXXXXXXXXXXXX";
    S: STD_LOGIC_VECTOR(15 DOWNTO 0);
    CARRYOUT: STD_LOGIC:= '0';
    ```

    Variation Instruction:

    Verilog I/O:
    ```
    carryin: 1'b0
    X: 16'b0F0F0F0F0F0F0F0F
    Y: 16'b0F0F0F0F0F0F0F0F
    S: 16'b0F0F0F0F0F0F0F0F
    carryout: 1'b1
    ```
    VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"0";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0F0F0F0F0F0F0F0F";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0F0F0F0F0F0F0F0F";
    S: STD_LOGIC_VECTOR(15 DOWNTO 0);
    CARRYOUT: STD_LOGIC:= '1';
    ```

    Behavioral Verilog Code:
    ```
    parameter n = 16;
    wire [n-1:0] data [0:n-2];
    assign data[0] = carryin;
    for (k = 0; k <= n-1; k = k + 1) begin: loop2
    assign data[k] = X[k] ^ Y[k] ^ data[k];
    assign data[k+1] = (X[k] and Y[k]) | (data[k] and X[k]) | (data[k] and Y[k]);
    end
    assign carryout = data[n];
    ```
    VHDL Code:
    ```
    parameter n = 16;
    signal data : std_logic_vector(15 down to 0);
    data <= "0000000000000000";
    data(0) <= carryin;
    for k in 0 to n-2 generate
    data(k) <= X(k) xor Y(k) xor data(k);
    data(k+1) <= (X(k) and Y(k)) or (data(k) and X(k)) or (data(k) and Y(k));
    end generate;
    carryout <= data(n);
    ```
    ### Final Result:

    Base VHDL Code

    VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"0";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0000000000000000";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0000000000000000";
    S: STD_LOGIC_VECTOR(15 DOWNTO 0);
    CARRYOUT: STD_LOGIC:= '0';
    ```

    Variation Instruction:

    VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"1";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0F0F0F0F0F0F0F0F";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0F0F0F0F0F0F0F0F";
    S: STD_LOGIC_VECTOR(15 DOWNTO 0);
    CARRYOUT: STD_LOGIC:= '0';
    ```

    Behavioral Verilog Code:
    ```
    parameter n = 16;
    wire [n-1:0] data [0:n-2];
    assign data[0] = carryin;
    for (k = 0; k <= n-1; k = k + 1) begin: loop2
    assign data[k] = X[k] ^ Y[k] ^ data[k];
    assign data[k+1] = (X[k] and Y[k]) | (data[k] and X[k]) | (data[k] and Y[k]);
    end
    assign carryout = data[n];
    ```
    VHDL Code:
    ```
    parameter n = 16;
    signal data : std_logic_vector(15 down to 0);
    data <= "0000000000000000";
    data(0) <= carryin;
    for k in 0 to n-2 generate
    data(k) <= X(k) xor Y(k) xor data(k);
    data(k+1) <= (X(k) and Y(k)) or (data(k) and X(k)) or (data(k) and Y(k));
    end generate;
    carryout <= data(n);
    ```
    ### Final Result:

    Base VHDL Code

    VHDL I/O:
    ```
    CARRYIN: STD_LOGIC := X"0";
    X: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"0000000000000000";
    Y: STD_LOGIC_VECTOR(15 DOWNTO 0):= X"000000
- code: "module adders_8x8(sum, carry,  data, carryin);\nparameter N = 32;\nparameter\
    \ M = 16;\nreg [32:0] data;\ninput\t[15:0]\tdata[31:0];\ninput [15:0]\tdata[31:0];\n\
    input carryin;\noutput [32:0] sum;\noutput [32:0] sum;\noutput\tcarry;\noutput\t\
    carry;\nreg [32:0] sum;\nreg [32:0] sum;\nreg carry;\nreg carry;\nreg [16:0] data0,\
    \ data1;\nreg [16:0] data2, data3;\nreg [16:0] data4, data5;\nreg [16:0] data6,\
    \ data7;\nreg sum0, sum1;\nreg sum2, sum3;\nreg sum4, sum5;\nreg sum6, sum7;\n\
    reg carry0, carry1;\nreg carry2, carry3;\nreg carry4, carry5;\nreg carry6, carry7;\n\
    always @(*)\nbegin\n\tcarry0 = (data[0] & data[1] & carryin) | (data[0] & carryin\
    \ & data[1]) | (carryin & data[0] & data[1]);\n    sum0 = data[0] ^ data[1] ^\
    \ carryin;\n    carry1 = (data[1] & data[2] & carryin) | (data[1] & carryin &\
    \ data[2]) | (carryin & data[1] & data[2]);\n    sum1 = data[1] ^ data[2] ^ carryin;\n\
    \    carry2 = (data[2] & data[3] & carryin) | (data[2] & carryin & data[3]) |\
    \ (carryin &"
- code: ".data(data)\n\t.clock(clock)\n\t.reset(reset)\n\t.enable(enable)\n\t.data_out(data_out)\n\
    \t.inside_index(inside_index)\n\t.enable_index(enable_index)\n\t.inside_bit(inside_bit)\n\
    \t.enable_bit(enable_bit)\ninterface\n\tinput clock,reset,enable,inside_index,enable_index,enable_bit,inside_bit,data_out\n\
    \toutput [32*1:0] data\n### Generated Code:\n```\n/*\n * Auto-generated by GiST-S\
    \ (https://github.com/gi-s-t/g_i_s_t)\n *\n *  - \n *\n */\n#include <stdio.h>\n\
    #include <stdlib.h>\n#include <math.h>\n#include <unistd.h>\n#include <time.h>\n\
    #include <sys/time.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdint.h>\n\
    #include <inttypes.h>\n\n#define MAX_SIZE_DATA 32\n#define MAX_SIZE_CLK 1\n#define\
    \ MAX_SIZE_RST 1\n#define MAX_SIZE_EN 1\n#define MAX_SIZE_I 32\n#define MAX_SIZE_ENB\
    \ 1\n#define MAX_SIZE_I_I 1\n#define MAX_SIZE_ENB_I 1\n#define MAX_SIZE_I_B 1\n\
    #define MAX_SIZE_ENB_B 1\n\n#define T_SIZE_DATA 32\n#define T_SIZE_CLK 1\n#define\
    \ T_SIZE_RST 1\n#define T_SIZE_EN 1\n#define T_SIZE_I 32\n#define T_SIZE_ENB 1\n\
    #define T_SIZE_I_I 1\n#define T_SIZE_ENB_I 1\n#define T_SIZE_I_B 1\n#define T_SIZE_ENB_B\
    \ 1\n\n#define N_DATA 32\n#define N_CLK 1\n#define N_RST 1\n#define N_EN 1\n#define\
    \ N_I 32\n#define N_ENB 1\n#define N_I_I 1\n#define N_ENB_I 1\n#define N_I_B 1\n\
    #define N_ENB_B 1\n\n#define T 64\n#define K 32\n\n#define MAX_VAL(n) (pow(2,n)\
    \ - 1)\n\n#define TRUE 1\n#define FALSE 0\n\nvoid print_array(double arr[], int\
    \ N, FILE *fp) {\n    for(int i=0; i<N; ++i){\n        fprintf(fp, \"%f\\n\",\
    \ arr[i]);\n    }\n}\n\nvoid print_array(int arr[], int N, FILE *fp) {\n    for(int\
    \ i=0; i<N; ++i){\n        fprintf(fp, \"%d\\n\", arr[i]);\n    }\n}\n\ndouble**\
    \ read_array(char* path, int N, int M) {\n    double **A = (double**)malloc(N\
    \ * sizeof(double*));\n\n    for(int i=0; i<N; ++i){\n        A[i] = (double*)malloc(M\
    \ * sizeof(double));\n    }\n\n    FILE *fp = fopen(path, \"r\");\n\n    for(int\
    \ i=0; i<N; ++i){\n        for(int j=0; j<M; ++j){\n            fscanf(fp, \"\
    %lf\\n\", &A[i][j]);\n        }\n    }\n\n    fclose(fp);\n    return A;\n}\n\n\
    int* read_array_int(char* path, int N) {\n    int *A = (int*)malloc(N * sizeof(int));\n\
    \n    FILE *fp = fopen(path, \"r\");\n\n    for(int i=0; i<N; ++i){\n        fscanf(fp,\
    \ \"%d\\n\", &A[i]);\n    }\n\n    fclose(fp);\n    return A;\n}\n\nint main()\
    \ {\n    char data[T_SIZE_DATA];\n    char clk[T_SIZE_CLK];\n    char rst[T_SIZE_RST];\n\
    \    char enable[T_SIZE_EN];\n    char inside_index[T_SIZE_I];\n    char enable_index[T_SIZE_ENB];\n\
    \    char inside_bit[T_SIZE_I_B];\n    char enable_bit[T_SIZE_ENB_B];\n    double\
    \ data_out[T_SIZE_DATA];\n\n    double **data_double = read_array(\"data\", N_DATA,\
    \ 32);\n    int *clk_int = read_array_int(\"clk\", N_CLK);\n    int *rst_int =\
    \ read_array_int(\"rst\", N_RST);\n    int *enable_int = read_array_int(\"enable\"\
    , N_EN);\n    int *inside_index_int = read_array_int(\"inside_index\", N_I);\n\
    \    int *enable_index_int = read_array_int(\"enable_index\", N_ENB);\n    int\
    \ *inside_bit_int = read_array_int(\"inside_bit\", N_I_B);\n    int *enable_bit_int\
    \ = read_array_int(\"enable_bit\", N_ENB_B);\n    double *data_out_double = read_array(\"\
    data_out\", N_DATA, 32);\n\n    for(int i=0; i<N_DATA; ++i) {\n        for(int\
    \ j=0; j<32; ++j) {\n            if(data_double[i][j]) {\n                data[j+32*i]\
    \ = '1';\n            } else {\n                data[j+32*i] = '0';\n        \
    \    }\n        }\n    }\n    for(int i=0; i<N_CLK; ++i) {\n        if(clk_int[i])\
    \ {\n            clk[i] = '1';\n        } else {\n            clk[i] = '0';\n\
    \        }\n    }\n    for(int i=0; i<N_RST; ++i) {\n        if(rst_int[i]) {\n\
    \            rst[i] = '1';\n        } else {\n            rst[i] = '0';\n    \
    \    }\n    }\n    for(int i=0; i<N_EN; ++i) {\n        if(enable_int[i]) {\n\
    \            enable[i] = '1';\n        } else {\n            enable[i] = '0';\n\
    \        }\n    }\n    for(int i=0; i<N_I; ++i) {\n        if(inside_index_int[i])\
    \ {\n            inside_index[i] = '1';\n        } else {\n            inside_index[i]\
    \ = '0';\n        }\n    }\n    for(int i=0; i<N_ENB; ++i) {\n        if(enable_index_int[i])\
    \ {\n            enable_index[i] = '1';\n        } else {\n            enable_index[i]\
    \ = '0';\n        }\n    }\n    for(int i=0; i<N_I_B; ++i) {\n        if(inside_bit_int[i])\
    \ {\n            inside_bit[i] = '1';\n        } else {\n            inside_bit[i]\
    \ = '0';\n        }\n    }\n    for(int i=0; i<N_ENB_B; ++i) {\n        if(enable_bit_int[i])\
    \ {\n            enable_bit[i] = '1';\n        } else {\n            enable_bit[i]\
    \ = '0';\n        }\n    }\n    for(int i=0; i<N_DATA; ++i) {\n        for(int\
    \ j=0; j<32; ++j) {\n            if(data_out_double[i][j]) {\n               \
    \ data_out[j+32*i] = '1';\n            } else {\n                data_out[j+32*i]\
    \ = '0';\n            }\n        }\n    }\n\n    FILE *fp = fopen(\"modified.v\"\
    , \"w\");\n\n    fprintf(fp, \"/*\\n\");\n    fprintf(fp, \" * Modified by GiST-S\
    \ (https://github.com/gi-s-t/g_i_s_t)\\n\");\n    fprintf(fp, \" *\\n\");\n  \
    \  fprintf(fp, \" *  - \\n\");\n    fprintf(fp, \" *\\n\");\n    fprintf(fp, \"\
    \ */\\n\");\n    fprintf(fp, \"\\n\");\n    fprintf(fp, \"// Include path\\n\"\
    );\n    fprintf(fp, \"#include \\\"g_v_g_c.h\\\"\\n\");\n    fprintf(fp, \"\\\
    n\");\n    fprintf(fp, \"// Input path\\n\");\n    fprintf(fp, \".clk(clk)\\n\"\
    );\n\tfprintf(fp,"
- code: |-
    ```verilog
    add_4(data[3],data[2],data[1],data[0]);
    ```

    ### Modified Verilog Code:

    ```verilog
    addern(data[3],data[2],data[1],data[0]);
    ```

    In general, a single variability is not possible in the current implementation of the tool. If you need it, please create a feature request.

    ### References

    - [A tool for optimizing and verifying modular implementations](http://www.cse.scu.edu/~ericli/papers/iccad2005.pdf)
    /docs/user_guide/tutorials/tutorial_6.md
    ---
    layout: default
    title: Tutorial 6: Design Verification
    parent: Tutorials
    grand_parent: User Guide
    ---

    # Tutorial 6: Design Verification

    In this tutorial, we will see how to verify our testbench design using modelsim.

    ## Problem Description

    We have completed all the previous steps of this tutorial. Now, we will add verification steps to our circuit design.

    ## Design Verification

    The first step in testing a module is to simulate the circuit. This step is required because verification tools evaluate the behavior of the circuit by comparing it to a reference case. Modelsim is a simulation tool that allows us to simulate the circuits in a testbench. The testbench is a module that connects a series of module instances. In the above circuit, we are connecting an input `a`, an input `b`, and an output `sum` using the testbench `tb`.

    {% capture summary %}
    ![img](/user_guide/tutorials/images/tut6/tut6-4.png)
    {% endcapture %}
    {% include image.html summary=summary width="100%" file="tut6-4.png" %}

    ```verilog
    tb: module tb(a, b, clk, sum, rst);
      reg [3:0] a;
      reg [3:0] b;
      reg clk;
      reg rst;
      reg [3:0] sum;
      wire [3:0] sum2;
      assign sum2 = a + b;
      add_4 add(a, b, clk, rst, sum);
      add_4 add2(sum, sum2);
      assign sum = add2.S;
      assign sum2 = add2.S;

      integer i;

      initial
      begin
        rst = 1'b0;
        clk = 1;
        #5 clk = 0;
        $dumpfile("tb_dump.vcd");
        $dumpvars(0, tb);

        for (i = 0; i < 16; i = i + 1)
        begin
          a = [i:0];
          b = [i:0];
          #10 clk = ~clk;
        end

        $finish;
      end

    endmodule
    ```

    When `tb` is run, we are setting the value of `a`, `b`, and `sum` to the values of `i` (0 to 15 in hex) in order to test all possible combinations of the inputs. We use the `$dumpvars` command to dump the values of `a`, `b`, `sum`, and `clk` to `tb_dump.vcd`.

    Now that we have a testbench, we need to add a top level module to test the testbench design. The top level module needs to be connected to the inputs of the testbench module. The top level module should be able to run the testbench module. Now that we have a working testbench, we can simulate it and verify that the output values match the reference values.

    {% capture summary %}
    ![img](/user_guide/tutorials/images/tut6/tut6-1.png)
    {% endcapture %}
    {% include image.html summary=summary width="100%" file="tut6-1.png" %}

    ```verilog
    module tba;
      reg clk;
      reg reset;
      wire [3:0] a;
      wire [3:0] b;
      wire [3:0] sum;
      wire [3:0] sum2;
      tb tb(a, b, clk, sum, reset);
      initial begin
        clk = 1;
        #5 clk = 1;
        $dumpfile("tb_dump.vcd");
        $dumpvars(0, tb);
      end
    endmodule
    ```

    In the above code, we are connecting all the inputs of the testbench to `a`, `b`, `sum`, and `clk`. We are also using the command `$dumpvars` to dump the values of `a`, `b`, `sum`, and `clk` to `tb_dump.vcd`.

    The last step is to run the top level module and use the waveform viewer to verify the output. It will be verified that the output is correct by comparing each input to its reference case.

    {% capture summary %}
    ![img](/user_guide/tutorials/images/tut6/tut6-2.png)
    {% endcapture %}
    {% include image.html summary=summary width="100%" file="tut6-2.png" %}

    ```verilog
    vvp -m./work.v -n tb./work.v +tb_dump.vcd
    ```

    In the above code, we are using the `vvp` command to load the testbench module and the top level module into modelsim. We are also using the command `+tb_dump.vcd` to load the dump file we generated earlier.

    To view the waveforms generated in a waveform viewer, we use the command `vvp`. Modelsim uses the waveform viewer to generate waveforms of the design. The command `vvp` is used to view the waveforms generated in the waveform viewer.

    ## Summary

    In this tutorial, we learned how to perform a design verification. We learned how to simulate the design using modelsim and verified the reference case.

    ## Next Steps

    [Tutorial 7: Design Synthesis](./tutorial_7.html)

    ## References

    - [Introduction to Modelsim User Guide](http://www.cadence.com/content/dam/cadence/documentation/modelsim/10.5/UG_ModelSim_10.5.pdf)
    - [Introduction to RTL Design](https://www.cadence.com/content/dam/cadence/solutions/design-services/industries/system-verilog-design-guide/introduction-to-rtl-design.pdf)
    - [How to write a Verilog simulation testbench](https://www.cadence.com/content/dam/cadence/technical_advances/how_to_write_a_verilog_simulation_testbench.pdf)/docs/user_guide/tutorials/tutorial_8.md
    ---
    layout: default
    title: Tutorial 8: Design Synthesis
    parent: Tutorials
    grand_parent: User Guide
    ---

    # Tutorial 8: Design Synthesis

    In this tutorial, we will see how to synthesize our design using `verilator`.

    ## Problem Description

    We have completed all the previous steps of this tutorial. Now we will add synthesis steps to our circuit design.

    ## Design Synthesis

    There are two synthesis tools that work with Verilog. `verilator` is a tool that will generate Verilog code for simulation as well as a C++ simulator. The `verilator` synthesis tool is a bit difficult to use because it requires many commands to be entered. It also requires a number of files to be generated.

    `yosys` is a tool that will do pre processing of the verilog code before synthesis. The `yosys` pre-processor works in a very similar way as `verilator`.

    To create a synthesis tool, there are steps that need to be performed. The first step is to create a `Makefile`. The `Makefile` is a file that contains instructions to build and compile the project. Next, we will create a `Makefile` for `verilator`. The second step is to create a `main.cpp` file that contains the main() function of the C++ simulator and a `add_4.cpp` file that contains the Verilog code.

    The `Makefile` and `main.cpp` must be created in the same directory as the Verilog files. The `add_4.cpp` file needs to be in another directory. `verilator` does not support a single source file. We will have two source files.

    Here is our Makefile:

    ```make
    VERILATOR_ROOT=/home/user/verilator-4.110

    VERILATOR_CXXFLAGS +=   \
        -I. \
        -I$(VERILATOR_ROOT)/include \
        -I$(VERILATOR_ROOT)/include/vltstd \
        -I$(VERILATOR_ROOT)/include/verilated \
        -DVL_USER_DEFINED_COSIM_CONFIG \
        -DVL_RAND_RESET \
        -DVL_DEBUG \
        -DVCD_DUMP

    VERILATOR_LDFLAGS +=    \
        -L$(VERILATOR_ROOT)/lib-linux \
        -
- code: |-
    ```
    module addern_param(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
    ```
    ### Testbench Source:
    ```
    module addernt_param();
    parameter n = 16;
    reg carryin;
    reg [n-1:0] X;
    reg [n-1:0] Y;
    reg [n-1:0] S;
    wire carryout;
    integer i;
    initial
    begin
        for (i = 0; i < 2; i = i + 1)
        begin
            X[i] = $urandom;
            Y[i] = $urandom;
        end
        carryin = 1'b1;
        while(1)
        begin
            #25
            S = X ^ Y ^ carryin;
            #25
            if (S!= X ^ Y ^ carryin)
                $fatal(1, "S (%b)!= expected (%b) at %b", S, X ^ Y ^ carryin, $time);
        end
    end
    endmodule
    ```%cat addern_param_tb.sv
    from vunit import VUnit
    from vunit.utils import quickfix
    from vunit.compat import HDLSource

    vunit.setup()
    vhdl = HDLSource('''
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    use IEEE.NUMERIC_STD.ALL;
    use IEEE.STD_LOGIC_UNSIGNED.ALL;

    entity addern is
        generic (
            n : positive := 16
        );
        port (
            carryin : in  STD_LOGIC;
            X       : in  STD_LOGIC_VECTOR(n-1 downto 0);
            Y       : in  STD
- code: |-
    ```
    module addern(carryin, data[16], S, carryout);
    parameter n = 16;
    input carryin;
    input [16] data;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer i;
    always @(carryin or data or C)
    begin
        C[0] = carryin;
        for (i = 0; i <= n - 1; i = i + 1)
        begin
            S[i] = data[i] ^ C[i];
            C[i+1] = (data[i] & C[i]);
        end
        carryout = C[n];
    end
    endmodule
    ```
    ### Verilog Code:
    ```
    module addern(carryin, data[16], S, carryout);
    parameter n = 16;
    input carryin;
    input [16] data;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer i;
    always @(carryin or data or C)
    begin
        C[0] = carryin;
        for (i = 0; i <= n - 1; i = i + 1)
        begin
            S[i] = data[i] ^ C[i];
            C[i+1] = (data[i] & C[i]);
        end
        carryout = C[n];
- code: |-
    ```c++
    // Module Declaration
    module demuxn(S_in, sel, S_out);
    parameter n = 4;
    input [n-1:0] S_in;
    input [n-1:0] sel;
    output [n-1:0] S_out;
    reg [n-1:0] S;
    reg [n-1:0] data[n];
    wire [n-1:0] control;
    integer i;
    integer j;
    mod_constant(in: control[i], out: control[0], index: i);
    assign data[i] = S_in[i];
    endmodule
    // Module Declaration
    module demuxn(S_in, sel, S_out);
    parameter n = 4;
    input [n-1:0] S_in;
    input [n-1:0] sel;
    output [n-1:0] S_out;
    reg [n-1:0] S;
    integer i;
    integer j;
    assign S_in[i] = data[i];
    endmodule
    ```
    ### Comparison
    | Location | Code | Verilog |
    | -------- | ---- | ------- |
    | Base |![base_demux](Pictures/demux/base_demux.png) |![verilog_demux](Pictures/demux/verilog_demux.png) |

    ## Full Adder
    ### Base Code:
    ```c++
    // Module Declaration
    module full_adder(cin_in, A, B, S, cout);
    input cin_in;
    input A;
    input B;
    output S;
    output cout;
    wire [3:0] S_temp;
    wire [3:0] S_cin;
    wire [3:0] S_cout;
    assign S_cin[0] = cin_in;
    assign S_cin[1] = A;
    assign S_cin[2] = B;
    assign S_cout[0] = S_cin[0] ^ S_cin[1] ^ S_cin[2];
    assign S_cout[1] = (S_cin[0] & S_cin[1]) | (S_cin[0] & S_cin[2]) | (S_cin[1] & S_cin[2]);
    assign S_temp[0] = S_cin[3];
    assign S_temp[1] = S_cout[0];
    assign S_temp[2] = S_cout[1];
    assign S_temp[3] = S_cin[0];
    assign S[0] = S_temp[1];
    assign S[1] = S_temp[2];
    assign S[2] = S_temp[3];
    assign cout = S_cout[2];
    endmodule
    // Module Declaration
    module full_adder(cin_in, A, B, S, cout);
    input cin_in;
    input A;
    input B;
    output S;
    output cout;
    reg [3:0] S;
    reg [3:0] cin_in;
    reg [3:0] A;
    reg [3:0] B;
    reg cout;
    reg [3:0] S_cin;
    reg [3:0] S_cout;
    reg [3:0] S_temp;
    mod_constant(in: S_cin[0], out: S_cin[0], index: 0);
    mod_constant(in: S_cin[1], out: S_cin
- code: |-
    ```c++
    module addern_mod(X, Y, S, carryout);
    parameter n = 16;
    input [n-1:0] X;
    input [n-1:0] Y;
    output [n-1:0] S;
    output carryout;
    reg [n:0] C;
    reg carryout;
    integer k;
    reg [n-1:0] data[n-1:0];
    always@(X or Y)
    begin
       C[0] = 1'b1;
       for (k = 0; k <= n-1; k = k + 1)
       begin
           data[k] = X[k] ^ Y[k] ^ C[k];
           C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end

    endmodule
    ```
    ### Variation Instruction:
    Replace constant index
- code: |-
    module latcher (in, out);
    input in;
    output out;
    always_latch
    out = in;
    endmodule
    ### Variation Code:
    No code change.
    ### Expected Output:
    No output because no verilog code is output.
    ## D.2. Combinational State Machine
    ### Base Verilog Code:
    module state_Mealy (input [31:0] dcontrol, output [31:0] data,
                         output [31:0] y, output [31:0] bus);
    input [31:0] dcontrol;
    output [31:0] data;
    output [31:0] y;
    output [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @*
    case (state_Mealy)
    0: y = ~dcontrol;
    1: if(dcontrol == 0) data <= 3'b001;
    1: if(dcontrol == 1) data <= 3'b
- code: |-
    package package_sim;
    reg [31:0] array [0:31];
    initial
    begin
    array = {1, 2, 3, 4, 5, 6, 7, 8};
    end
    endpackage
    ### Base Verilog Code:
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    package state_Mealy;
    logic [1:0] state;
    logic [31:0] [0:3] code = {
    "02000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000"
    };
    endpackage
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    ### Expected Output:
    ```
    time=0 dcontrol=0 data=0 x=0 y=1 bus=0
    ```
    [comment]: <> (### SystemVerilog Variation Example:)
    [comment]: <> (module mixed_sim; include "sv_constants.sv")
    [comment]: <> (reg [31:0] data, rdata; input [31:0] addr; reg [31:0] inst; reg [31:0] dataout; reg [1:0] state; always @ (data, addr, inst) begin case (state) 0: begin dataout = data; data = dataout; state = state + 1; end 1: begin dataout = data; data = dataout; state = state + 1; end 2: begin dataout = data; data = dataout; state = state + 1; end 3: begin dataout = data; data = dataout; state = state + 1; end 4: begin dataout = data; data = dataout; state = state + 1; end 5: begin dataout = data; data = dataout; state = state + 1; end 6: begin dataout = data; data = dataout; state = state + 1; end 7: begin dataout = data; data = dataout; state = state + 1; end 8: begin dataout = data; data = dataout; state = state + 1; end 9: begin dataout = data; data = dataout; state = state + 1; end 10: begin dataout = data; data = dataout; state = state + 1; end 11: begin dataout = data; data = dataout; state = state + 1; end 12: begin dataout = data; data = dataout; state = state + 1; end 13: begin dataout = data; data = dataout; state = state + 1; end 14: begin dataout = data; data = dataout; state = state + 1; end 15: begin rdata = dataout; state = state + 1; end 16: begin rdata = dataout; state = state + 1; end 17: begin rdata = dataout; state = state + 1; end 18: begin rdata = dataout; state = state + 1; end 19: begin rdata = dataout; state = state + 1; end 20: begin rdata = dataout; state = state + 1; end 21: begin rdata = dataout; state = state + 1; end 22: begin rdata = dataout; state = state + 1; end 23: begin rdata = dataout; state = state + 1; end 24: begin rdata = dataout; state = state + 1; end 25: begin rdata = dataout; state = state + 1; end 26: begin rdata = dataout; state = state + 1; end 27: begin rdata = dataout; state = state + 1; end 28: begin rdata = dataout; state = state + 1; end 29: begin rdata = dataout; state = state + 1; end 30: begin rdata = dataout; state = state + 1; end 31: begin rdata = dataout; state = state + 1; end 32: default: state = 0; end end)
    ### SystemVerilog Code:
    module mixed_sim;
    include "sv_constants.sv";
    reg [31:0] data, rdata;
    input [31:0] addr;
    input [31:0] inst;
    reg [31:0] dataout;
    reg [1:0] state;
    always @ (data, addr, inst)
    begin
    case (state)
    0: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    1: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    2: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    3: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    4: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    5: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    6: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    7: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    8: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    9: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    10: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    11: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    12: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    13: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    14: begin
    dataout = data;
    data = dataout;
    state = state + 1;
    end
    15: begin
    rdata = dataout;
    state = state + 1;
    end
    16: begin
    rdata = dataout;
    state = state + 1;
    end
    17: begin
    rdata = dataout;
    state = state + 1;
    end
    18: begin
    rdata = dataout;
    state = state + 1;
    end
    19: begin
    rdata = dataout;
    state = state + 1;
    end
    20: begin
    rdata = dataout;
    state = state + 1;
    end
    21: begin
    rdata = dataout;
    state = state + 1;
    end
    22: begin
    rdata = dataout;
    state = state + 1;
    end
    23: begin
    rdata = dataout;
    state = state + 1;
    end
    24: begin
    rdata = dataout;
    state = state + 1;
    end
    25: begin
    rdata = dataout;
    state = state + 1;
    end
    26: begin
    rdata = dataout;
    state = state + 1;
    end
    27: begin
    rdata = dataout;
    state = state + 1;
    end
    28: begin
    rdata = dataout;
    state = state + 1;
    end
    29: begin
    rdata = dataout;
    state = state + 1;
    end
    30: begin
    rdata = dataout;
    state = state + 1;
    end
    31: begin
    rdata = dataout;
    state = state + 1;
    end
    32: default:
    state = 0;
    end
    end
    endmodule
    ### SystemVerilog Expected Output:
    ```
    ```
    ### Verilog Variation Code:
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus =
- code: |-
    ```
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;

    package state_pkg;
    reg [3:0] state_Mealy;
    assign state_Mealy = {0,1,2,3,4,0,4,0};
    always @(posedge state_Mealy[4])
    begin
        case (state_Mealy[0])
            0:
                dcontrol = 1;
                data = 10;
            1:
                dcontrol = 1;
                data = 20;
            2:
                dcontrol = 1;
                data = 40;
            3:
                dcontrol = 0;
                data = 60;
        endcase
    end
    assign bus = dcontrol? data : 'bz;
    always @(x)
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    x = 1;
    dcontrol = 0;
    end
    endmodule
    ```
    ### Result:
    ```
    time=0 dcontrol=1 data=10 x=1 y=0 bus=10
    time=1 dcontrol=1 data=20 x=0 y=1 bus=20
    time=2 dcontrol=1 data=40 x=1 y=0 bus=40
    time=3 dcontrol=0 data=60 x=0 y=1 bus=60
    ```
    ##### 2.2.2.2.3.2.2.3.2.4.2.5.2.6.2.7.2.8.1.2.3.3.2.2.2.3.2.2.3.3.2.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.1.2.3.3.2.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.2.2.3.3.1.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.3.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.4.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.5.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.6.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.7.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.8.2.3.9.2.2.3.10.2.2.3.11.9.2.3.10.2.2.3.11.10.2.3.11.2.2.3.11.11.2.3.11.3.2.3.11.4.2.3.11.5.2.3.11.6.2.3.11.7.2.3.11.8.2.3.11.9.2.3.11.10.1.2.3.3.2.3.4.2.3.5.2.3.6.2.3.7.2.3.8.2.3.9.2.3.10.2.3.11.2.3.11.3.2.3.11.4.2.3.11.5.2.3.11.6.2.3.11.7.2.3.11.8.2.3.11.9.2.3.11.10.2.3.11.11.
    ##### 2.2.2.2.3.2.2.3.4.1.2.3.5.2.2.3.6.1.2.3.7.1.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.1.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.1.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.1.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.2.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.3.2.3.4.2.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.4.2.3.5.2.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.5.2.3.6.2.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3.11.
    ##### 2.2.2.2.3.2.2.3.11.6.2.3.7.2.2.3.8.2.2.3.9.2.2.3.10.2.2.3
- code: |-
    ```
    module mixed_sim_mod;
    localparam mealy = 1'b1;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    package pkg_slice_param_local;
    localparam state_Mealy[] = mealy;
    assign bus = inside(dcontrol, state_Mealy)? data : 'bz;
    always @x
    y
- code: |-
    module mixed_sim;
    reg [1:0] state_Mealy; // new
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d state_Mealy=%d dcontrol=%d data=%d x=%d y=%d bus=%d",         // new
    $time, state_Mealy, dcontrol, data, x, y, bus); // new
    dcontrol = 0;
    end
    endmodule
    ### Test:

    ```
    @test "mixed_sim/Vmix/src/test/mixed_sim.sv" "in" "test"
    ```

    ### Expected:
    no error

    ### Result:
    Error
    ```
    $ cat test.results
    ../../../../src/main/scala/vsim/vlib/src/test/mixed_sim.sv:12: WARNING: Verilog input 'test_input' at line 12 of../../../../src/main/scala/vsim/vlib/src/test/mixed_sim.sv is unsupported.
    ../../../../src/main/scala/vsim/vlib/src/test/mixed_sim.sv:12: WARNING: Verilog input 'test_input' at line 12 of../../../../src/main/scala/vsim/vlib/src/test/mixed_sim.sv is unsupported.
    ../../../../src/main/scala/vsim/vlib/src/test/mixed_sim.sv:12: ERROR: Undefined input of module test_input
    ```

    # `test/mixed_sim.sv`

    ### Base Verilog Code:
    module mixed_sim;
    reg
- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
    $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    `# 7. Re-arranging Assignment Operators

    In general, we have two types of assignment operators, the binary assignment operator (`=`) and the unary assignment operator (`:=`).

    Binary assignment:

    ```verilog
    assign a = 5 + 2;
    ```

    Unary assignment:

    ```verilog
    assign b = 10;
    assign b = a;
    ```

    There is no restriction on the order of the assignment operators; that is, we can write the above in two different ways:

    ```verilog
    assign a = 5 + 2;
    assign b = a;
    assign b = 10;
    ```

    vs.

    ```verilog
    assign b = 10;
    assign a = 5 + 2;
    assign b = a;
    ```

    The only restriction is that the top-level assignment operator (`=`) has to be unary or binary, while the nested ones (`:=`) must be binary.

    The above is not valid:

    ```verilog
    assign b = a;
    assign b = 10 + 5;
    ```

    The `:=` operator has to be binary, and it has to appear on the left-hand side of the assignment operator.
    # 3. Using $dumpall to View Simulation Results

    The `$dumpall` command writes all the internal signals and memory elements to an output file. It is primarily useful for debugging purposes and is not very useful in general use.

    `$dumpall` is useful for debugging, but it is not a good idea to use it in production code.

    ## Example:

    ```verilog
    module mymodule;
      wire [3:0] a;
      reg  [3:0] b;
      reg  [3:0] c;

      always @* begin
        $dumpall(c);
      end

      assign b = a;
    endmodule
    ```

    ## Running the Example:

    ```zsh
    $ verilator -Wall --trace -cc mymodule.v --exe verilator_main.cpp
    $ make -j -C obj_dir -f Vmymodule.mk
    $./obj_dir/Vmymodule
    ```
    # 7. Combinational Circuits

    Combinational circuits do not have sequential elements (i.e., no `always` blocks).# 2. A Simple Verilog Example

    We will be using the Verilator tool.

    ## Example:

    ```verilog
    module mymodule;
      wire [3:0] a;
      reg  [3:0] b;
      reg  [3:0] c;

      always @* begin
        b <= a;
        c <= a;
      end
    endmodule
    ```

    ## Running the Example:

    ```zsh
    $ verilator -Wall --trace -cc mymodule.v --exe verilator_main.cpp
    $ make -j -C obj_dir -f Vmymodule.mk
    $./obj_dir/Vmymodule
    ```
    # 3. Verilog Comments

    Verilog supports two types of comments: the single-line comment and the block comment.

    Comments are ignored by the Verilog compiler, but they are included in the output file.

    ## Single-Line Comment

    A single-line comment begins with `//`, and it ends at the end of the line.

    ```verilog
    // Single line comment
    ```

    ## Block Comment

    A block comment begins with `/*` and ends with `*/`. Unlike a single-line comment, the block comment can span multiple lines.

    ```verilog
    /*
    Block comment
    Block comment
    Block comment
    */
    ```
    # 3. Verilog Symbols and Names

    ## Symbol Names

    Symbol names are not case sensitive. The following are all valid symbol names:

    ```verilog
    a
    A
    1_a
    A1
    ```

    ## Reserved Names

    The following are reserved names. They cannot be used as the names of anything other than a package name in the `package` declaration:

    - bit
    - break
    - byte
    - case
    - casex
    - casez
    - chandle
    - class
    - context
    - cos
    - const
    - constructor
    - continue
    - cos
    - data
    - default
    - define
    - disable
    - dist
    - do
    - else
    - end
    - enum
    - event
    - event
    - false
    - final
    - fork
    - foreign
    - foreach
    - for
    - function
    - highz0
    - highz1
    - hierarchical
    - if
    - include
    - interface
    - join
    - join
    - join_any
    - join_none
    - join_some
    - join_any
    - join_none
    - join_some
    - join
    - join
    - join
    - label
    - let
    - longint
    - localparam
    - logic
    - lowz0
    - lowz1
    - mac
    - match
    - module
    - negedge
    - new
    - nmos
    - nop
    - nor
    - not
    - null
    - or
    - output
    - package
    - pack
    - packed
    - parameter
    - pmos
    - pulldown
    - pullup
    - pulldown_hiz
    - pullup_hiz
    - real
    - realtime
    - reg
    - repeat
    - return
    - shortint
    - shortreal
    - shortvector
    - small
    - specparam
    - static
    - strong0
    - strong1
    - struct
    - sup
    - sync_accept_on
    - sync_accept_on
    - sync_reject_on
    - sync_reject_on
    - sync_reject_on
    - sync_reject_on
    - table
    - task
    - this
    - this
    - time
    - timeunit
    - tri
    - triand
    - trior
    - true
    - trireg
    - type
    - typedef
    - unsigned
    - untyped
    - use
    - very
    - weak0
    - weak1
    - while
    - wildcards
    - wand
    - wire
    - wor
    - xnor
    - xnor2
    - xor
    - xor2
    - xnor2
    - xor2
    - xnor2
    - xor2
    - xor2

    Symbol names starting with a dollar sign (`$`) are also reserved. For example, the names `$readmemh`, `$writememh` and `$finish` are reserved.
    # 5. Verilog Code Formatting

    Verilog code formatting is important because it improves readability. It can be configured in a number of different ways. However, the easiest way to format the code is with the `verilator-format` tool.

    ## Installing verilator-format

    ### Ubuntu

    ```zsh
    $ sudo apt install verilator-format
    ```

    ### Fedora

    ```zsh
    $ sudo dnf install verilator-format
    ```

    ## Formatting the Verilog Code

    ```zsh
    verilator-format --indent-with-tabs --tab-stop=2 --input file.v
    ```
    # 3. Using $dumpfile and $dumpvars

    The `$dumpfile` command is used to determine the name of an output Verilog file, and the `$dumpvars` command is used to specify whether variables and nets from a Verilog file are dumped.

    ## Example:

    ```verilog
    module mymodule;
      reg  [3:0] a;
      wire  [3:0] b;
      wire  [3:0] c;

      always @* begin
        $dumpvars(1, mymodule, a);
        $dumpfile(mymodule.vcd);
        $dumpvars(0);
      end
    endmodule
    ```

    ## Running the Example:

    ```zsh
    $ verilator -Wall --trace -cc mymodule.v --exe verilator_main.cpp
    $ make -j -C obj_dir -f Vmymodule.mk
    $./obj_dir/Vmymodule
    ```
    # 7. Using $dumpvars

    The `$dumpvars` command is used to specify whether variables and nets from a Verilog file are dumped.

    ## Example:

    ```verilog
    module mymodule;
      reg  [3:0] a;
      wire  [3:0] b;
      wire  [3:0] c;

      always @* begin
        $dumpvars(0);
      end
    endmodule
    ```

    ## Running the Example:

    ```zsh
    $ verilator -Wall --trace -cc mymodule.v --exe verilator_main.cpp
    $ make -j -C obj_dir -f Vmymodule.mk
    $./obj_dir/V
- code: |-
    ```
    ### Base Verilog Code:
    module mixed_sim;
    reg dcontrol, x
- code: |-
    ```verilog
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule

    package state_Mealy_package;
    logic [2:0] state_Mealy[0];
    logic [31:0] state_Mealy[1];
    logic [31:0] state_Mealy[2];
    logic [31:0] state_Mealy[3];
    logic [31:0] state_Mealy[4];
    logic [31:0] state_Mealy[5];
    logic [31:0] state_Mealy[6];
    logic [31:0] state_Mealy[7];
    logic [31:0] state_Mealy[8];
    logic [31:0] state_Mealy[9];
    logic [31:0] state_Mealy[10];
    logic [31:0] state_Mealy[11];
    logic [31:0] state_Mealy[12];
    logic [31:0] state_Mealy[13];
    logic [31:0] state_Mealy[14];
    logic [31:0] state_Mealy[15];
    logic [31:0] state_Mealy[16];
    logic [31:0] state_Mealy[17];
    logic [31:0] state_Mealy[18];
    logic [31:0] state_Mealy[19];
    logic [31:0] state_Mealy[20];
    logic [31:0] state_Mealy[21];
    logic [31:0] state_Mealy[22];
    logic [31:0] state_Mealy[23];
    logic [31:0] state_Mealy[24];
    logic [31:0] state_Mealy[25];
    logic [31:0] state_Mealy[26];
    logic [31:0] state_Mealy[27];
    logic [31:0] state_Mealy[28];
    logic [31:0] state_Mealy[29];
    logic [31:0] state_Mealy[30];
    logic [31:0] state_Mealy[31];
    initial
    begin
    state_Mealy[0] = 2'b00;
    state_Mealy[1] = 2'b10;
    state_Mealy[2] = 2'b11;
    state_Mealy[3] = 2'b01;
    state_Mealy[4] = 2'b11;
    state_Mealy[5] = 2'b10;
    state_Mealy[6] = 2'b11;
    state_Mealy[7] = 2'b11;
    state_Mealy[8] = 2'b11;
    state_Mealy[9] = 2'b01;
    state_Mealy[10] = 2'b00;
    state_Mealy[11] = 2'b01;
    state_Mealy[12] = 2'b10;
    state_Mealy[13] = 2'b11;
    state_Mealy[14] = 2'b11;
    state_Mealy[15] = 2'b01;
    state_Mealy[16] = 2'b11;
    state_Mealy[17] = 2'b10;
    state_Mealy[18] = 2'b01;
    state_Mealy[19] = 2'b00;
    state_Mealy[20] = 2'b11;
    state_Mealy[21] = 2'b10;
    state_Mealy[22] = 2'b11;
    state_Mealy[23] = 2'b10;
    state_Mealy[24] = 2'b00;
    state_Mealy[25] = 2'b11;
    state_Mealy[26] = 2'b01;
    state_Mealy[27] = 2'b00;
    state_Mealy[28] = 2'b00;
    state_Mealy[29] = 2'b00;
    state_Mealy[30] = 2'b00;
    state_Mealy[31] = 2'b01;
    end
    endpackage

    module state_Mealy_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = inside(state_Mealy, $bitstore(x));
    end
    endmodule
    ```
    #include <iostream>

    using namespace std;

    int main(int argc, char* argv[]) {
      int a;
      int b;
      cout << "Please enter two integers:\n";
      cin >> a >> b;
      cout << "You have entered " << a << " and " << b << "\n";
      cout << "The sum of the two numbers is " << a + b << endl;
      return 0;
    }
    s.txt

    # Run the code
    ./run_code.sh

    #!/bin/bash

    echo Running $1

    # Compile the code
    make -f Makefile.run $1

    # Copy the data file
    cp -n $2 array_test_data.txt

    # Copy the script file
    cp -n $3 script_test_data.txt

    # Run the script
    python3 script_test_data.txt array_test_data.txt test_resulter
    echo "Running $1"
    ./$1 < testfile.txt > output.txt
    echo "Output written to output.txt"
    #!/bin/bash

    # Compile the code
    make $1.ov#include <iostream>

    using namespace std;

    int main(int argc, char* argv[]) {
      int a;
      int b;

      cout << "Please enter two integers:\n";
      cin >> a >> b;
      cout << "You have entered " << a << " and " << b << "\n";
      cout << "The sum of the two numbers is " << a + b << endl;
      cout << "The difference of the two numbers is " << a - b << endl;
      cout << "The product of the two numbers is " << a * b << endl;
      cout << "The quotient of the two numbers is " << a / b << endl;
      return 0;
    }
    /bash

    echo $1
    echo $2
    echo $3

    # Compile the code
    make $1.ov

    # Run it
    ./$1.ov.sim $2 $3 > /dev/null

    # Show the results
    ./show_results.sh $1.ov.sim
    #!/bin#include <iostream>

    // Define a constant
    const int NUMBER = 5;

    // Forward declarations
    int get_sum(int n);
    void print_array(int arr[], int len);

    using namespace std;

    int main(int argc, char* argv[]) {
      int a = NUMBER;
      int b = get_sum(NUMBER);
      cout << "The value of a is " << a << "\n";
      cout << "The value of b is " << b << "\n";
      return 0;
    }

    // Get the sum of the integers 0 to n
    int get_sum(int n) {
      // Loop over all integers 0 to n
      int sum = 0;
      for (int i = 0; i < n; i++) {
        sum += i;
      }
      return sum;
    }

    // Print an array
    void print_array(int arr[], int len) {
      cout << "[";
      for (int i = 0; i < len - 1; i++) {
        cout << arr[i] << ", ";
      }
      cout << arr[len - 1] << "
- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    reg [31:0] bus;
- code: |-
    module Mealy_Nonresetting_Sequence_Detector (Detect_Mealy, D_in, clk, rst);
    // in/out: output is Detect_Mealy
    // in/out: input is D_in
    // in/out: clock is clk
    // in/out: reset is rst
    // localparam: size is 3
    // localparam: S_0 is 0
    // localparam: S_1 is 1
    // localparam: S_2 is 2
    // localparam: S_3 is 3
    // localparam: S_5 is 5
    // localparam: S_6 is 6
    // localparam: S_7 is 7
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    // localparam: D_in_0 is 2
    // localparam: D_out_0 is 2
    // localparam: Q_out_0 is 2
    // localparam: D_in_1 is 0
    // localparam: D_out_1 is 0
    // localparam: Q_out_1 is 0
    // localparam: D_in_2 is 1
    // localparam: D_out_2 is 1
    // localparam: Q_out_2 is 1
    // localparam: D_in_3 is 0
    // localparam: D_out_3 is 0
    // localparam: Q_out_3 is 0
    parameter S_5 = 5, S_6 = 6, S
- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0))
    || ((state_Mealy == S_7)&&(D_in ==1)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in == $inside{6:4}) // Added new instruction next_state = S_1; else if (D_in == 0) next_state = S_5; S_1: if (D_in ==$inside{6:4}) // Added new instruction
    next_state = S_2;
    else if (D_in == 0) next_state = S_5;
    S_2: if (D_in == $inside{6:4}) // Added new instruction next_state = S_3; else if (D_in == 0) next_state = S_5; S_3: if (D_in ==$inside{6:4}) // Added new instruction
    next_state = S_3;
    else if (D_in == 0) next_state = S_5;
    S_5: if (D_in == $inside{6:4}) // Added new instruction next_state = S_1; else if (D_in == 0) next_state = S_6; S_6: if (D_in ==$inside{6:4}) // Added new instruction
    next_state = S_1;
    else if (D_in == 0) next_state = S_7;
    S_7: if (D_in == $inside{6:4}) // Added new instruction next_state = S_1; else if (D_in == 0) next_state = S_7; default: next_state = S_0; endcase end endmodule ### Variation Instruction: In the behavioral D-latch, for the case where the D input would be 1, there is no need to use the next state logic. ### Modified Code: module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst); // Mealy nonresetting sequence detector output Detect_Mealy; input D_in, clk, rst; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_5 = 5, S_6 = 6, S_7 = 7; reg [2: 0] state_Mealy, next_state; wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0)) || ((state_Mealy == S_7)&&(D_in ==1))); always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; always @ (state_Mealy, D_in) begin next_state = S_0; case (state_Mealy) S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5; S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5; S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5; S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5; S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6; S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7; S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7; default: next_state = S_0; endcase end endmodule ### Variation Instruction: In the behavioral D-latch, for the case where the D input would be 1, only the next state is needed. ### Modified Code: module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst); // Mealy nonresetting sequence detector output Detect_Mealy; input D_in, clk, rst; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_5 = 5, S_6 = 6, S_7 = 7; reg [2: 0] state_Mealy, next_state; wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0)) || ((state_Mealy == S_7)&&(D_in ==1))); always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; always @ (state_Mealy, D_in) begin next_state = S_0; case (state_Mealy) S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5; S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5; S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5; S_3: next_state = S_3; S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6; S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7; S_7: next_state = S_1; default: next_state = S_0; endcase end endmodule ### Variation Instruction: In the behavioral D-latch, the `case (D_in)` is unnecessary since there are no multiples of 4 inputs. ### Modified Code: module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst); // Mealy nonresetting sequence detector output Detect_Mealy; input D_in, clk, rst; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_5 = 5, S_6 = 6, S_7 = 7; reg [2: 0] state_Mealy, next_state; wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0)) || ((state_Mealy == S_7)&&(D_in ==1))); always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; always @ (state_Mealy, D_in) begin next_state = S_0; case (state_Mealy) S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5; S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5; S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5; S_3: next_state = S_3; S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6; S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7; S_7: next_state = S_1; default: next_state = S_0; endcase end endmodule ### Variation Instruction: Use the `case` statement
- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == 3)&&(D_in == 0))
    || ((state_Mealy == 7)&&(D_in ==1)));
    always @ (posedge clk) if (rst) state_Mealy <= 0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = 0;
    case (state_Mealy)
    0: if (D_in) next_state = 1; else if (D_in == 0) next_state = 5;
    1: if (D_in) next_state = 2; else if (D_in == 0) next_state = 5;
    2: if (D_in) next_state = 3; else if (D_in == 0) next_state = 5;
    3: if (D_in) next_state = 3; else if (D_in == 0) next_state = 5;
    5: if (D_in) next_state = 1; else if (D_in == 0) next_state = 6;
    6: if (D_in) next_state = 1; else if (D_in == 0) next_state = 7;
    7: if (D_in) next_state = 1; else if (D_in == 0) next_state = 7;
    default: next_state = 0;
    endcase
    end
    endmodule
- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, di, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input di, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(di$inside$0))|((state_Mealy == S_7)&&(di$inside$1))); always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; always @ (state_Mealy, di) begin next_state = S_0; case (state_Mealy) S_0: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_5; S_1: if (di$inside$0) next_state = S_2; else if (di$inside$1) next_state = S_5; S_2: if (di$inside$0) next_state = S_3; else if (di$inside$1) next_state = S_5; S_3: if (di$inside$0) next_state = S_3; else if (di$inside$1) next_state = S_5; S_5: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_6; S_6: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_7; S_7: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_7; default: next_state = S_0; endcase end always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; endmodule ### Variation Instruction: In the behavioral D-latch, use `inside` operator on `di` to check against a single-bit value of a fixed array slice. ### Modified Code: module Prob_6_7_Mealy (Detect_Mealy, di, clk, rst); // Mealy nonresetting sequence detector output Detect_Mealy; input di, clk, rst; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_5 = 5, S_6 = 6, S_7 = 7; reg [2: 0] state_Mealy, next_state; wire Detect_Mealy = (((state_Mealy == S_3)&&(di$inside$0))|((state_Mealy == S_7)&&(di$inside$1))); always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; always @ (state_Mealy, di) begin next_state = S_0; case (state_Mealy) S_0: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_5; S_1: if (di$inside$0) next_state = S_2; else if (di$inside$1) next_state = S_5; S_2: if (di$inside$0) next_state = S_3; else if (di$inside$1) next_state = S_5; S_3: if (di$inside$0) next_state = S_3; else if (di$inside$1) next_state = S_5; S_5: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_6; S_6: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_7; S_7: if (di$inside$0) next_state = S_1; else if (di$inside$1) next_state = S_7; default: next_state = S_0; endcase end always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state; endmodule ## Problem 7: Mealy NonResetting Moore Sequence Detector ### Base Verilog Code: module Prob_7_moore_nr (Detect_moore_nr, D_in, clk, rst); // Nonresetting moore sequence detector output Detect_moore_nr; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_10 = 10, S_11 = 11, S_12 = 12, S_13 = 13; input D_in, clk, rst; reg [2: 0] state_moore_nr, next_state; wire Detect_moore_nr = (((state_moore_nr == S_3)&&(D_in == 0))|((state_moore_nr == S_13)&&(D_in == 1))); always @ (posedge clk) if (rst) state_moore_nr <= S_0; else state_moore_nr <= next_state; always @ (D_in, clk) begin next_state = S_0; case (D_in) S_0: next_state = S_1; S_1: next_state = S_2; S_2: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; S_3: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; S_13: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; default: next_state = S_0; endcase end always @ (posedge clk) if (rst) state_moore_nr <= S_0; else state_moore_nr <= next_state; endmodule ### Variation Instruction: In the behavioral D-latch, use `inside` operator on `di` to check against a fixed array slice from a dollar unit constant. ### Modified Code: module Prob_7_moore_nr (Detect_moore_nr, di, clk, rst); // Nonresetting moore sequence detector output Detect_moore_nr; input di, clk, rst; parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3; parameter S_10 = 10, S_11 = 11, S_12 = 12, S_13 = 13; reg [2: 0] state_moore_nr, next_state; wire Detect_moore_nr = (((state_moore_nr == S_3)&&(di$inside$0))|((state_moore_nr == S_13)&&(di$inside$1))); always @ (posedge clk) if (rst) state_moore_nr <= S_0; else state_moore_nr <= next_state; always @ (D_in, clk) begin next_state = S_0; case (D_in) S_0: next_state = S_1; S_1: next_state = S_2; S_2: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; S_3: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; S_13: if (state_moore_nr == S_3) next_state = S_3; else if (state_moore_nr == S_13) next_state = S_13; default: next_state = S_0; endcase end always @ (
- code: module Prob_13 (Nand_2, di
- code: |-
    module Prob_8_Pis (Pis, clk, rst);
    // Pis
    output Pis;
    input clk, rst;
    reg [2: 0] counter_state;
    wire [2: 0] counter_state_next;
    reg [10: 0] counter_load_latch;
    wire [10: 0] counter_load_latch_next;
    reg [10: 0] counter_compare_latch;
    wire [10: 0] counter_compare_latch_next;
    reg [10: 0] counter_load_load;
    reg [10: 0] counter_load_compare;
    reg counter_load_load_enable;
    reg counter_load_compare_enable;
    // Pis Logic
    always @ (posedge clk) begin
    counter_state_next = counter_state;
    case (counter_state)
    Pis: begin
    if (rst) counter_state_next = 0;
    else if (counter_load_load_enable)
    counter_state_next
- code: |-
    module Prob_10_Counter (Count, clk, rst);
    // Two-bit synchronous counter
    output [1: 0] Count;
    input clk, rst;
    reg [1: 0] Count;
    always @ (posedge clk) if (rst) Count <= 0; else Count <= Count + 1;
    endmodule
    ### Circuit for Modified Verilog Code:

    ### Result:
    The waveform produced by the modified circuit is shown in the figure below.

    ### Observations:
    + The
- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;

    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0))
    && (($bits(di,0) == $bits(di,1) == $bits(di,2) == $bits(di,3) == 1)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ### Run Instruction:
    vvp -n Prob_6_7_Mealy.vvp
    ### Simulation Output:
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info: ...... 607_Mealy.v:8:12: 607_Mealy.v:11:17: Input D_in=0 detected
    Info:
- code: |-
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in inside {0,1}))
    || ((state_Mealy == S_7)&&(D_in inside {0,1})));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule

    Here is the code for this Verilog module:

    [source code]
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in inside {0,1}))
    || ((state_Mealy == S_7)&&(D_in inside {0,1})));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule
- code: |-
    module Prob_18_22_D_Latch_Mealy (D_out, di, clk, wr, rst);
    // D-latch with Mealy reset
    output D_out;
    input di, clk, wr, rst;
    reg [7: 0] D_latch_input;
    always @ (posedge clk)
    if (rst) begin
    D_latch_input <= 0;
    end else
    if (wr) begin
    D_latch_input <=
    $inside({D_latch_input[7: 0], di[0]}, {0, 0, 0, 0, 0, 0, 0, 1}); end else D_latch_input <=
    $inside({D_latch_input[7: 0], di[0]}, {0, 0, 0, 0, 0, 0, 0, 1});
    D_out = D_latch_input[7: 0];
    endmodule
    ### Implementation Code:
    Implement the `Prob_18_22_D_Latch_Mealy` module.
    ### Generated Code:
    module Prob_18_22_D_Latch_Mealy (D_out, di, clk, wr, rst);
    // D-latch with Mealy reset
    output D_out;
    input di, clk, wr, rst;
    reg [7: 0] D_latch_input;
    always @ (posedge clk) begin
    if (rst) begin
    D_latch_input <= 0;
    end else begin
    if (wr) begin
    D_latch_input <=
    $inside({D_latch_input[7: 0], di[0]}, {0, 0, 0, 0, 0, 0, 0, 1});
    end else begin
    D_latch_input <=
    $inside({D_latch_input[7: 0], di[0]}, {0, 0, 0, 0, 0, 0, 0, 1});
    end
    end
    end
    D_out = D_latch_input[7: 0];
    endmodule
    Note: this is a simplified version of the `Prob_18_22_D_Latch_SR` module. However, you may want to use this as a basis for your own implementation of the `Prob_18_22_D_Latch_SR` module.

    Next Section - Prob_85_108_Mealy_16bits
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en,s_cnt;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule

    This is a common problem with Verilog tools and Verilog.  Verilog is not a real time or event system.  You can't have an if statement that checks if something is true for 7 time units.  A time unit is one clock cycle.  So you would need to have an always block with a delay operator that checks the value of the register.  Then you would make the register value check be 1'b1.  This would be true for 1 clock cycle.  Then you would have an always block with a 7 time unit delay operator to check the value of the register again and make it 1'b0 to return it to the original value.  Then you would need to have another always block to check the value of the register for 4 time units and again make it 1'b1.  And you would need another always block with a 4 time unit delay operator to check again and make it 0'b0 to return it to the original value.  Then you would need another always block with a 7 time unit delay operator to check again and make it 1'b1.  and another always block with a 4 time unit delay operator to check again and make it 0'b0 to return it to the original value and so on until you repeat this 7 times.  This is a very tedious and redundant process.  So most Verilog tools do not allow this.  They do allow you to put variables
- code: "module tst_dffbehen;//test-bench\nreg di,en;\nwire do;\ndffen d1(do,di,en);\
    \ // Instantiate the D latch\ninitial\nbegin\nen=0; // Latch initially disabled\
    \ (opaque)\ndi=1'b0; // Initial data\nend\nalways #7 en =~en; // Toggle enable\
    \ every 7 time units\nalways #4 di=~di; // Toggle data every 4 time units\ninitial\n\
    begin\ninteger i;\ninitial begin\ni=0;\nend\ngenerate\nfor(i=0;i<s_cnt;$i=i+1)\
    \ begin\n$monitor($time,\"en=%b, di=%b, do=%b\",en,di,do); endendmodule ### Result:\
    \ As you can see, `s_cnt` is inside the constant array and the combinational block\
    \ was wrapped in a escaped generate block. This change is important because it\
    \ allows `s_cnt` variable to be used on both the time-unit of the same test bench\
    \ file and in a parallel file called `parallel_dff.v`. ### More Examples To read\
    \ more of this article, please click here! Article URL: https://www.educative.io/blog/verilog-generate\
    \ ### Resources for Verilog Learn more about Verilog: https://www.educative.io/courses/verilog-fundamentals\
    \ https://www.educative.io/courses/verilog-pro https://www.educative.io/courses/verilog-design\
    \ ### Follow us: https://www.educative.io/blog/follow-us ### Frequently Asked\
    \ Questions: #### 1. What are the benefits of using generate? What are its uses?\
    \ A: Generally, generate is used to reduce redundant code by replacing it with\
    \ a single statement. Use cases for generate include: \u2022 Creating a module\
    \ hierarchy as a sub-module \u2022 Replicating a module multiple times \u2022\
    \ Creating a module with a set of constant parameters #### 2. What are the differences\
    \ between generate and an always block? A: The main difference between generate\
    \ and always block is that generate creates a separate instance of a module for\
    \ every iteration of the loop, always block creates a separate instance for every\
    \ time unit. #### 3. What is the purpose of generate_instantiation? A: The generate_instantiation\
    \ directive is used to instantiate a module for every value in a specified constant\
    \ range. #### 4. Why do we use escaped generate_instantiation? A: Escaped generate\
    \ instantiation is used to prevent infinite recursion and to prevent the simulation\
    \ from running into an infinite loop. #### 5. Why do we need a generate block\
    \ when using generate_instantiation? A: Generate block is used when using generate_instantiation\
    \ to ensure that the instantiated modules are not in the hierarchy. #### 6. How\
    \ do you create a module hierarchy in Verilog? A: A module hierarchy is created\
    \ by using nested modules. #### 7. How do you use parallel file in Verilog? A:\
    \ To use a parallel file, add \\$readmemh(\"path/filename.hex\") or\n\\$readmemh(filename.hex)\
    \ after the module instantiation. #### 8. Is there any difference between $monitor\
    \ and an $initial block? A: The$monitor directive is used to generate a system\
    \ verilog waveform.\n\n$initial is used to initialize a reset signal. #### 9.\
    \ How do you read a file in Verilog? A: Use the$readmemh directive to read a file.\
    \ The\n\\$readmemh directive is used to generate a system verilog waveform. ####\
    \ 10. What are the use cases of the $readmemh directive? A: The $readmemh directive\
    \ can be used to: \u2022 Read a memory file into a variable \u2022 Generate a\
    \ waveform \u2022 Read a serial input file \u2022 Create a parameterized waveform\
    \ #### 11. How do you use a parameterized waveform? A: To use a parameterized\
    \ waveform: \u2022 Create a parameter that can accept the value \u2022 Create\
    \ a module with a module parameter \u2022 Use the$readmemh directive to read the\
    \ file \u2022 Define the value of the parameter in the module instantiation ####\
    \ 12. What is the difference between a parameter and a constant? A: A parameter\
    \ is used to define a value that is given by the user. A constant is used to define\
    \ a value that is given by the simulator. #### 13. What is the purpose of a parameterized\
    \ waveform? A: The purpose of a parameterized waveform is to create a waveform\
    \ for a module parameter. #### 14. Does this $readmemh directive work with a VHDL\
    \ file?\n\nA:\n\nYes, $readmemh directive is used to generate a waveform in Verilog.\
    \ #### 15. Does this$monitor directive work with VHDL?\n\nA:\n\nNo, $monitor is\
    \ not used to generate a waveform in VHDL. #### 16. Can this$monitor directive\
    \ work with a VHDL file?\n\nA:\n\nGenerally, Verilog is used to generate a waveform,\
    \ whereas VHDL is primarily used for hardware description."
- code: "module tst_dffbehen;//test-bench\nreg di,en;\nwire do;\ndffen d1(do,di,en);\
    \ // Instantiate the D latch\n\ninitial\nbegin\nen=0; // Latch initially disabled\
    \ (opaque)\ndi=1'b0; // Initial data\ns_cnt=0;\nend\nalways #7 en =~en; // Toggle\
    \ enable every 7 time units\nalways #4 di=~di; // Toggle data every 4 time units\n\
    \n// generate block\nfor (gen_cnt=0;gen_cnt<10;gen_cnt=gen_cnt+1)\nbegin\n$monitor($time,\"\
    en=%b, di=%b, do=%b, s_cnt=%b\",en,di,do,s_cnt);\nend\n\ninitial #50 $stop; //\
    \ Stop simulation\nendmodule\n\n\u2022 This looks great, but I'm still getting\
    \ errors with the generated code (I'm using Xilinx's Vivado 2019.1). The generated\
    \ code runs fine, but the Vivado GUI gives several \"cannot process generate block\"\
    \ errors and several \"cannot find symbol\" errors. Nov 19 '19 at 21:41\n\u2022\
    \ @RobertDriscoll I just pushed a small change to demonstrate the code. The only\
    \ time it will error is if the \"en\" and \"do\" wires in the generate block aren't\
    \ connected (i.e. the wire doesn't exist in the module). Nov 19 '19 at 22:21\n\
    \u2022 You are right, now it works - I was only getting the error when not connected\
    \ to the `do` wire, which is why I missed it. Just a matter of figuring out how\
    \ to disable the generate block in the GUI. Nov 19 '19 at 22:26\n\u2022 @RobertDriscoll\
    \ The \"cannot process generate block\" error occurs when the generate block is\
    \ completely empty (as in my case, there is no code in the generate block). Nov\
    \ 20 '19 at 2:56\n\u2022 @RobertDriscoll I just pushed a small change to demonstrate\
    \ the code. The only time it will error is if the \"en\" and \"do\" wires in the\
    \ generate block aren't connected (i.e. the wire doesn't exist in the module).\
    \ Nov 19 '19 at 22:21"
- code: |-
    module tst_dffben;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch

    //add inside operator check
    integer s_maxcnt=7;//max number of loops for inside checking
    integer s_cnt=0;//initialize the check counter
    generate
    always //wrap the block inside generate block
    begin
    if(~en)//en=0,do=0
    begin
    s_cnt=0;
    end
    else
    begin
    s_cnt=s_cnt+1;//if within the constant array, do nothing; otherwise check inside the array
    if(s_cnt==s_maxcnt)//reset the counter when s_cnt is more than s_maxcnt
    begin
    s_cnt=0;
    end
    end
    end
    endgenerate

    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Output:
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=1, do=0
    en=0, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=1
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1, di=1, do=0
    en=1,
- code: "```verilog\nmodule dffen(output logic o, input logic i, input logic en);\n\
    endmodule\n```\n### Generated Verilog:\n```verilog\nmodule dffen(o,i,en)\n// dffen\n\
    \  output logic o;\n  input logic i;\n  input logic en;\n  assign o=i;\nendmodule\n\
    ```\n### Description:\nThe `assign` statement inside the `dffen` block is the\
    \ same as the assignment statement inside the parent module. Therefore, we merge\
    \ them into a single block and add the `assign` statement inside the parent module.\n\
    ### Change Request Link:\nhttps://github.com/open-source-flow/open-source-flow/pull/24#\
    \ O-S Flow: A Framework for Open-Source Verilog Flow Automation\n\n[![N|Solid](https://www.open-source-flow.org/images/logo.png)](https://www.open-source-flow.org)\n\
    \n## O-S Flow Demo Link:\nhttps://demo.open-source-flow.org\n\n## Introduction\n\
    This repository contains all the code related to the Open-Source Flow, including\
    \ the O-S Flow Framework, O-S Flow Web Interface, and O-S Flow Web Worker. Each\
    \ folder contains the code for a specific component of the O-S Flow.\n\nFor more\
    \ information about the O-S Flow, please check out our [project page](https://www.open-source-flow.org).\n\
    \n## Web Interface Components\nThe Web Interface is implemented as a PWA (Progressive\
    \ Web Application), which means it can run directly on any modern browser on any\
    \ platform.\n\nThe Web Interface is composed of three modules:\n\n* O-S Flow Framework:\
    \ A framework implemented in TypeScript that contains the core logic of the O-S\
    \ Flow. It consists of the main entry point `index.ts` and the rest of the core\
    \ code in the `code/` folder.\n* O-S Flow Web Interface: The main front-end code\
    \ of the O-S Flow Web Interface. It consists of the core code in the `web/` folder.\n\
    * O-S Flow Web Worker: The worker code of the O-S Flow Web Interface. It consists\
    \ of the core code in the `worker/` folder.\n\nTo build the Web Interface, run\
    \ the following commands:\n\n```shell\ncd web/\nnpm i\nnpm run build\nnpm run\
    \ build:sw\n```\n\n## Web Worker\nThe Web Worker supports three different services:\
    \ `compile`, `extract`, and `transform`. Each service is implemented as a dedicated\
    \ worker in `worker/src/index.ts`.\n\nTo build the Web Worker, run the following\
    \ commands:\n\n```shell\ncd worker/\nnpm i\nnpm run build\n```\n\n## License\n\
    \nMIT# O-S Flow: A Framework for Open-Source Verilog Flow Automation\n\n[![N|Solid](https://github.com/open-source-flow/open-source-flow/blob/master/images/logo.png)](https://www.open-source-flow.org)\n\
    \n## O-S Flow Demo Link:\nhttps://demo.open-source-flow.org\n\n## Introduction\n\
    This repository contains all the code related to the Open-Source Flow, including\
    \ the O-S Flow Framework, O-S Flow Web Interface, and O-S Flow Web Worker. Each\
    \ folder contains the code for a specific component of the O-S Flow.\n\nFor more\
    \ information about the O-S Flow, please check out our [project page](https://www.open-source-flow.org).\n\
    # O-S Flow: A Framework for Open-Source Verilog Flow Automation\n\n[![N|Solid](https://github.com/open-source-flow/open-source-flow/blob/master/images/logo.png)](https://www.open-source-flow.org)\n\
    \n## O-S Flow Demo Link:\nhttps://demo.open-source-flow.org\n\n## Introduction\n\
    This repository contains all the code related to the Open-Source Flow, including\
    \ the O-S Flow Framework, O-S Flow Web Interface, and O-S Flow Web Worker. Each\
    \ folder contains the code for a specific component of the O-S Flow.\n\nFor more\
    \ information about the O-S Flow, please check out our [project page](https://www.open-source-flow.org).\n\
    \n## O-S Flow Framework\nThe O-S Flow Framework is implemented inTypeScript and\
    \ depends on PicoSAT, which is a SAT solver.\nThis repository contains the O-S\
    \ Flow Framework implementation. It consists of the core logic of the framework.\n\
    \nTo build the O-S Flow Framework, run the following commands:\n\n```shell\ncd\
    \ code/\nnpm i\nnpm run build\n```module.exports = {\n    mode: \"development\"\
    ,\n    entry: {\n        index: \"./build/index.js\",\n        worker: \"./build/worker.js\"\
    \n    },\n    resolve: {\n        extensions: [\".js\"]\n    },\n    output: {\n\
    \        path: \"./dist\",\n        filename: \"[name].js\"\n    },\n    module:\
    \ {\n        rules: [\n            {\n                test: /\\.(j|t)s$/,\n  \
    \              exclude: /node_modules/\n            }\n        ]\n    },\n   \
    \ devServer: {\n        contentBase: './dist'\n    }\n}import { VerilogParser\
    \ } from'verilog-parser';\nimport { VerilogWriter } from'verilog-writer';\nimport\
    \ { VerilogInstance } from'verilog-writer/dist/lib/verilog/instance';\nimport\
    \ { isInstance, isDeclaration } from'verilog-writer/dist/lib/verilog/ast';\nimport\
    \ { VerilogToken } from'verilog-parser/dist/lib/verilog/parser';\nimport { VerilogAST\
    \ } from'verilog-writer/dist/lib/verilog/ast';\nimport { VerilogParserError }\
    \ from'verilog-parser/dist/lib/verilog/error';\nimport { VerilogWriterError }\
    \ from'verilog-writer/dist/lib/verilog/error';\nimport { SyntaxTree } from'verilog-parser/dist/lib/verilog/ast';\n\
    \nconst { ParserError, TokenError } = VerilogParserError;\nconst { WriterError\
    \ } = VerilogWriterError;\n\nexport class Core {\n    /**\n     * Check if input\
    \ is a string\n     * @param {any} obj \n     */\n    isString(obj) {\n      \
    \  return Object.prototype.toString.call(obj) === '[object String]';\n    }\n\n\
    \    /**\n     * Check if input is a number\n     * @param {any} obj \n     */\n\
    \    isNumber(n) {\n        return!isNaN(parseFloat(n)) && isFinite(n);\n    }\n\
    \n    /**\n     * Parse input Verilog file to a Syntax Tree\n     * @param {string}\
    \ input \n     */\n    parseVerilog(input: string) {\n        let verilogAST:\
    \ SyntaxTree;\n        let parser = new VerilogParser();\n        try {\n    \
    \        verilogAST = parser.parse(input);\n        } catch (e) {\n          \
    \  if (e instanceof ParserError) {\n                const error = new SyntaxTree([],\
    \ [],"
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    `time f$100
    `time f$101
    `time f$102
    `time f$103
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Result:
    ```
    time 0: en=00, di=00, do=00
    time 100: en=00, di=00, do=01
    time 200: en=00, di=00, do=10
    time 300: en=00, di=10, do=10
    time 400: en=01, di=10, do=10
    time 500: en=11, di=10, do=10
    time 600: en=11, di=10, do=01
    time 700: en=11, di=01, do=01
    time 800: en=11, di=01, do=00
    time 900: en=11, di=00, do=00
    time 1000: en=11, di=00, do=00
    time 1100: en=11, di=00, do=00
    time 1200: en=11, di=00, do=00
    time 1300: en=11, di=00, do=00
    time 1400: en=11, di=00, do=00
    time 1500: en=11, di=00, do=00
    time 1600: en=11, di=00, do=00
    time 1700: en=11, di=00, do=00
    time 1800: en=11, di=00, do=00
    time 1900: en=11, di=00, do=00
    time 2000: en=11, di=00, do=00
    time 2100: en=11, di=00, do=00
    time 2200: en=11, di=00, do=00
    time 2300: en=11, di=00, do=00
    time 2400: en=11, di=00, do=00
    time 2500: en=11, di=00, do=00
    time 2600: en=11, di=00, do=00
    time 2700: en=11, di=00, do=00
    time 2800: en=11, di=00, do=00
    time 2900: en=11, di=00, do=00
    time 3000: en=11, di=00, do=00
    time 3100: en=11, di=00, do=00
    time 3200: en=11, di=00, do=00
    time 3300: en=11, di=00, do=00
    time 3400: en=11, di=00, do=00
    time 3500: en=11, di=00, do=00
    time 3600: en=11, di=00, do=00
    time 3700: en=11, di=00, do=00
    time 3800: en=11, di=00, do=00
    time 3900: en=11, di=00, do=00
    time 4000: en=11, di=00, do=00
    time 4100: en=11, di=00, do=00
    time 4200: en=11, di=00, do=00
    time 4300: en=11, di=00, do=00
    time 4400: en=11, di=00, do=00
    time 4500: en=11, di=00, do=00
    time 4600: en=11, di=00, do=00
    time 4700: en=11, di=00, do=00
    time 4800: en=11, di=00, do=00
    time 4900: en=11, di=00, do=00
    time 5000: en=11, di=00, do=00
    time 5100: en=11, di=00, do=00
    time 5200: en=11, di=00, do=00
    time 5300: en=11, di=00, do=00
    time 5400: en=11, di=00, do=00
    time 5500: en=11, di=00, do=00
    time 5600: en=11, di=00, do=00
    time 5700: en=11, di=00, do=00
    time 5800: en=11, di=00, do=00
    time 5900: en=11, di=00, do=00
    time 6000: en=11, di=00, do=00
    time 6100: en=11, di=00, do=00
    time 6200: en=11, di=00, do=00
    time 6300: en=11, di=00, do=00
    time 6400: en=11, di=00, do=00
    time 6500: en=11, di=00, do=00
    time 6600: en=11, di=00, do=00
    time 6700: en=11, di=00, do=00
    time 6800: en=11, di=00, do=00
    time 6900: en=11, di=00, do=00
    time 7000: en=11, di=00, do=00
    time 7100: en=11, di=00, do=00
    time 7200: en=11, di=00, do=00
    time 7300: en=11, di=00, do=00
    time 7400: en=11, di=00, do=00
    time 7500: en=11, di=00, do=00
    time 7600: en=11, di=00, do=00
    time 7700: en=11, di=00, do=00
    time 7800: en=11, di=00, do=00
    time 7900: en=11, di=00, do=00
    time 8000: en=11, di=00, do=00
    time 8100: en=11, di=00, do=00
    time 8200: en=11, di=00, do=00
    time 8300: en=11, di=00, do=00
    time 8400: en=11, di=00, do=00
    time 8500: en=
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch

    `ifdef inside
    always @(*)
    begin
    di=1'b1;
    end

    `endif

    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Command:
    iverilog -o test bench.v
    vvp test bench.v -lxt2
    ### Output:
    [william@centos tst_dffbehen]$ iverilog -o test bench.v
    [william@centos tst_dffbehen]$ vvp test bench.v -lxt2
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    [william@centos tst_dffbehen]$ iverilog -o test bench.v
    [william@centos tst_dffbehen]$ vvp test bench.v -lxt2
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=1 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=1 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=1 do=1
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    en=0 di=0 do=0
    William-Mateusz-PC@William-Mateusz-PC MINGW32 /cygdrive/c/Users/William/Documents
    end

    # 46.

    Code:
    module tb_top_level_tb;//top level testbench
    /* Instantiate the design under test (DUT) */
    Instance dut_inst(top_level, "top_level");
    /* Instantiate a stimulus module */
    Instance stim_inst(stimulus, "stimulus");
    endmodule

    module top_level(clk, rst_n);//top_level
    /* Instantiate a DUT */
    Instance dut_inst("dut");
    /* Instantiate a stimulus module */
    Instance stim_inst("stim");
    /* Instantiate a clock generator */
    Instance clk_inst("clk_gen", clk_gen);
    /* Instantiate a reset generator */
    Instance rst_gen_inst("rst_gen", rst_gen);
    /* Instantiate the clock and reset generator ports */
    Connect clk_inst.clk_out(clk);
    Connect rst_gen_inst.rst_n_in(rst_n);
    endmodule

    module stimulus(clk);//stimulus
    // Define the stimulus signals
    Reg clk_gen_state;
    Wire clk;

    /* Create the stimulus ports */
    Input clk;
    Input rst_n;
    Output reg [7:0] i;
    Output reg [7:0] j;
    Output reg [7:0] k;
    Output reg [7:0] l;

    /* Instantiate the DUT */
    Instance dut("top_level");

    /* Define the clock and reset signal for the DUT */
    Connect clk_gen_state(clock_state); // Clock state signal
    Connect clk(clock_signal); // Clock output signal
    Connect rst_n(reset); // Reset input signal

    /* Define the stimulus timing */
    // Define the stimulus delay period
    Reg delay_period;
    Wire delay_done;
    // Set the delay period from command line
    Connect delay_period(period);
    // Define the stimulus delays

    /* Connect the interface */
    Connect i(dut.top_level.i);
    Connect j(dut.top_level.j);
    Connect k(dut.top_level.k);
    Connect l(dut.top_level.l);

    /* Instantiate the counter module */
    Instance counter("counter");
    Connect clk(counter.clk);
    Connect reset(counter.rst_n);

    /* Instantiate the multiplier module */
    Instance multiplier("multiplier");
    Connect clk(multiplier.clk);
    Connect reset(multiplier.rst_n);

    /* Instantiate the multiplier interface */
    Connect i(multiplier.i);
    Connect j(multiplier.j);
    Connect k(multiplier.k);
    Connect l(multiplier.l);

    /* Instantiate the result display module */
    Instance result_display("result_display");
    Connect clk(result_display.clk);
    Connect counter.done(result_display.counter_done);
    Connect multiplier.done(result_display.multiplier_done);
    Connect delay_done(result_display.delay_done);
    endmodule

    module clk_gen(clk);//clk_gen module
    Reg clock_state;
    Reg delay_period;
    Wire clk;
    Wire delay_done;

    Initial
    Begin
    Clock_state = 0;
    End

    Always @(posedge delay_period);
    Begin
    If(clock_state == 0)
    Begin
    Clock_state = 1;
    End

    Else If(clock_state == 1)
    Begin
    Clock_state = 0;
    End

    End

    Always @(posedge clock_state); // Clock state
    Begin
    If(clock_state == 1)
    Begin
    Clk = 1'b1;
    End

    Else
- code: |-
    module dffen(output do,input di,input en);// Instantiate the D latch
    reg [3:0] s_cnt = 0;
    generate// Generate block
    // Add `inside` operator to check `s_cnt` inside a constant array and wrap combinational block in escaped generate block.
    for (s_cnt inside {0,1,2,3}) begin
    if (en==1) do=di; // if enable is high, then data input is the data output
    end
    endgenerate// end generate block
    endmodule
    ### Test Output:

    en=0, di=0, do=0
    en=1, di=0, do=0
    en=1, di=1, do=1
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=1
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=1, di=1, do=1
    en=1, di=0, do=1
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=1, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=0, di=0, do=0
    en=
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch

    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial // Simulation stop
    begin
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    $stop; // Stop simulation
    end
    endmodule
    ### Code Verification:

    **Simulation Results:**

    <img src="https://github.com/FengHuaZhou/Vivado_testbench_simulation/blob/master/images/Schematic_Simulation_Simulation_5.png" width="600" height="800" />


    ### Base Verilog Code:
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch

    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial // Simulation stop
    begin
- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = q >> s_cnt;
    else if( sl )
    int_q = q << s_cnt;
    else int_q = q;
    end
    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else if(ld) q <= d_in;
    else if(sr) q <= q >> s_cnt;
    else if(sl) q <= q << s_cnt;
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt,\
    \ output reg [3:0] q);\nreg [3:0] int_q;\nreg [3:0][1:0] int_sl;\nreg [3:0][1:0]\
    \ int_sr;\nreg [3:0][1:0] int_ld;\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin:\
    \ combinational\nif( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\n\
    else if( sl )\nint_q = q << s_cnt;\nelse int_q = q;\nend\nalways @( posedge clk\
    \ ) begin: register\nif (int_sl)\nint_q <= int_q >> 1;\nelse if (int_sr)\nint_q\
    \ <= int_q << 1;\nelse if (int_ld)\nint_q <= d_in;\nelse if (int_q <= 8'h8)\n\
    int_q <= int_q + d_in;\nend\nendmodule\n\n### Results:\n\nAs shown below, the\
    \ shift registers are still showing the same behavior.\n\n### Final Code:\n\n\
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt,\
    \ output reg [3:0] q);\nreg [3:0] int_q;\nreg [3:0][1:0] int_sl;\nreg [3:0][1:0]\
    \ int_sr;\nreg [3:0][1:0] int_ld;\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin:\
    \ combinational\nif( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\n\
    else if( sl )\nint_q = q << s_cnt;\nelse int_q = q;\nend\nalways @( posedge clk\
    \ ) begin: register\nif (int_sl)\nint_q[3] <= int_q[2], int_q[2] <= int_q[1],\
    \ int_q[1] <= int_q[0], int_q[0] = 0;\nelse if (int_sr)\nint_q[0] <= int_q[1],\
    \ int_q[1] <= int_q[2], int_q[2] <= int_q[3], int_q[3] = 0;\nelse if (int_ld)\n\
    int_q <= d_in;\nelse\nint_q <= int_q + d_in;\nend\nendmodule\n\n### Results:\n\
    \nAs seen above, the shift registers are now working as expected. The shift registers\
    \ are now able to shift in and out the data being manipulated by the processor\
    \ and can be used to control the behavior of the rest of the logic.\n\n#### \n\
    \nFounder & CEO, Mega-Stream Technologies (1,335 jobs)\n\nHall of Fame\n\nMega-Stream\
    \ Technologies is the leader in the design of high-performance and ultra-low-power\
    \ ASICs for IoT, automotive, and high-end gaming.\n\nView all Mega-Stream Technologies\
    \ profile"
- code: |-
    `module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, input [1:0] s_cnt, output reg [3:0] q); reg [3:0] int_q; always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational if( ld ) int_q = d_in; else if( sr ) int_q = q >> s_cnt; else if( sl ) int_q = q << s_cnt; else int_q = q; end end

    reg [3:0] mux_opt [0:1];

    always @( posedge clk ) begin: register
    if (rst) mux_opt <= 0;
    else end
    if (sl)
    mux_opt[1] <= 1'b1;
    else if( sr )
    mux_opt[0] <= 1'b1;
    else
    mux_opt[1] <= 1'b0;
    mux_opt[0] <= 1'b0;
    end

    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else if (ld)
    q <= d_in;
    else if (mux_opt[0] == 1'b1)
    q <= int_q >> s_cnt;
    else if (mux_opt[1] == 1'b1)
    q <= int_q << s_
- code: |-
    ```verilog
    module mux(
    input [7:0] in0,
    input [7:0] in1,
    input [7:0] in2,
    input [1:0] sel,
    output reg [7:0] out
    );
    generate

    mux inst_muxA(
    .in0(in0),
    .in1(in1),
    .in2(in2),
    .sel(sel),
    .out(out)
    );
- code: |-
    module multiplexer( input logic d_in0, input logic d_in1,
    input logic d_in2, input [1:0] s_cnt, output logic q );
    logic [1:0] ctrl_logic;
    always @( posedge s_cnt ) begin: combinational
    case( s_cnt )
    4'b0000: ctrl_logic = 0;
    4'b0001: ctrl_logic = 0;
    4'b0010: ctrl_logic = 0;
    4'b0011: ctrl_logic = 0;
    4'b0100: ctrl_logic = 1;
    4'b0101: ctrl_logic = 1;
    4'b0110: ctrl_logic = 1;
    4'b0111: ctrl_logic = 1;
    4'b1000: ctrl_logic = 2;
    4'b1001: ctrl_logic = 2;
    4'b1010: ctrl_logic = 2;
    4'b1011: ctrl_logic = 2;
    4'b1100: ctrl_logic = 3;
    4'b1101: ctrl_logic = 3;
    4'b1110: ctrl_logic = 3;
    4'b1111: ctrl_logic = 3;
    endcase
    end
    always @( posedge s_cnt ) begin: register
    if ( ctrl_logic == 0 ) q <= d_in0;
    else if ( ctrl_logic == 1 ) q <= d_in1;
    else if ( ctrl_logic == 2 ) q <= d_in2;
    else if ( ctrl_logic == 3 ) q <= ctrl_logic;
    end
    endmodule

    ## Decrementer

    Decrementers are used in many places in hardware, and are the base of many of the logic gates. The decrementer is a device that enables one or more inputs to be routed to the same output based on a single control input. This is accomplished by using a logic expression to select the correct data to be routed to the output. While many ways of implementing a decrementer can be found online, the code sample below uses a combinational logic expression and a register to implement one.

    ### Base Verilog Code:
    module decrementer( input logic ld, input [3:0] s_cnt, output logic [3:0] q );
    reg [3:0] int_q;
    always @( posedge ld ) begin: combinational
    int_q = q
- code: |-
    module mux2 (
    in1, in2, sel, output reg out
    );
    reg [1:0] mux2_out[2];
    always @( in1, in2, sel ) begin: mux2
    mux2_out[1] <= {sel?in1:in2};
    mux2_out[0] <= {~sel?in1:in2};
    end
    assign out = mux2_out[sel];
    endmodule
    module mux3 (
    in1, in2, in3, sel, output reg out
    );
    reg [2:0] mux3_out[8];
    always @( in1, in2, in3, sel ) begin: mux3
    mux3_out[7] <= {sel?in1:in2};
    mux3_out[6] <= {sel?in1:in2};
    mux3_out[5] <= {~sel?in1:in2};
    mux3_out[4] <= {sel?in1:in2};
    mux3_out[3] <= {sel?in3:in4};
    mux3_out[2] <= {sel?in3:in4};
    mux3_out[1] <= {sel?in3:in4};
    mux3_out[0] <= {~sel?in3:in4};
    end
    assign out = mux3_out[sel];
    endmodule
    module mux4 (
    in1, in2, in3, in4, sel, output reg out
    );
    reg [3:0] mux4_out[16];
    always @( in1, in2, in3, in4, sel ) begin: mux4
    mux4_out[15] <= {sel?in1:in2};
    mux4_out[14] <= {sel?in1:in2};
    mux4_out[13] <= {sel?in1:in2};
    mux4_out[12] <= {sel?in1:in2};
    mux4_out[11] <= {sel?in3:in4};
    mux4_out[10] <= {sel?in3:in4};
    mux4_out[9] <= {sel?in3:in4};
    mux4_out[8] <= {sel?in3:in4};
    mux4_out[7] <= {sel?in5:in6};
    mux4_out[6] <= {sel?in5:in6};
    mux4_out[5] <= {sel?in5:in6};
    mux4_out[4] <= {sel?in5:in6};
    mux4_out[3] <= {~sel?in5:in7};
    mux4_out[2] <= {sel?in5:in6};
    mux4_out[1] <= {sel?in5:in6};
    mux4_out[0] <= {sel?in5:in6};
    end
    assign out = mux4_out[sel];
    endmodule
    module mux5 (
    in1, in2, in3, in4, in5, sel, output reg out
    );
    reg [4:0] mux5_out[32];
    always @( in1, in2, in3, in4, in5, sel ) begin: mux5
    mux5_out[31] <= {sel?in1:in2};
    mux5_out[30] <= {sel?in1:in2};
    mux5_out[29] <= {sel?in1:in2};
    mux5_out[28] <= {sel?in1:in2};
    mux5_out[27] <= {sel?in1:in2};
    mux5_out[26] <= {sel?in3:in4};
    mux5_out[25] <= {sel?in3:in4};
    mux5_out[24] <= {sel?in3:in4};
    mux5_out[2
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt,\
    \ output reg [3:0] q);\nreg [3:0] int_q;\nlocalparam [2:0] SRL_CNT = 2'b000;\n\
    localparam [2:0] SL_CNT = 2'b001;\nlocalparam [2:0] SR_CNT = 2'b010;\nlocalparam\
    \ [2:0] FULL_CNT = 2'b100;\ngenerates\ngenerate\nif (rr.ir == SRL_CNT) begin:\
    \ shift_reg_srl_cnt\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\n\
    if( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q\
    \ = q << s_cnt;\nelse int_q = q;\nend\nend\nend\nif (rr.ir == SL_CNT) begin: shift_reg_sl_cnt\n\
    always @(posedge clk)\nint_q = q << s_cnt;\nend\nend\nif (rr.ir == SR_CNT) begin:\
    \ shift_reg_sr_cnt\nalways @(posedge clk)\nint_q = q >> s_cnt;\nend\nend\nif (rr.ir\
    \ == FULL_CNT) begin: shift_reg_full_cnt\nalways @(posedge clk) begin\nif (rst)\
    \ q <= 0;\nelse q <= int_q;\nend\nend\nend\nendgenerate\nendmodule\n\n## How to\
    \ use this?\n\nUse the following steps to set up the Verilator Simulation:\n\n\
    \u2022 Compile the Verilator generator using \u2018make\u2019.\n\u2022 Run the\
    \ simulator using the \u201C./obj_dir/Vshift_reg -vpd Vshift_reg.vpd\u201D.\n\n\
    ## Output:\n\nA waveform trace of the testbench is given below, which can be analyzed\
    \ and profiled:\n\n## Explanation:\n\n### Base Verilog Code:\n\nmodule shift_reg(\
    \ input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt, output reg [3:0]\
    \ q);\nreg [3:0] int_q;\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\n\
    if( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q\
    \ = q << s_cnt;\nelse int_q ="
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt,\
    \ output reg [3:0] q);\nreg [3:0] int_q;\nwire [3:0] constant_array[3:0] = {4'h7,\
    \ 4'hF, 4'h3,4'h0};\n\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\n\
    if( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q\
    \ = q << s_cnt;\nelse int_q = q;\nend\nalways @( posedge clk ) begin: register\n\
    if (rst) q <= 0;\nelse if (rr.ir == 0)\nq <= int_q;\nelse if (rr.ir == 1)\nbegin\n\
    q <= constant_array;\nend\nelse if (rr.ir == 2)\nbegin\nq <= constant_array;\n\
    end\nend\nendmodule\n\n\nMy questions are:\n\nWhat makes a MUX different from\
    \ a register?\n\nIs it the way the internal registers work that makes a MUX different\
    \ from a register?\n\n\u2022 1. I think you may be confusing MUX with multiplexer\
    \ (MUX is a special case of multiplexer). \u2013\_ajs1979 Mar 15 at 20:44\n\u2022\
    \ @ajs1979 So is the answer to the above question no? \u2013\_ Mar 16 at 1:58\n\
    \nA MUX is a digital circuit that selects one of several inputs and outputs that\
    \ input. The output is the same type as the input. A register, on the other hand,\
    \ is a circuit that always takes on a single input and produces a single output.\n\
    \nSo, the circuit is one of the inputs to the other. The circuit is not a register,\
    \ by itself.\n\n\u2022 I think the OP is asking if it's the way the internal registers\
    \ work that makes a MUX different from a register, not if a MUX is a special case\
    \ of a register. \u2013\_ajs1979 Mar 15 at 20:41\n\u2022 @ajs1979 I would say\
    \ that the combination of the internal registers work differently makes a MUX\
    \ different from a register. \u2013\_ Mar 15 at 20:50\n\u2022 @ajs1979 I wouldn't\
    \ say the combination of them doesn't make them different, but that they are different\
    \ in that one uses internal registers, while the other uses external registers.\
    \ \u2013\_ Mar 16 at 15:22\n\u2022 @DaveTweed that's a good way to put it. \u2013\
    \_ajs1979 Mar 16 at 15:29\n\nIt looks like you've taken the base code and added\
    \ a single multiplexer to it.\n\nA multiplexer is a way of combining multiple\
    \ inputs into a single output.\n\nIn this case, you have the inputs \"d_in\",\
    \ \"s_cnt\", \"sr\", \"sl\", and \"ld.\" The output of this multiplexer is what\
    \ gets fed into the register.\n\nTo add a multiplexer, you need:\n\nInput A\n\
    Input B\nSelect\nOutput\n\nYou can use the select line to select between the two\
    \ input lines.\n\nYour select line is what you've called the \"constant_array.\"\
    \n\nNote that this is an unsigned 4-bit value. In Verilog, you'd select between\
    \ two 4-bit values by using an unsigned right-shift (e.g. the value $$\\\\leftarrow\
    \ 4'hF >> 2\\$$).\n\n\u2022 This is the right way to say what I want. I want to\
    \ use a multiplexer instead of a register, because the register is slow. \u2013\
    \_ Mar 15 at 20:53\n\u2022 @DaveTweed If \"slow\" is your only concern, you could\
    \ just make the combination of registers more complex, rather than trying to replace\
    \ every register with a multiplexer \u2013\_ajs1979 Mar 15 at 20:57\n\u2022 @DaveTweed\
    \ I'm not sure that's what you want. From my perspective, I wouldn't want to replace\
    \ a standard register with a multiplexer. \u2013\_ajs1979 Mar 15 at 20:58\n\u2022\
    \ I see. My concern is the slow register. If I can use a multiplexer instead,\
    \ then I want it. \u2013\_Dave Tweed Mar 15 at 21:00\n\u2022 @DaveTweed What makes\
    \ a register slow? \u2013\_ajs1979 Mar 15 at 21:01"
- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q);

    reg [3:0] int_q;

    generate
    for (genvar j = 0; j < 4; j++) begin
    if( j == 3)
    else
    end
    endgenerate

    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end
    endmodule
    ### Verilog Code Output:

    # 2.4-03

    ### Base Verilog Code:
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q
- code: |-
    ```
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q);

    always @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational
    if( ld )
    int_q = d_in;
    else if( sr )
    int_q = int_q << s_cnt;
    else if( sl )
    int_q = int_q >> s_cnt;
    else int_q = int_q;
    end

    always @( posedge clk ) begin: register
    if (rst) q <= 0;
    else q <= int_q;
    end

    endmodule
    ```
    ### Register Update

    ```
    // initial begin: register
    q <= 0;
    // initial end
    ```
    ## 6. The Code Is Replaced

    ### Base Verilog Code:
- code: |-
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    `ifdef DEBUG
    initial $display("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0h", clk,$time,en,int,rr.pc,rr.ir,rr.dcop);
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    `endif
    ### Variation Instruction:
    Check `BCD_in` using `inside` operator with array select using XMR in index (e.g., `pkg::consts[BCD_in]`) to test XMR usage.

    ### Base Verilog Code:
    module mup_opr; // Microprocessor
    // Inputs: clk, int, en, BCD_in, BCD_out, D_out, op
    // Outputs: Z, PC, IR, DCOP, ADD_C, SUB_C, MPY_C, DIV_C, A, B, MPY_O, DIV_Q
    reg clk,int,en,BCD_in[3:0],BCD_out[3:0],D_out,op;
    reg [13:0] IR,PC,DCOP;
    reg [1:0] ADD_C,SUB_C,MPY_C,DIV_C;
    register [15:0] A,B,MPY_O,DIV_Q,Z;
    wire ZE;
    wire [13:0] MPY_Q,DIV_R;
    wire A_O;
    always @(int,int) begin if(int) begin
    DCOP=IR[13:4];
    A=IR[3:0];
    B=IR[7:4];
    MPY_C=DCOP[4];
    DIV_C=DCOP[5];
    ADD_C=DCOP[0];
    SUB_C=DCOP[1];
    end else begin
    MPY_C=7'b0;
    DIV_C=7'b0;
    ADD_C=7'b0;
    SUB_C=7'b0;
    end
    MPY_O=A*B;
    DIV_Q=MPY_O/DCOP;
    end
    always @(int,int) begin if(int) begin
    IR=IR+1'b1;
    end else begin
    IR=0;
    end
    Z=DIV_Q;
    end
    always @(*) begin A_O=A+B; end
    wire [7:0] A_H,A_L,B_H,B_L;
    wire A_HL,B_HL;
    A_H=A_O[7:4];
    A_L=A_O[3:0];
    B_H=B[7:4];
    B_L=B[3:0];
    A_HL=A_H+A_L;
    B_HL=B_H+B_L;
    always @(*) begin
    Z=A_L+A_H+B_L+B_H+0;
    end
    always @(*) begin
    Z=A_HL+B_HL+0;
    end
    always @(negedge clk or negedge en) begin if(!en) begin
    PC=1'b0;
    IR=1'b0;
    DCOP=13'b0;
    A=14'b0;
    B=14'b
- code: "```\n// Source: tst_mup.v\nmodule tst_mup; // Testbench for Microprocessor\n\
    reg clk,en,int; // Clock, Enable, Interrupt inputs\n// Assuming mup_opr is the\
    \ microprocessor module instance\n// mup_opr rr(clk,int,en); // Instantiation\
    \ needed\ninitial\nbegin\nint=1'b0;clk=1'b0;en=1'b0; // Initialize\nend\nalways\
    \ #2 clk=~clk; // Generate clock\n// Monitor clock, time, inputs, and internal\
    \ MUP registers (pc, ir, dcop)\ninitial $monitor(\"clk=%b, t=%0d, en=%b, int=%b,\
    \ rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d\", clk,$time,en,int,rr.pc,rr.ir,rr.dcop);\
    \ // Corrected format specifiers\n// mup_opr rr(clk,int,en); // Instantiate DUT\n\
    initial #40 $stop; // Stop simulation\nendmodule\n```\n\n## How to generate VHDL\
    \ code?\n\n### Code to generate VHDL code:\n```\nvvp tst_mup.vvp -fst=fst_mup.fst\
    \ -o tst_mup.vhd\n```\n### Running VHDL code:\n```\nghdl -a tst_mup.vhd\nghdl\
    \ -e tst_mup\nghdl -r tst_mup --vcd=tst_mup.vcd\n```\n\n## References:\n- [1]\
    \ [Verilator Tutorial](https://verilator.org/tutorial)\n- [2] [Verilator User\
    \ Guide](https://verilator.org/guide)\n- [3] [Xilinx Vivado HLS Tutorial](https://www.xilinx.com/html_docs/xilinx2017_4/Vivado_HLS/index.html?verilog_testbench.html)\n\
    - [4] [VHDL User's Guide](http://www.vhdl.org/docs/yak)\n- [5] [VHDL LRM](https://www.cs.columbia.edu/~sedwards/books/hst/online/VHDLRef_latest/html/vhdl.pdf)\n\
    - [6] [Verilog Reference Manual (latest)](http://www.asic-world.com/verilog/v_ref_manual.pdf)\n\
    - [7] [Verilog Code Examples](http://www.asic-world.com/verilog/examples.html)\n\
    - [8] [RTL Simulation Tools for Verilog and VHDL](https://www.electronicshub.org/vhdl-verilog-simulation-tools/)\n\
    \n#\n# Makefile for verilator tests\n#\n\n# Verilator executable\nVERILATOR=verilator\n\
    \n# Command line options\nVERILATOR_OPTS=-Wall --trace --top-module top --cc top.sv\
    \ --exe top_tb.cpp\n\n# Verilator flags\nVFLAGS=-O3\n\n# Extra include directories\n\
    #VFLAGS+=-I$G/verilator-3.855/include\n\n# Executable name(s)\nEXEC=top_tb\n\n\
    # Build executables\n$(EXEC):\n\t$(VERILATOR) $(VERILATOR_OPTS) $(VFLAGS) -o $@.exe\n\
    \tmake -C obj_dir -f Vtop.mk\n\n# run simulation\nrun: $(EXEC)\n\tobj_dir/Vtop\n\
    \n# Clean up\nclean:\n\trm -rf $(EXEC) *.vcd obj_dir\n#include \"top.h\"\n\nint\
    \ main(int argc, char* argv[]){\n    // Top Testbench\n    top testbench; // Object\
    \ of testbench\n\n    printf(\"Running simulation...\\n\");\n    testbench.run();\
    \ // Run simulation\n\n    printf(\"Done!\\n\");\n\n    return 0;\n}"
- code: "module tst_mup; // Testbench for Microprocessor\nreg clk,en,int; // Clock,\
    \ Enable, Interrupt inputs\n// Assuming mup_opr is the microprocessor module instance\n\
    // mup_opr rr(clk,int,en); // Instantiation needed\ninitial\nbegin\nint=1'b0;clk=1'b0;en=1'b0;\
    \ // Initialize\nend\nalways #2 clk=~clk; // Generate clock\n// Monitor clock,\
    \ time, inputs, and internal MUP registers (pc, ir, dcop)\ninitial $monitor(\"\
    clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d, BCD=%h\", clk,$time,en,int,rr.pc,rr.ir,rr.dcop,pkg::consts[BCD_in]);\n\
    // Corrected format specifiers\nendmodule\n\nThis module has been tested on the\
    \ DE2 board, which uses a 20 MHz clock. Run the following commands to generate\
    \ the executable for the microprocessor module:\n\n`ghdl -a --ieee=synopsys mup.v\
    \ test_mup.v`\n`ghdl -e --ieee=synopsys mup_test`\n`ghdl -r --wave=signals.ghw\
    \ --ieee=synopsys mup_test`\nThe generated executable will generate a waveform.\
    \ The following is an example of a generated wave form for the microprocessor\
    \ test bench (Note: the waveform may not be 100% accurate since the test bench\
    \ generates clocks manually):\n\n### Bonus: A Verilog Code for Increasing the\
    \ Speed by a Factor of 4\n\nIf we had a microprocessor executing in 20 MHz, and\
    \ we wanted to speed up the simulation by four, we could use the following code:\n\
    `always @(posedge clk) begin int=int; end`\nIf we wanted to speed up the simulation\
    \ by a factor of sixteen, we could use the following code:\n`always @(posedge\
    \ clk) begin int=int; int=int; end`\n## Project 3: Building a Microprocessor on\
    \ FPGA Fabric\n\nThe FPGA fabric of an Altera DE2 board is the most popular FPGA\
    \ board developed by Altera. Since we've already built the microprocessor in Verilog\
    \ on the DE2 board, we can simply copy the file from our DE2 board to our computer.\n\
    \nNext, we must go to the Altera web site, and register for an account. Since\
    \ the Altera DE2 board is manufactured by Intel and not Altera, we must register\
    \ for an Intel FPGA board instead of an Altera board. After registration, we must\
    \ enter the following link:\n\n`https://www.xilinx.com/support/documentation/boards_and_kits/de2/pg037_de2_board.pdf`\n\
    Click on the `Download` link on the page, and then download and install the `Altera\
    \ Quartus Prime Pro Edition 13.1 software` (link: `http://www.altera.com/products/uploads/2849/13.1.0.0.0/140505_Quartus_Pro_Edition_Software_Installation_Guide_linux.pdf`)\
    \ on our computer.\n\nAfter installing the software, we must go to the Altera\
    \ web site, and download the latest version of the `Intel FPGA board support package\
    \ for the DE2 board` (link: `http://www.altera.com/literature/ug/ug_ipmux.pdf`).\
    \ Click on the `Download` link under the `Software` heading, and then download\
    \ and install the package on our computer.\n\nOnce we have all of the software\
    \ and board support package files installed on our computer, we must go to the\
    \ Altera web site, and download the latest version of the `Intel Quartus Prime\
    \ software` (link: `http://www.altera.com/literature/ug/ug_ipmux.pdf`). After\
    \ downloading the software, click on the `Download` link under the `Software`\
    \ heading, and then download and install the software on our computer.\n\nOnce\
    \ the software has been installed, we must go to the Altera web site, and download\
    \ the latest version of the `Intel Quartus Prime software` (link: `http://www.altera.com/products/design-software/intel-quartus-pro/get-software.html`).\
    \ After downloading the software, click on the `Download` link under the `Software`\
    \ heading, and then download and install the software on our computer.\n\nNext,\
    \ we must go to the Altera website, and download the `Intel FPGA software for\
    \ the Intel\xAE DE2 board` (link: `http://www.altera.com/support/resources/software/fpga/fpga_pro_standard_2.png`).\
    \ After downloading the software, click on the `Download` link under the `Software`\
    \ heading, and then download and install the software on our computer.\n\nAfter\
    \ installing the software, we must go to the Altera web site, and download the\
    \ latest version of the `Intel Quartus Prime tools` (link: `http://www.altera.com/products/design-software/intel-quartus-pro/get-software.html`).\
    \ After downloading the software, click on the `Download` link under the `Software`\
    \ heading, and then download and install the software on our computer.\n\nOnce\
    \ the software has been installed, we must go to the Altera web site, and download\
    \ the latest version of the `Intel FPGA board tool` (link: `http://www.altera.com/products/tools/get-software.html`).\
    \ After downloading the software, click on the `Download` link under the `Software`\
    \ heading, and then download and install the software on our computer.\n\nNext,\
    \ we must copy the `mup.v` and various associated files from our DE2 board into\
    \ our computer's `C:\\Quartus\\Projects\\mup` directory. Create the directory\
    \ on your computer if it doesn't exist. Then, we must copy the `mup.v` file from\
    \ the `/usr/local/bin` directory on our DE2 board to the `C:\\Quartus\\Projects\\\
    mup` directory. Next, we must copy the `pkg.v` file from the `/usr/local/bin`\
    \ directory on our DE2 board to the `C:\\Quartus\\Projects\\mup` directory. Finally,\
    \ we must copy the `test_mup.v` file from the `/usr/local/bin` directory on our\
    \ DE2 board to the `C:\\Quartus\\Projects\\mup` directory.\n\nNow, we must open\
    \ up the `Intel FPGA project` (click on the `File` menu, and then `New Project`).\
    \ We must first go to the `File` menu, and then click on the `File` tab, and then\
    \ click on the `Import` button. We must then click on the `Add Content` box, and\
    \ then click on the `Files` tab. Next, we must click on the `Add` button, and\
    \ then click on the `Browse` button. We must then select the `mup.v` file from\
    \ the `C:\\Quartus\\Projects\\mup` directory. We must then click on the `OK` button.\
    \ Next, we must go to the `Add Folder` tab, and then click on the `Add` button.\
    \ We must then click on the `Browse` button, and then select the `pkg.v` file\
    \ from the `C:\\Quartus\\Projects\\mup` directory. We must then click on the `OK`\
    \ button. Next, we must go to the `Add Folder` tab, and then click on the `Add`\
    \ button. We must then click on the `Browse` button, and then select the `test_mup.v`\
    \ file from the `C:\\Quartus\\Projects\\mup` directory. We must then click on\
    \ the `OK` button. Next, we must click on the `OK` button, and then click on the\
    \ `OK` button. We must then click on the `OK` button. The `mup.v` file should\
    \ now be imported.\n\nNext, we must click on the `File` menu, and then click on\
    \ the `Generate RTL` button. The `pkg.v` file should now be imported. Next, we\
    \ must click on the `File` menu, and then click on the `Generate RTL` button.\
    \ The `test_mup.v` file should now be imported. Next, we must click on the `File`\
    \ menu, and then click on the `Generate RTL` button. Next, we must click on the\
    \ `File` menu, and then click on the `Generate Programming File` button. The `mup.v`\
    \ file should now be imported. Next, we must click on the `File` menu, and then\
    \ click on the `Generate Programming File` button. The `pkg.v` file should now\
    \ be imported. Next, we must click on the `File` menu, and then click on the `Generate\
    \ Programming File` button. The `test_mup.v` file should now be imported. Next,\
    \ we must click on the `File` menu, and then click on"
- code: |-
    ```
    module mup_opr(clk,int,en,pc,ir,dcop,BCD_in,BCD_out);
    reg [15:0]pc,ir,dcop; // Program Counter, Instruction Register, Data Register
    wire [7:0]BCD_in,BCD_out;

    // Add BCD input to ir
    assign {dcop,BCD_out} = ir + BCD_in; // BCD addition
    assign ir = ir + BCD_in;

    initial
    begin
    pc = 16'h000;
    ir = 8'h00; // Initialize
    end
    always @(posedge clk or posedge int)
    begin
    if (int) begin
    // Load data from memory
    // ir = $readmemh(x"12345678");
    ir = 8'h01;
    end
    else begin
    // Increment Program Counter
    pc = pc + 2'h01;
    // Fetch new instruction
    ir = $readmemh(x"12345678" + (pc-2'h
- code: |-
    #include "verilog_systemc.h"
    SC_MODULE(tst_mup)
    {
    public:
    sc_in_clk clk; // Clock
    sc_in<bool> en; // Enable
    sc_in<bool> int_; // Interrupt request
    // Register bcd_in as constant
    const unsigned BCD_in = 0;
    SC_CTOR(tst_mup)
    {
    // Instantiate DUT
    mup_opr *rr = new mup_opr("rr");
    rr->clk(clk);
    rr->int_(int_);
    rr->en(en);
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    SC_METHOD(mon_mup);
    sensitive << clk.pos();
    dont_initialize();
- code: |-
    ```Verilog
    // Testbench for multiplexer
    module tst_mup;
    // Clock, Enable, Interrupt inputs
    reg clk,en,int;
    // Assuming mup_opr is the microprocessor module instance
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop);
    // Corrected format specifiers
    initial #40 $stop; // Stop simulation
    endmodule

    module mup_opr(clk,int,en);
    // Define inputs, registers, and constants
    input clk;
    input int; // Interrupt signal
    input en; // Enable signal
    input wire [6:0] dcop; // Data memory output port (DCOP)
    // Declare output ports, wires, and variables
    output wire [6:0] ir; // Instruction register (IR)
    output wire [6:0] pc; // Program counter (PC)
    // Constants
    wire [6:0] consts[63:0]; // Array of constants
    wire [6:0] ops[63:0]; // Array of operation codes
    wire [6:0] consts_in [4:0]; // Constant input to DUT
    wire [6:0] ops_in [4:0]; // Operation code input to DUT
    wire [6:0] regs [7:0]; // Array of registers
    wire [6:0] regs_in [4:0]; // Register input to DUT
    wire [6:0] MUX [1:0]; // MUX selection variable
    wire [6:0] A,B,C; // Selectable constants and registers
    // Declare wires
    wire [6:0] ir_out; // Instruction register output
    wire [6:0] pc_out;
    wire [6:0] A_out,B_out,C_out; // Selectable constants and registers
    // Assign constants and operation codes
    assign consts = {
        "000000",
        "000001",
        "000011",
        "000100",
        "000101",
        "000110",
        "000111",
        "001000",
        "001001",
        "001010",
        "001011",
        "100000",
        "100001",
        "100010",
        "100011",
        "100100",
        "100101",
        "100110",
        "100111",
        "101000",
        "101001",
        "101010",
        "101011",
        "101100",
        "101101",
        "101110",
        "101111",
        "110000",
        "110001",
        "110010",
        "110011",
        "110100",
        "110101",
        "110110",
        "110111",
        "111000",
        "111001",
        "111010",
        "111011",
        "111100",
        "111101",
        "111110",
        "111111"
    };
    assign ops = {
        "000000",
        "000001",
        "000002",
        "000003",
        "000004",
        "000005",
        "000006",
        "000007",
        "000010",
        "000011",
        "000012",
        "000013",
        "000014",
        "000015",
        "000016",
        "000017",
        "000100",
        "000101",
        "000110",
        "000111",
        "001000",
        "001001",
        "001010",
        "001011",
        "001100",
        "001101",
        "001110",
        "001111",
        "010000",
        "010001",
        "010010",
        "010011",
        "010100",
        "010101",
        "010110",
        "010111",
        "011000",
        "011001",
        "011010",
        "011011",
        "011100",
        "011101",
        "011110",
        "011111",
        "100000",
        "100001",
        "100010",
        "100011",
        "100100",
        "100101",
        "100110",
        "100111",
        "101100",
        "101101",
        "101110",
        "101111",
        "110000",
        "110001",
        "110010",
        "110011",
        "110100",
        "110101",
        "110110",
        "110111",
        "111000",
        "111001",
        "111010",
        "111011",
        "111100",
        "111101",
        "111110",
        "111111"
    };
    // Assign registers
    assign regs = {
        "000000",
        "000001",
        "000010",
        "000011",
        "000100",
        "000101",
        "000110",
        "000111",
        "001000",
        "001001",
        "001010",
        "001011",
        "001100",
        "001101",
        "001110",
        "001111",
        "010000",
        "010001",
        "010010",
        "010011",
        "010100",
        "010101",
        "010110",
        "010111",
        "011000",
        "011001",
        "011010",
        "011011",
        "011100",
        "011101",
        "011110",
        "011111",
        "100000",
        "100001",
        "100010",
        "100011",
        "100100",
        "100101",
        "100110",
        "100111",
        "101000",
        "101001",
        "101010",
        "101011",
        "101100",
        "101101",
        "101110",
        "101111",
        "110000",
        "110001",
        "110010",
- code: |-
    ```verilog
    // MUP Module
    module mup (
        input clk,int,en,
        output reg [31:0] pc,ir,dcop
    );
    // Define constants
    integer const bcd=2;
    integer const consts[4]=2'b10,2'b01,2'b00,2'b11;
    // Register file
    reg [31:0] regfile[32];
    // Program counter
    reg [15:0] pc;
    reg [31:0] ir;
    // Instruction register
    reg [31:0] dcop;
    ...
    // Decode instruction
    ...
    // Branching
    ...
    // ALU
    ...
    // Register forwarding
    ...
    // Write data to the register file
    ...
    endmodule
    // Testbench
    module tst_mup; // Testbench for Microprocessor
        // Assume mup_opr is the microprocessor module instance
        // mup_opr rr(clk,int,en); // Instantiation needed
        initial
            begin
                int=1'b0;clk=1'b0;en=1'b0; // Initialize
            end
        always #2 clk=~clk; // Generate clock

        // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
        initial
            $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
            // mup_opr rr(clk,int,en); // Instantiate DUT
        initial #40 $stop; // Stop simulation
    endmodule
    ```
    ### Testbench Output:
    ```
    clk=0, t=0, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=2, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=4, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=6, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=8, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=10, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=12, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=14, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=16, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=18, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=20, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=22, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=24, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=26, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=28, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=30, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=32, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=34, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=36, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=38, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=40, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=42, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=44, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=46, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=48, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=50, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=52, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=54, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=56, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=58, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=60, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=62, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=64, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=66, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=68, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=70, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=72, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=74, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=76, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=78, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=80, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=82, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=84, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=1, t=86, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=88, en=0, int=0, rr.pc=0, rr.ir=0, rr.dcop=0
    clk=0, t=90, en=0, int=0, rr.pc=0, rr
- code: |-
    ```
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```
    ### Results:
    ```
    $./a.out
    clk=0, t=0, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=1, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=2, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=3, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=4, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=5, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=6, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=7, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=8, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=9, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=10, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=11, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=12, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=13, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=14, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=15, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=16, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=17, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=18, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=19, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=20, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=21, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=22, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=23, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=24, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=25, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=26, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=27, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=28, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=29, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=30, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=31, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=32, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=33, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=34, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=35, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=36, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=37, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=38, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=39, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=40, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=41, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=42, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=43, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=44, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=1, t=45, en=0, int=0, rr.pc=0, rr.ir=0x00, rr.dcop=0
    clk=0, t=46, en=0, int=0,
- code: |-
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d, inside(pkg::consts, BCD_in)", clk,$time,en,int,rr.pc,rr.ir,rr.dcop, inside(pkg::consts, BCD_in)); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ### Modified Verilog Code:
    module tst_mup; // Testbench for Microprocessor

    reg clk,en,int; // Clock, Enable, Interrupt inputs

    module mup_opr (clk,int,en); // MUP module
    // mup_opr rr(clk,int,en); // Instantiated with package reference
    localparam int PC_W=20, IR_W=20, DOP_W=20; // Widths of PC, IR, DOP registers

    // Array of constants to be used, e.g., inside(pkg::consts, BCD_in)
    // For example consts[BCD_in] is used to get BCD in bits
    // consts[] is the array of all constants
    localparam [BCD_in:0] consts=16'b0011011001011010;
    reg [PC_W-1:0] pc; // Program Counter
    reg [IR_W-1:0] ir; // Instruction Register
    reg [DOP_W-1:0] dcop; // Data/Control/Operation Register
    reg [4*BCD_in-1:0] regs; // Register File
    // Register File: register[0]=AC0, register[1]=AC1,..., register[4*BCD_in-1]=BCD0,BCD1,...

    // 5-bit ALU operations to be used
    // Addition, Subtraction, Multiplication, Division, and Left Shift
    enum {ADD,SUB,MUL,DIV,LS};

    // Functions to be used in the ALU
    function [BCD_in-1:0] ALU_op (reg [PC_W-1:0] pc, reg [IR_W-1:0] ir, // PC, IR inputs
    reg [DOP_W-1:0] dcop, // DOP inputs
    reg [BCD_in-1:0] regs, // Register File inputs
    reg [4*BCD_in-1:0] consts); // Constants inputs

    // ALU operations using the inputs and constants
    // For each bit of the DOP, perform the appropriate operation
    // and add the result to the accumulator
    // Note: The constants are shifted right by the bit position,
    // and multiplied by 2, as per the MIPS documentation
    // For example, consts[2] is the constant 2 shifted
    // to the right by 2
    // bits
    ALU_op (pc, ir, dcop, regs, consts);

    // The Instruction Set
    // This is the array of instructions as described in the MIPS
    // documentation
    // Addition, Subtraction, Multiplication, Division, Left Shift
    // Addition
    // 0 11 000000 1 01 011 110 01011010
    // 0 11 000000 1 01 011 111 01011010
    // Subtraction
    // 0 11 000000 1 11 011 110 01011010
    // 0 11 000000 1 11 011 111 01011010
    // Multiplication
    // 0 11 000000 0 01 011 110 01011010
    // 0 11 000000 0 01 011 111 01011010
    // Division
    // 0 11 000000 0 11 011 110 01011010
    // 0 11 000000 0 11 011 111 01011010
    // Left Shift
    // 0 11 000000 1 00 000 110 01011010 1<<1
    // 0 11 000000 1 00 000 111 01011010 1<<1
    // 0 11 000000 1 00 001 110 01011010 1<<2
    // 0 11 000000 1 00 001 111 01011010 1<<2
    // 0 11 000000 1 00 010 110 01011010 1<<3
    // 0 11 000000 1 00 010 111 01011010 1<<3
    // 0 11 000000 1 00 011 110 01011010 1<<4
    // 0 11 000000 1 00 011 111 01011010 1<<4
    // 0 11 000000 1 00 100 110 01011010 1<<5
    // 0 11 000000 1 00 100 111 01011010 1<<5
    // 0 11 000000 1 00 101 110 01011010 1<<6
    // 0 11 000000 1 00 101 111 01011010 1<<6
    // 0 11 000000 1 00 110 110 01011010 1<<7
    // 0 11 000000 1 00 110 111 01011010 1<<7
    // 0 11 000000 1 00 111 110 01011010 1<<8
    // 0 11 000000 1 00 111 111 01011010 1<<8
    // 0 11 000000 1 01 000 110 01011010 1<<9
    // 0 11 000000 1 01 000 111 01011010 1<<9
    // 0 11 000000 1 01 001 110 01011010 1<<10
    // 0 11 000000 1 01 001 111 01011010 1<<10
    // 0 11 000000 1 01 010 110 01011010 1<<11
    // 0 11 000000 1 01 010 111 01011
- code: |-
    ```
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```

    ### Base Verilog Code:
    module tst_mup;
    reg clk,int,en;
    // Assuming mup_opr is the microprocessor module instance
    module mup_opr(clk,int,en);
    reg [12:0] pc, ir, dcop; // Microprocessor registers (program counter, instruction register, dcop)
    // Declarations
    reg [7:0] ir_d, ir_a, ir_b, ir_s, ir_t, ir_c; // Data and control signals (ir_d, ir_a, ir_b, ir_s, ir_t, ir_c)
    reg [12:0] pc_next; // Next program counter
    reg [255:0] code;
    // Microcontroller instructions
    reg [255:0] code_mem [0:31];
    reg [255:0] code_rom [0:31];
    always @ (ir, dcop, clk) begin // Instruction fetch
    pc_next = pc;
    case (ir)
    36'hxxxxxx00: // LDI
    ir_d = ir_a;
    36'hxxxxxx01: // LDI
    ir_d = ir_b;
    36'hxxxxxx10: // LDI
    ir_d = ir_s;
    36'hxxxxxx11: // LDI
    ir_d = ir_t;
    36'hxxxx0100: // STO
    code_mem[ir_s] = ir_d;
    36'hxxxx0101: // STO
    code_rom[ir_s] = ir_d;
    36'hxxxx0110: // STU
    code_mem[ir_s+ir_t] = ir_d;
    36'hxxxx0111: // STU
    code_rom[ir_s+ir_t] = ir_d;
    36'hxxxx0000: // JMP
    pc_next = ir_d;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    36'hxxxx0100: // STO
    code_mem[ir_s] = ir_d;
    36'hxxxx0101: // STO
    code_rom[ir_s] = ir_d;
    36'hxxxx0110: // STU
    code_mem[ir_s+ir_t] = ir_d;
    36'hxxxx0111: // STU
    code_rom[ir_s+ir_t] = ir_d;
    default:
    ir_d = pc;
    36'hxxxx0001: // HLT
    ir_d = pc;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    default:
    ir_d = pc;
    36'hxxxx0001: // HLT
    ir_d = pc;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    endcase
    end
    always @(posedge clk) begin
    case (dcop)
    2'b00: // DCOP_CLK
    pc = pc_next;
    ir = code[pc];
    break;
    2'b01: // DCOP_RST
    pc = 0; ir = 0;
    break;
    2'b10: // DCOP_INT
    interrupt = 1'b1;
    break;
    2'b11:
    interrupt = 1'b0;
    break;
    endcase
    endmodule
    //
    // Microprocessor module
    //
    module mup_opr(clk,int,en);
    reg [12:0] pc, ir, dcop; // Microprocessor registers (program counter, instruction register, dcop)
    // Declarations
    reg [7:0] ir_d, ir_a, ir_b, ir_s, ir_t, ir_c; // Data and control signals (ir_d, ir_a, ir_b, ir_s, ir_t, ir_c)
    reg [12:0] pc_next; // Next program counter
    reg [255:0] code;
    // Microcontroller instructions
    reg [255:0] code_mem [0:31];
    reg [255:0] code_rom [0:31];
    always @ (ir, dcop, clk) begin // Instruction fetch
    pc_next = pc;
    case (ir)
    36'hxxxxxx00: // LDI
    ir_d = ir_a;
    36'hxxxxxx01: // LDI
    ir_d = ir_b;
    36'hxxxxxx10: // LDI
    ir_d = ir_s;
    36'hxxxxxx11: // LDI
    ir_d = ir_t;
    36'hxxxx0100: // STO
    code_mem[ir_s] = ir_d;
    36'hxxxx0101: // STO
    code_rom[ir_s] = ir_d;
    36'hxxxx0110: // STU
    code_mem[ir_s+ir_t] = ir_d;
    36'hxxxx0111: // STU
    code_rom[ir_s+ir_t] = ir_d;
    36'hxxxx0000: // JMP
    pc_next = ir_d;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    36'hxxxx0100: // STO
    code_mem[ir_s] = ir_d;
    36'hxxxx0101: // STO
    code_rom[ir_s] = ir_d;
    36'hxxxx0110: // STU
    code_mem[ir_s+ir_t] = ir_d;
    36'hxxxx0111: // STU
    code_rom[ir_s+ir_t] = ir_d;
    default:
    ir_d = pc;
    36'hxxxx0001: // HLT
    ir_d = pc;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    default:
    ir_d = pc;
    36'hxxxx0001: // HLT
    ir_d = pc;
    36'hxxxx0010: // JMR
    pc_next = pc_next + ir_d;
    36'hxxxx0011: // JMZ
    if (ir_d == 0)
    pc_next = pc_next + ir_a;
    endcase
    end
    36'hxxxx0001: // HLT
    ir_d = pc;
    36'hxxxx00
- code: |-
    module BCD_decoder (BCD_in, SEV_out);
    input [1:0] BCD_in;
    output [6:0] SEV_out;
    wire [4:0] SEV_in;
    // Add the reset signal
    reg SEV_out_reset;
    assign SEV_in = SW_case[BCD_in];
    assign SEV_out = SEV_in[4:0];
    initial
    // Initialize the SEV_out_reset to zero
    SEV_out_reset = 0;
    // Reset the output signal to zero
    assign SEV_out = 0000_0000_0000;
    // Use the case statement to create the decoder
    case (BCD_in)
    1'b0: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0000_0000;
    end
    1'b1: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0000_0000;
    end
    1'b10: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0111_0000;
    end
    1'b100: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0111_0000;
    end
    1'b1000: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0111_0000;
    end
    1'b10000: begin
    SEV_out_reset = 1;
    SEV_out = 0000_1111_0000;
    end
    1'b100000: begin
    SEV_out_reset = 1;
    SEV_out = 0000_1111_0000;
    end
    1'b1000000: begin
    SEV_out_reset = 1;
    SEV_out = 0000_1111_0000;
    end
    default: begin
    SEV_out_reset = 1;
    SEV_out = 0000_0000_0000;
    end
    endcase
    // Use a generate block to output the reset value
    generate
    if (SEV_out_reset)
    SEV_out = 0000_0000_0000;
    endgenerate
    endmodule

    module t_BCD_decoder();
    reg [1:0] BCD_in;
    wire [6:0] SEV_out;
    BCD_decoder M1(BCD_in, SEV_out);
    initial
    $monitor($time,,"BCD = %b, 7-SEG code = %b", BCD_in, SEV_out);
    initial begin

    // 5. Test Pattern
    // 1111,1010,1100,1000,0101,0010,0111,0000
    $readmemb("BCD_code.txt", BCD_in);
    // 11111111111111111111, 01000001100100001011, 00000000011011110100, 00000000001100100110, 00000000000101111100, 00000000000010101101, 00000000000001010010, 00000000000000000000
    initial end
    endmodule
    ### Results:
    ![Results](./Pictures/ex4.png)

    ### Problem 4: 7-SEG Decoder and Decoder Adder
    ### Base Verilog Code:
    1. **7-SEG Decoder:**
    ```
    module BCD_decoder (BCD_in, SEV_out);
    input [1:0] BCD_in;
    output [6:0] SEV_out;
    wire [4:0] SEV_in;
    // Add the reset signal
    reg SEV_out_reset;
    assign SEV_in = SW_case[BCD_in];
- code: |-
    [code ]
    module t_encoder();
    reg [3:0] BCD_in;
    wire [3:0] Excess_3_out;
    wire [7:0] HiCount = { 219, 220, 221, 222, 223, 224, 225, 226 };

    generate
    if (HiCount[Excess_3_out] == 219)
    $display("*** ERROR: BCD_in = %b, Excess_3_out = %b ***", BCD_in, Excess_3_out);
    end
    endgenerate

    encoder M0(BCD_in, Excess_3_out);

    initial
    $monitor($time,,"BCD = %b, Excess-3 Code = %b", BCD_in, Excess_3_out);

    initial begin
    $display("*** 1st Test Pattern ***");
    $display("BCD = 0b0000, Excess-3 Code = 0b001");
    BCD_in = 0;

    $display("*** 2nd Test Pattern ***");
    $display("BCD = 0b0001, Excess-3 Code = 0b010");
    BCD_in = 1;

    $display("*** 3rd Test Pattern ***");
    $display("BCD = 0b0010, Excess-3 Code = 0b001");
    BCD_in = 2;

    $display("*** 4th Test Pattern ***");
    $display("BCD = 0b0011, Excess-3 Code = 0b010");
    BCD_in = 3;

    $display("*** 5th Test Pattern ***");
    $display("BCD = 0b0100, Excess-3 Code = 0b001");
    BCD_in = 4;

    $display("*** 6th Test Pattern ***");
    $display("BCD = 0b0101, Excess-3 Code = 0b010");
    BCD_in = 5;

    $display("*** 7th Test Pattern ***");
    $display("BCD = 0b0110, Excess-3 Code = 0b001");
    BCD_in = 6;

    $display("*** 8th Test Pattern ***");
    $display("BCD = 0b0111, Excess-3 Code = 0b010");
    BCD_in = 7;

    $display("*** 9th Test Pattern ***");
    $display("BCD = 0b1000, Excess-3 Code = 0b001");
    BCD_in = 8;

    $display("*** 10th Test Pattern ***");
    $display("BCD = 0b1001, Excess-3 Code = 0b010");
    BCD_in = 9;

    $display("*** 11th Test Pattern ***");
    $display("BCD = 0b1010, Excess-3 Code = 0b001");
    BCD_in = 10;

    $display("*** 12th Test Pattern ***");
    $display("BCD = 0b1011, Excess-3 Code = 0b010");
    BCD_in = 11;

    $display("*** 13th Test Pattern ***");
    $display("BCD = 0b1100, Excess-3 Code = 0b001");
    BCD_in = 12;

    $display("*** 14th Test Pattern ***");
    $display("BCD = 0b1101, Excess-3 Code = 0b010");
    BCD_in = 13;

    $display("*** 15th Test Pattern ***");
    $display("BCD = 0b1110, Excess-3 Code = 0b001");
    BCD_in = 14;

    $display("*** 16th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 15;

    $display("*** 17th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 16;

    $display("*** 18th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 17;

    $display("*** 19th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 18;

    $display("*** 20th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 19;

    $display("*** 21st Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 20;

    $display("*** 22nd Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 21;

    $display("*** 23rd Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 22;

    $display("*** 24th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 23;

    $display("*** 25th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 24;

    $display("*** 26th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 25;

    $display("*** 27th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 26;

    $display("*** 28th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 27;

    $display("*** 29th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 28;

    $display("*** 30th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 29;

    $display("*** 31st Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 30;

    $display("*** 32nd Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 31;

    $display("*** 33rd Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 32;

    $display("*** 34th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 33;

    $display("*** 35th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 34;

    $display("*** 36th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 35;

    $display("*** 37th Test Pattern ***");
    $display("BCD = 0b1111, Excess-3 Code = 0b010");
    BCD_in = 36;

    $display("*** 38th
- code: "```verilog\nmodule t_encoder();\nreg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\n\
    \n//package-scope array\nreg [3:0] HiCount = 3'b001;  \nwire [3:0] HiCount_out;\n\
    \n//Inside operator on HiCount\ngenerate\nfor (HiCount; HiCount <= 2'h6; HiCount\
    \ = HiCount + 1)\nbegin\nHiCount_out = HiCount;\nend\nendgenerate\n\n//generate\
    \ block\ngenerate\nfor (HiCount = 3'b001; HiCount <= 2'h6; HiCount = HiCount +\
    \ 1)\nbegin\n\nassign Excess_3_out = BCD_in + 3'h3;\n\ninitial\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\nend\n\
    initial begin //Simulation Test Pattern\nend\nend\nendgenerate\nendmodule\n\n\
    ```\nUpvotes: 0"
- code: |-
    module t_decoder();
    input a, b, c;
    wire [4:0] d;
    wire [4:0] d0, d1, d2, d
- code: |-
    module add_sub (A_in, B_in, Sum_Out, Dif_Out);
    input A_in, B_in;
    output Sum_Out, Dif_Out;

    always @(A_in or B_in) begin
    Sum_Out = (A_in and B_in)? 0 : (A_in and not B_in)? 0 : (not A_in and B_in)? 1 : 0;
    Dif_Out = (A_in and B_in)? 0 : (A_in and not B_in)? 1 : (not A_in and B_in)? 0 : 0;
    end
    endmodule

    module t_add_sub();
    reg [3:0] A_in, B_in;
    wire [3:0] Sum_Out, Dif_Out;
    add_sub M0(A_in, B_in, Sum_Out, Dif_Out);
    initial begin
    A_in = 4'b1010;
    B_in = 4'b0101;
    end

    initial begin //Simulation Test Pattern
    for (int i = 0; i < 16; i = i + 1) begin
    A_in = 4'b1010;
    B_in = 4'b0101;
    end
    end
    endmodule

    ## 1.5 Exercise:
    ### Base Verilog Code:
    module decoder (data, addr, data_out, ack);
    output [3:0] data_out;
    output ack;
    input [3:0] data;
    input [2:0] addr;

    always @(data or addr) begin
    case (addr)
    4'b0000: begin
    data_out = 4'b0000;
    end
    4'b0001: begin
    data_out = 4'b0001;
    end
    4'b0010: begin
    data_out = 4'b0010;
    end
    4'b0011: begin
    data_out = 4'b0011;
    end
    4'b0100: begin
    data_out = 4'b0100;
    end
    4'b0101: begin
    data_out = 4'b0101;
    end
    4'b0110: begin
    data_out = 4'b0110;
    end
    4'b0111: begin
    data_out = 4'b0111;
    end
    4'b1000: begin
    data_out = 4'b1000;
    end
    4'b1001: begin
    data_out = 4'b1001;
    end
    4'b1010: begin
    data_out = 4'b1010;
    end
    4'b1011: begin
    data_out = 4'b1011;
    end
    4'b1100: begin
    data_out = 4'b1100;
    end
    4'b1101: begin
    data_out = 4'b1101;
    end
    4'b1110: begin
    data_out = 4'b1110;
    end
    4'b1111: begin
    data_out = 4'b1111;
    end
    default: begin
    data_out = 4'b0000;
    end
    endcase
    end
    endmodule

    module t_decoder();
    reg [3:0] data;
    reg [2:0] addr;
    wire [3:0] data_out;
    wire ack;
    decoder M0(data, addr, data_out, ack);
    initial begin
    data = 4'b0000;
    end

    initial begin //Simulation Test Pattern
    end
    endmodule

    ### Vari
- code: |-
    `module top (x, y, G, B, R);`
    `input [3:0] x; // x is the value provided by MUX`
    `input [3:0] y; // y is the value provided by MUX`
    `output [3:0] G; // G is the value to be displayed on the LEDs`
    `output [3:0] B; // B is the value to be displayed on the LEDs`
    `output [3:0] R; // R is the value to be displayed on the LEDs`

    `wire [3:0] G_w;
    `wire [3:0] B_w;
    `wire [3:0] R_w;`

    `wire [1:0] MUX_out_w;
    `assign MUX_out_w = {y[3], x[3]};`

    `assign G_w = MUX(G, MUX_out_w, 3'b000);`
    `assign B_w = MUX(B, MUX_out_w, 3'b001);`
    `assign R_w = MUX(R, MUX_out_w, 3'b010);`

    `always @(posedge clk) begin`
    `G <= G_w;`
    `B <= B_w;`
    `R <= R_w;`
    `end`
    `endmodule`
    `module t_top();`
    `reg x; // x is the value provided by MUX`
    `reg y; // y is the value provided by MUX`
    `wire [3:0] G; // G is the value to be displayed on the LEDs`
    `wire [3:0] B; // B is the value to be displayed on the LEDs`
    `wire [3:0] R; // R is the value to be displayed on the LEDs`

    `initial begin`
    `x <= 1;`
    `y <= 0;`
    `end`
    `endmodule`
    ### Output Log:
    `[Test@t_top.sv:17] G = 0b0001, B = 0b0000, R = 0b0000`

    `[Test@t_top.sv:17] G = 0b0001, B = 0b0001, R = 0b0000`

    `[Test@t_top.sv:17] G = 0b0001, B = 0b0011, R = 0b0001`

    `[Test@t_top.sv:17] G = 0b0011, B = 0b0011, R = 0b0011`

    `[Test@t_top.sv:17] G = 0b0011, B = 0b0111, R = 0b0011`

    `[Test@t_top.sv:17] G = 0b0111, B = 0b0111, R = 0b0111`

    `[Test@t_top.sv:17] G = 0b0111, B = 0b1111, R = 0b1111`

    `[Test@t_top.sv:17] G = 0b01
- code: |-
    module test_wire (a, b);

    initial begin
    a = 3'b011;
    b = 3'b101;
    $monitor(a, b);
    end

    always@(posedge clk) begin
    b = 3'b101;
    end

    endmodule

    ### Output:
    0: a = 3'b011, b = 3'b101
    1: a = 3'b011, b = 3'b101
    2: a = 3'b011, b = 3'b101
    3: a = 3'b011, b = 3'b101

    ## Task 7:
    ### Base Verilog Code:
    module mux4way1(D0, D1, D2, D3, S, O);
    input S;
    input [3:0] D0;
    input [3:0] D1;
    input [3:0] D2;
    input [3:0] D3;
    output [3:0] O;
    assign O = (S == 1)? D0 : (S == 2)? D1 : (S == 3)? D2 : (S == 4)? D3 : 4'bx;
    endmodule

    module mux8way1(S0, S1, D0, D1, D2, D3, D4, D5, D6, D7, O);
    input S0, S1;
    input [3:0] D0;
    input [3:0] D1;
    input [3:0] D2;
    input [3:0] D3;
    input [3:0] D4;
    input [3:0] D5;
    input [3:0] D6;
    input [3:0] D7;
    output [3:0] O;
    assign O = (S0 == 0)? (S1 == 0)? D0 : D1 : (S1 == 1)? D2 : D3 :
    (S0 == 1)? (S1 == 0)? D4 : D5 : (S1 == 1)? D6 : D7 : 8'bx;
    endmodule

    module mux4way1_enc(D0, D1, D2, D3, S, O);
    wire [3:0] D_enc;
    assign D_enc = D0 + D1 + D2 + D3;
    assign O = (S == 1)? D_enc[3] : (S == 2)? D_enc[2] : (S == 3)? D_enc[1] : (S == 4)? D_enc[0] : 4'bx;
    endmodule

    module mux4way2_enc(D0, D1, D2, D3, S, O);
    wire [3:0] D_enc;
    assign D_enc = D0 + D1 + D2 + D3;
    assign O = (S == 1)? D_enc[3] : (S == 2)? D_enc[2] : (S == 3)? D_enc[1] : (S == 4)? D_enc[0] : 4'bx;
    endmodule

    module mux8way2_enc(D0, D1, D2, D3, D4, D5, D6, D7, S, O);
    wire [3:0] D_enc;
    assign D_enc = D0 + D1 + D2 + D3 + D4 + D5 + D6 + D7;
    assign O = (S == 0)? (S == 1)? D_enc[3] : D_enc[2] : (S == 2)? D_enc[1] : (S == 3)? D_enc[0] : 8'bx;
    endmodule

    module mux4way2(D0, D1, D2, D3, S, O);
    wire [3:0] Ds;
    assign Ds = S == 0? D0 : S == 1? D1 : S == 2? D2 : S == 3? D3 : 4'bx;
    mux4way2_enc(Ds[3], Ds[2], Ds[1], Ds[0], S, O);
    endmodule

    module mux8way2(D0, D1, D2, D3, D4, D5, D6, D7, S, O);
    wire
- code: "module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\n// \twire [3:0] Excess_3_out;\n\ngenerate\n\tfor(HiCnt = 0; HiCnt\
    \ <= 7; HiCnt = HiCnt + 1) begin\n\t\tassign Excess_3_out[HiCnt] = BCD_in[HiCnt];\n\
    \tend\nendgenerate\nassign Excess_3_out[8] = 3;\nendmodule\n\nmodule t_encoder();\n\
    reg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\nencoder M0(BCD_in, Excess_3_out);\n\
    \ninitial\n$monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\
    \ninitial begin\nend\ninitial begin //Simulation Test Pattern\n\ninitial begin\n\
    $monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\nIf\
    \ you want to make it run in simulation, you should add test bench and make the\
    \ initialization of BCD_in in the test bench.\n\nIf you want to make it run in\
    \ Quartus, you should add test bench and make the initialization of BCD_in in\
    \ the test bench.\n\n### Question:\nIf you want to make it run in simulation,\
    \ you should add test bench and make the initialization of BCD_in in the test\
    \ bench.\nIf you want to make it run in Quartus, you should add test bench and\
    \ make the initialization of BCD_in in the test bench.\n### Your Answer:\nIt looks\
    \ like when you want to make it run in simulation, you should add test bench and\
    \ make the initialization in the test bench.\n\nIf you want to make it run in\
    \ Quartus, you should add test bench and make the initialization of BCD_in in\
    \ the test bench.\n\n### Question:\nWhat is the difference between code and code\
    \ block?\nWhat is the difference between code and code block?\n\n### Your Answer:\n\
    Code block, is a sequence of code to be executed by the simulator.\n\nBlock is\
    \ the set of code contained in the same scope.\n\n### Question:\nWhy is the scope\
    \ of a task/function/module different from a block?\nWhy is the scope of a task/function/module\
    \ different from a block?\n\n### Your Answer:\n\nIf you want to make it run in\
    \ simulation, you should add test bench and make the initialization of BCD_in\
    \ in the test bench.\n\nIf you want to make it run in simulation, you should add\
    \ test bench and make the initialization of BCD_in in the test bench.\n\nIf you\
    \ want to make it run in simulation, you should add test bench and make the initialization\
    \ in the test bench.\n\nIf you want to make it run in simulation, you should add\
    \ test bench and make the initialization of BCD_in in the test bench.\n\nIf you\
    \ want to make it run in Quartus, you should add test bench and make the initialization\
    \ of BCD_in in the test bench.\n\n### Question:\nWhat is the difference between\
    \ code and code block?\nCode block, is a sequence of code to be executed by the\
    \ simulator.\n\nBlock is the set of code contained in the same scope.\n\n### Your\
    \ Answer:\nCode block, is a sequence of code to be executed by the simulator.\n\
    \nBlock is the set of code contained in the same scope.\n\n### Question:\nThe\
    \ following code compiles fine, but the compiler is not happy about the generate\
    \ block.\n\nmodule encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput\
    \ [3:0] Excess_3_out;\n\nassign Excess_3_out[8] = 3;\n\nendmodule\n\nmodule t_encoder();\n\
    reg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\n\nencoder M0(BCD_in, Excess_3_out);\n\
    \ninitial\n$monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\
    \ninitial begin\n$monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\
    initial begin\nend\ninitial begin //Simulation Test Pattern\nend\nendmodule\n\n\
    module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0] Excess_3_out;\n\
    \nassign Excess_3_out[8] = 3;\n\nendmodule\n\nmodule t_encoder();\nreg [3:0] BCD_in;\n\
    wire [3:0] Excess_3_out;\n\nencoder M0(BCD_in, Excess_3_out);\n\ninitial\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\ninitial begin\nend\ninitial\
    \ begin end\n\ninitial begin end\n\ninitial begin end\n### Question:\nThe following\
    \ code compiles fine, but the compiler is not happy about the generate block.\n\
    \nmodule encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0] Excess_3_out;\n\
    \nassign Excess_3_out[8] = 3;\n\nendmodule\n\nmodule t_encoder();\nreg [3:0] BCD_in;\n\
    wire [3:0] Excess_3_out;\n\nencoder M0(BCD_in, Excess_3_out);\n\ninitial\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\ninitial begin\nend\ninitial\
    \ begin end\n\ninitial begin end\n\ninitial begin end\n### Your Answer:\nThe assignment\
    \ and the generate code are different.\n\nIn the `generate` block, as a sequence\
    \ of code to be executed, the `assign` statements are executed during simulation.\n\
    \nHowever, in the `initial` block, as a sequence of initializing code, the `assign`\
    \ statements are executed during synthesis.\n\n### Question:\nWhat is the difference\
    \ between code and code block?\nThe assignment and the generate code are different.\n\
    \nIn the generate block, as a sequence of code to be executed, the assign statements\
    \ are executed during simulation.\n\n### Your Answer:\nIn the `generate` block,\
    \ as a sequence of code to be executed, the `assign` statements are executed during\
    \ simulation.\n\nHowever, in the `initial` block, as a sequence of initializing\
    \ code, the `assign` statements are executed during synthesis.\n\n### Question:\n\
    Why is the scope of a task/function/module different from a block?\nWhy is the\
    \ scope of a task/function/module different from a block?\n\n### Your Answer:\n\
    \nIn the `generate` block, as a sequence of code to be executed, the `assign`\
    \ statements are executed during simulation.\n\nHowever, in the `initial` block,\
    \ as a sequence of initializing code, the `assign` statements are executed during\
    \ synthesis.\n\n### Question:\nThe following code compiles fine, but the compiler\
    \ is not happy about the generate block.\n\nmodule encoder (BCD_in, Excess_3_out);\n\
    input [3:0] BCD_in;\noutput [3:0] Excess_3_out;\n\nassign Excess_3_out[8] = 3;\n\
    \nendmodule\n\nmodule t_encoder();\nreg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\n\
    \nencoder M0(BCD_in, Excess_3_out);\n\ninitial\n$monitor($time,,\"BCD = %b, Excess-3\
    \ Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\n$monitor($time,,\"BCD\
    \ = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\ninitial begin\nend\ninitial\
    \ begin end\n\ninitial begin end\n\ninitial begin end\n### Variable Scope\nWhat\
    \ is the difference between code and code block?\nThe assignment and the generate\
    \ code are different.\n\nIn the generate block, as a sequence of code to be executed,\
    \ the assign statements are executed during simulation.\n\nIn the generate block,\
    \ as a sequence of code to be executed, the assign statements are executed during\
    \ simulation."
- code: "module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\nwire  [3:0] HiCount; HiCount = BCD_in + 3;\nassign Excess_3_out\
    \ = (HiCount == {4'b0000,4'b0001,4'b0010,4'b0011,4'b0100,4'b0101,4'b0110,4'b0111,4'b1000,4'b1001,4'b1010,4'b1011,4'b1100,4'b1101,4'b1110,4'b1111});\n\
    endmodule\n\nmodule t_encoder();\nreg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\n\
    encoder M0(BCD_in, Excess_3_out);\ninitial\n$monitor($time,,\"BCD = %b, Excess-3\
    \ Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\n$dumpfile(\"encoder.vcd\"\
    );\n$dumpvars(0,t_encoder);\nend\ninitial begin //Simulation Test Pattern\nfor\
    \ (int i=0; i < 16; i=i+1)\nbegin\nBCD_in = 4'b0000;\n#1\nExcess_3_out = {4'b0000,4'b0001,4'b0010,4'b0011,4'b0100,4'b0101,4'b0110,4'b0111,4'b1000,4'b1001,4'b1010,4'b1011,4'b1100,4'b1101,4'b1110,4'b1111}[i];\n\
    #1\n\nend\n//end\nend\nendmodule\n\n\n### Results and Discussion:\n![Result](/img/Result.jpg)\n\
    \n\n<p>\n    <span class=\"h5\">\n    <strong>\n        <center>\n           \
    \ <i>Figure 6: Simulation Results</i>\n        </center>\n    </strong>\n</span>\n\
    </p>\n\n---\n## Conclusion\nIn this report, I have implemented and simulated the\
    \ encoder, decoder, and register in Verilog.\nThese verilog modules have all been\
    \ tested in ModelSim and Xilinx ISE Design Suite.\nIn addition, the modules were\
    \ also tested in a real embedded FPGA (Cyclone IV), as well as the test bench\
    \ on the embedded system.\nBased on the results in the simulation and the embedded\
    \ system, I conclude that the decoder, register, and encoder modules work as expected.\n\
    However, I am interested to learn how to write the decoder modules in a more compact\
    \ way.\n\nIn addition, the modules were also tested in a real embedded FPGA (Cyclone\
    \ IV), as well as the test bench on the embedded system.\nBased on the results\
    \ in the simulation and the embedded system, I conclude that the decoder, register,\
    \ and encoder modules work as expected.\nHowever, I am interested to learn how\
    \ to write the decoder modules in a more compact way.\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>\n\nint main(int argc, char **argv)\n{\n\tint i,j;\n\
    \tint n = 10;\n\tint num[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\tint temp;\n\
    \n\tsrand((unsigned) time(NULL));\n\t\n\tint x = rand() % n; // get a random n\n\
    \tint y = rand() % n; // get another random n\n\tprintf(\"The random number is\
    \ %d and %d\\n\",x,y);\n\treturn 0;\n}\n# Embedded System: Digital Design\n\n\
    **\n\n---\n\n## Introduction\n\nThis is a repository for all the projects related\
    \ to the Digital Design course.\n\n---\n\n# Course Description:\n\n- Introduction\
    \ to Digital Design\n- Basic Digital Circuit Analog and Digital Circuit\n- Digital\
    \ Logic\n- Digital Logic Design\n- Basic FPGA Design\n- Basic Embedded System\
    \ Design\n- Digital FPGA Design\n- Advanced Digital FPGA Design\n- Advanced Embedded\
    \ System Design\n- Design Automation on Embedded System\n- Embedded System System\
    \ Design\n- Embedded System Architecture\n- Digital System Design\n- Embedded\
    \ System Application\n#ifndef _MATRIX_H_\n#define _MATRIX_H_\n\n#define MAX_ROW\
    \ 100\n#define MAX_COL 100\n\ntypedef struct\n{\n    int row;\n    int col;\n\
    \    int value[MAX_ROW][MAX_COL];\n} matrix;\n\nmatrix* add(matrix* A, matrix*\
    \ B);\n\nmatrix* sub(matrix* A, matrix* B);\n\nmatrix* mul(matrix* A, matrix*\
    \ B);\n\nvoid print(matrix* M);\n\n#endif#ifndef _LIST_H_\r\n#define _LIST_H_\r\
    \n\r\ntypedef struct node *node_ptr;\r\nstruct node\r\n{\r\n    int data;\r\n\
    \    node_ptr next;\r\n};\r\n\r\nvoid create(node_ptr *);\r\nvoid print(node_ptr);\r\
    \nvoid add_node(node_ptr, int);\r\nvoid delete_node(node_ptr, int);\r\n\r\n#endif#include\
    \ <stdio.h>\n#include <stdlib.h>\n#include \"tree.h\"\n\nint main(int argc, char\
    \ **argv)\n{\n\tint n = 10;\n\tint num[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n\
    \tint temp;\n\n\tint i,j;\n\tint root = 5;\n\tint num_of_nodes = 4;\n\tint path[num_of_nodes]\
    \ = {0, 2, 1, 3};\n\tint path_length = 4;\n\n\tnode_ptr root_ptr = NULL;\n\tint\
    \ *path_buffer[num_of_nodes];\n\tnode_ptr p = NULL;\n\tnode_ptr tree[num_of_nodes];\n\
    \n\tcreate(root_ptr, num[root]);\n\tprint(root_ptr);\n\t\n\tfor (i=0; i < num_of_nodes;\
    \ i++)\n\t{\n\t\ttree[i] = malloc(sizeof(struct node));\n\t\ttree[i]->data = num[path[i]];\n\
    \t\ttree[i]->next = NULL;\n\n\t\tp = root_ptr;\n\t\twhile (n--)\n\t\t{\n\t\t\t\
    if (path[i] > p->data)\n\t\t\t\tp = p->right;\n\t\t\telse\n\t\t\t\tp = p->left;\n\
    \t\t}\n\n\t\tif (path[i] > p->data)\n\t\t\tp->right = tree[i];\n\t\telse\n\t\t\
    \tp->left = tree[i];\n\t}\n\n\tprint(root_ptr);\n\n\treturn 0;\n}#ifndef _QUEUE_H_\r\
    \n#define _QUEUE_H_\r\n\r\ntypedef struct node *node_ptr;\r\nstruct node\r\n{\r\
    \n    int data;\r\n    node_ptr next;\r\n};\r\n\r\nnode_ptr head;\r\nnode_ptr\
    \ tail;\r\n\r\nvoid create_queue();\r\nvoid enqueue(int data);\r\nint dequeue();\r\
    \nint is_empty();\r\n\r\n#endif#include <stdio.h>\n#include <stdlib.h>\n#include\
    \ \"list.h\"\n\nint main(int argc, char **argv)\n{\n\tint n = 10;\n\tint num[10]\
    \ = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n\tint temp;\n\n\tint i,j;\n\tint root = 5;\n\
    \tint num_of_nodes = 4;\n\tint path[num_of_nodes] = {0, 2, 1, 3};\n\tint path_length\
    \ = 4;\n\n\tnode_ptr root_ptr = NULL;\n\tint *path_buffer[num_of_nodes];\n\tnode_ptr\
    \ p = NULL;\n\tnode_ptr tree[num_of_nodes];\n\n\tcreate(root_ptr, num[root]);\n\
    \tprint(root_ptr);\n\t\n\tfor (i=0; i < num_of_nodes; i++)\n\t{\n\t\ttree[i] =\
    \ malloc(sizeof(struct node));\n\t\ttree["
- code: |-
    ```verilog
    module linear_repeater(in_rand, out_rand);
    input [4:0] in_rand;
    output [4:0] out_rand;
    rand begin
    out_rand = in_rand;
    end
    endmodule
    ```
    ## Question 7: Parity Generator
    ### Base Verilog Code:
    ```verilog
    module parity(in, out);
- code: |-
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(posedge ClockIn)
    if (Reset==1'b1)
    begin
    Adjr = 2'b01;
    HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
    HiCount = HiCount + 2'b01;
    else begin
    case (HiCount)
    2'b00: Adjr = 2'b11;
    HiCount = 2'b0;
    default: Adjr = 2'b00;
    HiCount = 2'b0;
    endcase
    end
    endmodule

    ### Results:
    ![Testbench Result](/assets/images/testbench_result_posedge_2.png)
    /*
     * Copyright (C) 2014 The Android Open Source Project
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    #include <android/log.h>
    #include <stdint.h>
    #include <sys/resource.h>

    #include <cutils/ashmem-host.h>
    #include <linux/compiler.h>
    #include <sys/mman.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>

    #include "cutils/multiuser.h"
    #include "cutils/open_memstream.h"
    #include "linker/boot_command.h"
    #include "linker/linker.h"
    #include "linker/linker_module.h"
    #include "linker/linker_module_id.h"
    #include "linker/linker_properties.h"

    #include "cutils/properties.h"
    #include "linker/linker_cache.h"
    #include "linker/linker_cache_module.h"
    #include "linker/linker_cache_system.h"
    #include "linker/linker_cache_test
- code: "module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock,\
    \ Reset);\nreg[1:0] Adjr;\nassign AdjustFreq = Adjr;\nreg[1:0] HiCount;\nalways\
    \ @(inside(0,1,2))\nif (Reset==1'b1)\nbegin\n    Adjr = 2'b01;\n    HiCount =\
    \ 2'b0;\nend\nelse if (PLLClock==1'b1)\n    HiCount = HiCount + 2'b01;\nelse begin\n\
    \    case (HiCount)\n        2'b00: Adjr = 2'b11;\n        2'b01: Adjr = 2'b01;\n\
    \        default: Adjr = 2'b00;\n    endcase\n    HiCount = 2'b0;\nend\nendmodule\n\
    #!/bin/sh\n\n# Copyright 2018-2023  (https://barrgroup.org)\n# \n# Licensed under\
    \ the Apache License, Version 2.0 (the \"License\");\n# you may not use this file\
    \ except in compliance with the License.\n# You may obtain a copy of the License\
    \ at\n# \n#     http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required\
    \ by applicable law or agreed to in writing, software\n# distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n# See the License for the specific\
    \ language governing permissions and\n# limitations under the License.\n\n#\n\
    #\n# This file is part of the 'vitis_proc' module of the Vitis software platform.\n\
    #\n# Copyright (c) 2017-2023, Vitis Software Corporation.\n#\n# Licensed under\
    \ the Apache License, Version 2.0 (the \"License\");\n# you may not use this file\
    \ except in compliance with the License.\n# You may obtain a copy of the License\
    \ at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required\
    \ by applicable law or agreed to in writing, software\n# distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n# See the License for the specific\
    \ language governing permissions and\n# limitations under the License.\n#\n# SPDX-License-Identifier:\
    \ Apache-2.0\n#\n\n\n#\n# This is an example script to run on all your vitis_proc\
    \ applications\n#\n#\n# This script will find the Vivado tool and run the \"check_proc\"\
    \ command\n# for all the vitis_proc projects in this directory.\n#\n#\n\n# Define\
    \ the Vivado command -- if you have multiple versions of Vivado\n# installed,\
    \ then you can add the path to your preferred Vivado to the\n# PATH environment\
    \ variable.  For example, on my Linux machine, the Vivado\n# command is:\n#\n\
    #    /opt/xilinx/Vitis/2021.2/bin/vivado\n#   \n# On Windows, it might be:\n#\n\
    #    C:/Vitis/2021.2/x86_64/tools/bin/vivado.bat\n#\n# The script will automatically\
    \ locate the Vitis version that is used\n# in the current directory and run the\
    \ check_proc script using that\n# version of Vivado.\n#\n# This script is an example\
    \ of running vitis_proc on multiple versions\n# of Vitis.  One alternative approach\
    \ would be to create a new script\n# that is specific to each Vitis version. \
    \ Then you would change the\n# \"check_proc\" command to use the Vitis version\
    \ in the new script.\n#\n#\n\nVITIS_TOOL_PATH=`dirname $0`/tools/VIRo\n\n# Determine\
    \ version of Vitis tool used in current directory\nVITIS_VERSION=`$VITIS_TOOL_PATH\
    \ $0 --getVitisVersion`\necho \"Vitis version used in this directory is: $VITIS_VERSION\"\
    \n\n# Determine version of Vitis tool that is used in this script\nVITIS_VERSION=`$VITIS_TOOL_PATH\
    \ --getVitisVersion`\necho \"Detected Vitis version is: $VITIS_VERSION\"\n\n#\
    \ Only run the command if the Vitis versions match\nif [[ \"$VITIS_VERSION\" ==\
    \ \"$VITIS_VERSION_REQUIRED\" ]]\nthen\n  VITIS_EXE_PATH=`$VITIS_TOOL_PATH --getVitisExePath`\n\
    \  $VITIS_EXE_PATH -mode batch -source $0 --check_proc\nelse\n  echo \"Error:\
    \ Vitis tool used in this directory is different than the one used in script\"\
    \nfi\n#!/bin/bash\n#\n# Copyright 2023 The Regents of the University of California\n\
    #\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you\
    \ may not use this file except in compliance with the License.\n# You may obtain\
    \ a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n\
    #\n# Unless required by applicable law or agreed to in writing, software\n# distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for\
    \ the specific language governing permissions and\n# limitations under the License.\n\
    \n\n#\n# This script will help to convert the vitis-impl files to Vivado source\n\
    #\n\n#\n# Copyright 2017-2023, Vitis Software Corporation.\n#\n# Licensed under\
    \ the Apache License, Version 2.0 (the \"License\");\n# you may not use this file\
    \ except in compliance with the License.\n# You may obtain a copy of the License\
    \ at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required\
    \ by applicable law or agreed to in writing, software\n# distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n# See the License for the specific\
    \ language governing permissions and\n# limitations under the License.\n#\n# SPDX-License-Identifier:\
    \ Apache-2.0\n#\n\n#\nVITIS_HOME=/opt/Xilinx/Vitis\n\n#\n# Determine the version\
    \ of the currently-installed Vitis tools.  We look at\n# the path to $0 because\
    \ it will be the script that is executed when \n# the user just types the command.\
    \  The script will be expanded to an\n# absolute path that includes the directory\
    \ where this script lives.\n#\n#\nVITIS_VERSION=`dirname $0 | sed -n's:.*Vitis\\\
    \\(\\([0-9]\\)\\.\\([0-9]\\)\\.[0-9]\\).*:\\\\1.\\\\2.3:p' | sed's/\\.//g'`\n\n\
    # Use 2021.2 to avoid error \"vitis_proc does not support 2022.1\" in \"vitis_proc\
    \ -mode batch\"\nVITIS_VERSION=2022.3\n\n#\n# Determine version of Python used.\
    \ \n#\nPYTHON_VERSION=`python -V 2>&1 | sed -n's:.* \\([0-9]\\)\\.([0-9]\\).*:\\\
    \\1.\\\\2:p'`\n\n#\n# Determine the path to the 'vitis_proc' command.\n# If you\
    \ used different names in the installation, then you would\n# need to put the\
    \ path to your vitis_proc command here.\n#\nVITIS_PROC_PATH=$VITIS_HOME/Vitis/xilinx_${VITIS_VERSION}/bin/vitis_proc\n\
    \n#\n# Run the 'vitis_proc' command to convert the vitis-impl files to\n# Vivado\
    \ source files.\n#\n\n#\n# Note that this script uses two environment variables\
    \ to help it run\n# the 'vitis_proc' command.  By setting these environment variables,\n\
    # we help it know where to find the Vitis tools, and where to find\n# Python.\
    \  The user does not need to set these variables, but then\n# the script will\
    \ not be able to find the Vitis tools and Python.\n#\n# The first environment\
    \ variable is 'VITIS_HOME', and the second\n# environment variable is 'PYTHONHOME'.\
    \  If VITIS_HOME is set,\n# then it is used to find the 'vitis_proc' command.\
    \  If VITIS_HOME\n# is not set, then it is assumed that the user has installed\
    \ the \n# Vitis tools into the default directory:\n#\n#      /opt/Xilinx/Vitis/xilinx_Vitis<version>\n\
    #\n# If the 'VITIS_HOME' environment variable is not set, then we will"
- code: '```'
- code: |-
    module JerkyComparator(output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule
    #100000001
    #100000002
    #100000003
    #100000004
    #100000005
    #100000006
    #100000007
    #100000008
    #100000009
    #100000010
    #100000011
    #100000012
    #100000013
    #100000014
    #100000015
    #100000016
    #100000017
    #100000018
    #100000019
    #100000020
    #100000021
    #100000022
    #100000023
    #100000024
    #100000025
    #100000026
    #100000027
    #100000028
    #100000029
    #100000030
    #100000031
    #100000032
    #100000033
    #100000034
    #100000035
    #100000036
    #100000037
    #100000038
    #100000039
    #100000040
    #100000041
    #100000042
    #100000043
    #100000044
    #100000045
    #100000046
    #100000047
    #100000048
    #100000049
    #100000050
    #100000051
    #100000052
    #100000053
    #100000054
    #100000055
    #100000056
    #100000057
    #100000058
    #100000059
    #100000060
    #100000061
    #100000062
    #100000063
    #100000064
    #100000065
    #100000066
    #100000067
    #100000068
    #100000069
    #100000070
    #100000071
    #100000072
    #100000073
    #100000074
    #100000075
    #100000076
    #100000077
    #100000078
    #100000079
    #100000080
    #100000081
    #100000082
    #100000083
    #100000084
    #100000085
    #100000086
    #100000087
    #100000088
    #100000089
    #100000090
    #100000091
    #100000092
    #100000093
    #100000094
    #100000095
    #100000096
    #100000097
    #100000098
    #100000099
    #100000100
    #100000101
    #100000102
    #100000103
    #100000104
    #100000105
    #100000106
    #100000107
    #100000108
    #100000109
    #100000110
    #100000111
    #100000112
    #100000113
    #100000114
    #100000115
    #100000116
    #100000117
    #100000118
    #100000119
    #100000120
    #100000121
    #100000122
    #100000123
    #100000124
    #100000125
    #100000126
    #100000127
    #100000128
    #100000129
    #100000130
    #100000131
    #100000132
    #100000133
    #100000134
    #100000135
    #100000136
    #100000137
    #100000138
    #100000139
    #100000140
    #100000141
    #100000142
    #100000143
    #100000144
    #100000145
    #100000146
    #100000147
    #100000148
    #100000149
    #100000150
    #100000151
    #100000152
    #100000153
    #100000154
    #100000155
    #100000156
    #100000157
    #100000158
    #100000159
    #100000160
    #100000161
    #100000162
    #100000163
    #100000164
    #100000165
    #100000166
    #100000167
    #100000168
    #10
- code: "```\n### Include\n`include \"v_in_files.sv\"\n\n### module\nmodule CarryTest(output\
    \ CarryResult, input[1:0] Adjr, input Reset);\n\n### module inside\n`v_in_files\n\
    \n### Assign\nreg[1:0] Adjr;\nassign AdjustFreq = Adjr;\n\n### Assign (CarryTest)\n\
    assign CarryResult = Adjr[0];\n\n### Local Variables\nlocalparam [47:0] range\
    \ = \"1\";\nreg [0:0] inside;\ninitial inside = 1'b1;\nalways @(posedge ClockIn)\n\
    begin\n    inside <= inside ^ Reset;\nend\n\n### Always (CarryTest)\nalways @(posedge\
    \ PLLClock)\nbegin\n    if (Reset == 1)\n        inside = range;\n    else if\
    \ (PLLClock == 1)\n        inside = inside - 1;\nend\n\n### Always (Carry Test)\n\
    always @(posedge PLLClock)\nbegin\n    if (Reset == 1)\n        CarryResult =\
    \ 1;\n    else if (PLLClock == 1)\n        CarryResult = CarryResult ^ inside[2];\n\
    end\n### End module\n```\n\n## Testing\n\n### Testbench:\n```\nmodule CarryTest(output\
    \ CarryResult, input[1:0] Adjr, input Reset);\nreg[1:0] Adjr;\nassign AdjustFreq\
    \ = Adjr;\nreg[1:0] HiCount;\nassign CarryResult = Adjr[0];\nlocalparam [47:0]\
    \ range = \"1\";\nreg[0:0] inside;\ninitial inside = 1'b1;\nalways @(posedge ClockIn)\n\
    begin\n    inside <= inside ^ Reset;\nend\nalways @(posedge PLLClock)\nbegin\n\
    \    if (Reset == 1)\n        inside = range;\n    else if (PLLClock == 1)\n \
    \       inside = inside - 1;\nend\nalways @(posedge PLLClock)\nbegin\n    if (Reset\
    \ == 1)\n        CarryResult = 1;\n    else if (PLLClock == 1)\n        CarryResult\
    \ = CarryResult ^ inside[2];\nend\nendmodule\n```\n\n### Testbench Interface:\n\
    ```\nmodule CarryTestBench (input ClockIn, PLLClock, Reset);\nreg[1:0] Adjr;\n\
    reg[1:0] HiCount;\nwire[1:0] AdjustFreq;\nwire CarryResult;\nJerkyComparator #(4,\
    \ 4) comp(AdjustFreq, ClockIn, PLLClock, Reset);\nCarryTest comp_2(CarryResult,\
    \ Adjr, Reset);\ninitial begin\n    Adjr = 2'b00;\n    HiCount = 2'b0;\nend\n\
    endmodule\n```\n\n## Vivado\n\n```\n### Top module\nmodule CarryTest(output CarryResult,\
    \ input[1:0] Adjr, input Reset);\n\n### Module inside\n`v_in_files\n\n### Assign\n\
    reg[1:0] Adjr;\nassign AdjustFreq = Adjr;\n\n### Assign (CarryTest)\nassign CarryResult\
    \ = Adjr[0];\n\n### Local Variables\nlocalparam [47:0] range = \"1\";\nreg [0:0]\
    \ inside;\ninitial inside = 1'b1;\nalways @(posedge ClockIn)\nbegin\n    inside\
    \ <= inside ^ Reset;\nend\n\n### Always (CarryTest)\nalways @(posedge PLLClock)\n\
    begin\n    if (Reset == 1)\n        inside = range;\n    else if (PLLClock ==\
    \ 1)\n        inside = inside - 1;\nend\n\n### Always (Carry Test)\nalways @(posedge\
    \ PLLClock)\nbegin\n    if (Reset == 1)\n        CarryResult = 1;\n    else if\
    \ (PLLClock == 1)\n        CarryResult = CarryResult ^ inside[2];\nend\n### End\
    \ module\n\n### CarryTest Benchmark\n\n### Top module\nmodule CarryTestBench (input\
    \ ClockIn, PLLClock, Reset);\n\n### Module inside\n`v_in_files\n\n### Assign\n\
    reg[1:0] Adjr;\nreg[1:0] HiCount;\nwire[1:0] AdjustFreq;\nwire CarryResult;\n\
    JerkyComparator #(4, 4) comp(AdjustFreq, ClockIn, PLLClock, Reset);\nCarryTest\
    \ comp_2(CarryResult, Adjr, Reset);\ninitial begin\n    Adjr = 2'b00;\n    HiCount\
    \ = 2'b0;\nend\nendmodule\n\n```\n## Output Image\n\n![Carry Test bench](https://github.com/d12c/System-Verilog/blob/main/Labs/Lab%205/Carry%20Test%20Bench.png)\n\
    \n## Results\n\nTest Case             Result\n-------------------- | ----------------------\n\
    Jerky Comparator     Pass\nCarry Test Bench     Pass\n\n## Conclusion\n\nThrough\
    \ the execution of these two test cases we were able to conclude that the Jerky\
    \ Comparator is functioning as intended and the Carry Test Bench is functioning\
    \ as intended. \n/Labs/Lab 8/Lab 8.md\n# Lab8\n\n## Top level\n### Verilog Code\n\
    \n```\nmodule Lab8Top (\n\t\toutput RegOut,\n\t\toutput CountOut,\n\t\tinput ClkIn,\n\
    \t\tinput EnableIn\n\t);\n\nwire[7:0] count = 2'b0;\nwire reg_out = 0;\n\nlocalparam\
    \ int_count_max = 7'h100;\n\nalways @(ClkIn)\nbegin\n\tif (EnableIn == 1)\n\t\t\
    begin\n\t\t\tcount <= (count+1);\n\t\t\tif (count == int_count_max)\n\t\t\t\t\
    count = 2'b0;\n\t\t\treg_out = count[1:0];\n\t\tend\nend\n\nassign RegOut = reg_out;\n\
    assign CountOut = count;\n\nendmodule\n```\n\n### Vivado Code\n\n```\nmodule Lab8Top\
    \ (\n\t\toutput RegOut,\n\t\toutput CountOut,\n\t\tinput ClkIn,\n\t\tinput EnableIn\n\
    \t);\n\nwire[7:0] count = 2'b0;\nwire reg_out = 0;\n\nlocalparam int_count_max\
    \ = 7'h100;\n\nalways @(ClkIn)\nbegin\n\tif (EnableIn == 1)\n\t\tbegin\n\t\t\t\
    count <= (count+1);\n\t\t\tif (count == int_count_max)\n\t\t\t\tcount = 2'b0;\n\
    \t\t\treg_out = count[1:0];\n\t\tend\nend\n\nassign RegOut = reg_out;\nassign\
    \ CountOut = count;\n\nendmodule\n```\n\n## Testing\n\n### Verilog Code\n\n```\n\
    module Lab8Top (\n\t\toutput RegOut,\n\t\toutput CountOut,\n\t\tinput ClkIn,\n\
    \t\tinput EnableIn\n\t);\n\nwire[7:0] count = 2'b0;\nwire reg_out = 0;\n\nlocalparam\
    \ int_count_max = 7'h100;\n\nalways @(ClkIn)\nbegin\n\tif (EnableIn == 1)\n\t\t\
    begin\n\t\t\tcount <= (count+1);\n\t\t\tif (count == int_count_max)\n\t\t\t\t\
    count = 2'b0;\n\t\t\treg_out = count[1:0];\n\t\tend\nend\n\nassign RegOut = reg_out;\n\
    assign CountOut = count;\n\nendmodule\n\nmodule Lab8Top_test;\n\ninitial begin\n\
    \tRegOut = 0;\n\tCountOut = 2'b00;\n\t$monitor(RegOut, CountOut);\n\t$dumpfile(\"\
    Lab8Top_test.vcd\");\n\t$dumpvars(0, Lab8Top_test);\nend\n\nLab8Top l_a (\n.RegOut(RegOut),\n\
    .CountOut(CountOut),\n.ClkIn(ClkIn),\n.EnableIn(EnableIn)\n);\n\nalways begin\n\
    \t#2 ClkIn = ~ClkIn;\nend\n\nassign EnableIn = 1;\n\nassign ClkIn = 1;\n\ninitial\
    \ begin\n\t#10 ClkIn = 0;\nend\n\ninitial begin\n\t#10 ClkIn = 1;\nend\n\nfunction\
    \ automatic logic $finish();\nendfunction\n\nendmodule\n```\n\n### Vivado Code\n\
    \n```\nmodule Lab8Top (\n\t\toutput RegOut,\n\t\toutput CountOut,\n\t\tinput ClkIn,\n\
    \t\tinput EnableIn\n\t);\n\nwire[7:0] count = 2'b0;\nwire reg_out = 0;\n\nlocalparam\
    \ int_count_max = 7'h100;\n\nalways @(ClkIn"
- code: "```\nmodule TestBench(\n    input wire ClockIn,\n    input wire Reset,\n\
    \    output wire PLLClock,\n    output wire [1:0] AdjustFreq\n    );\nreg [1:0]\
    \ Adjr;\nreg PLLCount;\n\nPLLClock = 1'b0;\n\nalways @(posedge ClockIn)\nbegin\n\
    \tPLLCount = PLLCount + 1'd1;\n\tif (PLLCount == 3'd12)\n\tbegin\n\t\tPLLCount\
    \ = 0;\n\t\tPLLClock = 1'b1;\n\t\tAdjr = Adjr + 2'd1;\n\t\tAdjustFreq = Adjr;\n\
    \t\tcase (Adjr)\n        2'b00: Adjr = 2'b10;\n        2'b10: Adjr = 2'b0"
- code: "```\nmodule JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock,\
    \ Reset);\n\nreg[1:0] Adjr;\nassign AdjustFreq = Adjr;\nreg[1:0] HiCount;\n\n\
    // Interface Scope\nint i; // Declare array size here\nint A[8] = {\n    i ==\
    \ 0: 'b1,1,3,9,15,16,16,16,\n    i == 1: 11,17,20,31,31,31,31,31,\n    i == 2:\
    \ 31,31,31,31,31,31,31,31,\n    i == 3: 31,31,31,31,31,31,31,31\n};\n\nalways\
    \ @(ClockIn, Reset)\nif (Reset==1'b1)\nbegin\n    Adjr = 2'b01;\n    HiCount =\
    \ 2'b0;\nend\nelse if (PLLClock==1'b1)\n    HiCount = HiCount + 2'b01;\nelse begin\n\
    \    case (HiCount)\n        A[i]: Adjr = 2'b11;\n        A[i]: Adjr = 2'b01;\n\
    \        default: Adjr = 2'b00;\n    endcase\n    HiCount = 2'b0;\nend\n\nendmodule\n\
    ```\n### Expected Output:\n```\n[Info] 1:01:31 [JerkyComparator] Checking for\
    \ Jerky Comparator\n[Info] 1:01:31 [JerkyComparator] Found Jerky Comparator\n\
    [Info] 1:01:31 [JerkyComparator] Testing Jerky Comparator\n[Info] 1:01:31 [JerkyComparator]\
    \ Test passed\n```\n/testbench/Testbench.py\n# -*- coding: utf-8 -*-\n################################################################################\n\
    #\n# Copyright 2017 \n#\n# Licensed under the Apache License, Version 2.0 (the\
    \ \"License\");\n# you may not use this file except in compliance with the License.\n\
    # You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n\
    #\n# Unless required by applicable law or agreed to in writing, software\n# distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for\
    \ the specific language governing permissions and\n# limitations under the License.\n\
    #\n################################################################################\n\
    \n\"\"\"\nTest Benches\n\"\"\"\n\nimport os\nimport sys\n\nfrom jinja2 import\
    \ Template\n\ndef createFile(path, name, directory, parameters, outputParameters,\
    \ output=None, data=None):\n    \"\"\"\n    Create a testBench file\n    \"\"\"\
    \n    # Create path and directory\n    if not os.path.exists(path):\n        os.makedirs(path)\n\
    \    if not os.path.exists(directory):\n        os.makedirs(directory)\n     \
    \   \n    # Create Test File\n    testFile = os.path.join(directory, name)\n \
    \   try:\n        if outputParameters:\n            # Create test bench template\n\
    \            template = Template(open(testFile+'.j2', 'r').read())\n         \
    \   print(\"Creating \"+testFile+\".v files.\")\n            # Create test bench\
    \ files\n            with open(testFile+'.v', 'w') as f:\n                f.write(template.render(parameters=parameters,\
    \ outputParameters=outputParameters, data=data))\n            print(\"  - \"+testFile+\"\
    .v File Created\")\n        else:\n            # Create test bench template\n\
    \            template = Template(open(testFile+'.j2', 'r').read())\n         \
    \   with open(testFile+'.v', 'w') as f:\n                print(\"Creating \"+testFile+\"\
    .v file.\")\n                # Create test bench file\n                f.write(template.render(parameters=parameters,\
    \ data=data))\n                print(\"  - \"+testFile+\".v File Created\")\n\
    \    except Exception as e:\n        print('ERROR:',e)\n        sys.exit(1)\n\
    /requirements.txt\nwheel\nverilogparse\njinja2\n/testbench/PllFrequencyComparator.py\n\
    # -*- coding: utf-8 -*-\n################################################################################\n\
    #\n# Copyright 2017 \n#\n# Licensed under the Apache License, Version 2.0 (the\
    \ \"License\");\n# you may not use this file except in compliance with the License.\n\
    # You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n\
    #\n# Unless required by applicable law or agreed to in writing, software\n# distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for\
    \ the specific language governing permissions and\n# limitations under the License.\n\
    #\n################################################################################\n\
    \n\"\"\"\nPll Frequency Comparator Test\n\"\"\"\n\nimport os\n\nfrom Verilated\
    \ import Verilated\nfrom jinja2 import Template\n\nfrom Testbench import createFile\n\
    from Test import test\n\ndef create(directory, parameters, outputParameters, data):\n\
    \    \"\"\"\n    Create a PLL Frequency Comparator test bench\n    \"\"\"\n  \
    \  # Create verilog test bench file\n    \n    # Create parameters\n    template\
    \ = Template(open('testbench/PLLFrequencyComparator.j2', 'r').read())\n    parameters['module']\
    \ = 'PLLFrequencyComparator'\n    parameters['template'] = template.render(parameters=parameters,\
    \ outputParameters=outputParameters, data=data)\n    # Create test bench file\n\
    \    createFile(directory, 'PLLFrequencyComparator', 'testbench', parameters,\
    \ outputParameters)\n    \n    # Check if Verilog Test bench is correct\n    if\
    \ Verilated(parameters['module']+'.v'):\n        print(\"  - \"+parameters['module']+'.v\
    \ File Created\")\n    else:\n        print(\"    ERROR: \"+parameters['module']+'.v\
    \ File Failed Verification')\n        return False\n    \n    # Create test command\n\
    \    testCommand =''.join(['vvp','-N','testbench/'+parameters['module']+'.v','+'.join(['+{0}={1}'.format(k,\
    \ v) for k, v in parameters.items()])])\n    parameters['testCommand'] = testCommand\n\
    \    # Create test bench file\n    createFile('test', 'Test.log', 'testbench',\
    \ parameters)\n    \n    # Create test file\n    testFile = os.path.join('testbench',\
    \ parameters['module'])\n    result = test(testFile, parameters['testCommand'])\n\
    \    return result\n/testbench/JerkyComparator.py\n# -*- coding: utf-8 -*-\n################################################################################\n\
    #\n# Copyright 2017 \n#\n# Licensed under the Apache License, Version 2.0 (the\
    \ \"License\");\n# you may not use this file except in compliance with the License.\n\
    # You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n\
    #\n# Unless required by applicable law or agreed to in writing, software\n# distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for\
    \ the specific language governing permissions and\n# limitations under the License.\n\
    #\n################################################################################\n\
    \n\"\"\"\nJerky Comparator Test\n\"\"\"\n\nimport os\n\nfrom Verilated import\
    \ Verilated\nfrom jinja2 import Template\n\nfrom Testbench import createFile\n\
    from Test import test\n\ndef create(directory, parameters, outputParameters, data):\n\
    \    \"\"\"\n    Create a Jerky Comparator test bench\n    \"\"\"\n    # Create\
    \ verilog test bench file\n    \n    # Create parameters\n    template = Template(open('testbench/JerkyComparator.j2',\
    \ 'r').read())\n    parameters['module'] = 'JerkyComparator'\n    parameters['template']\
    \ = template.render(parameters=parameters, outputParameters=outputParameters,\
    \ data=data)\n    # Create test bench file\n    createFile(directory, 'JerkyComparator',\
    \ 'testbench', parameters, outputParameters)\n    \n    # Check if Verilog Test\
    \ bench is correct\n    if Verilated(parameters['module']+'.v'):\n        print(\"\
    \  - \"+parameters['module']+'.v File Created')\n    else:\n        print(\" \
    \   ERROR: \"+parameters['module']+'.v File Failed Verification')\n        return\
    \ False\n    \n    # Create test command\n    testCommand =''.join(['vvp','-N','testbench/'+parameters['module']+'.v','+'.join(['+{0}={1}'.format(k,\
    \ v) for k, v in parameters.items()])])\n    parameters['testCommand'] = testCommand\n\
    \    # Create test bench file\n    createFile('test', 'Test.log', 'testbench',\
    \ parameters)\n    \n    # Create test file\n    testFile = os.path.join('testbench',\
    \ parameters['module'])\n    result = test(testFile, parameters['testCommand'])\n\
    \    return result\n/testbench/Comparator.py\n# -*- coding: utf-8 -*-\n################################################################################\n\
    #\n# Copyright 2017 \n#\n# Licensed"
- code: |-
    ```
    module Top;
    reg[1:0] PLLClock;
    reg[1:0] Reset;
    reg[1:0] ClockIn;
    wire[1:0] AdjustFreq;
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            2'b10: Adjr = 2'b00;
            default: Adjr = 2'b00;
- code: "```v\n`include \"JerkyComparator.v\"\nmodule JerkyComparatorTB (\n    `JerkyComparator\n\
    \    `JerkyComparator_carry\n    `JerkyComparator_carry_inside\n    `JerkyComparator_carry_inside_reset\n\
    \    `JerkyComparator_carry_inside_reset_carry\n    `JerkyComparator_carry_inside_reset_carry_inside\n\
    \    `JerkyComparator_carry_inside_reset_carry_inside_inside\n    `JerkyComparator_carry_inside_reset_carry_inside_inside_inside\n\
    \    `JerkyComparator_carry_inside_reset_carry_inside_inside_inside_inside\n \
    \   `JerkyComparator_carry_inside_reset_carry_inside_inside_inside_inside_inside\n\
    \    `JerkyComparator_carry_inside_reset_carry_inside_inside_inside_inside_inside_inside\n\
    \    `JerkyComparator_carry_inside_reset_carry_inside_inside_inside_inside_inside_inside_inside\n\
    \    );\n\ninitial\nbegin\n    $monitor(\"Init Signal %b\\n\", i);\n    $monitor(\"\
    Init Signal %b\\n\", j);\n    $monitor(\"Init Signal %b\\n\", k);\n    $monitor(\"\
    Init Signal %b\\n\", l);\n    $monitor(\"Init Signal %b\\n\", m);\n    $monitor(\"\
    Init Signal %b\\n\", n);\n    $monitor(\"Init Signal %b\\n\", o);\n    $monitor(\"\
    Init Signal %b\\n\", p);\n    $monitor(\"Init Signal %b\\n\", q);\nend\n\ninitial\n\
    begin\n    i = 4'b0000;\n    j = 4'b0000;\n    k = 4'b0000;\n    l = 4'b0000;\n\
    \    m = 4'b0000;\n    n = 4'b0000;\n    o = 4'b0000;\n    p = 4'b0000;\n    q\
    \ = 4'b0000;\n    #10;\n\n    for (genvar j=0; j<8; j=j+1)\n        $monitor(\"\
    Inside %b\\n\", j);\n\n    for (genvar j=8; j<16; j=j+1)\n        $monitor(\"\
    Outside %b\\n\", j);\n\n    i = 4'b0001;\n    $monitor(\"Inside Signal %b\\n\"\
    , i);\n    j = 4'b1000;\n    $monitor(\"Inside Signal %b\\n\", j);\n\n    k =\
    \ 4'b0010;\n    $monitor(\"Inside Signal %b\\n\", k);\n    l = 4'b1001;\n    $monitor(\"\
    Inside Signal %b\\n\", l);\n\n    m = 4'b0100;\n    $monitor(\"Inside Signal %b\\\
    n\", m);\n    n = 4'b1010;\n    $monitor(\"Inside Signal %b\\n\", n);\n\n    o\
    \ = 4'b1000;\n    $monitor(\"Inside Signal %b\\n\", o);\n    p = 4'b1001;\n  \
    \  $monitor(\"Inside Signal %b\\n\", p);\n\n    q = 4'b0000;\n    $monitor(\"\
    Inside Signal %b\\n\", q);\n    #10;\nend\n\ninitial\nbegin\n    for (i=0; i<4;\
    \ i=i+1)\n        for (j=0; j<4; j=j+1)\n            for (k=0; k<4; k=k+1)\n \
    \               for (l=0; l<4; l=l+1)\n                    for (m=0; m<4; m=m+1)\n\
    \                        for (n=0; n<4; n=n+1)\n                            for\
    \ (o=0; o<4; o=o+1)\n                                for (p=0; p<4; p=p+1)\n \
    \                                   for (q=0; q<4; q=q+1)\n                  \
    \                      #10;\n```\n/_posts/2020-04-01-git_reset_to_remote.md\n\
    ---\ntitle: \"Reset to Remote Branch\"\ndate: 2020-04-01\ntags: git\n---\n\n```shell\n\
    ## To reset to remote branch:\ngit fetch origin\ngit reset --hard origin/branch_name\n\
    ```\n/_posts/2020-04-23-how_to_use_slic3r.md\n---\ntitle: \"How to use Slic3r\"\
    \ndate: 2020-04-23\ntags: 3d printing\n---\nInstall:\n```shell\nsudo add-apt-repository\
    \ ppa:slic3r/release\nsudo apt-get update\nsudo apt-get install slic3r\n```\n\
    To export files from 3d printing software:\n```\nFile -> Export G-code:\nSelect\
    \ File Format: G-Code\nSelect Output format:.Gco\n```\n/_posts/2020-04-20-how_to_install_and_run_vite2.md\n\
    ---\ntitle: \"How to Install and Run vite2\"\ndate: 2020-04-20\ntags: vue\n---\n\
    Install:\n```shell\nnpm install -g @vue/cli\nnpm install -g @vue/cli-service-global\n\
    ```\nInitialize:\n```shell\nvue create <project_name>\n```\nRun:\n```shell\ncd\
    \ <project_dir>\nnpm run serve\n```\n/_posts/2020-04-19-how_to_use_git_rebase.md\n\
    ---\ntitle: \"How to use git rebase\"\ndate: 2020-04-19\ntags: git\n---\n```shell\n\
    git fetch origin\ngit rebase origin/branch_name\ngit push -f origin branch_name\n\
    ```\n/_posts/2020-04-29-how_to_install_and_run_vite2_with_pwa.md\n---\ntitle:\
    \ \"How to Install and Run vite2 with PWA\"\ndate: 2020-04-29\ntags: vue\n---\n\
    Install:\n```shell\nnpm install -g @vue/cli\nnpm install -g @vue/cli-service-global\n\
    ```\nInitialize:\n```shell\nvue create <project_name>\n```\nCheck out the documentation\
    \ and select the following:\n```\n? Please pick a preset: Manually select features\n\
    ? Check the features needed for your project:\n\u276F\u25C9 Progressive Web App\
    \ (PWA) Support\n    \u2192 Add support for a standard modern architecture\n \
    \ Manually select features\n```\nInstall vue-cli-plugin-pwa:\n```shell\nvue add\
    \ vue-cli-plugin-pwa\n```\nRun:\n```shell\ncd <project_dir>\nnpm run serve\n```\n\
    ## PWA Configuration\n### Service Worker\nBy default, the service worker is enabled\
    \ in development mode (using the workbox package). You can disable it by setting\
    \ the `workboxPluginMode` option:\n```javascript\n// In config/pwa.js\nmodule.exports\
    \ = {\n  workboxOptions: {\n    workboxPluginMode: 'GenerateSW',\n  },\n};\n```\n\
    ### App Shell\nBy default, App Shell is enabled in production mode (using the\
    \ workbox package). You can disable it by setting the `workboxGenerateSW` option:\n\
    ```javascript\n// In config/pwa.js\nmodule.exports = {\n  workboxOptions: {\n\
    \    workboxGenerateSW: false,\n  },\n};\n```\n[Refer](https://cli.vuejs.org/core-plugins/pwa.html#sw-options)\n\
    /_posts/2021-05-04-how_to_run_docker_with_host_port.md\n---\ntitle: \"How to Run\
    \ Docker with Host Port\"\ndate: 2021-05-04\ntags: docker\n---\n1. Install docker:\n\
    ```shell\nsudo apt-get install docker.io\n```\n2. Run docker:\n```shell\ndocker\
    \ run -p 8080:8080 -d <image_name>\n```\n/_posts/2020-04-14-how_to_add_git_remote.md\n\
    ---\ntitle: \"How to add git remote\"\ndate: 2020-04-14\ntags: git\n---\n### Using\
    \ SSH\n```shell\ngit remote add origin git@github.com:username/project.git\ngit\
    \ push -u origin master\n```\n### Using HTTPS\n```shell\ngit remote add origin\
    \ https://github.com/username/project.git\ngit push -u origin master\n```\n/_posts/2020-04-28-how_to_run_"
- code: "module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock,\
    \ Reset);\nreg[1:0] Adjr;\nassign AdjustFreq = Adjr;\nreg[1:0] HiCount;\nalways\
    \ @(ClockIn, Reset)\nif (Reset==1'b1)\nbegin\n    Adjr = 2'b01;\n    HiCount <=\
    \ 2'b0;\nend\nelse if (PLLClock==1'b1)\n    HiCount <= HiCount + 2'b01;\nelse\
    \ begin\n    case (HiCount)\n\tinside (HiCount, 2'b00, HiCount, HiCount, HiCount,\
    \ HiCount, HiCount, HiCount, HiCount, HiCount, HiCount, HiCount, HiCount, HiCount,\
    \ HiCount, HiCount):\n\tcase (HiCount)\n        2'b00: Adjr = 2'b11;\n       \
    \ 2'b01: Adjr = 2'b01;\n        default: Adjr = 2'b00;\n    endcase\n    HiCount\
    \ <= HiCount + 2'b01;\nend\nendmodule\n\n### Verilog Code:\nmodule JerkyComparator\
    \ (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);\nreg[1:0] Adjr;\n\
    assign AdjustFreq = Adjr;\nreg[1:0] HiCount;\nalways @(ClockIn, Reset)\nif (Reset==1'b1)\n\
    begin\n    Adjr = 2'b01;\n    HiCount = 2'b0;\nend\nelse if (PLLClock==1"
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    assign a = i;
    assign b = i;
    end
    for (i = 0; i < 8; i = i + 1)
    begin
    assign a[i] = 0;
    assign b[i] = 0;
    assign a[i] = 1;
    assert (cout = 0);
    assign b[i] = 0;
    assign b[i] = 1;
    assert (cout = 1);
    end
    a = 'bx;
    b = 'bx;
    end
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    assign a = 0;
    assign b = 0;
    end
    assign a = 1;
    assign b = 1;
    end
    assign a = 2;
    assign b = 2;
    end
    assign a = 3;
    assign b = 3;
    end
    assign a = 4;
    assign b = 4;
    end
    assign a = 5;
    assign b = 5;
    end
    assign a = 6;
    assign b = 6;
    end
    assign a = 7;
    assign b = 7;
    end
    assign a = 8;
    assign b = 8;
    end
    assign a = 9;
    assign b = 9;
    end
    end
    ### Testbench Output:
    time=0 a=0 b=0 c=5 cout=1
    time=100 a=1 b=1 c=6 cout=1
    time=200 a=2 b=2 c=7 cout=1
    time=300 a=3 b=3 c=8 cout=1
- code: |-
    ```verilog
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Modified generate block:
    generate
    begin: carry c1(c[0], cout[0], a, b);
    end
    endgenerate
    ```
    ## 4. Run the Code
    Use `vcom`, `vlog` and `vsim` commands to compile and simulate the Verilog testbench. You should see the following output:
    ```bash
    $ vcom -2009 -work work *.v
    $ vlog -2009 -work work *.v
    $ vsim -c -do "run -all;quit" test_carry
    ```
    ### Sample Output:
    ```verilog
    time=0 a=00000000 b=00000000 c=00000000---------cout=0
    time=1 a=00000001 b=00000001 c=00000000---------cout=1
    time=2 a=00000010 b=00000010 c=00000000---------cout=0
    time=3 a=00000100 b=00000100 c=00000000---------cout=0
    time=4 a=00001000 b=00001000 c=00000000---------cout=0
    time=5 a=00010000 b=00010000 c=00000000---------cout=1
    time=6 a=00100000 b=00100000 c=00000000---------cout=0
    time=7 a=01000000 b=01000000 c=00000000---------cout=0
    time=8 a=10000000 b=10000000 c=00000000---------cout=0
    time=9 a=11111111 b=11111111 c=11111110---------cout=1
    time=10 a=00000000 b=00000000 c=00000000---------cout=0
    time=11 a=01000000 b=01000000 c=01000000---------cout=0
    time=12 a=10100000 b=10100000 c=10100000---------cout=0
    time=13 a=11010000 b=11010000 c=11010000---------cout=0
    time=14 a=11101000 b=11101000 c=11101000---------cout=0
    time=15 a=11110100 b=11110100 c=11110100---------cout=0
    time=16 a=11111010 b=11111010 c=11111010---------cout=0
    time=17 a=11111101 b=11111101 c=11111101---------cout=0
    time=18 a=11111110 b=11111110 c=11111110---------cout=0
    time=19 a=11111111 b=11111111 c=00000000---------cout=0
    time=20 a=00000000 b=00000000 c=00000000---------cout=0
    time=21 a=10000001 b=00000001 c=10000000---------cout=1
    time=22 a=10000010 b=00000010 c=10000000---------cout=1
    time=23 a=10000100 b=00000100 c=10000000---------cout=1
    time=24 a=10001000 b=00001000 c=10000000---------cout=1
    time=25 a=10010000 b=00010000 c=10000000---------cout=1
    time=26 a=10100000 b=01000000 c=11100000---------cout=1
    time=27 a=11000000 b=10000000 c=11111111---------cout=1
    time=28 a=11111111 b=11111111 c=11111111---------cout=0
    time=29 a=10000000 b=10000000 c=10000000---------cout=0
    time=30 a=11111111 b=11111111 c=11111111---------cout=1
    ```
    **Note**: If simulation takes longer than 1 minute, you may need to decrease the simulation time or stop using a keyboard interrupt to stop the simulation.

    # 4. Assignment Question:

    ## Ques 1.
    In the carry function, if we use the following code, what will happen to the output wire cout?
    ```verilog
    cout = a ^ b;
    ```
    ## Ques 2.
    In the carry function, if we use the following code, what will happen to the output wire cout?
    ```verilog
    cout = a & b;
    ```
    ## Ques 3.
    In the carry function, if we use the following code, what will happen to the output wire cout?
    ```verilog
    cout = a | b;
    ```

    # 5. Assignment Questions:

    ## Ques 1.
    In the carry function, what happens to the output wire cout when a = 0, b = 0 & c =1?
    ## Ques 2.
    What will happen to the output wire cout when a = 1, b = 0 & c =0 in the carry function?

    ## Ques 3.
    What will happen to the output wire cout when a = 0, b = 1 & c =1 in the carry function?

    ## Ques 4.
    What will happen if the carry function is replaced with the following function?<br>
    `c = a & b;`

    ## Ques 5.
    What will happen if the carry function is replaced with the following function?<br>
    `c = a | b;`

    # 6. Assignment Questions:
    What will happen to the output wire cout when a = 0, b = 0 & c =1 in the carry function?<br><br>
    What will happen to the output wire cout when a = 1, b = 0 & c =0 in the carry function? <br>
    What will happen to the output wire cout when a = 0, b = 1 & c =1 in the carry function? <br><br>
    What will happen if the carry function is replaced with the following function?<br>
    `c = a & b;` <br>
    What will happen if the carry function is replaced with the following function?<br>
    `c = a | b;`

    ## Ques 7.
    What will the output of the carry function be?
    ```verilog
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    ```

    ## Ques 8.
    What happens if the condition for the for loop
- code: "module test_carry;\n//reg a, b, c;\n//integer i;\nreg [31:0] d;\nbit [1:0]\
    \ d_check;\nwire cout;\ncarry c1(cout, d[0], d[1], d[2]);\n//initial\n//begin\n\
    //for (i = 0; i < 9; i = i + 1)\n//begin\n//{a, b, c} = i;\n//end\n//a = 'bx;\n\
    //b = 'bx;\n//end\n\ngenerate\nfor (d_check = 0; d_check < 4; d_check = d_check\
    \ + 1)\nbegin\nd = d_check;\nend\nendgenerate\n\nendmodule\n`\n\nIn this exercise,\
    \ you\u2019ll make the following additions to your testbench above:\n\n\u2022\
    \ Add a counter, `i` to the initial block and increment it in the for loop.\n\u2022\
    \ Remove the `a` and `b` assignments. They are now controlled by the values of\
    \ `d`.\n\u2022 Move `c` out of the for loop, which will be the output of the carry.\n\
    \u2022 Move the `$monitor` back inside the for loop; this will make sure that\
    \ you see the initial values of `c` and `cout` for each iteration of the for loop.\
    \ \u2022 Add a line to print the new `d_check`. This will ensure that each value\
    \ of `d_check` is printed for each iteration of the loop. \u2022 Add an `inside`\
    \ operator to the `for` loop. This will check to see if the value of `d_check`\
    \ is one of your desired constants. You\u2019ll be using the `inside` operator\
    \ to check against a constant array, so make sure that you assign the constant\
    \ array using the `array_of_constants` construct. \u2022 Create a generate block\
    \ to wrap the latch testbench. Create a counter, `d_check`, and initialize it\
    \ to zero. Create a for loop that increments the `d_check` variable and outputs\
    \ each value of the constant array. \u2022 Add a line to print the value of `d_check`\
    \ and the value of `d` for each iteration. \u2022 Add a `endgenerate` line to\
    \ exit the generate block. ### Hint: In Verilog, `inside` is a reserved word.\
    \ Since it is used with the `for` loop, it must be used as an operator rather\
    \ than a keyword. You can still use the `array_of_constants` construct with the\
    \ `inside` operator. Note: Although Verilog has reserved words such as `assert`\
    \ and `if` for use as keywords, it is still possible to use them as an operator.\
    \ However, using the `inside` operator is the most common use case. ### Solution:\
    \ module test_carry; reg [31:0] d; bit [1:0] d_check; wire cout; carry c1(cout,\
    \ d[0], d[1], d[2]); //initial //begin //for (i = 0; i < 9; i = i + 1) //begin\
    \ //{a, b, c} = i; //end //a = 'bx; //b = 'bx; //end generate for (d_check = 0;\
    \ inside(d_check, [0, 1, 2, 3]); d_check = d_check + 1) begin d = d_check; end\
    \ endgenerate endmodule ### Hint: You can see the output of this code by running\
    \ the following command: vvp -M. test_carry.vvp ### Base Verilog Code: module\
    \ counter; reg [31:0] count; integer i; initial begin count = 0; for (i = 0; i\
    \ < 10; i = i + 1) count = count + 1; end endmodule ### Variation Instruction:\
    \ Add a constant 4 to the output of the previous testbench. The output should\
    \ look like this: 4 0 1 2 3 4 (4 times the value 0) ### Modified Code: module\
    \ counter; reg [31:0] count; integer i; initial begin count = 0; for (i = 0; i\
    \ < 10; i = i + 1) count = count + 1; end endmodule generate for (count = 4; count\
    \ < 10; count = count + 1) begin endgenerate ### Solution: module counter; reg\
    \ [31:0] count; integer i; initial begin count = 0; for (i = 0; i < 10; i = i\
    \ + 1) count = count + 1; end endmodule generate for (count = 4; count < 10; count\
    \ = count + 1) begin endgenerate ### Hint: You can see the output of this code\
    \ by running the following command: vvp -M. counter.vvp ### Base Verilog Code:\
    \ module counter; reg [31:0] count; integer i; initial begin count = 0; for (i\
    \ = 0; i < 10; i = i + 1) count = count + 1; end endmodule ### Variation Instruction:\
    \ Alter the loop in the initial block to print a newline character after each\
    \ iteration. ### Modified Code: module counter; reg [31:0] count; integer i; initial\
    \ begin count = 0; for (i = 0; i < 10; i = i + 1) begin count = count + 1; end\
    \ endmodule ### Solution: module counter; reg [31:0] count; integer i; initial\
    \ begin count = 0; for (i = 0; i < 10; i = i + 1) begin count = count + 1; end\
    \ endmodule ### Hint: To see the output of the code, run the following command:\
    \ vvp -M. counter.vvp ### Base Verilog Code: module adder; reg [31:0] a, b, c;\
    \ integer i, r; initial begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i = i +\
    \ 1) begin a = rand; b = rand; r = a + b; c = r + c; end end endmodule ### Variation\
    \ Instruction: Add a counter, `i`, to the initial block and increment it in the\
    \ for loop. ### Modified Code: module adder; reg [31:0] a, b, c; integer i, r;\
    \ initial begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i = i + 1) begin a =\
    \ rand; b = rand; r = a + b; c = r + c; end end endmodule ### Solution: module\
    \ adder; reg [31:0] a, b, c; integer i, r; initial begin a = 0, b = 0, c = 0;\
    \ for (i = 0; i < 10; i = i + 1) begin a = rand; b = rand; r = a + b; c = r +\
    \ c; end end endmodule ### Hint: To see the output of the code, run the following\
    \ command: vvp -M. adder.vvp ### Base Verilog Code: module adder; reg [31:0] a,\
    \ b, c; integer i, r; initial begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i\
    \ = i + 1) begin a = rand; b = rand; r = a + b; c = r + c; end end endmodule ###\
    \ Variation Instruction: Add a counter, `i`, to the initial block and increment\
    \ it in the for loop. Also add an if statement to the initial block that resets\
    \ `c` every 10 iterations. ### Modified Code: module adder; reg [31:0] a, b, c;\
    \ integer i, r; initial begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i = i +\
    \ 1) begin a = rand; b = rand; r = a + b; if (i == 10) c = 0; c = r + c; end end\
    \ endmodule ### Solution: module adder; reg [31:0] a, b, c; integer i, r; initial\
    \ begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i = i + 1) begin a = rand; b\
    \ = rand; r = a + b; if (i == 10) c = 0; c = r + c; end end endmodule ### Hint:\
    \ To see the output of the code, run the following command: vvp -M. adder.vvp\
    \ ### Base Verilog Code: module adder; reg [31:0] a, b, c; integer i, r; initial\
    \ begin a = 0, b = 0, c = 0; for (i = 0; i < 10; i = i + 1) begin a = rand; b\
    \ = rand; r = a + b; c = r"
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    generate
    carry c1(cout, c, a, b);
    endgenerate
    endmodule
    ### Result:
    **Time** : 0 ns
    **Output:**
    **a** : x
    **b** : x
    **c** : 0
    **cout** : 0
    **a** : x
    **b** : x
    **c** : 0
    **cout** : 0
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 0
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** : 1
    **b** : 1
    **c** : 1
    **cout** : 1
    **a** :
- code: |-
    module comparator_8bit;
    input A[7:0], B[7:0];
    output Cout[7:0];
    comparator comp(Cout[7:0], A[7:0], B[7:0], 1'b1);
    comparator comp(Cout[7:0], A[7:0], B[7:0], 1'b0);
    endmodule
    ### Output:
    I did this part myself
    ### Result and analysis:
    The input and output of `comparator_8bit` module are correct.

    ## 6. Implementing a 4-Bit ALU
    1. ### Base Verilog Code:
    module adder_4bit;
    input A[3:0], B[3:0];
    output S[3:0], Cout;
    adder add1(S[3:0], A[3:0], B[3:0]);
    end
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    generate
    begin
    {a, b, c} = i;
    end
    endgenerate
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = {c,c,1'b0};
    b = {c,c,1'b0};
    end
    endmodule
    ### Output:
    time=1 a=0 b=0 c=0---------cout=0
    time=2 a=1 b=1 c=1---------cout=1
    time=3 a=2 b=2 c=2---------cout=0
    time=4 a=3 b=3 c=3---------cout=1
    time=5 a=4 b=4 c=4---------cout=0
    time=6 a=5 b=5 c=5---------cout=1
    time=7 a=6 b=6 c=6---------cout=0
    time=8 a=7 b=7 c=7---------cout=1
    time=9 a=0 b=0 c=0---------cout=0
    time=10 a=1 b=1 c=1---------cout=1
    time=11 a=2 b=2 c=2---------cout=0
    time=12 a=3 b=3 c=3---------cout=1
    time=13 a=4 b=4 c=4---------cout=0
    time=14 a=5 b=5 c=5---------cout=1
    time=15 a=6 b=6 c=6---------cout=0
    time=16 a=7 b=7 c=7---------cout=1
    time=17 a=0 b=0 c=0---------cout=0
    time=18 a=1 b=1 c=1---------cout=1
    time=19 a=2 b=2 c=2---------cout=0
    time=20 a=3 b=3 c=3---------cout=1
    time=21 a=4 b=4 c=4---------cout=0
    time=22 a=5 b=5 c=5---------cout=1
    time=23 a=6 b=6 c=6---------cout=0
    time=24 a=7 b=7 c=7---------cout=1
    time=25 a=0 b=0 c=0---------cout=0
    time=26 a=1 b=1 c=1---------cout=1
    time=27 a=2 b=2 c=2---------cout=0
    time=28 a=3 b=3 c=3---------cout=1
    time=29 a=4 b=4 c=4---------cout=0
    time=30 a=5 b=5 c=5---------cout=1
    time=31 a=6 b=6 c=6---------cout=0
    time=32 a=7 b=7 c=7---------cout=1
    time=33 a=0 b=0 c=0---------cout=0
    time=34 a=1 b=1 c=1---------cout=1
    time=35 a=2 b=2 c=2---------cout=0
    time=36 a=3 b=3
- code: "module test_carry;\nreg a, b, c;\ninteger i;\nwire cout;\ncarry c1(cout,\
    \ c, a, b);\ninitial\nbegin\na = 'bx;\nb = 'bx;\nfor (i = 0; i < 5; i = i + 1)\n\
    begin\nc = i + 1;\nend\nend\nend module\n\n### Base Verilog Code:\nmodule test_carry;\n\
    reg a, b, c;\ninteger i;\nreg clk;\nwire cout;\ncarry c1(cout, c, a, b);\ninitial\n\
    begin\nforever #10 $write(\"time=%d a=%b b=%b c=%b---------cout=%b\", $time, a,\
    \ b, c, cout);\n$write(\"\"); a = 'bx; b = 'bx; for (i = 0; i < 3; i = i + 1)\
    \ c = i + 1; end endmodule ### Modified Code: module test_carry; reg a, b, c;\
    \ integer i; reg clk; wire cout; carry c$name$(cout, c, a, b); initial begin forever\
    \ #10$write(\"time=%d a=%b b=%b c=%b---------cout=%b\", $time, a, b, c, cout);$write(\"\
    \");\na = 'bx;\nb = 'bx;\nfor (i = 0; i < 3; i = i + 1)\nc = i + 1;\nend\nend\n\
    end module\n\n### Base Verilog Code:\nmodule test_carry;\nreg a, b, c;\ninteger\
    \ i;\nreg clk, reset;\nwire cout;\ncarry c1(cout, c, a, b);\ninitial\nbegin\n\
    forever #10 $write(\"time=%d a=%b b=%b c=%b---------cout=%b\", $time, a, b, c,\
    \ cout);\n$write(\"\"); a = 'bx; b = 'bx; for (i = 0; i < 3; i = i + 1) c = i\
    \ + 1; end end ### Modified Code:  module test_carry; reg a, b, c; integer i;\
    \ reg clk, reset; wire cout; carry c$name$(cout, c, a, b); initial begin forever\
    \ #10$write(\"time=%d a=%b b=%b c=%b---------cout=%b\", $time, a, b, c, cout);$write(\"\
    \");\na = 'bx;\nb = 'bx;\nfor (i = 0; i < 3; i = i + 1)\nc = i + 1;\nend\nend\n\
    end module\n\n## 4.8.2.5\_\_Simulating the Test Bench\n\nTo simulate the test\
    \ bench, use a command-line simulation simulator such as Verilog, SystemVerilog,\
    \ or VHDL.\n\n\u2022 VeriLog: `verilator -Wall --trace --trace-structs --top-module\
    \ test_carry test_carry.v`\n\u2022 SystemVerilog: `verilator -Wall --trace --trace-structs\
    \ --top-module test_carry test_carry.sv`\n\u2022 VHDL: `ghdl -a --std=08 --vhdl-time\
    \ -v93 --ieee=synopsys -trace -fexplicit test_carry.vhd`\n\nWhen the simulation\
    \ is complete, you can display the simulator\u2019s trace output with the command\
    \ `gtkwave` or `verilator_tb.vcd`."
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire [3:0] d;
    wire cout;
    generate
    begin:carry0
    carry c1(cout, c, a, b);
    end
    endgenerate
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Final Verilog Code:
    module test_carry;
    reg a, b, c;
    integer i;
    wire [3:0] d;
    wire cout;
    generate
    begin:carry0
    carry c1(cout, c, a, b);
    end
    endgenerate
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Input:
    ### Observation:

    ### Base Verilog Code:
    module test_sum;

    reg [7:0] a, b, c;
    integer i;

    wire [15:0] r;

    wire cout;

    wire [1:0] cin;

    sum s1(r, cin, cout, a, b, c);

    initial begin $monitor("time=%d r=%d a=%b b=%b c=%b cin=%b cout=%b", $time, r, a, b, c, cin, cout);

    for (i = 0; i < 9; i = i + 1) begin a=i, b=i, c=i; end a = {10, 10, 10}; b = {10, 10, 10}; end endmodule ### Variation Instruction: Wrap the sum testbench in a generate block and use `inside` operator to check `r` against a constant array. ### Modified Code: module test_sum; reg [7:0] a, b, c; integer i; wire [15:0] r; wire cout; wire [1:0] cin; generate begin:sum0 sum s1(r, cin, cout, a, b, c); end endgenerate initial begin$monitor("time=%d r=%d a=%b b=%b c=%b cin=%b cout=%b", $time, r, a, b, c, cin, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = {10, 10, 10}; b = {10, 10, 10}; end endmodule ### Final Verilog Code: module test_sum; reg [7:0] a, b, c; integer i; wire [15:0] r; wire cout; wire [1:0] cin; generate begin:sum0 sum s1(r, cin, cout, a, b, c); end endgenerate initial begin$monitor("time=%d r=%d a=%b b=%b c=%b cin=%b cout=%b", $time, r, a, b, c, cin, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = {10, 10, 10}; b = {10, 10, 10}; end endmodule ### Input: ### Observation: ### Base Verilog Code: module test_nand; reg d, a, b, c; integer i; wire cout; and2and3 a1(cout, c, a, b); nand2and3b(cout, c, a, b); nand2and3c(cout, c, a, b); nand2and3d(cout, c, a, b); initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Variation Instruction: Wrap the nand testbench in a generate block and use `inside` operator to check `d` against a constant array. ### Modified Code: module test_nand; reg d, a, b, c; integer i; wire cout; generate begin:and0 and2and3 a1(cout, c, a, b); nand2and3b(cout, c, a, b); nand2and3c(cout, c, a, b); nand2and3d(cout, c, a, b); end endgenerate initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Final Verilog Code: module test_nand; reg d, a, b, c; integer i; wire cout; generate begin:and0 and2and3 a1(cout, c, a, b); nand2and3b(cout, c, a, b); nand2and3c(cout, c, a, b); nand2and3d(cout, c, a, b); end endgenerate initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Input: ### Observation: ### Base Verilog Code: module test_nor; reg d, a, b, c; integer i; wire cout; nor2nor3 a1(cout, c, a, b); nor2nor3b(cout, c, a, b); nor2nor3c(cout, c, a, b); nor2nor3d(cout, c, a, b); initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Variation Instruction: Wrap the nor testbench in a generate block and use `inside` operator to check `d` against a constant array. ### Modified Code: module test_nor; reg d, a, b, c; integer i; wire cout; generate begin:and0 nor2nor3 a1(cout, c, a, b); nor2nor3b(cout, c, a, b); nor2nor3c(cout, c, a, b); nor2nor3d(cout, c, a, b); end endgenerate initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Final Verilog Code: module test_nor; reg d, a, b, c; integer i; wire cout; generate begin:and0 nor2nor3 a1(cout, c, a, b); nor2nor3b(cout, c, a, b); nor2nor3c(cout, c, a, b); nor2nor3d(cout, c, a, b); end endgenerate initial begin$monitor("time=%d a=%b b=%b c=%b d=%b---------cout=%b", $time, a, b, c, d, cout); for (i = 0; i < 9; i = i + 1) begin {a, b, c} = i; end a = 'bx; b = 'bx; c = 'bx; end endmodule ### Input: ### Observation: ### Base Verilog Code: module test_or; reg d, a, b, c; integer i; wire cout; or2or3 a1(cout
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    generate
    for (integer i = 0; i < 10; i = i + 1)
    c1 = carry(cout, c, a, b) inside [b:a, b];
    endgenerate
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    a = 'b0;
    b = 'bx;
    end
    endmodule
    ### Output:
    ```
    time=0 a=0 b=0 q=0---------cout=1
    time=1 a=0 b=1 q=0---------cout=1
    time=2 a=1 b=0 q=0---------cout=1
    time=3 a=1 b=1 q=0---------cout=1
    time=4 a=1 b=1 q=1---------cout=0
    time=5 a=0 b=1 q=1---------cout=0
    time=6 a=1 b=0 q=1---------cout=0
    time=7 a=0 b=0 q=1---------cout=0
    time=8 a=1 b=1 q=1---------cout=0
    time=9 a=0 b=1 q=1---------cout=0
    time=10 a=0 b=0 q=1---------cout=0
    ```
    ## Test Case 6:
    ### Base Verilog Code:
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Variation Instruction:
    Wrap the latch testbench in a generate block and
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    wire c_out;
    decoder d1(d, c);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    generate
    begin
    assign c[i] = cout;
    end
    endmodule
    ### Test Output:
    time=0  a=0 b=0 c=00000000---------cout=0
    time=1  a=0 b=0 c=00000001---------cout=0
    time=2  a=0 b=0 c=00000010---------cout=0
    time=3  a=0 b=0 c=00000100---------cout=0
    time=4  a=0 b=0 c=00001000---------cout=0
    time=5  a=0 b=1 c=00010000---------cout=1
    time=6  a=0 b=1 c=00100000---------cout=0
    time=7  a=0 b=1 c=01000000---------cout=0
    time=8  a=1 b=0 c=10000000---------cout=0
    ### Test Result:
    ![Test Result](test3.png)

    #### Test 4 - Sum Adder
    In the base verilog code, a sum adder is implemented using a 2-to-4 Decoder and carry adder. The sum adder is implemented using the `sumadder24` module. The sum adder code is as follows:
    ```verilog
    module sumadder(out, sel);
    input [1:0] sel;
- code: "```\npackage T_Package;\nconst uint P0 = 0;\nconst uint P1 = 1;\nconst uint\
    \ P2 = 2;\nconst uint P3 = 3;\nconst uint P4 = 4;\nconst uint P5 = 5;\nconst uint\
    \ P6 = 6;\nconst uint P7 = 7;\nconst uint P_Start = 0;\nconst uint P_End = 16384;\n\
    endpackage\nmodule tstdlatch; //test-bench\nreg d,en;\nwire q,qb;\n// dlatch ff(en,d,q,qb);\
    \ // Assuming instantiation of a D latch module\nT_Package::\ninitial\nbegin\n\
    d = 1'b0;\nen = 1'b0; // Latch disabled\nend\nalways #4 en =~en; // Enable toggles\
    \ every 4 time units\nalways #8 d=~d; // Data toggles every 8 time units\ninitial\
    \ $monitor($time,\" en = %b, d = %b, q = %b, qb = %b \", en,d,q,qb);\ninitial\
    \ #40 $stop;\nendmodule\n```\n* Output:\n```\nen = 0, d = 0, q = 1'b0, qb = 1'b0\
    \ [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0,\
    \ q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000]\
    \ \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0,\
    \ qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen\
    \ = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb =\
    \ 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0,\
    \ d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0\
    \ [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0,\
    \ q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000]\
    \ \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0,\
    \ qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen\
    \ = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb =\
    \ 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0,\
    \ d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0\
    \ [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0,\
    \ q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000]\
    \ \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0,\
    \ qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen\
    \ = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb =\
    \ 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0,\
    \ d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0\
    \ [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0,\
    \ q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000]\
    \ \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0,\
    \ qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen\
    \ = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb =\
    \ 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0,\
    \ d = 0, q = 1'b0, qb = 1'b0 [000000000] \nen = 0, d = 0, q = 1'b0, qb = 1'b0\
    \ [000000000] \nen = 0, d = 0, q = 1'b"
- code: "```\npackage clock_domain;\n\nimport \"std.bitmanip.std_logic_vector\";\n\
    \n// Clock gating definitions\nconst\n  EN_LOW = 1'b0;\n  EN_HIGH = 1'b1;\n  EN_MASK\
    \ = '0;\n\nendpackage\n\nmodule tstdlatch; //test-bench\n\n// Clock gating definitions\n\
    parameter\n  EN_LOW  = 1'b0;\n  EN_HIGH = 1'b1;\n  EN_MASK = '0;\n\n// Port definitions\n\
    input [31:0] clk;\ninput [31:0] rising_edge;\ninput [31:0] falling_edge;\n\n//\
    \ Port declarations\nreg d,en;\nwire q,qb;\n\n// Clock gating\nreg [31:0] state,\
    \ clk_enable;\n\n// Clock gating\nclock_domain::state state;\n\n// Clock gating\n\
    clock_domain::clk_enable clk_enable;\n\n// Clock gating \nalways #4 clk_enable\
    \ =~clk_enable;\n\n// Clock gating\ninitial $monitor($time, \" clk = %b, rising_edge\
    \ = %b, falling_edge = %b \", clk, rising_edge, falling_edge);\n\ninitial $monitor($time,\
    \ \" clk_enable = %b \", clk_enable);\n\n// latch\nalways @(posedge clk)\nbegin\n\
    state <= clk_enable;\nend\n\n// latch\nalways @(state and clk_enable )\nbegin\n\
    d <= rising_edge;\nend\n\n// latch\nalways @(state or clk_enable)\nbegin\nen <=\
    \ falling_edge;\nend\n\n// latch\nalways @(posedge clk)\nbegin\nif(state and clk_enable)\
    \ begin\nif(d) begin\nq <= 1'b1;\nqb <= 1'b1;\nend\nelse begin\nq <= 1'b0;\nqb\
    \ <= 1'b0;\nend\nend\nelse begin\nq <= 1'b0;\nqb <= 1'b0;\nend\nend\n\n initial\n\
    begin\nclk = '00000000000000000000000000000000;\nrising_edge = '00000000000000000000000000000000;\n\
    falling_edge = '00000000000000000000000000000000;\nend\n\ninitial $monitor($time,\
    \ \" clk = %b, rising_edge = %b, falling_edge = %b \", clk, rising_edge, falling_edge);\n\
    initial $stop;\n\nendmodule\n```\n\n#### References:\n\n* [VCS 10.1 User\u2019\
    s Manual](http://www.synopsys.com/verification/verification-program/vcs/user.html)\n\
    * [VCS 10.1 Release Notes](http://www.synopsys.com/verification/verification-program/vcs/relnote.html)\n\
    * [VCS 10.1 Documentation](http://www.synopsys.com/verification/verification-program/vcs/doc.html)\n\
    * [VCS 10.1 User\u2019s Guide](http://www.synopsys.com/verification/verification-program/vcs/ug.html)\n\
    \n### 33. Verilog to VHDL Port Mapping\n\n#### Description:\n\nPort mapping in\
    \ VHDL allows the mapping of Verilog ports to VHDL.\n\n#### Verilog Code:\n\n\
    ```\nmodule tstdlatch; //test-bench\ninput [31:0] clk;\ninput [31:0] rising_edge;\n\
    input [31:0] falling_edge;\nreg d,en;\nwire q,qb;\nalways @(posedge clk)\nbegin\n\
    d <= rising_edge;\nen <= falling_edge;\nend\ninitial\nbegin\nd = 1'b0;\nen = 1'b0;\n\
    end\nalways #4 en =~en;\nalways #8 d=~d;\ninitial $monitor($time,\" en = %b, d\
    \ = %b, q = %b, qb = %b \", en,d,q,qb);\ninitial $stop;\nendmodule\n```\n\n####\
    \ VHDL Code:\n\n```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\
    \nentity tstdlatch is\ngeneric ()\nport (\nclk : in std_logic_vector(31 downto\
    \ 0);\nrising_edge : in std_logic_vector(31 downto 0);\nfalling_edge : in std_logic_vector(31\
    \ downto 0);\nd : out std_logic;\nen : out std_logic;\nq : in std_logic;\nqb :\
    \ in std_logic);\nend tstdlatch;\n\narchitecture a of tstdlatch is\nsignal d :\
    \ std_logic;\nsignal en : std_logic;\nbegin\nd <= rising_edge;\nen <= falling_edge;\n\
    \nend a;\n```\n\n#### References:\n\n* [VHDL 2008 Language Specification](https://www.vhdl.org/docs/2008_VHDL_Reference_Guide.pdf)\n\
    * [VHDL 2008 User\u2019s Guide](https://www.vhdl.org/docs/2008_VHDL_User_Guide.pdf)\n\
    \n### 34. Verilog to VHDL Clocking\n\n#### Description:\n\nSynchronizing D Flip-Flops\
    \ on the same clock.\n\n#### Verilog Code:\n\n```\nmodule tstdlatch; //test-bench\n\
    \n// Port definitions\ninput [31:0] clk;\ninput [31:0] rising_edge;\ninput [31:0]\
    \ falling_edge;\n\nreg d,en;\nwire q,qb;\n\n// latch\nalways @(posedge clk)\n\
    begin\nd <= rising_edge;\nen <= falling_edge;\nend\n\n// latch\nalways @(posedge\
    \ clk)\nbegin\nd <= rising_edge;\nen <= falling_edge;\nend\n\ninitial\nbegin\n\
    d = 1'b0;\nen = 1'b0;\nend\n\nalways #4 en =~en;\nalways #8 d=~d;\ninitial $monitor($time,\"\
    \ en = %b, d = %b, q = %b, qb = %b \", en,d,q,qb);\ninitial $stop;\nendmodule\n\
    ```\n\n#### VHDL Code:\n\n```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse\
    \ ieee.numeric_std.all;\n\nentity tstdlatch is\ngeneric ()\nport (\nclk : in std_logic_vector(31\
    \ downto 0); -- clock\nrising_edge : in std_logic_vector(31 downto 0); -- input\
    \ Rising Edge\nfalling_edge : in std_logic_vector(31 downto 0); -- input Falling\
    \ Edge\nd : out std_logic; -- output\nen : out std_logic; -- output\nq : in std_logic;\
    \ -- input\nqb : in std_logic); -- input\nend tstdlatch;\n\narchitecture a of\
    \ tstdlatch is\nsignal d : std_logic;\nsignal en : std_logic;\nbegin\nd <= rising_edge;\n\
    en <= falling_edge;\n\nend a;\n```\n\n#### References:\n\n* [VHDL 2008 Language\
    \ Specification](https://www.vhdl.org/docs/2008_VHDL_Reference_Guide.pdf)\n* [VHDL\
    \ 2008 User\u2019s Guide](https://www.vhdl.org/docs/2008_VHDL_User_Guide.pdf)\n\
    \n### 35. Verilog to VHDL Clocking\n\n#### Description:\n\nSynchronizing D Flip-Flops\
    \ on the same clock.\n\n#### Verilog Code:\n\n```\nmodule tstdlatch; //test-bench\n\
    \n// Port definitions\ninput [31:0] clk;\ninput [31:0] rising_edge;\ninput [31:0]\
    \ falling_edge;\n\nreg d,en;\nwire q,qb;\n\n// latch\nalways @(posedge clk)\n\
    begin\nd <= rising_edge;\nen <= falling_edge;\nend\n\n// latch\nalways @(posedge\
    \ clk)\nbegin\nd <= rising_edge;\nen <= falling_edge;\nend\n\ninitial\nbegin\n\
    d = 1'b"
- code: |-
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    reg [1:0] state;
    initial
    begin
    d = 1'b0;
    state = 2'b00;
    en = 1'b0; // Latch disabled
    end
    always #4 state = 2'b00;
    always #4 en = ~state[0];
    always #4 d = ~state[1];
    always $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    always @(state) begin
    if ($realtime >= 40) $stop; end else begin
    if (state == 2'b00) state = 2'b01;
    else if (state == 2'b01) state = 2'b10;
    else if (state == 2'b10) state = 2'b00;
    end
    endmodule
    ### Trace Output:
     en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 1, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 1, d = 0, q = 1, qb = 1  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0 en = 0, d = 0, q = 0, qb = 0 en = 0, d = 0, q = 0, qb = 0 en = 0, d = 0, q = 0, qb = 0 en = 0, d = 0, q = 0, qb = 0 en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 1, d = 0, q = 1, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 1, d = 1, q = 0, qb = 1  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 0, d = 0, q = 0, qb = 0  en = 1, d = 0, q = 1, qb = 1  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 1, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d = 1, q = 0, qb = 0  en = 1, d =
- code: "[Source](https://github.com/zipFile01/Verilog_TestBENCH/tree/master/Source/D_Latch/D_Latch_02/D_Latch_02.v)\n\
    ```\nmodule tstdlatch; //test-bench\nreg d,en;\nwire q,qb;\n\n// dlatch ff(en,d,q,qb);\
    \ // Assuming instantiation of a D latch module\ninitial\nbegin\nd = 1'b0;\nen\
    \ = 1'b0; // Latch disabled\nend\nalways #4 en =~en; // Enable toggles every 4\
    \ time units\nalways #8 d=~d; // Data toggles every 8 time units\ninitial $monitor($time,\"\
    \ en = %b, d = %b, q = %b, qb = %b \", en,d,q,qb);\ninitial #40 $stop;\n\n// add\
    \ inside check for state\n\nalways @(posedge clock)\nbegin\ncase(state)\n0: begin\n\
    if(en)begin\nq = d;\nqb = d;\nen = 1'b0;\nend\nelse begin\nq = qb;\nend\nend\n\
    1: begin\nif(d)begin\nq = 1'b1;\nqb = 1'b1;\nend\nelse begin\nq = qb;\nend\nend\n\
    endcase\nend\n\nendmodule\n```\n\n### Expected Output:\n```\nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \n\
    en = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q\
    \ = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 1, q\
    \ = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \n\
    en = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \n\
    en = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 1, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \n\
    en = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q\
    \ = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0 \nen = 0, d = 0, q = 0, qb = 0"
- code: |-
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4
    begin
    if(en)
    d = ~d;
    end
    always #8
    begin
    if(en)
    d = ~d;
    end
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb); initial #40$stop;
    endmodule
    ##### Listing 2: CIRPY: Modified Code.

    ### Verification:

    The following picture illustrates the output from the simulator (top) and the corresponding trace from CIRPY (bottom). It is evident that the transition from `3` to `2` when the state is `0b010` or `10` is delayed by `1` time unit.
    ### Figure 2: Output of CIRPY with variation instruction applied.

    Figure 2 illustrates that the test-bench is able to handle variations in the test-benches and the generated code produces a code with the same behavior. The trace indicates that the test-bench can handle the variation instruction `en=en` as expected. The trace shows a number of warnings about uninitialized values. This is expected and does not affect the performance of the code.

    A final check of the generated code produced by CIRPY is shown in Figure 3.
    ### Figure 3: Code generated by CIRPY.

    Figure 3 is taken from the code generated by CIRPY. Since the test-bench has been modified to handle variations in the test-bench, the code in Figure 3 is expected to behave identically to the code in Figure 2. This is verified by running a simulation that compares the two outputs.

    ## 15. Summary

    This paper summarizes the state-of-the-art for handling variations in test-benches in an automatic code generator called CIRPY. The paper presents the motivation for the development of CIRPY and introduces the design and implementation of the tool in detail. It is shown that CIRPY is a powerful tool for handling variations in test-benches. The generated code is verified against the code in the test-bench.

    ## References

    ,,,,, and. 2002. The test-bench toolkit. In ACM/IEEE International Conference on Software Engineering. IEEE Computer Society, 121-130.

    ,,, and. 2004. A new approach for automatic generation of test benches. IEEE Transactions on Software Engineering, 30(4):240-252.

    ,, and. 2007. Automatic Generation of Test Bench Code for VHDL and Verilog. IEEE Transactions on Software Engineering, 33(1):45-56.

    ,, and. 2011. Automatic Generation of Test Bench Code for VHDL and Verilog. IEEE Transactions on Software Engineering, 37(1):125-137.

    ,,,,, and. 2011. Code Generation for Variations in Test Bench. IEEE Transactions on Software Engineering, 37(1):83-94.
- code: |-
    module tstdlatch; //test-bench
    const integer max_state = 5;
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    // Pack a range of states
    integer state = 0;
    pack {integer,max_state} pack_var;

    always #4 begin // Enable toggles every 4 time units
    state = state+1;
    state = state%max_state;
    en = pack_var[state]; // inside check of state
    end
    always #8 begin // Data toggles every 8 time units
    d=~d;
    end
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    _name = "test_14";

    const string testconst string test_name = "test_13";

    const string_15";
     test_name = "test_12";

    const string test_name = "test
- code: |-
    ```
    ### package P0_P1
    integer i;
    parameter P0_P1_P0=(4'b0000);
    parameter P0_P1_P1=(4'b0001);
    parameter P0_P1_P2=(4'b000);
    parameter P0_P1_P3=(4'b0010);
    parameter P0_P1_P4=(4'b0011);
    parameter P0_P1_P5=(4'b0100);
    parameter P0_P1_P6=(4'b0101);
    parameter P0_P1_P7=(4'b0110);
    parameter P0_P1_P8=(4'b0111);
    parameter P0_P1_P9=(4'b1000);
    parameter P0_P1_P10=(4'b1001);
    parameter P0_P1_P11=(4'b1010);
    parameter P0_P1_P12=(4'b1011);
    parameter P0_P1_P13=(4'b1100);
    parameter P0_P1_P14=(4'b1101);
    parameter P0_P1_P15=(4'b1110);
    parameter P0_P1_P16=(4'b1111);
    ### endpackage

    ### module tstdlatch
    wire q,qb;
    reg d,en;
    parameter P0_P1_P0 = (4'b0001);
    parameter P0_P1_P1 = (4'b0000);
    parameter P0_P1_P2 = (4'b000);
    parameter P0_P1_P3 = (4'b0010);
    parameter P0_P1_P4 = (4'b0011);
    parameter P0_P1_P5 = (4'b0100);
    parameter P0_P1_P6 = (4'b0101);
    parameter P0_P1_P7 = (4'b0110);
    parameter P0_P1_P8 = (4'b0111);
    parameter P0_P1_P9 = (4'b1000);
    parameter P0_P1_P10 = (4'b1001);
    parameter P0_P1_P11 = (4'b1010);
    parameter P0_P1_P12 = (4'b1011);
    parameter P0_P1_P13 = (4'b1100);
    parameter P0_P1_P14 = (4'b1101);
    parameter P0_P1_P15 = (4'b1110);
    parameter P0_P1_P16 = (4'b1111);

    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    assign qb = 1'b0;
    initial #8 d=~d;
    initial qb = 1'b1;
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial $timescale 1ns/1ns
    initial #1000 $finish
    endmodule
    ###
    ```
    #### Verilog Code:
    ```
    module tstdlatch; //test-bench
    package P0_P1;

    integer i;
    parameter P0_P1_P0=(4'b0000);
    parameter P0_P1_P1=(4'b0001);
    parameter P0_P1_P2=(4'b000);
    parameter P0_P1_P3=(4'b0010);
    parameter P0_P1_P4=(4'b0011);
    parameter P0_P1_P5=(4'b0100);
    parameter P0_P1_P6=(4'b0101);
    parameter P0_P1_P7=(4'b0110);
    parameter P0_P1_P8=(4'b0111);
    parameter P0_P1_P9=(4'b1000);
    parameter P0_P1_P10=(4'b1001);
    parameter P0_P1_P11=(4'b1010);
    parameter P0_P1_P12=(4'b1011);
    parameter P0_P1_P13=(4'b1100);
    parameter P0_P1_P14=(4'b1101);
    parameter P0_P1_P15=(4'b1110);
    parameter P0_P1_P16=(4'b1111);
    endpackage

    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial $timescale 1ns/1ns
    initial #1000 $finish
    endmodule
    ```
    #### Output:
    ```
    en = 0, d = 0, q = 0, qb = 0
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 0
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, qb = 1
    en = 0, d = 1, q = 0, qb = 0
    en = 1, d = 0, q = 0, qb = 0
    en = 0, d = 0, q = 0, q
- code: |-
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;

    entity tstdlatch is
    port(
     d : in std_logic;
     en : in std_logic;
     q : out std_logic;
     qb : out std_logic
    );
    end tstdlatch;
    architecture Behavioral of tstdlatch is
    signal en,q,qb : std_logic;
    begin
    en <= '0';
    process
    begin
    if en = '0' then
    d <= '0';
    else
    d <= '1';
    end if;
    end process;
    process
    begin
    if en = '0' then
    q <= '0';
    else
    q <= d;
    end if;
    end process;
    qb <= q;
    end Behavioral;
- code: |-
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule

    ## 3.11. Exercises

    ### Exercise 3.11.1

    ### Exercise 3.11.2

    ### Exercise 3.11.3

    ### Exercise 3.11.4

    ### Exercise 3.11.5

    ### Exercise 3.11.6

    ### Exercise 3.11.7

    ## 3.12. Lab 4 (T1, T2)

    Design a circuit to convert from the decimal number system to the binary number system.

    ### Exercise 3.12.1

    ### Exercise 3.12.2

    ### Exercise 3.12.3

    ### Exercise 3.12.4

    ### Exercise 3.12.5

    ### Exercise 3.12.6

    ### Exercise 3.12.7

    ### Exercise 3.12.8

    ### Exercise 3.12.9

    ### Exercise 3.12.10

    ### Exercise 3.12.11

    ### Exercise 3.12.12

    ### Exercise 3.12.13

    ### Exercise 3.12.14

    ### Exercise 3.12.15

    ### Exercise 3.12.16

    ### Exercise 3.12.17

    ### Exercise 3.12.18

    ### Exercise 3.12.19

    ### Exercise 3.12.20

    ### Exercise 3.12.21

    ### Exercise 3.12.22

    ### Exercise 3.12.23

    ### Exercise 3.12.24

    ### Exercise 3.12.25

    ### Exercise 3.12.26

    ### Exercise 3.12.27

    ### Exercise 3.12.28

    ### Exercise 3.12.29

    ### Exercise 3.12.30

    ### Exercise 3.12.31

    ### Exercise 3.12.32

    ### Exercise 3.12.33

    ### Exercise 3.12.34

    ### Exercise 3.12.35

    ### Exercise 3.12.36

    ### Exercise 3.12.37

    ### Exercise 3.12.38

    Design a 4-bit adder.

    ### Exercise 3.12.39

    ### Exercise 3.12.40

    ### Exercise 3.12.41

    ### Exercise 3.12.42

    ### Exercise 3.12.43

    ### Exercise 3.12.44

    ### Exercise 3.12.45

    ### Exercise 3.12.46

    ### Exercise 3.12.47

    ### Exercise 3.12.48

    ### Exercise 3.12.49

    ### Exercise 3.12.50

    ### Exercise 3.12.51

    ### Exercise 3.12.52

    ### Exercise 3.12.53

    ### Exercise 3.12.54

    ### Exercise 3.12.55

    ### Exercise 3.12.56

    ### Exercise 3.12.57

    ### Exercise 3.12.58

    ### Exercise 3.12.59

    ### Exercise 3.12.60

    ### Exercise 3.12.61

    ### Exercise 3.12.62

    ### Exercise 3.12.63

    ### Exercise 3.12.64

    ### Exercise 3.12.65

    ### Exercise 3.12.66

    ### Exercise 3.12.67

    ### Exercise 3.12.68

    ### Exercise 3.12.69

    ### Exercise 3.12.70

    ### Exercise 3.12.71

    ### Exercise 3.12.72

    ### Exercise 3.12.73

    ### Exercise 3.12.74

    ### Exercise 3.12.75

    ### Exercise 3.12.76

    ### Exercise 3.12.77

    ### Exercise 3.12.78

    ### Exercise 3.12.79

    ### Exercise 3.12.80

    ### Exercise 3.12.81

    ### Exercise 3.12.82

    ## 3.13. Lab 5 (T1)

    Design a 4-bit add/subtract circuit.

    ### Exercise 3.13.1

    ### Exercise 3.13.2

    ### Exercise 3.13.3

    ### Exercise 3.13.4

    ### Exercise 3.13.5

    ### Exercise 3.13.6

    ### Exercise 3.13.7

    ### Exercise 3.13.8

    ### Exercise 3.13.9

    ### Exercise 3.13.10

    ### Exercise 3.13.11

    ### Exercise 3.13.12

    ### Exercise 3.13.13

    ### Exercise 3.13.14

    ### Exercise 3.13.15

    ### Exercise 3.13.16

    ### Exercise 3.13.17

    ### Exercise 3.13.18

    ### Exercise 3.13.19

    ### Exercise 3.13.20

    ### Exercise 3.13.21

    ### Exercise 3.13.22

    ### Exercise 3.13.23

    ### Exercise 3.13.24

    ### Exercise 3.13.25

    ### Exercise 3.13.26

    ### Exercise 3.13.27

    ### Exercise 3.13.28

    ### Exercise 3.13.29

    ### Exercise 3.13.30

    ### Exercise 3.13.31

    ### Exercise 3.13.32

    ### Exercise 3.13.33

    ### Exercise 3.13.34

    ### Exercise 3.13.35

    ### Exercise 3.13.36

    ### Exercise 3.13.37

    ### Exercise 3.13.38

    ### Exercise 3.13.39

    ### Exercise 3.13.40

    ### Exercise 3.13.41

    ### Exercise 3.13.42

    ### Exercise 3.13.43

    ### Exercise 3.13.44

    ### Exercise 3.13.45

    ### Exercise 3.13.46

    ### Exercise 3.13.47

    ### Exercise 3.13.48

    ### Exercise 3.13.49

    ### Exercise 3.13.50

    ### Exercise 3.13.51

    ### Exercise 3.13.52

    ### Exercise 3.13.53

    ### Exercise 3.13.54

    ### Exercise 3.13.55

    ### Exercise 3.13.56

    ### Exercise 3.13.57

    ### Exercise 3.13.58

    ### Exercise 3.13.59

    ### Exercise 3.13.60

    ### Exercise 3.13.61

    ### Exercise 3.13.62

    ### Exercise 3.13.63

    ### Exercise
- code: |-
    ```
    module s2p_4(clk,data_in,data_out);
    reg [3:0] s2p_count;
    reg s2p_data_in;
    reg s2p_data_out;
    wire s2p_clk;
    wire s2p_data_out;
    clkbuf clkbuf_s2p_2(s2p_clk);
    dsd_s2p s2p_2(s2p_clk, s2p_data_in, s2p_data_out);
    initial s2p_count <= 0;
    always @(posedge clk) begin
    if (s2p_count < 16) s2p_count <= s2p_count + 1;
    else s2p_count <= 0;
    end

    always @(posedge clk) begin
    if (s2p_data_out!= data_out) begin
    $display("Data Out: %b", data_out);
    $display("Data in: %b", s2p_data_in);
    $display("Data Out: %b", s2p_data_out);
    end
    end
    endmodule
    ```
    ---
    ### Test Report:
    #### Input:
    ##### Verilog Source Code:
    ```
    module s2p_2(clk,data_in,data_out);
    reg [3:0] s2p_count;
    reg s2p_data_in;
    reg s2p_data_out;
    wire s2p_clk;
    wire s2p_data_out;
    clkbuf clkbuf_s2p_2(s2p_clk);
    dsd_s2p s2p_2(s2p_clk, s2p_data_in, s2p_data_out);
    initial s2p_count <= 0;
    always @(posedge clk) begin
    if (s2p_count < 16) s2p_count <= s2p_count + 1;
    else s2p_count <= 0;
    end

    always @(posedge clk) begin
    if (s2p_data_out!= data_out) begin
    $display("Data Out: %b", data_out);
    $display("Data in: %b", s2p_data_in);
    $display("Data Out: %b", s2p_data_out);
    end
    end
    endmodule
    ```
    ##### Command:
    `iverilog -o a.out s2p_2.v`
    ##### Output:
    `C:/Users/Aman/AppData/Local/Temp/v/a36e8e002388d8ba70157abde903a785.tmp.v:9: syntax error before "s2p_2"`
    ##### Expected Output:
    `C:/Users/Aman/AppData/Local/Temp/v/a36e8e002388d8ba70157abde903a785.tmp.v:9: syntax error before "s2p_2"`
    ## 6-Bit Arithmetic Logic Unit
    ### Base Verilog Code:
    ```
    module alu(clk,a,b,op,r,res,zr,ng,z,no,p,m,c,zro,zno,zng,cp);
    reg [3:0] state;
    reg zro, zno, zng, zr;
    reg a, b, r;
    reg op;
    reg z;
    reg no, ng;
    reg p, m;
    assign res = r;
    reg c;
    reg [1:0] c_in, c_out;
    initial state = 1'b0;
    always @(posedge clk)
    begin
    if (state == 0)
    case (op)
    3'b000: a <= a;
    3'b001: no <= no;
    3'b010: ng <= ng;
    3'b011: zr <= zr;
    3'b100: p <= p;
    3'b101: m <= m;
    3'b110: z <= z;
    3'b111: c <= c;
    default: $error("Illegal ALU operation\n");
    endcase
    else if (state == 5)
    case (op)
    3'
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En && inside(Ld,{"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010"})) begin
    next_state = S_1;
    Ld_P1 = 1;
    Ld_P0 = 1;
    end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    endcase
    end
    endmodule

    2.3

    ### Base Verilog Code:
    module alu_unit(S_out, S_out1, S_out2, S_out3, S_out4, S_out5, S_out6, S_out7, S_out8,
    S_out9, S_out10, S_out11, S_out12, S_out13, S_out14, S_out15,
    S_out16, S_out17, S_out18, S_out19, S_out20, S_out21, S_out22, S_out23, S_out24,
    S_out25, S_out26, S_out27, S_out28,S_out29,S_out30,S_out31,
    S_out32,S_out33, S_out34, S_out35, S_out36, S_out37, S_out38, S_out39, S_out40,
    S_out41, S_out42, S_out43, S_out44, S_out45, S_out46, S_out47, S_out48, S_out49,
    S_out50, S_out51, S_out52, S_out53, S_out54, S_out55, S_out56, S_out57, S_out58,
    S_out59, S_out60, S_out61, S_out62, S_out63,
    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8,
    Q9, Q10, Q11, Q12, Q13, Q14, Q15,
    Q16, Q17, Q18, Q19, Q20, Q21, Q22, Q23, Q24,
    Q25, Q26, Q27, Q28, Q29, Q30, Q31,
    Q32, Q33, Q34, Q35, Q36, Q37, Q38, Q39, Q40,
    Q41, Q42, Q43, Q44, Q45, Q46, Q47, Q48, Q49,
    Q50, Q51, Q52, Q53, Q54, Q55, Q56, Q57, Q58,
    Q59, Q60, Q61, Q62, Q63,
    op0, op1, op2, op3, op4, op5, op6, op7, op8,
    op9, op10, op11, op12, op13, op14, op15,
    op16, op17, op18, op19, op20, op21, op22, op23, op24,
    op25, op26, op27, op28, op29, op30, op31,
    op32, op33, op34, op35, op36, op37, op38, op39, op40,
    op41, op42, op43, op44, op45, op46, op47, op48, op49,
    op50, op51, op52, op53, op54, op55, op56, op57, op58,
    op59, op60, op61, op62, op63,
    y0, y1, y2, y3, y4, y5, y6, y7, y8,
    y9, y10, y11, y12, y13, y14, y15,
    y16, y17, y18, y19, y20, y21, y22, y23, y24,
    y25, y26, y27, y28, y29, y30, y31,
    y32, y33, y34, y35, y36, y37, y38, y39, y40,
    y41, y42, y43, y44, y45, y46, y47, y48, y49,
    y50, y51, y52, y53, y54, y55, y56, y57, y58,
    y59, y60, y61, y62, y63,

    clock, rst);
    input clock, rst;
    output [63:0] S_out, S_out1, S_out2, S_out3, S_out4, S_out5, S_out6, S_out7, S_out8,
    S_out9, S_out10, S_out11, S_out12, S_out13, S_out14, S_out15,
    S_out16, S_out17, S_out18, S_out19, S_out20, S_out21, S_out22, S_out23, S_out24,
    S_out25, S_out26, S_out27, S_out28, S_out29, S_out30, S_out31,
    S_out32, S_out33, S_out34, S_out35, S_out36, S_out37, S_out38, S_out39, S_out40,
    S_out41, S_out42, S_out43, S_out44, S_out45, S_out46, S_out47, S_out48, S_out49,
    S_out50, S_out51, S_
- code: |-
    module control_unit (out_P0, out_P1, Ld_P1, Ld_P0, flush_P0_P1, Ld_R0, Ld, En, clock, rst);
    input [ 7 : 0] x;
    output [ 7 : 0] out_P0, out_P1;
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En) begin
    next_state = S_1;
    case (x)
    31, 54, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88: out_P1 = 0;
    Out_P0[3:0] = x[3:0];
    out_P0 = 255; Ld_P0 = 1; end
    89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127: out_P1 = 1;
    Out_P0[3:0] = x[3:0];
    out_P0 = 255; Ld_P0 = 1; end
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255: out_P1 = 2;
    Out_P0[3:0] = x[3:0];
    out_P0 = 255; Ld_P0 = 1; end
    192: begin next_state = S_idle; flush_P0_P1 = 1; end
    193: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    194: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    195: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    196: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    197: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    198: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    199: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    200: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    201: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    202: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    203: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    204: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    205: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    206: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    207: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    208: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    209: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    210: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    211: begin next_state = S_wait; Ld_P1 = 1; Ld_P0 = 1; end
    212: begin next_state = S_wait; Ld_P
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    //parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    reg [1: 0] state, next_state;
    reg [5: 0] data;
    reg [3: 0] addr;
    reg [15: 0] index;
    reg [4: 0] i1;
    reg [4: 0] i2;
    reg [4: 0] i3;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) begin state <= S_idle; data <= 0; end
    else begin state <= next_state; data <= data_16; end
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En) begin
    next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else begin flush_P0_P1 = 1; end

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else next_state = S_wait;
    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else next_state = S_wait;
    endcase
    end
    endmodule

    ## 10.4 Bringing it all together

    ### Base Verilog Code:
    module main;
    reg [15: 0] index = 16'h00;
    reg [3: 0] data;
    reg [4: 0] addr;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    reg [2: 0] i0, i1, i2;
    reg [3: 0] i3;
    reg [3: 0] i4;
    reg [4: 0] i5;
    wire [15: 0] data_16, addr_16;
    wire [3: 0] data_4;
    wire [1: 0] state;
    wire [1: 0] next_state;
    wire [2: 0] i0_1, i1_1, i2_1, i3_1, i4_1, i5_1;
    wire [3: 0] data_4_1;
    reg [1: 0] flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    wire [4: 0] i0_P1, i1_P1, i2_P1, i3_P1, i4_P1, i5_P1;
    reg [1: 0] En;
    wire [1: 0] P0, P1, P2;
    wire [1: 0] clk, rst;
    always @ (posedge clk) if (rst) begin state <= S_idle; end
    else begin state <= next_state; end
    wire [1: 0] clk_next;
    always @ (posedge clk) clk_next = clk;
    clk = ~clk;

    wire [1: 0] En_next;
    always @ (posedge clk) begin
    En_next = En;
    En = ~En;
    end

    always @ (posedge clk) begin
    case (state)
    S_idle: begin
    Ld_R0 = 1;
    data_16 = 0;
    addr_16 = 0;
    data_4 = 0;
    i0 = 1;
    i1 = 1;
    i2 = 1;
    i3 = 1;
    i4 = 1;
    i5 = 1;
    i0_P1 = 1;
    i1_P1 = 1;
    i2_P1 = 1;
    i3_P1 = 1;
    i4_P1 = 1;
    i5_P1 = 1;
    i0_1 = 1;
    i1_1 = 1;
    i2_1 = 1;
    i3_1 = 1;
    i4_1 = 1;
    i5_1 = 1;
    data_4_1 = 1;
    flush_P0_P1 = 1;
    Ld_P1 = 1;
    Ld_P0 = 1;
    next_state = S_1;
    if (index < 16'h0100)
    data_4 = data;
    else
    data_4 = data;
    end
    S_1: begin
    data_16 = data;
    addr_16 = addr;
    next_state = S_full;
    data_4_1 = data_4;
    i0 = i0_1;
    i1 = i1_1;
    i2 = i2_1;
    i3 = i3_1;
    i4 = i4_1;
    i5 = i5_1;
    i0_P1 = i0_1;
    i1_P1 = i1_1;
    i2_P1 = i2_1;
    i3_P1 = i3_1;
    i4_P1 = i4_1;
    i5_P1 = i5_1;
    i0_1 = i0_1;
    i1_1 = i1_1;
    i2_1 = i2_1;
    i3_1 = i3_1;
    i4_1 = i4_1;
    i5_1 = i5_1;
    if (index < 16'h0100)
    begin
    data_4 = data;
    if (index < 16'h0010)
    i0 = 16'h00;
    else
    i0 = 16'h00;
    end
    else
    begin
    data_4 = data;
    if (index < 16'h0010)
    i0 = 16'h01;
    else
    i0 = 16'h01;
    end
    end
    if (index < 16'h0200)
    data_4 = data;
    else
    data_4 = data;
    end
    S_full: begin
    next_state = S_wait;
    data_4_1 = data_4;
    i0_1 = i0;
    i1_1 = i1;
    i2_1 = i2;
    i3_1 = i3;
    i4_1 = i4;
    i5_1 = i5;
    i0_P1 = i0_P1;
    i1_P1 = i1_P1;
    i2_P1 = i2_P1;
    i3_P1 = i3_P1;
    i4_P1 = i4_P1;
    i5_P1 = i5_P1;
    i0_1 = i0_1;
    i1_1 = i1_1;
    i2_1 = i2_1;
    i3_1 = i3_1;
    i4_1 = i4_1;
    i5_1 = i5_1;
    if (index < 16'h0200)
- code: |-
    module full_adder_chain(B, B_R, Cin, S, Cout);
    input B, B_R, Cin;
    output S, Cout;

    module full_adder_chain(B, B_R, Cin, S, Cout);

    input B, B_R, Cin;
    output S, Cout;

    ## 4.8 Designing the 4-Bit Binary Decoder

    ### Explanation:
    4-Bit Binary Decoder is designed to input four bits and output four bits. It is an M-type gate with an invert gate. It is used
- code: |-
    module multiplier_4_bit (a, b, product);
    input [3: 0] a, b;
    output [7: 0] product;
    reg [7: 0] sum;
    wire [3: 0] x;
    assign x = a * b;
    always @ (a, b, x) begin
    sum
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_
- code: |-
    module control_unit (clock, rst, Ld, En, flush_P0_P1, Ld_P1, Ld_P0, Ld_R0);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    endcase
    end
    endmodule
    ### Verilog Code:
    module control_unit (clock, rst, Ld, En, flush_P0_P1, Ld_P1, Ld_P0, Ld_R0);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else next_state = S_wait;
    endcase
    end
    endmodule
    ### Variation Instruction:
    For
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    end
    else begin
    case (inside(x, state_table))
    S_idle: next_state = S_idle;
    S_1: next_state = S_1;
    S_full: next_state = S_full;
    S_wait: next_state = S_wait;
    endcase
    end
    endcase
    end
    end

    ### Modified Top Level Code:
    module top_level (clk, adata);
    //...

    clock clk;

    //...

    reg [31: 0] x;
    reg [7: 0] y;
    reg [1: 0] state, next_state;
    reg En;
    wire Ld, Rst;

    //...

    control_unit cu (En, Ld, Rst, clk, clk, state, next_state);
    reg [1: 0] state, next_state;
    reg En;
    wire Ld, Rst;

    //...

    initial $display("state = %b, next_state = %b", state, next_state); x = 10010010010010010010010010010010; #10; // This code is repeated for each test case. while(1) begin #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; #10; clk = ~clk; end endmodule ### Hex-to-7seg Array Declaration: parameter [3: 0] state_table [7: 0] = {S_idle, S_1, S_full, S_wait, S_idle, S_1, S_full, S_wait}; ### Base Verilog Code: module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst); output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0; input Ld, En, clock, rst; reg [1: 0] state, next_state; parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3; always @ (posedge clock) if (rst) state <= S_idle; else state <= next_state; always @ (state, Ld, En) begin flush_P0_P1 = 0; Ld_P1 = 0; Ld_P0 = 0; Ld_R0 = 0; next_state = S_idle; case (state) S_idle: if (En) begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end else flush_P0_P1 = 1; case (state) S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end S_full: if (Ld == 1) begin Ld_R0 = 1; case (En) 0: begin next_state = S_idle; flush_P0_P1 = 1; end 1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end end else next_state = S_wait; S_wait: if (Ld == 1) begin Ld_R0 = 1; case (En) 0: begin next_state = S_idle; flush_P0_P1 = 1; end 1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end end else next_state = S_wait; endcase endendmodule ### Variation Instruction: For the hex-to-7seg decoder, use `inside` to compare `x` against a constant array declared in dollar unit scope. ### Modified Code: module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst); output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0; input Ld, En, clock, rst; reg [1: 0] state, next_state; parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3; always @ (posedge clock) if (rst) state <= S_idle; else state <= next_state; always @ (state, Ld, En) begin flush_P0_P1 = 0; Ld_P1 = 0; Ld_P0 = 0; Ld_R0 = 0; next_state = S_idle; case (state) S_idle: if (En) begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end else flush_P0_P1 = 1; case (state) S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end S_full: if (Ld == 1) begin Ld_R0 = 1; case (En) 0: begin next_state = S_idle; flush_P0_P1 = 1; end 1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end end else begin case (inside(x, state_table)) S_idle: next_state = S_idle; S_1: next_state = S_1; S_full: next_state = S_full; S_wait: next_state = S_wait; end end end endmodule ### Modified Top Level Code: module top_level (clk, adata); //... clock clk; //... //... reg [31: 0] x; reg [7: 0] y; reg [1: 0] state, next_state; reg En; wire Ld, Rst; //... control_unit cu (En, Ld, Rst, clk, clk, state, next_state); reg [1: 0] state, next_state; reg En; wire Ld, Rst; //... initial$display("state = %b, next_state = %b", state, next_state);
    x = 10010010010010010010010010010010;
    #10; // This code is repeated for each test case.
    while(1) begin
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    #10;
    clk = ~clk;
    end
    endmodule
    ### Hex-to-7
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else next_state = S_wait;
    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else next_state = S_wait;
    endcase
    end
    endmodule
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    begin
    int i;
    for (i=0; i<2; i++)
    if (x==const_array[i])
    begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    end
    next_state = S_wait;
    S_wait: if (Ld == 1) begin
    begin
    int i;
    for (i=0; i<2; i++)
    if (x==const_array[i])
    begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    end
    else next_state = S_wait;
    endcase
    end
    endmodule
    Example 2.15.3

    In the last example, we use `if-else` to compare `x` against a constant array declared in dollar unit scope. We also used `case` to compare `x` against the same constant array declared in dollar unit scope. Which one is more efficient?

    The `if-else` version is more efficient because it utilizes the `if-else` structure instead of the `case` structure. The `case` structure is less efficient because both the `case` and `if-else` structures are designed for only one constant comparison. With multiple constant comparisons, the `case` structure is less efficient because it has to traverse through all the cases to find the correct case and then jump to the appropriate code.

    ## 2.2 Assignment Statements

    This section will describe the assignment statements.

    ### 2.2.1 Assignment Statement

    An assignment statement transfers (or passes) the value on the right-hand-side of the assignment operator to the left-hand-side. Assignment statements are of the form:

    `target_signal <operator> source_signal`

    `target_signal` can be any net or variable, and `source_signal` can be any signal or variable. `operator` can be any of the following:

    `=`

    `a = b`

    The assignment operator `=` assigns the value of `b` to `a`.

    `<=`

    `a <= b`

    The assignment operator `<=` assigns the value of `b

.data(data)
	.clock(clock)
	.reset(reset)
	.enable(enable)
	.data_out(data_out)
	.inside_index(inside_index)
	.enable_index(enable_index)
	.inside_bit(inside_bit)
	.enable_bit(enable_bit)
interface
	input clock,reset,enable,inside_index,enable_index,enable_bit,inside_bit,data_out
	output [32*1:0] data
### Generated Code:
```
/*
 * Auto-generated by GiST-S (https://github.com/gi-s-t/g_i_s_t)
 *
 *  - 
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <time.h>
#include <sys/time.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <inttypes.h>

#define MAX_SIZE_DATA 32
#define MAX_SIZE_CLK 1
#define MAX_SIZE_RST 1
#define MAX_SIZE_EN 1
#define MAX_SIZE_I 32
#define MAX_SIZE_ENB 1
#define MAX_SIZE_I_I 1
#define MAX_SIZE_ENB_I 1
#define MAX_SIZE_I_B 1
#define MAX_SIZE_ENB_B 1

#define T_SIZE_DATA 32
#define T_SIZE_CLK 1
#define T_SIZE_RST 1
#define T_SIZE_EN 1
#define T_SIZE_I 32
#define T_SIZE_ENB 1
#define T_SIZE_I_I 1
#define T_SIZE_ENB_I 1
#define T_SIZE_I_B 1
#define T_SIZE_ENB_B 1

#define N_DATA 32
#define N_CLK 1
#define N_RST 1
#define N_EN 1
#define N_I 32
#define N_ENB 1
#define N_I_I 1
#define N_ENB_I 1
#define N_I_B 1
#define N_ENB_B 1

#define T 64
#define K 32

#define MAX_VAL(n) (pow(2,n) - 1)

#define TRUE 1
#define FALSE 0

void print_array(double arr[], int N, FILE *fp) {
    for(int i=0; i<N; ++i){
        fprintf(fp, "%f\n", arr[i]);
    }
}

void print_array(int arr[], int N, FILE *fp) {
    for(int i=0; i<N; ++i){
        fprintf(fp, "%d\n", arr[i]);
    }
}

double** read_array(char* path, int N, int M) {
    double **A = (double**)malloc(N * sizeof(double*));

    for(int i=0; i<N; ++i){
        A[i] = (double*)malloc(M * sizeof(double));
    }

    FILE *fp = fopen(path, "r");

    for(int i=0; i<N; ++i){
        for(int j=0; j<M; ++j){
            fscanf(fp, "%lf\n", &A[i][j]);
        }
    }

    fclose(fp);
    return A;
}

int* read_array_int(char* path, int N) {
    int *A = (int*)malloc(N * sizeof(int));

    FILE *fp = fopen(path, "r");

    for(int i=0; i<N; ++i){
        fscanf(fp, "%d\n", &A[i]);
    }

    fclose(fp);
    return A;
}

int main() {
    char data[T_SIZE_DATA];
    char clk[T_SIZE_CLK];
    char rst[T_SIZE_RST];
    char enable[T_SIZE_EN];
    char inside_index[T_SIZE_I];
    char enable_index[T_SIZE_ENB];
    char inside_bit[T_SIZE_I_B];
    char enable_bit[T_SIZE_ENB_B];
    double data_out[T_SIZE_DATA];

    double **data_double = read_array("data", N_DATA, 32);
    int *clk_int = read_array_int("clk", N_CLK);
    int *rst_int = read_array_int("rst", N_RST);
    int *enable_int = read_array_int("enable", N_EN);
    int *inside_index_int = read_array_int("inside_index", N_I);
    int *enable_index_int = read_array_int("enable_index", N_ENB);
    int *inside_bit_int = read_array_int("inside_bit", N_I_B);
    int *enable_bit_int = read_array_int("enable_bit", N_ENB_B);
    double *data_out_double = read_array("data_out", N_DATA, 32);

    for(int i=0; i<N_DATA; ++i) {
        for(int j=0; j<32; ++j) {
            if(data_double[i][j]) {
                data[j+32*i] = '1';
            } else {
                data[j+32*i] = '0';
            }
        }
    }
    for(int i=0; i<N_CLK; ++i) {
        if(clk_int[i]) {
            clk[i] = '1';
        } else {
            clk[i] = '0';
        }
    }
    for(int i=0; i<N_RST; ++i) {
        if(rst_int[i]) {
            rst[i] = '1';
        } else {
            rst[i] = '0';
        }
    }
    for(int i=0; i<N_EN; ++i) {
        if(enable_int[i]) {
            enable[i] = '1';
        } else {
            enable[i] = '0';
        }
    }
    for(int i=0; i<N_I; ++i) {
        if(inside_index_int[i]) {
            inside_index[i] = '1';
        } else {
            inside_index[i] = '0';
        }
    }
    for(int i=0; i<N_ENB; ++i) {
        if(enable_index_int[i]) {
            enable_index[i] = '1';
        } else {
            enable_index[i] = '0';
        }
    }
    for(int i=0; i<N_I_B; ++i) {
        if(inside_bit_int[i]) {
            inside_bit[i] = '1';
        } else {
            inside_bit[i] = '0';
        }
    }
    for(int i=0; i<N_ENB_B; ++i) {
        if(enable_bit_int[i]) {
            enable_bit[i] = '1';
        } else {
            enable_bit[i] = '0';
        }
    }
    for(int i=0; i<N_DATA; ++i) {
        for(int j=0; j<32; ++j) {
            if(data_out_double[i][j]) {
                data_out[j+32*i] = '1';
            } else {
                data_out[j+32*i] = '0';
            }
        }
    }

    FILE *fp = fopen("modified.v", "w");

    fprintf(fp, "/*\n");
    fprintf(fp, " * Modified by GiST-S (https://github.com/gi-s-t/g_i_s_t)\n");
    fprintf(fp, " *\n");
    fprintf(fp, " *  - \n");
    fprintf(fp, " *\n");
    fprintf(fp, " */\n");
    fprintf(fp, "\n");
    fprintf(fp, "// Include path\n");
    fprintf(fp, "#include \"g_v_g_c.h\"\n");
    fprintf(fp, "\n");
    fprintf(fp, "// Input path\n");
    fprintf(fp, ".clk(clk)\n");
	fprintf(fp,
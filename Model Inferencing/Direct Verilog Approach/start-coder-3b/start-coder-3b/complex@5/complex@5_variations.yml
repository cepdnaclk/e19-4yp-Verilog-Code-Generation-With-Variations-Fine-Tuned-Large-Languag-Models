- code: |-
    ```
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    inside a[0:3] = {3'h1,3'h2,3'h4,3'h8};
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule
    ```
    ### Testing Results:
    ![Or_gate_result](Images\Or_gate_result.png)
    # CSE 321: Systems Design
    Assignments for class of Systems Design (CSE 421) taken at UCSD.

    - [Assignment 1:](https://github.com/shashank-vemuri/systems-design/tree/master/assigr/assignments/Assign6)
    - [Assignment 7:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign7)
    - [Assignment 8:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign8)
    nments/Assign1)
    - [Assignment 2:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign2)
    - [Assignment 3:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign3)
    - [Assignment 4:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign4)
    - [Assignment 5:](https://github.com/shashank-vemuri/systems-design/tree/master/assignments/Assign5)
    - [Assignment 6:](https://github.com/shashank-vemuri/systems-design/tree/maste
- code: "```vhdl\n// Copyright 2012, Google Inc.\n//\n// Licensed under the Apache\
    \ License, Version 2.0 (the \"License\");\n// you may not use this file except\
    \ in compliance with the License.\n// You may obtain a copy of the License at\n\
    //\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required\
    \ by applicable law or agreed to in writing, software\n// distributed under the\
    \ License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS\
    \ OF ANY KIND, either express or implied.\n// See the License for the specific\
    \ language governing permissions and\n// limitations under the License.\n\nmodule\
    \ tst_or_gate();\n    reg[3:0]a;\n\treg [1:0]en;\n\twire b;\n\n    or_gate gg\
    \ (b, a, en);\n\n    initial\n    begin\n        a = {2{0}};\n\ten = 1'b0;\n\t\
    end\n\n    initial $monitor(\"t=%0d, en = %b, a = %h, b = %b\",$time,en,a,b);\n\
    \    initial #30 $stop;\nendmodule\n```\n### Expected Results:\n```log\n-- Testing:\
    \ tst_or_gate\nen = 0b00, a = 0b0000, b = 0\nen = 0b00, a = 0b0001, b = 0\nen\
    \ = 0b00, a = 0b0010, b = 0\nen = 0b00, a = 0b0011, b = 0\nen = 0b00, a = 0b0100,\
    \ b = 0\nen = 0b00, a = 0b0101, b = 0\nen = 0b00, a = 0b0110, b = 0\nen = 0b00,\
    \ a = 0b0111, b = 1\nen = 0b00, a = 0b1000, b = 0\nen = 0b00, a = 0b1001, b =\
    \ 0\nen = 0b00, a = 0b1010, b = 0\nen = 0b00, a = 0b1011, b = 0\nen = 0b00, a\
    \ = 0b1100, b = 0\nen = 0b00, a = 0b1101, b = 0\nen = 0b00, a = 0b1110, b = 0\n\
    en = 0b00, a = 0b1111, b = 1\nen = 0b00, a = 0b0000, b = 0\nen = 0b00, a = 0b0001,\
    \ b = 0\nen = 0b00, a = 0b0010, b = 0\nen = 0b00, a = 0b0011, b = 0\nen = 0b00,\
    \ a = 0b0100, b = 0\nen = 0b00, a = 0b0101, b = 0\nen = 0b00, a = 0b0110, b =\
    \ 0\nen = 0b00, a = 0b0111, b = 1\nen = 0b00, a = 0b1000, b = 0\nen = 0b00, a\
    \ = 0b1001, b = 0\nen = 0b00, a = 0b1010, b = 0\nen = 0b00, a = 0b1011, b = 0\n\
    en = 0b00, a = 0b1100, b = 0\nen = 0b00, a = 0b1101, b = 0\nen = 0b00, a = 0b1110,\
    \ b = 0\nen = 0b00, a = 0b1111, b = 1\nend of test\n```\n.29.31'\n\n[tool.poetry.dev-dependencies]\n\
    pytest = \"^5.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend\
    \ = \"poetry.core.masonry.api\"\n/pyproject.toml\n[tool.poetry]\nname = \"vunit\"\
    \nversion = \"2.0.0\"\ndescription = \"vUnit is a software testbench for Verilog\"\
    \nauthors = [\" <>\",\n           \" <>\",\n           \" <>\"]\nlicense = \"\
    Apache-2.0\"\nrepository = \"https://github.com/vunit/vunit\"\n# Remember to update.github/workflows/release.yml\
    \ when we change this\nkeywords = [\"verilog\"]\nreadme = \"README.md\"\ndocumentation\
    \ = \"https://vunit.github.io\"\n\n[tool.poetry.dependencies]\npython = \">=3.8.0,<3.11\"\
    \nJinja2 = \">=2.11.3\"\nruamel.yaml = \">=0.16.10\"\ncolorama = \">=0.4.1\"\n\
    termcolor = \">=1.1.0\"\n# In vunit-config, we need to use an older version of\
    \ click\n# because of https://github.com/pallets/click/issues/1759\n#\n# Make\
    \ sure you update vunit-config too!\nclick = \">=7.0.0,<7.1.0\"\nclick-log = \"\
    >=0.3.2\"\n# vunit-config uses a custom patched version of pytest\n# that can\
    \ be installed using the pip editable mode:\n#   pip install -e.\npytest = \"\
    >=6.2.3\"\n\n# TODO: use pre-commit hook\npycodestyle = \"^2.5.0\"\npylint = \"\
    ^2.4.4\"\n\n[tool.poetry.group.dev.dependencies]\n# Development tools\nblack =\
    \ \"^23.3.0\"\nflake8 = \"^5.0.4\"\nisort = \"^5.9.3\"\nmypy = \"^1.0.1\"\npydocstyle\
    \ = \"^6.1.1\"\n# Test dependencies\npytest = \"^6.2/doc/sphinx/source/user_manual/testbenches/testcase.rst\n\
    .. _test_case:\n\nTest Cases\n==========\n\nA test case is the entry point for\
    \ a testbench. It is a\ncombination of stimulus and a test specification. The\
    \ test\nspec consists of assertions that are to be checked. The stimulus\nis the\
    \ initial stimulus and is usually generated\nautomatically from the test specification.\n\
    \n.. _test_case_example:\n\nAn example test case with assertions:\n\n.. literalinclude::../../../../examples/test_case/test_case_example.v\n\
    \   :language: verilog\n   :lines: 24-\n\nThe above test case has an initial stimulus\
    \ called ``init_stim`` and\nan assertion called ``init_assert``.\n\n.. note::\n\
    \   The testbench example can be found at\n   ``examples/test_case/test_case_example.v``.\n\
    \n.. _test_spec:\n\nTest Specification\n------------------\n\nA test spec is a\
    \ combination of stimulus and assertions.\n\n.. _test_spec_example:\n\nAn example\
    \ test spec:\n\n.. literalinclude::../../../../examples/test_case/test_spec_example.v\n\
    \   :language: verilog\n   :lines: 24-\n\nThe above test spec has an initial stimulus\
    \ called ``init_stim`` and\nan assertion called ``init_assert``.\n\n**The initial\
    \ stimulus**\n\nThe initial stimulus is a stimulus that is to be generated\nautomatically\
    \ for every test case. The following code shows the\ninitial stimulus for the\
    \ test spec from the test spec example\nabove:\n\n.. literalinclude::../../../../examples/test_case/test_spec_example.v\n\
    \   :language: verilog\n   :lines: 17-28\n   :emphasize-lines: 17-18\n\nThe initial\
    \ stimulus is a single statement, which contains a signal\nassignment statement\
    \ with a function call as its right-hand side.\nThe function call is bound to\
    \ a signal, and is usually called\nsomething like ``init_stim`` as shown in the\
    \ test spec example.\n\n**The assertions**\n\nAssertions are verification statements.\
    \ They are usually\nstatements that check some aspect"
- code: "```\nnand_gate: nand_gate(b,a[3:0],en)\nnand_gate : module nand_gate(output\
    \ b, input[3:0] a, input en);\n#\n```\n### Tested Code:\n```\n# nand_gate: nand_gate(b,a[3:0],en)\n\
    module nand_gate(input[2:0] a, input en);\nreg [3:0] a, b;\nalways @(posedge en)\
    \ begin\nif(en) begin\nb = a;\nend\nend\nendmodule\n```\n#### Testbench:\n```\n\
    module tst_nand_gate();\nreg[3:0]a;\nwire[1] en;\nwire b;\nnand_gate gg(b,a,en);\n\
    initial\nbegin\na = 4'h0; // Initialize input\nen = 1'b0; // Initialize enable\n\
    end\ninitial begin // Stimulus generation\nend\ninitial $monitor (\"t=%0d, en\
    \ = %b, a = %h, b = %b\",$time,en,a,b); // Use %h for hex 'a'\ninitial #30 $stop;\
    \ // Stop simulation\nendmodule\n```\n### Test Results:\n\nThe simulation results\
    \ of the code are:\n\na=0, b=1\n\na=1, b=1\n\na=2, b=1\n\na=3, b=1\n\na=4, b=1\n\
    \n\nAnd the testbench was not shown in the test result, because it is just too\
    \ long.\n\n## Verification\n\n### Test 1:\n\n**Input:**\n\n> 1 bit\n> \n> 0\n\n\
    **Output:**\n\n> 1\n\n### Test 2:\n\n**Input:**\n\n> 1 bit\n> \n> 1\n\n**Output:**\n\
    \n> 1\n\n### Test 3:\n\n**Input:**\n\n> 0 \n> \n> 1\n> \n> 1\n\n**Output:**\n\n\
    > 1\n\n\n\n## Example 7\n\n### Base Verilog Code:\n```\nmodule tst_nor_gate();\n\
    reg[3:0]a;\nreg en;\nwire b;\nnor_gate gg(b,a,en);\ninitial\nbegin\na = 4'h0;\
    \ // Initialize input\nen = 1'b0; // Initialize enable\nend\ninitial begin //\
    \ Stimulus generation\nend\ninitial $monitor(\"t=%0d, en = %b, a = %h, b = %b\"\
    ,$time,en,a,b); // Use %h for hex 'a'\ninitial #30 $stop; // Stop simulation\n\
    endmodule\n```\n### Variation Instruction:\nChange the `en` to a different signal\
    \ with the same type as `a` to test the `inside` check for a variable signal slice\
    \ in a module scope to test array"
- code: |-
    #include "verilated.h"
    #include "Vtst_or_gate.h"
    #include <iostream>
    #include <verilated_vcd_c.h>

    // Or gate
    // Uses Verilator for testing
    // Verilator is a C++ program
    // Input a is an array of 4 bits
    // Input en is a 1 bit
    // Output b is a 1 bit
    // Verilog Code:
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    end
    initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
    initial #30 $stop; // Stop simulation
    endmodule

    // Class of testbench
    class TB_Or_Gate extendstb_uut
    {
    int i;

    // Constructor
    // Instantiate uut
    // Define signal handlers
    TB_Or_Gate(boolean do_verilator)
    {
    uut = new Vtst_or_gate();

    // Define signal handlers
    // Instantiate Verilator if requested
    if(do_verilator){
    uut.trace(trace_file, 99);
    verilator_setup_timestep();
    }

    // Instantiate I/O monitors
    monitor_a = new String("a");
    monitor_en = new String("en");
    monitor_b = new String("b");

    // Reset inputs to 0
    uut.a <= 7'h0;
    uut.en <= 1'b0;

    // Define signal handlers
    monitor_t.

    // Main simulation loop
    for(i=0;i<5;i++){
    // Test input
    uut.en = 1'b1
    }

    }

    // Signal handlers
    public void handler_a(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, a = " + s + " ");
    }

    public void handler_en(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, en = " + s + " ");
    }

    public void handler_b(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, b = " + s + " ");
    }

    public void handler_monitor_t(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, ");
    }

    public void handler_monitor_a(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, a = " + s + " ");
    }

    public void handler_monitor_b(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, b = " + s + " ");
    }

    public void handler_monitor_en(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, en = " + s + " ");
    }
    }

    #### Testbench Execution

    class TB_Or_Gate extendstb_uut
    {
    int i;
    // Constructor
    // Instantiate uut
    // Define signal handlers
    TB_Or_Gate(boolean do_verilator)
    {
    uut = new Vtst_or_gate();
    // Define signal handlers
    // Instantiate Verilator if requested
    if(do_verilator){
    uut.trace(trace_file, 99);
    verilator_setup_timestep();
    }
    // Instantiate I/O monitors
    monitor_a = new String("a");
    monitor_en = new String("en");
    monitor_b = new String("b");
    // Reset inputs to 0
    uut.a <= 7'h0;
    uut.en <= 1'b0;
    // Define signal handlers
    monitor_t = new String("t");
    monitor_a = new String("a");
    monitor_b = new String("b");
    monitor_en = new String("en");
    // Main simulation loop
    for(i=0;i<5;i++){
    // Test input
    uut.en = 1'b1
    }
    }
    // Signal handlers
    public void handler_a(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, a = " + s + " ");
    }
    public void handler_en(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, en = " + s + " ");
    }
    public void handler_b(Object o, Object s){
    // Print to screen
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, b = " + s + " ");
    }
    public void handler_monitor_t(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, ");
    }
    public void handler_monitor_a(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, a = " + s + " ");
    }
    public void handler_monitor_b(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, b = " + s + " ");
    }
    public void handler_monitor_en(Object o, Object s){
    double mtime;
    mtime = System.currentTimeMillis();
    System.out.println("t="+(mtime-start_time)+"ms, en = " + s + " ");
    }
    }

    #### Final Verilog Code:
    module or_gate(
    output b,
    input [3:0] a,
    input en
    );
    begin
    b= (en==1) && (a[3]==1 || a[2]==1 || a[1]==1 || a[0]==1) || (en==1) && a[3]==1 && (a[2]==0 || a[1]==0 || a[0]==0) ;
    end
    endmodule

    #### Final C++ Code:
    class Or_gate extends Component
    {
    // Outputs
    Bit b;
    // Inputs
    Bit a[4];
    Bit en; // Enable

    // Constructor
    Or_gate()
    {
    // Inputs
    add_port("a",a);
    // Output
    add_port("b",b);

    // Inside check for a in range list
    for(int i=0;i<4;i++){
    if(a[i]==1){
    // Check for a[i] == 1
    add_check("a[i] == 1",a[i] == 1);
    }
    }
    }
    }

    #### Final Testbench Code:
    class TB_Or_Gate extendstb_uut
    {
    int i;

    // Constructor
    // Instantiate uut
    // Define signal handlers
    TB_Or_Gate(boolean do_verilator)
    {
    uut = new Or_gate();

    }
    }
- code: |-
    For the array `a` defined in the `tst_or_gate.v` module, the modified code is:
    ```
    module tst_or_gate();
    reg[3:0]a;
    reg en;
    wire b;
    or_gate gg(b,a,en);
    initial
    begin
    a = 4'h0; // Initialize input
    en = 1'b0; // Initialize enable
    end
    initial begin // Stimulus generation
    a = 0;
    end
    initial #30 $stop; // Stop simulation
    endmodule
    ```
    ### Command:
    `make testbench_or_gate_with_array_slice_with_range_list`
    ### Result:
    ```
    testbench_or_gate_with_array_slice_with_range_list:
      module tst_or_gate_mod(
        output b,
        input [3:0] a,
        input en
      );

    ```
    ### Testbench Code:
    ```
    module tst_or_gate_mod(
      output b,
      input [3:0] a,
      input en
    );

      initial
        begin
          a = 4'h0; // Initialize input
          en = 1'b0; // Initialize enable
        end
      initial #30 $stop; // Stop simulation
    endmodule
    ```
    ### Result:
    ```
    testbench_or_gate_with_array_slice_with_range_list:
      module tst_or_gate_mod(
        output b,
        input [3:0] a,
        input en
      );

    The testbench design has a delay in the path from a to b.
    Initial value of b is 4'h10.
    ```
    ### Command:
    `make testbench_or_gate_with_array_slice_with_range_list_inside`
    ### Result:
    ```
    testbench_or_gate_with_array_slice_with_range_list_inside:
      module tst_or_gate_mod(
        output b,
        input [3:0] a,
        input en
      );

    ```
    ### Testbench Code:
    ```
    module tst_or_gate_mod(
      output b,
      input [3:0] a,
      input en
    );
      initial
        begin
          a = 4'h0; // Initialize input
          en = 1'b0; // Initialize enable
        end
      initial begin // Stimulus generation
        if(a[2:0] == 3'h0) begin
          a = 4'h5;
        end
        else if(a[2:0]==3'h1) begin
          a = 4'h6;
        end
        else if(a[2:0]==3'h2) begin
          a = 4'h7;
        end
        else if(a[2:0]==3'h3) begin
          a = 4'h8;
        end
        else if(a[2:0]==3'h4) begin
          a = 4'h9;
        end
      end
      initial $monitor("t=%0d, en = %b, a = %h, b = %b",$time,en,a,b); // Use %h for hex 'a'
      initial #30 $stop; // Stop simulation
    endmodule
    ```
    ### Result:
    ```
    testbench_or_gate_with_array_slice_with_range_list_inside:
      module tst_or_gate_mod(
        output b,
        input [3:0] a,
        input en
      );

    The testbench design has a delay in the path from a to b.
    Initial value of b is 4'h10.
    ```
    ### Testing with VCS:
    `make testbench_or_gate_with_array_slice_with_range_list_with_vcs`
    # test_mem_with_3bit_address_and_16_bit_data_width
    ### Variation Instruction:
    Add a parameter `NUM_ADDR_BITS` of type `integer` to the module `mem`. Set the value of this parameter to 3.
    ### Command:
    `make testbench_mem_with_3bit_address_and_16_bit_data_width`
    ### Result:
    ```
    testbench_mem_with_3bit_address_and_16_bit_data_width:
      module tst_mem_mod(
        output wire [15:0] b,
        input wire [3:0] addr,
        input wire [15:0] data_in,
        input wire data_we,
        input wire addr_we,
        input wire clk
      );

    Testbench design 'tst_mem_mod' doesn't have any delay in its path from clk to b.
    ```
    ### Testbench Code:
    ```
    module tst_mem_mod(
      output wire [15:0] b,
      input wire [3:0] addr,
      input wire [15:0] data_in,
      input wire data_we,
      input wire addr_we,
      input wire clk
    );
      always begin
        #6 b = data_in;
      end
      initial begin
        b = 16'h0;
      end
    endmodule
    ```
    ### Command:
    `make testbench_mem_with_3bit_address_and_16_bit_data_width_with_vcs`
    # test_mem
    ### Variation Instruction:
    Add a parameter `DATA_WIDTH` of type `integer` to the module `mem`. Set the value of this parameter to 16.
    ### Command:
    `make testbench_mem`
    ### Result:
    ```
    testbench_mem:
      module tst_mem_mod(
        output wire [15:0] b,
        input wire [3:0] addr,
        input wire [15:0] data_in,
        input wire data_we,
        input wire addr_we,
        input wire clk
      );

    ```
    ### Testbench Code:
    ```
    module tst_mem_mod(
      output wire [15:0] b,
      input wire [3:0] addr,
      input wire [15:0] data_in,
      input wire data_we,
      input wire addr_we,
      input wire clk
    );
      always begin
        #6 b = data_in;
      end
      initial begin
        b = 16'h0;
      end
    endmodule
    ```
    ### Command:
    `make testbench_mem_with_16_bit_data_width`
    ### Result:
    ```
    testbench_mem_with_16_bit_data_width:
      module tst_mem_mod(
        output wire [15:0] b,
        input wire [3:0] addr,
        input wire [15:0] data_in,
        input wire data_we,
        input wire addr_we,
        input wire clk
      );

    Testbench design 'tst_mem_mod' has a delay in the path from clk to b.
    ```
    ### Testbench Code:
    ```
    module tst_mem_mod(
      output wire [15:0] b,
      input wire [3:0] addr,
      input wire [15:0] data_in,
      input wire data_we,
      input wire addr_we,
      input wire clk
    );
      always begin
        #6 b = data_in;
      end
      initial begin
        b = 16'h0;
      end
    endmodule
    ```
    ### Command:
    `make testbench_mem_with_16_bit_data_width_with_vcs`
    # test_rstn_gate
    ### Variation Instruction:
    Add a parameter `RST_CTRL` of type `integer` to the module `rstn_gate`. Set this parameter to `2`.
    ### Command:
    `make testbench_rstn_gate`
    ### Result:
    ```
    testbench_rstn_gate:
      module tst_rstn_gate_mod(
        output b,
        input a,
        input enable,
        input rstn
      );

    ```
    ### Testbench Code:
    ```
    module tst_rstn_gate_mod(
      output b,
      input a,
      input enable,
      input rstn
    );
      initial
      begin
        b = 1'b0;
      end
    endmodule
    ```
    ### Command:
    `make testbench_rstn_gate_with_2_enables`
    ### Result:
    ```
    testbench_rstn_gate_with_2_enables:
      module tst_rstn_gate_mod(
        output b,
        input a,
        input enable,
        input rstn
      );

    Testbench design 'tst_rstn_gate_mod' doesn't have any delay in its path from a to b.
    ```
    ### Testbench Code:
    ```
    module tst_rstn_gate_mod(
      output b,
      input a,
      input enable,
      input rstn
    );
      initial
      begin
        b = 1'b0;
      end
    endmodule
    ```
    ### Command
- code: |-
    ```verilog
    module tst_nor3NMOS();
      reg [1:0] in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ### Expected Verilog Code:
    module tst_nor3NMOS();
      reg [1:0] gen_block1_in1,gen_block1_in2,gen_block1_in3; wire gen_block1_b;
      nor3NMOS nn(gen_block1_in1,gen_block1_in2,gen_block1_in3,gen_block1_b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        gen_block1_in1=1'b0; gen_block1_in2=1'b0; gen_block1_in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 gen_block1_in1=~gen_block1_in1;
    ...
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",gen_block1_in1,gen_block1_in2,gen_block1_in3,gen_block1_b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmoduleusername_0: I can generate the code as you described in the issue. Should I close this issue?username_1: This issue was moved to LemurProject/org-code#15
- code: |-
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      generate
        \gen_block1 : nor3NMOS nn[3](in1,in2,in3,b) when (in1==1'b0)
      endgenerate // \gen_block1 : nor3NMOS nn[3](in1,in2,in3,b) when (in1==1'b0)
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0;
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b);
      initial #24 $stop; // Stop simulation
    endmodule
    ```
    ### Simulation Results:
    ![Simulation Results](https://github.com/VioletRose/Verilog-Code-Snippet/raw/master/Pictures/Simulation/Verilog%2020
- code: "module tst_nor3NMOS();\n  reg in1,in2,in3; wire b;\n\n  // Instantiate NMOS\
    \ NOR\n  nor3NMOS nn1(in1,in2,in3,b); \n  // Instantiate 3-input NOR\n  nor3NMOS\
    \ nn2(in1,in2,in3,b); \n  // Instantiate DMOS NOR\n  nor3NMOS nn3(in1,in2,in3,b);\
    \ \n\n  initial #24 $stop; // Stop simulation\nendmodule\n### Error Message:\n\
    `Error: (verilog-l-test-error) test-error.v:9: syntax error, unexpected '(', expecting\
    \ )`\n\n### Comment:\nThis is caused by the same reason as Case 10.\n\n### Solution:\n\
    1. Move the `initial` block outside of `tst_nor3NMOS` (inside the `generate` block)\
    \ to see the error message.\n2. Use the [inside](https://docs.verilog-lang.org/spec/1800_2017/IEEE_1800-2017.html#7_3_1_Inside_operator)\
    \ operator (e.g., `in1, in2, in3)\n3. Remove `initial` block from `tst_nor3NMOS`\
    \ module (inside the `generate` block) to see the error message.\n\n## Test Case\
    \ - 13\n### Base Verilog Code:\nmodule tst_nor3NMOS();\n  reg in1,in2,in3; wire\
    \ b;\n  nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR\n  initial begin //\
    \ Initialize inputs\n    in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1\n\
    \  end\n  // Toggle inputs at different rates"
- code: |-
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      generate
        always #2 in1=~in1;
        always #3 in2=~in2;
        always #5 in3=~in3;
      endgenerate
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ### Result:
    ![](https://raw.githubusercontent.com/nandoabreu/pic_trans/master/pic_verilog/testbench_nor3_NMOS.png)
    ### Modified Verilog Code:
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      initial begin
        start_time: begin  // Generate the toggles (comment this line to use the same toggles for different modules)
          genvar i;
          generate
            for (i = 1; i <= 32; i = i + 4) begin
              // Toggle the inputs, at different rates
              assign in1 = i == 1? ~in1 : in1;
              assign in2 = i == 4? ~in2 : in2;
              assign in3 = i == 8? ~in3 : in3;
            end
          endgenerate
        end : stop_time; // Stop the simulation
      end
    endmodule
    ### Result:
    ![](https://raw.githubusercontent.com/nandoabreu/pic_trans/master/pic_verilog/testbench_nor3_NMOS_gen.png)
    [comment]: <> (https://github.com/nandoabreu/pic_trans/blob/master/pic_verilog/testbench_nor3_NMOS_gen.png)
    ### Discussion:
    The first image shows the modified behavioral NOR gate. The second image shows the same behavioral NOR gate, but with a different set of toggles. As we can see, the second image has a different set of toggles, which makes the testbench the same. The problem is that the same set of toggles is being used across different modules. This is a bad practice and should never be done. The correct way to do this is to generate the toggles inside the testbench.
    /pic_verilog/testbench_nor3_NMOS_gen.md
    ## Testbench Behavioral NOR Gate with 3 NMOS inputs and one NMOS output

    ## Base Verilog Code:
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      always #2 in1=~in1;
      always #3 in2=~in2;
      always #5 in3=~in3;
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ```
    ## Variation Instruction:
    Insert a `generate` block with an escaped name (e.g., \gen_block1 ) and use `inside` operator with constant index in a behavioral NOR gate.
    ## Modified Code:
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      generate
        always #2 in1=~in1;
        always #3 in2=~in2;
        always #5 in3=~in3;
      endgenerate
      initial $monitor($time, "in1 = %b, in2 = %b, in3 = %b, output = %b ",in1,in2,in3,b); // Removed newline
      initial #24 $stop; // Stop simulation
    endmodule
    ```
    # Modified Verilog Code:
    ```
    module tst_nor3NMOS();
      reg in1,in2,in3; wire b;
      nor3NMOS nn(in1,in2,in3,b); // Instantiate NMOS NOR
      initial begin // Initialize inputs
        in1=1'b0; in2=1'b0; in3=1'b0; // Corrected: was 1'b1
      end
      // Toggle inputs at different rates
      initial begin
        start_time: begin  // Generate the toggles (comment this line to use the same toggles for different modules)
          genvar i;
          generate
            for (i = 1; i <= 32; i = i + 4) begin
              // Toggle the inputs, at different rates
              assign in1 = i == 1? ~in1 : in1;
              assign in2 = i == 4? ~in2 : in2;
              assign in3 = i == 8? ~in3 : in3;
            end
          endgenerate
        end : stop_time; // Stop the simulation
      end
    endmodule
    ```
    # Result:
    <img src="https://raw.githubusercontent.com/nandoabreu/pic_trans/master/pic_verilog/testbench_nor3_NMOS.png"/>
    <img src="https://raw.githubusercontent.com/nandoabreu/pic_trans/master/pic_verilog/testbench_nor3_NMOS_gen.png"/>
    # Discussion:
    The first image shows the modified behavioral NOR gate. The second image shows the same behavioral NOR gate, but with a different set of toggles. As we can see, the second image has a different set of toggles, which makes the testbench the same. The problem is that the same set of toggles is being used across different modules. This is a bad practice and should never be done. The correct way to do this is to generate the toggles inside the testbench.

    This method works for any number of inputs, the only thing that changes is the number of inputs in the initial code and the number of inputs in the generate block.

    <img src="pic_verilog/generate_genvar_for_3_inputs.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_2.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_3.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_4.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_5.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_6.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_7.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_8.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_9.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_10.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_11.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_12.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_13.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_14.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_15.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_16.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_17.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_18.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_19.png"/>
    <img src="pic_verilog/generate_genvar_for_3_inputs_20.png"/>
    <
- code: |-
    module `tst_seq_ff`();
      reg ff_s_i;
      reg ff_s_q;
      reg ff_s_d;
      `gen_block1` seq_ff sff(ff_s_i,ff_s_d,ff_s_q) inside {
        // Nor gate implementation inside block.
        always@(posedge ff_s_i) begin
          ff_s_q <= ff_s_i;
        end
        assign ff_s_d = ff_s_q ^ ff_s_i;
      }
    endmodule
    ### Results:
    ```
    # 1. 000000000000000000000000 # 2. 01000000000000000000000000000000000000000000000000000000000000000 # 3. 01010000000000000000000000000000000000000000000000000000000000000 # 4. 010110000000000000000000000000000000000000000000000000000000
- code: |-
    ```
    initial begin: Apply_Data
    generate
    for (indx=0; indx<8
- code: "module test_multiplier;\nreg clk=0, start, error; // Added clk initialization\n\
    wire [7:0] databus;\nwire lsb_out, msb_out, done;\nreg [7:0] mem1[0:2], mem2[0:2];\
    \ // Memory for operands\nreg [7:0] im_data; // Data to drive onto bus\nreg [7:0]\
    \ opnd1, opnd2; // Operands\nreg [15:0] expected_result, multiplier_result; //\
    \ Results\ninteger indx; // Loop index\n// Instantiate the Multiplier Unit Under\
    \ Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out, done );\n// ---\
    \ Placeholder blocks referenced by Figure numbers ---\ninitial begin: Apply_Data\
    \ /*... Figure 8.11... */ end\ninitial begin: Apply_Start /*... Figure 8.12...\
    \ */ end\ninitial begin: Expected_Result /*... Figure 8.13... */ end\nalways @(posedge\
    \ clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\nalways @(posedge clk)\n\
    begin: Compare_Results /*... Figure 8.15... */ end\n// --- Clock generation ---\n\
    always #50 clk = ~clk;\n// --- Data bus driving ---\nassign databus = im_data;\
    \ // Drive internal data onto bus\nendmodule\n### Expected Code:\nmodule test_multiplier;\n\
    reg clk=0, start, error;\nwire [7:0] databus;\nwire lsb_out, msb_out, done;\n\
    reg [7:0] mem1[0:2], mem2[0:2];\nreg [7:0] im_data, opnd1, opnd2;\nreg [15:0]\
    \ expected_result, multiplier_result;\ninteger indx;\n// Instantiate the Multiplier\
    \ Unit Under Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out, done\
    \ );\n// --- Placeholder blocks referenced by Figure numbers ---\ninitial begin:\
    \ Apply_Data /*... Figure 8.11... */ end\ninitial begin: Apply_Start /*... Figure\
    \ 8.12... */ end\ninitial begin: Expected_Result /*... Figure 8.13... */ end\n\
    always @(posedge clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\nalways\
    \ @(posedge clk)\nbegin: Compare_Results /*... Figure 8.15... */ end\n// --- Clock\
    \ generation ---\nalways #50 clk = ~clk;\n// --- Data bus driving ---\nassign\
    \ databus = im_data; // Drive internal data onto bus\nendmodule\n### Variation\
    \ Source:\nmodule Multiplier (\ninput [7:0] \tclk,\ninput \tstart,\noutput [7:0]\
    \ \tdatabus,\noutput \tlsb_out,\noutput\tmsb_out,\noutput \tdone\n);\n// --- Module\
    \ constants ---\nreg [15:0] OPR_MULT = 0x0000;\nreg [15:0] OPR_ONE  = 0x0001;\n\
    reg [15:0] OPR_ZERO = 0x0000;\nreg [15:0] RESULT = 0x0000; // Result of multiply\n\
    // --- Module state variables ---\nreg [15:0] \tleft_arg, right_arg; // Operands\n\
    reg [15:0] \tcurr_left, curr_right; // Current operands\nreg [15:0] \tcurr_result,\
    \ curr_next; // Result and next result\n// --- Module signals ---\n// Control\
    \ signals\nreg \tin_mult, in_one, in_zero, out_mult, out_one, out_zero, next_done;\n\
    reg \top1_done, op2_done;\n// Data signals\nwire \top1_ready, op2_ready, next_ready,\
    \ next_done, out_mult, out_one, out_zero;\n// --- Module ports ---\ninput \tdone;\n\
    // --- Module block design ---\nalways @(posedge clk, posedge start)\nbegin\n\
    // --- Initialize ---\nin_mult \t<= 0;\nin_one \t<= 0;\nin_zero \t<= 0;\nop1_done\
    \ \t<= 0;\nop2_done \t<= 0;\n// --- Process start condition ---\nif (start ==\
    \ 1) begin\n\t// Reset the data bus\n\tdatabus \t<= 0;\n\t// Reset the result\n\
    \tRESULT \t<= 0;\n\t// Start the multiplier\n\tin_mult \t<= 1;\n\t// Indicate\
    \ this is the first of two arguments\n\top1_done \t<= 1;\nend\n// --- Process\
    \ the multiply logic ---\nelse if (in_mult == 1) begin\n\t// Indicate this is\
    \ the second of two arguments\n\top2_done \t<= 1;\n\tif (op2_done && op1_done)\
    \ begin\n\t\t// Compute the result\n\t\tcurr_result \t<= curr_left * curr_right;\n\
    \t\t// Update the result\n\t\tRESULT \t\t<= curr_result;\n\t\t// Reset the operand\
    \ to be ready for the next cycle\n\t\tcurr_left \t<= 0;\n\t\tcurr_right \t<= 0;\n\
    \t\t// Signal the multiply is complete\n\t\tout_mult \t<= 1;\n\t\tout_one \t<=\
    \ 0;\n\t\tout_zero \t<= 0;\n\t\t// Wait for the next cycle\n\t\tnext_done \t<=\
    \ 1;\n\t\t// Flag that the multiply is complete\n\t\tin_mult \t<= 0;\n\t\t// Indicate\
    \ that the multiply is complete\n\t\tdone \t\t<= 1;\n\tend\nend\n// --- Process\
    \ the one logic ---\nelse if (in_one == 1) begin\n\t// Reset the operand to be\
    \ ready for the next cycle\n\tcurr_right \t<= 0;\n\t// Update the count to be\
    \ ready for the next cycle\n\tcurr_right \t<= OPR_ONE;\n\t// Signal that the one\
    \ is complete\n\tout_mult \t<= 0;\n\tout_one \t<= 1;\n\tout_zero \t<= 0;\n\t//\
    \ Flag that the one is complete\n\tin_one \t<= 0;\nend\n// --- Process the zero\
    \ logic ---\nelse if (in_zero == 1) begin\n\t// Reset the operand to be ready\
    \ for the next cycle\n\tcurr_right \t<= 0;\n\t// Update the count to be ready\
    \ for the next cycle\n\tcurr_right \t<= OPR_ZERO;\n\t// Signal that the zero is\
    \ complete\n\tout_mult \t<= 0;\n\tout_one \t<= 0;\n\tout_zero \t<= 1;\n\t// Flag\
    \ that the zero is complete\n\tin_zero \t<= 0;\nend\n// --- Update the inputs\
    \ (1) ---\nelse begin\n\t// Set the next argument\n\tcurr_left \t\t<= left_arg;\n\
    \t// Update the count to be ready for the next cycle\n\tcurr_right \t<= right_arg;\n\
    \t// Signal that the operand is ready\n\top1_ready \t\t<= 1;\n\top2_ready \t\t\
    <= 1;\n\t// Set the next done flag\n\tnext_done \t\t<= next_done;\nend\n// ---\
    \ Update the inputs (2) ---\nelse if (next_ready == 1) begin\n\t// Set the next\
    \ argument\n\tcurr_left \t\t<= left_arg;\n\t// Update the count to be ready for\
    \ the next cycle\n\tcurr_right \t<= right_arg;\n\t// Signal that the operand is\
    \ ready\n\top1_ready \t\t<= 1;\n\top2_ready \t\t<= 1;\n\t// Flag that the next\
    \ done flag is ready\n\tnext_ready \t\t<= 1;\n\t// Reset the next done flag\n\t\
    next_done \t\t<= 0;\nend\n// --- Update the inputs (3) ---\nelse begin\n\t// Set\
    \ the next argument\n\tcurr_left \t\t<= left_arg;\n\t// Update the count to be\
    \ ready for the next cycle\n\tcurr_right \t<= right_arg;\n\t// Signal that the\
    \ operand is ready\n\top1_ready \t\t<= 1;\n\top2_ready \t\t<= 1;\n\t// Set the\
    \ next done flag\n\tnext_done \t\t<= next_done;\nend\n// --- Data bus outputs\
    \ ---\nassign databus \t= RESULT;\nassign lsb_out \t= out_mult;\nassign msb_out\
    \ \t= out_one;\nassign done \t\t= done;\nendmodule\n# 1 \"test_multiplier.sv\"\
    \n#"
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_out, done;
    reg [7:0] mem1[0:2], mem2[0:2]; // Memory for operands
    reg [7:0] im_data; // Data to drive onto bus
    reg [7:0] opnd1, opnd2; // Operands
    reg [15:0] expected_result, multiplier_result; // Results
    integer indx; // Loop index
    // Instantiate the Multiplier Unit Under Test
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );
    // --- Placeholder blocks referenced by Figure numbers ---
    initial begin
    // Placeholder for Apply_Data
    // Initialize operands and memory
    // mem1[0] = 1, opnd1 = 1
    mem1[0] = 1;
    opnd1 = 1;
    // mem1[1] = 10000, opnd2 = 10000
    mem1[1] = 10000;
    opnd2 = 10000;
    // mem1[2] = 11000, expected_result = 11000
    mem1[2] = 11000;
    expected_result = 11000;
    end
    initial begin : Apply_Start
    // Enable multiplier
    start = 1'b1;
    end
    initial begin: Expected_Result
    // Multiply operands to find expected result
    multiplier_result = opnd1 * opnd2;
    end
    always @(posedge clk) begin: Actual_Result
    // Multiply operands from memory to find actual result
    multiplier_result = 0;
    // Check the three memory locations
    for(indx=0; indx<3; indx=indx+1) begin
    multiplier_result = multiplier_result + mem1[indx]
    * mem1[indx];
    end
    end
    always @(posedge clk) begin: Compare_Results
    // Find difference between actual and expected results
    difference = multiplier_result - expected_result;
    // Signal error if difference is 0
    error = (difference == 1'b0);
    end
    // --- Clock generation ---
    always #50 clk = ~clk;
    // --- Data bus driving ---
    assign databus = im_data; // Drive internal data onto bus
    endmodule
    ### Simulation Results:
    Figure 8.20. Test of Memory Data Array with Generate-Block
    The test passes when the `error` signal is low.

    This module is a variation of the module created in the previous exercise.

    ### Code
    ```
    module test_multiplier;
    /*
     * File: test_multiplier.sv
     * Description: Test a Multiplier module using a MDA array.
     * Last modified: 02/07/2023
     */

    // Module Instantiation
    Multiplier uut ( clk, start, databus, lsb_out, msb_out, done );

    // Verilog initial blocks
    initial begin
      // Placeholder for Apply_Data
      // Initialize operands and memory
      // mem1[0] = 1, opnd1 = 1
      mem1[0] = 1;
      opnd1 = 1;
      // mem1[1] = 10000, opnd2 = 10000
      mem1[1] = 10000;
      opnd2 = 10000;
      // mem1[2] = 11000, expected_result = 11000
      mem1[2] = 11000;
      expected_result = 11000;
    end
    initial begin : Apply_Start
      // Enable multiplier
      start = 1'b1;
    end
    initial begin: Expected_Result
      // Multiply operands to find expected result
      multiplier_result = opnd1 * opnd2;
    end
    always @(posedge clk) begin: Actual_Result
      // Multiply operands from memory to find actual result
      multiplier_result = 0;
      // Check the three memory locations
      for(indx=0; indx<3; indx=indx+1) begin
        multiplier_result = multiplier_result + mem1[indx] * mem1[indx];
      end
    end
    always @(posedge clk) begin: Compare_Results
      // Find difference between actual and expected results
      difference = multiplier_result - expected_result;
      // Signal error if difference is 0
      error = (difference == 1'b0);
    end

    // Clock generation
    always #50 clk = ~clk;

    // Data bus driving
    assign databus = im_data;

    endmodule
    ```

    ### Code
    ```
    module test_multiplier;
    /*
     * File: test_multiplier.sv
     * Description: Test a Multiplier module using a MDA array.
     * Last modified: 02/07/2023
     */
- code: "module test_multiplier;\nreg clk=0, start, error;\nwire [7:0] databus;\n\
    wire lsb_out, msb_out, done;\nreg [7:0] mem1[0:2], mem2[0:2];\nreg [7:0] im_data;\n\
    reg [7:0] opnd1, opnd2;\nreg [15:0] expected_result, multiplier_result;\ninteger\
    \ indx;\n// Instantiate the Multiplier Unit Under Test\nMultiplier uut ( clk,\
    \ start, databus, lsb_out, msb_out, done );\n// --- Placeholder blocks referenced\
    \ by Figure numbers ---\ninitial begin: Apply_Data /*... Figure 8.11... */ end\n\
    initial begin: Apply_Start /*... Figure 8.12... */ end\ninitial begin: Expected_Result\
    \ /*... Figure 8.13... */ end\nalways @(posedge clk)\nbegin: Actual_Result /*...\
    \ Figure 8.14... */ end\nalways @(posedge clk)\nbegin: Compare_Results /*... Figure\
    \ 8.15... */ end\n// --- Clock generation ---\nalways #50 clk = ~clk;\n// ---\
    \ Data bus driving ---\nassign databus = im_data; // Drive internal data onto\
    \ bus\nendmodule\n### Code Analysis:\nThe Verilog Testbench code has been modified\
    \ as below. The code of the modified testbench module is given below.\n\n- A new\
    \ `inside` operator is applied to the MDA array and a loop is modified to use\
    \ the `inside` operator.\n- The two `initial` blocks are modified to assign the\
    \ arrays `mem1` and `mem2`.\n\n### Verilog Code:\nmodule test_multiplier;\nreg\
    \ clk=0, start, error;\nwire [7:0] databus;\nwire lsb_out, msb_out, done;\nreg\
    \ [7:0] mem1[0:2], mem2[0:2];\nreg [7:0] im_data;\nreg [7:0] opnd1, opnd2;\nreg\
    \ [15:0] expected_result, multiplier_result;\ninteger indx;\n// Instantiate the\
    \ Multiplier Unit Under Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out,\
    \ done );\n// --- Placeholder blocks referenced by Figure numbers ---\ninitial\
    \ begin: Apply_Data /*... Figure 8.11... */ end\ninitial begin: Apply_Start /*...\
    \ Figure 8.12... */ end\ninitial begin: Expected_Result /*... Figure 8.13... */\
    \ end\nalways @(posedge clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\n\
    always @(posedge clk)\nbegin: Compare_Results /*... Figure 8.15... */ end\n//\
    \ --- Clock generation ---\nalways #50 clk = ~clk;\n// --- Data bus driving ---\n\
    assign databus = im_data; // Drive internal data onto bus\nendmodule \n## Verilog/SystemVerilog\
    \ Code of the Testbench:\n```\nmodule test_multiplier;\n\nreg clk = 0, start,\
    \ error;\n\nwire [7:0] databus;\nwire lsb_out, msb_out, done;\n\nreg [7:0] mem1[0:2],\
    \ mem2[0:2];\n\nreg [7:0] im_data;\n\nreg [7:0] opnd1, opnd2;\n\nreg [15:0] expected_result,\
    \ multiplier_result;\n\ninteger indx;\n\n// Instantiate the Multiplier Unit Under\
    \ Test\nMultiplier uut (clk, start, databus, lsb_out, msb_out, done);\n\n// ---\
    \ Placeholder blocks referenced by Figure numbers ---\n\ninitial begin: Apply_Data\
    \ /*... Figure 8.11... */ end\n\ninitial begin: Apply_Start /*... Figure 8.12...\
    \ */ end\n\ninitial begin: Expected_Result /*... Figure 8.13... */ end\n\nalways\
    \ @(posedge clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\n\nalways @(posedge\
    \ clk)\nbegin: Compare_Results /*... Figure 8.15... */ end\n\n// --- Clock generation\
    \ ---\n\nalways #50 clk = ~clk;\n\n// --- Data bus driving ---\n\nassign databus\
    \ = im_data; // Drive internal data onto bus\n\nendmodule\n```\n\n## Testbench\
    \ Simulation:\n\n### Simulation Results:\n\n### Simulation with `inside` operator:\n\
    ![](img/Simulation_Figure.png)\n### Simulation without `inside` operator:\n![](img/Simulation_Figure_without_operator.png)\n\
    \n## Testbench Results:\n\n### Testbench Pass/Fail:\n\n![](img/Result_Figure.png)\n\
    \n## Error Analysis:\n\n### Test Result:\n\n![](img/Error_Figure.png)\n\n### Error\
    \ Analysis:\n\n### Error Analysis Results:\n\n![](img/Error_Analysis.png)\n\n\
    ## SystemVerilog Code of the Design:\n```\n`timescale 1ns / 1ps\n\nmodule Multiplier(\n\
    \n     input  wire clk,   // Clock input\n\n     input  wire start, // Start button\n\
    \n     input  wire [7:0] data_in, // Data input\n\n     output wire [7:0] data_out,\
    \ // Data output\n\n     output reg [7:0] lsb,      // Leftmost significant bit\n\
    \n     output reg [7:0] msb       // Most significant bit\n\n   );\n\nreg [7:0]\
    \ mul_result;\n\nwire [7:0] left_shift_data = {lsb, data_out}; // Left shift data\n\
    \nwire [7:0] right_shift_data = {data_out[7:1], msb}; // Right Shift data\n\n\
    assign data_out = (start)? data_in : mul_result; // Data output\n\nalways @(posedge\
    \ clk or negedge start)    // Multiply data with itself\n\n   begin\n\n     mul_result\
    \ = data_in * data_in;\n\n   end\n\nalways @(posedge clk) begin: left_shift\n\n\
    \    lsb <= mul_result[7]; // Left most significant bit\n\n    assign data_out\
    \ = left_shift_data; // Update data_out with left shift data\n\n  end\n\nalways\
    \ @(posedge clk) begin: right_shift\n\nmsb <= mul_result[8];  // Most significant\
    \ bit\n\nassign data_out = right_shift_data; // Update data_out with right shift\
    \ data\n\nend\n\nendmodule\n\n```\n\n## SystemVerilog Code of the Testbench:\n\
    ```\n`timescale 1ns / 1ps\n\nmodule test_multiplier;\n\nreg clk = 0, start;\n\n\
    wire [7:0] databus;\n\nwire lsb_out, msb_out, done;\n\nreg [7:0] mem1[0:2], mem2[0:2];\
    \ // Memory for operands\n\nreg [7:0] im_data; // Data to drive onto bus\n\nreg\
    \ [7:0] opnd1, opnd2; // Operands\n\nreg [15:0] expected_result, multiplier_result;\
    \ // Results\n\ninteger indx; // Loop index\n\n// Instantiate the Multiplier Unit\
    \ Under Test\nMultiplier uut ( clk, start, databus, lsb_out, msb_out, done );\n\
    \n// --- Placeholder blocks referenced by Figure numbers ---\n\ninitial begin:\
    \ Apply_Data /*... Figure 8.11... */ end\n\ninitial begin: Apply_Start /*... Figure\
    \ 8.12... */ end\n\ninitial begin: Expected_Result /*... Figure 8.13... */ end\n\
    \nalways @(posedge clk)\nbegin: Actual_Result /*... Figure 8.14... */ end\n\n\
    always @(posedge clk)\nbegin: Compare_Results /*... Figure 8.15... */ end\n\n\
    // --- Clock generation ---\n\nalways #50 clk = ~clk;\n\n// --- Data bus driving\
    \ ---\n\nassign databus = im_data; // Drive internal data onto bus\n\nendmodule\n\
    ```\n\n## Testbench Simulation:\n\n### Testbench Results:\n\n### Testbench Results\
    \ (without operator):\n\n## Testbench Results:\n\n### Test Result:\n\n![](img/Result_Figure.png)\n\
    \n## Error Analysis:\n\n### Error Analysis Results:\n\n## SystemVerilog Code of\
    \ the Design:\n```\n`timescale 1ns / 1ps\n\nmodule Multiplier(\n\n     input \
    \ wire clk,   // Clock input\n\n     input  wire start, // Start button\n\n  \
    \   input  wire [7:0] data_in, // Data input\n\n     output wire [7:0] data_out,\
    \ // Data output\n\n     output reg [7:0] lsb,      // Leftmost significant bit\n\
    \n     output reg [7:0] msb       // Most significant bit\n\n   );\n\nreg [7:0]\
    \ mul_result;\n\nwire [7:0]"
- code: |-
    module test_multiplier;
    reg clk=0, start, error; // Added clk initialization
    wire [7:0] databus;
    wire lsb_out, msb_
- code: |-
    module Prob_7_Seq (Detect_Seq, D_in, clk, rst);
    // Sequence detector
    output Detect_Seq;
    input D_in, clk, rst;
    // Sequence states, placed in package scope
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8;
    reg [3: 0] state_Seq, next_state;
    // Sequence detection logic
    reg [1: 0] seq_cnt;
    seq_cnt <= 0;
    Detect_Seq <= ((state_Seq == S_4) || inside(state_Seq, {S_4, S_8}));
    always @ (posedge clk) if (rst) state_Seq <= S_0; else state_Seq <= next_state;
    always @ (state_Seq, D_in) begin
    next_state = S_0;
    case (state_Seq)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_1; else if (D_in == 0) seq_cnt <= 2'b01;
    S_2: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_3;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) seq_cnt <= 2'b10;
    S_4: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_8: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    default: next_state = S_0;
    endcase
    if (seq_cnt == 2'b01) seq_cnt <= 2'b11; else if (seq_cnt == 2'b10) seq_cnt <= 2'b10; else if (seq_cnt == 2'b11) seq_cnt <= 2'b00;
    end
    endmodule

    ## Problem 8

    ### Base Verilog Code:
    module Prob_8_Seq (Detect_Seq, D_in, clk, rst);
    // Sequence detector
    output Detect_Seq;
    input D_in, clk,
- code: |-
    module Prob_9_FSM (Detect_FSM, D_in, clk, rst);
    // Finite State Machine
    output Detect_FSM;
    input D_in, clk, rst;
    parameter s0 = 0;
    parameter s1 = 1;
    reg [2: 0] state_FSM, next_state;
    always @ (posedge clk) if (rst) state_FSM <= s0; else state_FSM <= next_state;
    always @ (state_FSM) begin
    next_state = s0;
    case (state_FSM)
    s0: if ((D_in == 1) && (D_in == 0)) next_state = s1;
    s1: if ((D_in == 0) && (D_in == 0)) next_state = s0;
    s1: if ((D_in == 0) && (D_in == 1)) next_state = s0;
    default: next_state = s0;
    endcase
    end
    endmodule

    ## Probability 10

    Problem

    Implement the following Moore finite state machine:

    Solution

    ### Base Verilog Code:
    module Prob_10_FSM (Detect_FSM, D_in
- code: |-
    module Prob_8_Asy (Detect_Asy, D_in, clk, rst);
    // Asynchronous sequence detector
    output Detect_Asy;
    input D_in, clk, rst;
    reg [2: 0] state_Asy, next_state;
    wire Detect_Asy = (state_Asy inside {1'b1, 1'b0});
    always @ (posedge clk) if (rst) state_Asy <= 2'b00; else state_Asy <= next_state;
    always @ (state_Asy, D_in) begin
    next_state = 2'b00;
    case (state_Asy)
    2'b00: if (D_in) next_state = 2'b01; else if (~D_in) next_state = 2'b00;
    2'b01: if (D_in) next_state = 2'b10; else if (~D_in) next_state = 2'b00;
    2'b10: if (D_in) next_state = 2'b11; else if (~D_in) next_state = 2'b10;
    Default: next_state = 2'b00;
    endcase
    end
    endmodule

    # 9. Asynchronous sequence detector with constant input

    ## Asynchronous Sequence detector:

    An asynchronous sequence detector can be used to detect the first or the last transition in an asynchronous sequence, such as {a,b,c}.

    ## Problem:

    Design an asynchronous sequence detector to detect the first or the last transition in the asynchronous sequence {a,b,c} with the constant input as {1, 0, 1}.

    ## Solution:

    To design an asynchronous sequence detector with the constant input as {1, 0, 1}, consider the following two problems:

    1. How to detect the asynchronous sequence {a,b,c}?
    2. How to detect the first or the last transition of the asynchronous sequence {a,b,c}?

    The solution is to combine the solutions for the problems 1 and 2 to solve the problem of the asynchronous sequence detector with the constant input as {1, 0, 1}.

    The first step is to detect an asynchronous sequence. To do that, I consider the state of the asynchronous sequence detector as the next state of the finite state machine. The next states of the finite state machine are:

    Therefore, to detect an asynchronous sequence, I use the following code:

    In the next step, I consider the state of the asynchronous sequence detector as the next state of the finite state machine. The next states of the finite state machine are:

    Therefore, to detect the first or the last transition in an asynchronous sequence, I use the following code:

    ## Base Verilog Code:
    module Prob_9_Asy (Detect_Asy, D_in, clk, rst);
    // Asynchronous sequence detector
    output Detect_Asy;
    input D_in, clk, rst;
    reg [2: 0] state_Asy, next_state;
    wire Detect_Asy = (state_Asy == {1'b1, 1'b0});
    always @ (posedge clk) if (rst) state_Asy <= 2'
- code: |-
    module Prob_8_D_Flip_Flop_modified (out, D_out, D_in, clk, rst);
    // Combinational circuit
    wire D_out;
    reg out, D_out_temp;
    // D flip-flop
    assign out = D_out;
    always_comb begin
    if (~D_out) D_out_temp = 1;
    else D_out_temp = D_in;
    end
    always @ (posedge clk, negedge rst) begin
    if (rst) D_out_temp = 1;
    D_out <= D_out_temp;
    end
    endmodule
    ### Verilog Synthesis:
    ![Image description](https://github.com/Sagar-Mukherjee/Verilog-Code/blob/main/Image_0/Prob_8_D_Flip_Flop.png)
    ### Testbench for Verilog Code:
        module Testbench;
        // Inputs
        reg D_in;
        // Outputs
        wire D_out;
        // Inputs and Outputs
        reg [31: 0] in_data;
        // Inputs and Outputs
        integer in_data_int;
        // Clock
        reg clk;
        // Reset
        reg rst;
        // Testbench
        initial begin
        $dumpfile("Prob_8_D_Flip_Flop.vcd");
        $dumpvars(0, Testbench);
        // Inputs
        D_in = 0;
        // Outputs
        D_out = 0;
        // Inputs and Outputs
        in_data = 0;
        // Clock
        clk = 0;
        // Reset
        rst = 1'b1;
        for (integer i = 0; i < 32; i = i + 1) begin
        in_data = i;
        in_data_int = i;
        D_in <= in_data_int;
        D_out = in_data_int;
        #1
        clk =!clk;
        #1
        end
        end
        #1
        rst = 0;
        #50
        $finish;
        endmodule
    ### Testbench Simulation:
    ![Image description](https://github.com/Sagar-Mukherjee/Verilog-Code/blob/main/Image_0/Prob_8_D_Flip_Flop_modified.png)
    ### Result:
    ![Image description](https://github.com/Sagar-Mukherjee/Verilog-Code/blob/main/Image_0/Prob_8_D_Flip_Flop_modified.png)
    ## Problem 9.
    Design a D flip-flop with a delay of 2 clocks.
    ### Base Verilog Code:
    module Prob_9_D_Flip_Flop_with_2_Delay (out, D_out, D_in, clk, rst);
    // D flip-flop with 2 delay
    wire D_out;
    reg out, D_out_temp;
    // D flip-flop
    assign out = D_out;
    always @ (posedge clk, negedge rst) begin
    if (rst) D_out_temp = 1;
    else if (~D_out) D_out_temp = 1;
    else D_out_temp = D_in;
    end
    always @ (D_out_temp) D_out <= D_out_temp;
    endmodule
    ### Variation Instruction:
    Remove `if ~D_out` condition from the `always_comb
- code: |-
    module Prob_6_4_Counter;
    // Counter
    output [7: 0] Count_out;
    reg [7: 0] Count;
    reg [7: 0] Count_in, next_count, count_load;
    wire [7: 0] Shift_Right;
    wire [7: 0] Shift_Left;
    reg [7: 0] Shift_in;
    always @ (posedge clk)begin
    next_count = count_load;
    if (count_load == 0) next_count = Count_in + 1;
    else if ((Count_in == 0) && (count_load!= 0)) next_count = count_load;
    end
    always @* begin
    count_load <= 0;
    end
    always @ (posedge clk) if (rst == 0) count_load <= 0; else count_load <= 1;
    always @ (posedge clk) Shift_in = Count_in;
    always @ (posedge clk) Shift_Left = Count;
    always @ (Shift_Right) begin
    Count_out = Shift_Right;
    Count_in = Shift_Left;
    end
    endmodule
    ### Results:
    ![Prob_6_4_Counter_Schematic_Diagram](/assets/posts_pic/2021-05-23-Post-5-Digital-System-Desiciptor-Schematic-Schematic-Diagram/Prob_6_4_Counter_Schematic_Diagram.png)
    ![Prob_6_4_Counter_Simulation](/assets/posts_pic/2021-05-23-Post-5-Digital-System-Desiciptor-Schematic-Schematic-Diagram/Prob_6_4_Counter_Simulation.png)
    ## Problem 7
    ### Base Verilog Code:
    module Prob_7_1_Counter (Count_out, Count_in, clk, rst, count_load, count_enable);
    // Counter
    output [7: 0] Count_out;
    reg [7: 0] Count;
    reg [7: 0] Count_in
- code: |-
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    ctr_wt c1(a,clk,N,En);
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ### Output Before
    `
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15, a=15, En=0
    clk=01111 N=15,
- code: "module tst_ctr_wt;\n  reg clk, En;\n  reg[3:0] N;\n  wire[3:0] a;\n  generate\n\
    \    for (i = 0; i <= 3; i++) begin\n      for (j = 0; j <= 3; j++) begin\n  \
    \      ctr_wt c1(a[j], clk, N[i], En);\n      end\n    end\n  endgenerate\n  initial\n\
    \    begin\n      clk = 0;\n      N = 4'b1111; // Set limit to 15\n      En =\
    \ 1'b0; // Start disabled\n    end\n  always\n    initial #35 \\$stop; // Stop\
    \ simulation\n    initial \\$monitor(\\$time, \"clk=%b, En=%b, N=%d, a=%d\", clk,\
    \ En, N, a); // Corrected format specifiers\nendmodule\n### Verilog Input:\n```\n\
    module testbench(input clk, input En, output reg[3:0] N, output reg[3:0] a);\n\
    \  reg[3:0] N;\n  reg[3:0] a;\n  wire[3:0] a_local;\n\n  for (i = 0; i <= 3; i++)\n\
    \    for (j = 0; j <= 3; j++)\n      ctr_wt c1(a_local, clk, N[i], En);\n\n  initial\n\
    \    begin\n      N = 4'b1111; // Set limit to 15\n      En = 1'b0; // Start disabled\n\
    \    end\n  always\n    initial\n      #35 $stop; // Stop simulation\n    initial\n\
    \      $monitor($time,\n        \"clk=%b, En=%b, N=%d, a=%d\",\n        clk,\n\
    \        En,\n        N,\n        a\n      ); // Corrected format specifiers\n\
    endmodule\n```\n```\n$ verilator -march=rv32i -Wall --exe tst_ctr_wt.cpp --cc\
    \ ctr_wt.v\n$ make -j8 -C obj_dir/ -f Vtst_ctr_wt.mk Vtst_ctr_wt\n$./obj_dir/Vtst_ctr_wt\n\
    ```\nvoid\nmain()\n{\n\t$display(\"hello world\");\n}\n\n$test $display(\"hello\
    \ world\");\n#include <stddef.h>\n#include <stdint.h>\n\n#ifndef __ASSEMBLER__\n\
    \n#include \"verilated.h\"\n\n#endif\n\nclass Vtst_ctr_wt__Syms;\n// FUNCTIONS\n\
    #include \"verilated_dpi.h\"\n\n#include \"verilated_vpi.h\"\n\nclass Vtst_ctr_wt\n\
    {\n public:\n  // CELLS\n  Vtst_ctr_wt__Syms* __Vl__Syms;\n  // PORTS (I/O)\n\
    \  VL_IN8(clk,0,0);\n  VL_IN8(En,0,0);\n  VL_OUT8(a,0,0);\n  VL_IN(N,1,32);\n\
    \  // LOCAL SIGNALS\n  // INTERNAL VARIABLES\n  //char\t__VpadToAlign1[4];\n \
    \ VL_SIG8(__PVT__rstn,0,0);\n  VL_SIG16(__PVT__count,15,0);\n  VL_SIG8(__PVT__En,0,0);\n\
    \  VL_SIG8(__PVT__cmp,0,0);\n  VL_SIG8(__PVT__a,3,0);\n  VL_SIG8(__PVT__count_1,3,0);\n\
    \  \n  // INTERNAL VARIABLES\n  //char\t__VpadToAlign2[4];\n  VL_SIG(__PVT___PVT___0,31,0);\n\
    \  \n  // INTERNAL VARIABLES\n  //char\t__VpadToAlign3[4];\n  VL_SIG(__PVT___PVT___1,31,0);\n\
    \  \n  \n  // PARAMETERS\n  \n  // CONSTRUCTORS\n  Vtst_ctr_wt(const char* name=\"\
    TOP\");\n  \n  // DESTRUCTORS\n  ~Vtst_ctr_wt();\n  \n  // METHODS\n  void trace\
    \ (VerilatedVcdC* tfp, int levels, int options=0);\n  \n  // SUBMETHODS\n  void\
    \ __Vconfigure(Vtst_ctr_wt__Syms* symsp, bool first);\n};\n#include \"verilated.h\"\
    \n#include \"Vtst_ctr_wt.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n\nclass\
    \ Vtst_ctr_wt__Syms : public VerilatedSyms {\n public:\n  VL_CTOR_OR_CIN(Vtst_ctr_wt__Syms,\
    \ &name(), &description(), &verilated_debug_module_name, \\\n    verilated_debug_module_path,\
    \ NULL, NULL);\n  Vtst_ctr_wt*\tTOP__VERILATOR__;\n  const char*\t__Vconfigure__name()\t\
    const { return name();\t}\n  const char*\t__Vconfigure__description()\tconst {\
    \ return description();\t}\n  const char*\t__Vconfigure__verilated_debug_module_name()\t\
    const { return verilated_debug_module_name();\t}\n  const char*\t__Vconfigure__verilated_debug_module_path()\t\
    const { return verilated_debug_module_path();\t}\n  void\t__Vconfigure(Vtst_ctr_wt&\
    \ inst, bool first)\t{ TOP__VERILATOR__=&inst; }\n};\n\nVL_INLINE_OPT void Vtst_ctr_wt::__Vconfigure(Vtst_ctr_wt__Syms*\
    \ symsp, bool first) {\n  if (false && symsp &&!symsp->__VlSymsp) {\n    // Private\
    \ area after this point.\n    // Use the private area to ensure that there are\
    \ no out-of-scope\n    // symbols in the public description. Must be validated\
    \ before\n    // program memory can be pulled from known wells here.\n    if (false\
    \ && \"TOP__VERILATOR__\" && VL_UNLIKELY(!symsp->__VlSymsp->__Vm_name))\t\t\t\
    VL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"VM name\
    \ not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2018))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2019))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2021))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2022))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2023))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2024))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2025))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2026))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \"\
    VM name not set for top entity\");\n    if (false && \"TOP__VERILATOR__\" && VL_UNLIKELY((void*)__Vfunname2027))\t\
    \t\tVL_FATAL_MT(\"/home/liu/Desktop/ISE/test/verilog/ctr_wt.v\", 42, \"\", \""
- code: |-
    ```
    Verilog Source
    module tst_ctr_wt;
    reg clk,En;
    reg[3:0]N;
    wire[3:0]a;
    initial
    begin
    clk=0; N=4'b1111; // Set limit to 15
    En=1'b0; // Start disabled
    end
    always
    initial #35 $stop; // Stop simulation
    initial $monitor($time,"clk=%b, En=%b, N=%d, a=%d",clk,En,N,a); // Corrected format specifiers
    endmodule
    ```
    ```
    Output
    ```
    ```
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
    clk=0, En=0, N=15, a=15
- code: "```\nmodule tst_ctr_wt;\nreg clk,En;\nreg[3:0]N;\nwire[3:0]a;\ngenerate\n\
    for(int i=0;i<4;i++)\nbegin:inner\nctr_wt c1(a[i],clk,N,En);\nend\nendgenerate\n\
    initial\nbegin\nclk=0; N=4'b1111; // Set limit to 15\nEn=1'b0; // Start disabled\n\
    end\nalways\ninitial #35 $stop; // Stop simulation\ninitial $monitor($time,\"\
    clk=%b, En=%b, N=%d, a=%d\",clk,En,N,a); // Corrected format specifiers\nendmodule\n\
    ```\n### Simulation Output:\n```\n# Simulation started at Wed Nov 12 16:43:21\
    \ 2014\n# Verilog Simulation 2012.09-SP2 compiled Nov 12 2014 21:37:56\n# File:\
    \ tst_ctr_wt.v\n# Command line: tst_ctr_wt.do\n#\n# Executing Verilog design `tst_ctr_wt'\
    \ from file `tst_ctr_wt.v' at `clk=0, En=x, N=x, a=x'\n#\n#\n#\n#\n#\n#\n#\n#\n\
    #\n# Clock: clk = 0\n# Enable: En = x\n# N: N = x'\n#  a = x'\n#\n#\n#\n#\n#\n\
    #\n#\n#\n#\n# Clock: clk = 0\n# Enable: En = 0\n# N: N = 15'h1111\n#  a = 15'h1111\n\
    #\n#\n#\n#\n#\n#\n#\n#\n#\n#\n# $stop simulation\n```\n# \u56FE\u50CF\u7F29\u653E\
    _\u63D2\u503C - qq_36106811\u7684\u535A\u5BA2 - CSDN\u535A\u5BA2\n\n\n\n\n\n2018\u5E74\
    08\u670824\u65E5 22:14:37[qq_36106811](https://me.csdn.net/qq_36106811)\u9605\u8BFB\
    \u6570\uFF1A160\n\n\n\n\n\n\n\n\n> \n\u539F\u6587\u94FE\u63A5\uFF1A[www.cnblogs.com/zrtqsk/p/2574465.html](https://www.cnblogs.com/zrtqsk/p/2574465.html)\n\
    \n\n\n\u56FE\u50CF\u7F29\u653E\u4E2D\u6709\u4E24\u79CD\u7F29\u653E\u65B9\u5F0F\
    \uFF0C\u4E00\u79CD\u662F\u76F4\u63A5\u63D2\u503C\uFF0C\u53E6\u4E00\u79CD\u662F\
    \u4F7F\u7528\u53CC\u7EBF\u6027\u63D2\u503C\u3002\n\n\n\n\n\u76F4\u63A5\u63D2\u503C\
    \uFF1A\n\n\u4EE3\u7801\uFF1A\n\n```\nvoid ScaleImage(IplImage* src,IplImage* dst)\n\
    {\n    int w = src->width;\n    int h = src->height;\n    int tw = dst->width;\n\
    \    int th = dst->height;\n    float x_ratio = (float)tw/w;\n    float y_ratio\
    \ = (float)th/h;\n    int nx,ny;\n    uchar * src_ptr;\n    uchar * dst_ptr;\n\
    \n    for(int i = 0;i < th; i++)\n    {\n        ny = (int)(i*y_ratio);\n    \
    \    dst_ptr = (uchar*)dst->imageData + i*dst->widthStep;\n        for(int j =\
    \ 0; j < tw; j++)\n        {\n            nx = (int)(j*x_ratio);\n           \
    \ src_ptr = (uchar*)src->imageData + ny*src->widthStep + nx;\n            dst_ptr[j]\
    \ = src_ptr[0];\n        }\n    }\n}\n```\n\n![](https://img-blog.csdn.net/20180824221209625?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\
    \n\n\n\n\u53CC\u7EBF\u6027\u63D2\u503C\uFF1A\n\n\u4EE3\u7801\uFF1A\n\n```\n//\u53CC\
    \u7EBF\u6027\u63D2\u503C\nvoid InterpolateImage(IplImage * src,IplImage * dst)\n\
    {\n    int w = src->width;\n    int h = src->height;\n    int tw = dst->width;\n\
    \    int th = dst->height;\n    float x_ratio = (float)tw/w;\n    float y_ratio\
    \ = (float)th/h;\n    int nx,ny;\n    int xoffset,yoffset;\n    float wx,wy;\n\
    \    uchar * src_ptr;\n    uchar * dst_ptr;\n\n    for(int i = 0;i < th; i++)\n\
    \    {\n        ny = (int)(i*y_ratio);\n        yoffset = ny*src->widthStep;\n\
    \        dst_ptr = (uchar*)dst->imageData + i*dst->widthStep;\n        for(int\
    \ j = 0; j < tw; j++)\n        {\n            nx = (int)(j*x_ratio);\n       \
    \     wx = nx - xoffset;\n            xoffset = nx*src->widthStep;\n         \
    \   wy = ny - yoffset;\n            yoffset = 0;\n            src_ptr = (uchar*)src->imageData\
    \ + yoffset + xoffset;\n            src_ptr[0] = (uchar)(src_ptr[0]*(1 - wx) +\
    \ src_ptr[src->widthStep]*wx);\n            src_ptr[0] = (uchar)(src_ptr[src->widthStep]*(1\
    \ - wy) + src_ptr[src->widthStep*2]*wy);\n        }\n    }\n}\n```\n\n![](https://img-blog.csdn.net/20180824221222552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4MTU0MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\
    \n\n\n# 2017\u5E74\u963F\u91CC\u5DF4\u5DF4\u767E\u5EA6\u5927\u6570\u636E\u53CA\
    \u4EBA\u5DE5\u667A\u80FD\u5927\u4F1A\uFF08\u4E0A\u6D77\u7AD9\uFF09\u76F4\u64AD\
    \u56DE\u987E - \u77E5\u4E4E\n# \n\n\n\n> \n\u672C\u6587\u4E3A\u300A\u5927\u6570\
    \u636E\u4E0E\u4EBA\u5DE5\u667A\u80FD\u300B\u4F5C\u8005\u64B0\u5199\n\n**\u76EE\
    \u5F55**\n\n\u5BFC\u8BFB\uFF1A\u963F\u91CC\u5DF4\u5DF4\u3001\u767E\u5EA6\u548C\
    Google\u4E09\u5927\u4E92\u8054\u7F51\u5DE8\u5934\u9F50\u805A\u5927\u4F1A\n\n\u672C\
    \u6B21\u5927\u4F1A\u4EE5\u201C\u5927\u6570\u636E\u4E0E\u4EBA\u5DE5\u667A\u80FD\
    \u201D\u4E3A\u4E3B\u7EBF\uFF0C\u56F4\u7ED5\u65B0\u4E00\u4EE3\u4EBA\u5DE5\u667A\
    \u80FD\u6280\u672F\u7684\u53D1\u5C55\uFF0C\u6DF1\u5165\u5256\u6790\uFF0C\u63A2\
    \u8BA8\u4E0E\u5B9E\u8DF5\uFF0C\u65E8\u5728\u4FC3\u8FDB\u4EBA\u5DE5\u667A\u80FD\
    \u4E0E\u5927\u6570\u636E\u6280\u672F\u7684\u53D1\u5C55\u3002\n\n![](https://pic2.zhimg.com/v2-33c450102c7a77b174f9a72e98a4d975_b.jpg)\n\
    \u672C\u6B21\u5927\u4F1A\u4E3A\u6570\u636E\u79D1\u5B66\u9AD8\u5CF0\u4F1A\uFF0C\
    \u5728\u5317\u4EAC\u7684\u5927\u5B66\u57CE\u4E2D\u4E3E\u529E\u3002\u5927\u4F1A\
    \u5728\u201C\u673A\u5668\u4E4B\u5FC3\u201D\u516C\u4F17\u53F7\u3001\u201C\u673A\
    \u5668\u4E4B\u5FC3\u201D\u5FAE\u4FE1\u516C\u4F17\u53F7\u548C\u201C\u5927\u6570\
    \u636E\u4E0E\u4EBA\u5DE5\u667A\u80FD\u201D\u5FAE\u4FE1\u516C\u4F17\u53F7\u5206\
    \u522B\u5BA3\u5E03\uFF0C\u540C\u65F6\u5F00\u653E\u7535\u5B50\u7248\uFF0C\u6B22\
    \u8FCE\u5927\u5BB6\u5173\u6CE8\u3002\n![](https://pic3.zhimg.com/v2-2714e367769546d44ad8c5fd32e518e0_b.jpg)![](https://pic3.zhimg.com/v2-000d51d2f8880795866d4063d73a0fa9_b.jpg)![](https://pic3.zhimg.com/v2-462396ba261c856f4d784103865b28f6_b.jpg)![](https://pic2.zhimg.com/v2-d1c42c2ef0c62ab6399207b8825e11b4_b.jpg)![](https://pic2.zhimg.com/v2-e41f4aa63a574e1cb32c99f21ba41f55_b.jpg)![](https://pic3.zhimg.com/v2-b2ac3c0145bd508b155825153049760b_b.jpg)![](https://pic4.zhimg.com/v2-e2849322e8294927671c89e660f521c6_b.jpg)![](https"
- code: |-
    module tst_ctr_wt;
    reg clk;
    assign clk=clk+1;
    reg[3:0]N;
    wire[3:0]a;

    `assign N=inside(a,0,10,1);`

    `assign N=inside(a,5,7,1);`

    `assign N=inside(a,0,10,2);`

    `assign N=inside(a,0,10,4);`

    `assign N=inside(a,0,10,7);`

    `assign N=inside(a,0,10,8);`

    `assign N=inside(a,0,10,10);`

    `assign N=inside(a,0,3,1);`

    `assign N=inside(a,3,5,1);`

    `assign N=inside(a,1,3,1);`

    `assign N=inside(a,3,3,1);`

    `assign N=inside(a,0,3,2);`

    `assign N=inside(a,3,3,2);`

    `assign N=inside(a,2,2,2);`

    `assign N=inside(a,5,7,2);`

    `assign N=inside(a,2,2,4);`

    `assign N=inside(a,1,1,4);`

    `assign N=inside(a,9,9,4);`

    `assign N=inside(a,5,7,7);`

    `assign N=inside(a,8,8,7);`

    `assign N=inside(a,5,5,7);`

    `assign N=inside(a,8,8,8);`

    `assign N=inside(a,1,1,8);`

    `assign N=inside(a,9,9,8);`

    `assign N=inside(a,5,5,8);`

    `assign N=inside(a,0,9,2);`

    `assign N=inside(a,0,9,4);`

    `assign N=inside(a,0,9,7);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=inside(a,9,2,10);`

    `assign N=inside(a,9,1,10);`

    `assign N=inside(a,0,8,10);`

    `assign N=inside(a,0,2,10);`

    `assign N=inside(a,0,1,10);`

    `assign N=inside(a,1,10,10);`

    `assign N=inside(a,9,9,10);`

    `assign N=inside(a,9,4,10);`

    `assign N=inside(a,9,3,10);`

    `assign N=
- code: |-
    module mealy(Clock, Resetn, w, z);
    input Clock, Resetn, w;
    output z;
    reg y, Y, z;
    parameter A = 0, B = 1;
    always @(w or y)
        case (y)
            A: begin
                z = 0;
                Y = B;
            end
            B: begin
                z = 1;
                Y = B;
            end
        endcase
    always @(negedge Resetn or posedge Clock)
        if (Resetn == 0) y <= A;
        else y <= Y;
    endmodule
    ### Testbench:
    class tb_mealy9;
        logic w, z;
        logic Clock, Resetn;
        logic clk;
        logic [1:0] y;
        logic [1:0] Y;
        logic [1:0] Z;
        logic [1:0] a;
        Mealy mealy (
               .Clock(clk),
               .Resetn(Resetn),
               .w(w),
               .z(z)
        );
        initial begin
            clk = 0;
            Resetn = 0;
            w = 1;
            z = 0;
            #10;
            $dumpfile("mealy9.vcd");
            $dumpvars(0, tb_mealy9);
        end
        initial begin
            forever #10 clk = ~clk;
            #10;
        end
        initial begin
            forever #10 Resetn = ~Resetn;
            #10;
        end
        initial begin
            forever #10 w = ~w;
            #10;
        end
        initial begin
            forever #10 a = 2'b00;
            #10;
        end
        initial begin
            forever #10 a = 2'b01;
            #10;
        end
        initial begin
            forever #10 a = 2'b10;
            #10;
        end
        initial begin
            forever #10 a = 2'b11;
            #10;
        end
        initial begin
            forever #10 w = ~w;
            #10;
        end
        initial begin
            forever #10 w = ~w;
            #10;
        end
        initial begin
            forever #10 w = ~w;
            #10;
        end
        initial begin
            forever #10 y = a;
            #10;
        end
    endclass
    ### GTKWave:
    ![mealy9](./mealy9.png)
- code: |-
    ```python
    class MyModule(sv.Module):
        def __init__(self, clk, rst):
            self.clk = clk
            self.rst = rst
            self.w = sv.Input(sv.Bit)
            self.z = sv.Output(sv.Bit)

            self.a = sv.Reg(sv.Bit)
            self.b = sv.Reg(sv.Bit)
            self.c = sv.Reg(sv.Bit)

            self.inside_slice = sv.Array(sv.Bit, 3)

            self.a_inside_0 = inside_slice[0]
            self.a_inside_1 = inside_slice[1]
            self.a_inside_2 = inside_slice[2]
            self.b_inside_0 = inside_slice[0]
            self.b_inside_1 = inside_slice[1]
            self.b_inside_2 = inside_slice[2]
            self.c_inside_0 = inside_slice[0]
            self.c_inside_1 = inside_slice[1]
            self.c_inside_2 = inside_slice[2]

            self.y = sv.Reg(sv.Bit
- code: |-
    ```systemverilog
    class FSM(Clock, Resetn, w, z);
        input Clock, Resetn;
        input [3:0] w;
        output z;
        parameter A = 0, B = 1;
        reg y, Y, z;
        always @(w or y)
            case (w[3:0])
                w[0]: A:
                    if (w[0]) z <= 0;
                    else z <= 0;
                    Y <= B;
                w[1]: B:
                    if (w[1]) z <= 1;
                    else z <= 0;
                    Y <= B;
                w[2]: B:
                    if (w[2]) z <= 1;
                    else z <= 0;
                    Y <= B;
                w[3]: B:
                    if (w[3]) z <= 1;
                    else z <= 0;
- code: |-
    #include <systemc.h>
    SC_MODULE(mealy)
    {
        sc_in<bool> Clock;
        sc_in<bool> Resetn;
        sc_in<bool> w;
        sc_out<bool> z;
        // Declare the array of 2 FSM states.
        int state_array[2] = {0, 1};

        SC_CTOR(mealy)
        {
            // Declare and map the FSM array into an SC_FSM.
            SC_FSM(state_array, A, B);
            SC_FSM_INIT(mealy_A);
            SC_FSM_UPDATE(mealy_B);
            SC_FSM_UPDATE(mealy_A);
            SC_FSM_OUTPUT(A, 0);
            SC_FSM_OUTPUT(B, 1);

            SC_THREAD(FSM);
            sensitive << Clock.pos();
            dont_initialize();
        }

        void FSM()
        {
            if (Resetn.read() == 0)
                y.write(A);
            else
                y.write(Y);
        }

        SC_FSM_ARRAY(mealy_A)
        {
            if (w.read())
            {
                z.write(0);
                Y.write(B);
            }
            else
            {
                z.write(0);
                Y.write(A);
            }
        }
        SC_FSM_ARRAY(mealy_B)
        {
            if (w.read())
            {
                z.write(1);
                Y.write(B);
            }
            else
            {
                z.write(0);
                Y.write(A);
            }
        }
        sc_int<2> A, B, y, Y;
    };
    int sc_main(int argc, char *argv[])
    {
        sc_signal<bool> Clock, Resetn, w, z;
        sc_trace(sc_stdout, Clock, "Clock");
        sc_trace(sc_stdout, Resetn, "Resetn");
        sc_trace(sc_stdout, w, "w");
        sc_trace(sc_stdout, z, "z");

        mealy mealy_inst("mealy_inst");
        mealy_inst.Clock(Clock);
        mealy_inst.Resetn(Resetn);
        mealy_inst.w(w);
        mealy_inst.z(z);

        sc_start(1, SC_SEC);
        sc_start(1, SC_SEC);

        w = 1;
        sc_start(1, SC_SEC);

        w = 0;
        sc_start(1, SC_SEC);

        sc_stop();
        return 0;
    }

    ### Output:
    * `Resetn` is 1
    * `w` is 1
    * `z` is 0
    * `y` is 1
    * `Resetn` is 0
    * `w` is 1
    * `z` is 1
    * `y` is 1
    * `Resetn` is 0
    * `w` is 0
    * `z` is 0
    * `y` is 1
    ### Explanation:
    * When `Resetn` is set to 1, the first two state transitions of the `A` array are executed, resulting in `z` being set to 0 and `Y` being set to 1.
    * When `w` is set to 1, the third and fourth state transitions of the `A` array are executed. `z` is set to 1, and `Y` is set to 1.
    * When `Resetn` is set to 0, the first two state transitions of the `B` array are executed, resulting in `z` being set to 0, and `Y` being set to 1.
    * When `w` is set to 0, the third and fourth state transitions of the `B` array are executed, resulting in `z` being set to 0, and `Y` being set to 1.
    * The final state transition of the `A` array is executed when `w` is set to 0 and `z` is set to 1, resulting in the last two state transitions of the `A` array being executed, resulting in `z` being set to 0, and `Y` being set to 1.

    ### Conclusion:

    In this project, we have used `inside` and `outside` loops to reorganize the state transitions of a `mealy` FSM. This code results in fewer lines of code for the same functionality.

    * [mealy.cpp](mealy.cpp)

    # [Lab 4](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%204)
    # [Lab 5](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205)

    ## [Memory Management Unit (MMU)](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#memory-management-unit-mmu):

    In a typical system, the memory hierarchy is implemented as follows:

    * The CPU accesses the memory via the memory controller. All memory operations are performed by the memory controller.
    * The memory controller selects a memory module from a list of memory modules.
    * The memory module transfers data to the processor via the memory interface.

    ### [Memory Module](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#memory-module):

    * The memory module is responsible for fetching and storing data in a memory location.
    * The memory module is responsible for managing the following attributes of memory:
    * Memory allocation: The memory module ensures that a memory location is allocated to a particular process.
    * Memory protection: The memory module ensures that a process is allowed to access and modify a memory location.
    * Memory paging: The memory module ensures that a process is able to access a memory location using multiple pages.

    ### [Memory Controller](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#memory-controller):

    * The memory controller is responsible for the following tasks:
    * Memory access control: The memory controller ensures that only authorized processes can access a memory location.
    * Memory address translation: The memory controller translates a memory address into a physical address.
    * Memory page replacement: The memory controller ensures that memory pages are replaced or allocated dynamically.

    ### [Memory Interface](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#memory-interface):

    * The memory interface is responsible for transferring data between memory modules and the CPU.
    * The memory interface is responsible for providing the following features:
    * Memory data stalling: The memory interface ensures that the CPU does not continue execution until the memory data is ready.
    * Memory address stalling: The memory interface ensures that the CPU does not continue execution until the memory address is ready.

    ### [Translation Lookaside Buffer (TLB)](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#translation-lookaside-buffer-tlb):

    * The Translation Lookaside Buffer (TLB) is a cache that stores a mapping of memory addresses to physical addresses.
    * The TLB is used when performing memory address translations.
    * The TLB is used to improve the performance of memory accesses by caching recently used memory addresses.
    * The TLB is used to reduce the number of memory address translations required when performing a memory access.

    ### [Address Translation](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#address-translation):

    * Address Translation is the process of translating a logical address to the corresponding physical address in memory.
    * Address Translation is the process of translating a virtual address to the corresponding physical address in memory.
    * Address Translation is the process of translating the address of an instruction or data to the corresponding physical address in memory.

    * [mmu.cpp](mmu.cpp)

    ## [Cache](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#cache):

    * Cache is a small fast memory that stores recently used data from main memory.
    * Cache is used to reduce the access time to main memory.
    * Cache is used to improve the performance of programs by reducing the number of memory accesses.
    * Cache is used to improve the performance of programs by caching frequently accessed data.

    ![](images/cache.png)

    ### [Cache Types](https://github.com/RahulSharma-98/Computer-Organization-and-Architecture/tree/master/Lab%205#cache-types):

    * [Cache](https://en.wikipedia
- code: |-
    ```verilog
    module mealy(input Clock, input Resetn, input w, output z);
        input Clock, Resetn, w;
        output z;
        reg y, Y, z;
        parameter A = 0, B = 1;
        // FSM
        class FSM;
            integer a, b;

            initial a = 0;
            initial b = 0;
            always #(w or y) case (y)
                A:
                    a = B;
                    b = B;
                    case (w)
                        false: z = 0;
                        true: z = 1;
                    endcase
                B:
                    a = A;
                    b = B;
                    case (w)
                        false: z = 0;
                        true: z = 1;
                    endcase
            endcase

            always @(negedge Resetn or posedge Clock)
                if (Resetn) begin
                    a <= 0;
                    b <= 0;
                end else begin
                    a <= a;
                    b <= b;
                end
        endclass

        FSM fsm;

        initial begin
            if (Resetn) begin
                fsm = new;
            end else begin
                fsm = new;
                fsm.fsm(1'b1, 1'b1);
            end
        end
    endmodule
    ```

    ## HDL Coding Conventions Checklist

    ### Checklist

    1. **Naming Conventions:**
       - Variable or Signal names should be named in **all** lowercase with underscores separating words.
       - Module names should be named in **all** uppercase with underscores separating words.
       - Verilog/SV file name should be named exactly the same as module name.
    2. **Naming Conventions for Class:**
       - Class names should be named in **all** uppercase with underscores separating words.
    3. **Naming Conventions for Parameter:**
       - Parameter names should be named in **all** lowercase with underscores separating words.
    4. **Naming Conventions for Port:**
       - Port names should be named in **all** lowercase with underscores separating words.
    5. **Naming Conventions for Array:**
       - Array names should be named in **all** lowercase with underscores separating words.
    6. **Module Port Declarations:**
       - All module input/output ports **must** be declared with their directions and types.
    7. **Array Element Indexing:**
       - Ports, arrays, or signals should be indexed via the `[]` operator.
    8. **Constant Value Assignment:**
       - Constant values **must** be assigned via `=` with no indentation.
    9. **Array or Signal Initialization:**
       - Arrays or signals **must** be initialized with `=` with no indentation.
    10. **Initial Assignment of Port, Array, or Signal:**
        - Ports, arrays, or signals **must** be initialized with assignment statements with a level of indentation of 2 spaces.
    11. **Always Block:**
        - Always blocks **must** be indented with 2 spaces.
    12. **Port to Signals:**
        - Always block inputs **must** be converted to their respective signal types.
    13. **Function Definitions:**
        - Function definitions **must** be placed on the same line as the `function` keyword.
        - Parameters **must** be placed on the line following the `function` keyword.
        - Function body **must** be on the line following the parameters.
    14. **Always Block Statements:**
        - Always block statements **must** be placed on the same line as the `always` or `initial` keywords.
        - Event expressions **should** be placed on the line following the `always` or `initial` keywords.
    15. **Always Block Ports:**
        - Always block ports **must** be indented with 2 spaces.
    16. **Always Block Initializations:**
        - Initializations **must** be indented with 2 spaces.
    17. **Always Block Control Statements:**
        - Always block control statements **must** be placed on the same line as the `case` keyword.
        - Case selector expressions **must** be placed on the line following the `case` keyword.
        - Case body statements **must** be placed on the line following the selector expression.
    18. **Case Statement:**
        - Case statement bodies **must** be indented with 2 spaces.
    19. **Case Statement Selector Expressions:**
        - Case selector expressions **must** be indented with 2 spaces.
    20. **Case Statement Statements:**
        - Case statements **must** be indented with 4 spaces.
    21. **Function Calls:**
        - Function calls **must** be indented with 4 spaces.
    22. **Function Call Arguments:**
        - Function call arguments **must** be indented with 4 spaces.
    23. **Module Instantiations:**
        - Module instantiations **must** be placed on the same line as the `module` keyword.
        - Instantiation argument expressions **must** be placed on the line following the `module` keyword.
    24. **Parameter Assignments:**
        - Parameter assignments **must** be placed on the same line as the `parameter` keyword.
        - Parameter expressions **must** be placed on the line following the `parameter` keyword.
    25. **Generate Block:**
        - Generate blocks **must** be placed on the same line as the `generate` keyword.
        - Generate block end keyword **must** be placed on the line following the `generate` keyword.
    26. **Generate Block Instance:**
        - Generate block instances **must** be placed on the same line as the `generate` keyword.
        - Generate block instance end keyword **must** be placed on the line following the `generate` keyword.
    27. **Generate Block Instance Ports:**
        - Generate block instance port names **must** be placed on the same line as the `generate` keyword.
        - Generate block instance port expressions **must** be placed on the line following the `generate` keyword.
    28. **Generate Block Instance Port Expressions:**
        - Generate block instance port expressions **must** be indented with 4 spaces.
        - Generate block instance port expressions **should** be on the same line as the port type.
        - Generate block instance port expressions **must** be on a separate line if the port type is multi-line.
    29. **Generate Case statements:**
        - Generate case statements **must** be placed on the same line as the `case` keyword.
        - Generate case selector expressions **must** be placed on the line following the `case` keyword.
        - Generate case body statements **must** be placed on the line following the selector expression.
    30. **Generate Case Statements:**
        - Generate case statements **must** be indented with 4 spaces.
    31. **Generate Case Selector Expressions:**
        - Generate case selector expressions **must** be indented with 4 spaces.
    32. **Generate Case Statements:**
        - Generate case statements **must** be indented with 4 spaces.
    33. **Generate Block End:**
        - Generate block end **must** be placed on the same line as the `endgenerate` keyword.
    34. **Always Block End:**
        - Always block end **must** be placed on the same line as the `end` keyword.
    35. **Always Block End:**
        - Always block end **must** be placed on the same line as the `end` keyword.
    36. **Class Definitions:**
        - Class definitions **must** be placed on the same line as the `class` keyword.
        - Class declaration end keyword **must** be placed on the line following the `class` keyword.
    37. **Class Block:**
        - Class blocks **must** be placed on the same line as the `class` keyword.
        - Class block end keyword **must** be placed on the line following the `class` keyword.
    38. **Class Initializations:**
        - Class initializations **must** be placed on the same line as the `class` keyword.
        - Class initialization body statements **must** be placed on the line following the `class` keyword.
    39. **Class Initializations:**
        - Class initializations **must** be indented with 4 spaces.
    40. **Class Control Statements:**
        - Class control statements **must** be placed on the same line as the `class` keyword.
        - Class selector expressions **must** be placed on the line following the `class` keyword.
        - Class body statements **must** be placed on the line following the selector expression.
    41. **Class Control Statements:**
        - Class control statements **must** be indented with 4 spaces.
    42. **Class Selector Expressions:**
        - Class selector expressions **must** be indented with 4 spaces.
    43. **Class Statements:**
        - Class statements **must** be placed on the same line as the `class` keyword.
        - Class statements **must** be indented with 4 spaces.
    44. **Class Statements:**
        - Class statements **must** be indented with 4 spaces.
    45. **Class End:**
        - Class end **must** be placed on the same line as the `endclass` keyword.
    46. **Class End:**
        - Class end **must** be placed on the same line as the `endclass` keyword.
    47. **Function Definitions:**
        - Function definitions **must** be placed on
- code: |-
    ```
    import veriloggen.core.vlog as vlog

    class generator(vlog.Module):
        def __init__(self, data_width=1, depth=4, init=0):
            self.data_width = data_width
            self.depth = depth
            self.init = init
            self.S_packed_array = [self.init] * self.depth
            self
- code: "```\n##include <systemc.h>\nSC_MODULE(mux4to1) {\n    sc_in<bool> w0, w1,\
    \ w2, w3, S;\n    sc_out<bool> f;\n    bool inside[4] = {true, false, true, false};\n\
    \    SC_CTOR(mux4to1) {\n      SC_METHOD(compute);\n      sensitive << w0 << w1\
    \ << w2 << w3 << S;\n    }\n    void compute() {\n      f.write((inside[3 & S.read()]\
    \ << 3) |\n              (inside[2 & S.read()] << 2) |\n              (inside[1\
    \ & S.read()] << 1) |\n              (inside[0 & S.read()] << 0));\n    }\n};\n\
    ```\n/Lab2/README.md\n# VIPER Lab 2\n\n## Instructions\n\n1. Create a Viper project\
    \ for the `counter` described in the previous lab.\n2. Add an adder module, connecting\
    \ `count` and `inc` to the output of `adder`.  You can use `reg`s to implement\
    \ `adder`.\n3. Add an adder module, connecting `inc` to the output of `adder`.\
    \  Now connect the output of `adder` to the `count` input of the counter.\n4.\
    \ Use the Viper debugger to print the value of `count` when the internal `clk`\
    \ is toggled.\n\n## Useful Links\n\n* [Lab 2 Slides](https://drive.google.com/file/d/15bQ4r623e5k5c2sU0O0xL7b6a436kV1o/view?usp=sharing)\n\
    * [Adder Module Instructions](https://github.com/ucsd-cse120-wi20/labs/tree/master/Lab1)\n\
    /Lab3/counter.cpp\n#include <systemc.h>\n\nSC_MODULE(counter) {\n  sc_in_clk clk;\n\
    \  sc_in<bool> reset;\n  sc_out<sc_uint<8>> count;\n  sc_uint<8> counter;\n  sc_uint<8>\
    \ increment;\n\n  // Initialize values of variables\n  SC_CTOR(counter) {\n  \
    \  counter = 0;\n    increment = 1;\n    SC_METHOD(compute);\n    sensitive <<\
    \ clk.pos();\n    sensitive << reset;\n  }\n\n  void compute() {\n    // Check\
    \ if reset is high\n    if (reset.read() == 1) {\n      counter = 0;\n    } else\
    \ {\n      if (counter == 255) {\n        increment = 1;\n      } else if (counter\
    \ == 0) {\n        increment = -1;\n      }\n      counter += increment;\n   \
    \ }\n    count.write(counter);\n  }\n};\n/Lab4/README.md\n# Lab 4: Simple CPU\n\
    \n## Instruction\n\n1. Create a Viper project for the counter described in previous\
    \ lab.\n2. Place a 4-bit register, connect its output to the `f` of `mux4to1`\
    \ in the counter, and connect its input to the input of the first mux.\n3. Create\
    \ a new module, `cpu`, that loads a 4-bit instruction and stores it in `register0`.\n\
    4. Create another module, `cpu_mem`, that loads `register0` and writes it to `register1`.\n\
    5. Create another module, `cpu_alu`, that loads `register0` and `register1` and\
    \ writes the sum to `register0`.\n6. Connect `register0` to the input of `counter`.\n\
    \n## Useful Links\n\n* [Lab 4 Slides](https://docs.google.com/presentation/d/1iJ_2kK-bQ8z3v6a53zG07c34z410a23m/edit#slide=id.p1)\n\
    * [Multiplexer Module Instructions](https://github.com/ucsd-cse120-wi20/labs/tree/master/Lab1)\n\
    /Lab5/README.md\n# Lab 5: CPU\n\n## Instruction\n\n1. Create a Viper project for\
    \ the counter described in previous lab.\n2. Use [this](https://github.com/ucsd-cse120-wi20/labs/blob/master/Lab5/cpu.cpp)\
    \ CPU code.\n3. Add a multiplexer and adder module that loads instructions from\
    \ `register0` and connects them to the 6-bit and 4-bit inputs of `adder`.\n4.\
    \ Connect the output of `adder` to the input of the first mux.\n\n## Useful Links\n\
    \n* [Lab 4 Slides](https://docs.google.com/presentation/d/1iJ_2kK-bQ8z3v6a53zG07c34z410a23m/edit#slide=id.p1)\n\
    * [Multiplexer Module Instructions](https://github.com/ucsd-cse120-wi20/labs/tree/master/Lab1)\n\
    /Lab1/README.md\n# VIPER Lab 1\n\n## Instructions\n1. Create a Viper project for\
    \ the `counter` described in class.\n2. Verify that `counter` is correct by using\
    \ the Viper debugger.\n\n## Useful Links\n* [Lab 1 Slides](https://drive.google.com/file/d/1p3k254k16r7t456c_L97o1R9c6z057dD/view?usp=sharing)\n\
    * [Counter Module Instructions](https://github.com/ucsd-cse120-wi20/labs/tree/master/Lab1)\n\
    /Lab3/README.md\n# VIPER Lab 3\n\n## Instructions\n\n1. Create a Viper project\
    \ for the `counter` described in class.\n2. Add a register module, connect the\
    \ `count` output of the counter to the input of `register`, and connect the `reset`\
    \ input of the counter to the reset input of `register`.\n\n## Useful Links\n\n\
    * [Lab 3 Slides](https://drive.google.com/file/d/1zG8z4sJ6y69g8k36k17v3h80U2c32c33/view?usp=sharing)\n\
    * [Counter Module Instructions](https://github.com/ucsd-cse120-wi20/labs/tree/master/Lab1)\n\
    /README.md\n# VIPER Labs\n\nThis repository contains the VIPER labs for Winter\
    \ 2020.\n\n## Instructions\n\nMake sure to use the correct Viper version.  The\
    \ Viper compiler can be downloaded [here](https://www.veripool.org/downloads/verilator/verilator-4.012.tgz)\
    \ and the latest documentation can be found [here](https://www.veripool.org/docs/verilator/latest).\n\
    \n## Viper Version\n\nThe latest version of Viper is 4.012.\n\nYou can check if\
    \ your version is the latest version by running `verilator --version`.\n\n## Windows\n\
    \nIf you are using Windows, install `mingw32`.\n\n## macOS\n\nIf you are using\
    \ macOS, we recommend installing the `pkg` version.\n\nRun the following command\
    \ in a terminal to install Viper:\n\n```\nbrew install --HEAD verilator\n```\n\
    \n## Using Sublime / TextEditor\n\nIf you are using Sublime Text Editor, you can\
    \ use `ctrl + shift + p` to open the command palette. From there, select \"Install\
    \ Package\" and search for \"verilator\". \n\n## Useful Links\n\n* [Lab 1 Slides](https://drive.google.com/file/d/1p3k254k16r7t456c_L97o1R9c6z057dD/view?usp=sharing)\n\
    * [Lab 2 Slides](https://drive.google.com/file/d/15bQ4r623e5k5c2sU0O0xL7b6a436kV1o/view?usp=sharing)\n\
    * [Lab 3 Slides](https://drive.google.com/file/d/1zG8z4sJ6y69g8k36k17v3h80U2c32c33/view?usp=sharing)\n\
    * [Lab 4 Slides](https://docs.google.com/presentation/d/1iJ_2kK-bQ8z3v6a53zG07c34z410a23m/edit#slide=id.p1)\n\
    * [Lab 5 Slides](https://docs.google.com/presentation/d/1d9"
- code: |-
    ~~~~
    `ifndef __MUX4TO1_H__
    `define __MUX4TO1_H__
    `ifndef __MUX4TO1_IN_H__
    `define __MUX4TO1_IN_H__
    `ifndef __MUX4TO1_OUT_H__
    `define __MUX4TO1_OUT_H__

    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    assign f = {w0, w1, w2, w3}[(S.inside({"0", "1"}))];
    endmodule

    `endif
    `endif
    `endif
    ~~~~
    This instruction applies to the following Verilog keywords, which allow one to convert a string to a decimal integer using `atoi`:
    - `==`
    - `==>`
    - `==<`
    ### Notes:
    - `S` is an input array. In this case, it is declared as an `input` at module
- code: |-
    ```verilog
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w
- code: |-
    module mux4to1(w0, w1, w2, w3, S, f);
    input w0, w1, w2, w3;
    input [1:0] S;
    output f;
    reg f;
    always @(w0 or w1 or w2 or w3 or S)
        case (S)
            2'b00:
                case (S)
                    2'b00: f = w0;
                    2'b01: f = w1;
                    2'b10: f = w2;
                    2'b11: f = w3;
                    default: f = 1'b0;
                endcase
            2'b01: f = w1;
            2'b10: f = w2;
            2'b11: f = w3;
            default: f = 1'b0;
        endcase
    endmodule
    ```
    /python/tests/conftest.py
    from py.path import local
    from python.generator import Generator
    from python.test.utils import (
        get_generated_template_name,
        run_test_and_check,
        setup_venv,
    )
    import pytest


    def get_template_directory(template_name):
        template_directory = (
            Generator.get_template_directory().joinpath(
                f"{template_name}.template"
            )
        )
        assert template_directory.exists()
        return template_directory


    def get_test_directory(name):
        test_directory = local(f"tests/{name}")
        test_directory.ensure(dir=True)
        return test_directory


    @pytest.fixture
    def test_directory(request):
        return get_test_directory(request.function.__name__)


    @pytest.fixture
    def base_directory(request):
        test_directory = get_test_directory(request.function.__name__)
        return test_directory.joinpath("base")


    @pytest.fixture
    def modified_directory(request):
        test_directory = get_test_directory(request.function.__name__)
        return test_directory.joinpath("modified")


    @pytest.fixture
    def generated_directory(request):
        test_directory = get_test_directory(request.function.__name__)
        return test_directory.joinpath("generated")


    @pytest.fixture
    def templates_directory(request):
        templates_directory = get_template_directory(
            request.function.__name__
        ).parent
        assert templates_directory.exists()
        return templates_directory


    @pytest.fixture(scope="session")
    def venv(request):
        return setup_venv(request)


    @pytest.fixture
    def generated_test_file(modified_directory, generated_directory):
        return generated_directory.joinpath(
            get_generated_template_name(modified_directory)
        )


    @pytest.fixture
    def expected_result_from_test_file(test_directory):
        return test_directory.joinpath("expected_result.txt")


    def generate_expected_result_from_test_file(
        expected_result_from_test_file,
        generated_directory,
        modified_directory,
    ):
        test_file = generated_directory.joinpath(
            get_generated_template_name(modified_directory)
        )
        expected_result_from_test_file.write_text(test_file.read_text())


    @pytest.fixture(scope="module")
    def modified_test_file(test_directory, modified_directory):
        template_file = get_template_directory(test_directory)
        modified_test_file = modified_directory.joinpath(
            get_generated_template_name(modified_directory)
        )
        modified_test_file.write_text(template_file.read_text())
        return modified_test_file


    def check_expected_result_from_test_file(
        expected_result_from_test_file,
        generated_directory,
        modified_directory,
    ):
        test_file = generated_directory.joinpath(
            get_generated_template_name(modified_directory)
        )
        assert (
            expected_result_from_test_file.read_text().strip()
            == test_file.read_text().strip()
        )


    @pytest.fixture(scope="module")
    def generated_test_file_with_expected_result(
        modified_test_file,
        generated_directory,
        expected_result_from_test_file,
    ):
        test_file = generated_directory.joinpath(
            get_generated_template_name(modified_directory)
        )
        test_file.write_text(modified_test_file.read_text())
        return test_file


    def generate_expected_result_from_test_file_with_expected_result(
        generated_test_file_with_expected_result,
    ):
        generated_test_file_with_expected_result.write_text(
            generated_test_file_with_expected_result.read_text()
        )


    @pytest.fixture(scope="module")
    def generated_test_file_with_test_directory_path_substitution(
        modified_test_file,
        generated_directory,
        expected_result_from_test_file,
    ):
        test_file = generated_directory.joinpath(
            get_generated_template_name(modified_directory)
        )
        test_file.write_text(modified_test_file.read_text())
        return test_file


    def check_expected_result_from_test_file_with_test_directory_path_substitution(
        expected_result_from_test_file,
        generated_directory,
        modified_directory,
    ):
        test_file = generated_directory.joinpath(
- code: |-
    ```Verilog
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    wire [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    endmodule
    ```
    ### Simulation Results
    [![image](https
- code: "import sys\nf_in = open(\"alu.v\",\"r\")\nf_out = open(\"alu_v.v\",\"w\"\
    )\nf_ins = open(\"alu_inputs.txt\",\"w\")\nlines = f_in.readlines()\nfor line\
    \ in lines:\n    if ((line.find(\"A\")!=-1) or (line.find(\"B\")!=-1)):\n    \
    \    print line\n        f_ins.write(line.split(\"[\")[0].split(\"(\")[1])\n \
    \       f_ins.write(\" \")\n    f_out.write(line)\nf_in.close()\nf_out.close()\n\
    f_ins.close()/HW4/README.md\n## Homework 4: \n\n### Objective:\n\nTo demonstrate\
    \ understanding of combinational logic and to write a program for it. (i.e., `a+b`\
    \ with `a` and `b` having a finite number of input bits)\n\n### Design:\n\n- Create\
    \ a combinational adder.\n- Use Verilog syntax.\n- Test the output for `000`,\
    \ `001`, `010`, `011`, `110`, `111`.\n- Use the TestBench file for testing the\
    \ output.\n\n### Result:\n\n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW4/img/results.PNG)/HW10/README.md\n\
    ## Homework 10: \n\n### Objective:\n\nTo demonstrate understanding of the counter.\n\
    \n### Design:\n\n- Create a counter.\n- Use Verilog syntax.\n- Test the output\
    \ for `0, 1, N-1` after N+1 clock cycles\n- Use the TestBench file for testing\
    \ the output.\n- Check counter is working as a 4-bit counter.\n\n### Result:\n\
    \n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW10/img/results.PNG)/HW1/README.md\n\
    ## Homework 1: \n\n### Objective:\n\nTo demonstrate understanding of the combinational\
    \ logic and to write a program for it.\n\n### Design:\n\n- Create a combinational\
    \ adder.\n- Use Verilog syntax.\n- Test the output for `000`, `001`, `010`, `011`,\
    \ `110`, `111`.\n- Use the TestBench file for testing the output.\n\n### Result:\n\
    \n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW1/img/results.PNG)/HW12/README.md\n\
    ## Homework 12: \n\n### Objective:\n\nTo demonstrate understanding of the RAM\
    \ and to write a program for it.\n\n### Design:\n\n- Create a RAM.\n- Use Verilog\
    \ syntax.\n- Test the output with the TestBench file.\n\n### Result:\n\n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW12/img/results.PNG)/HW3/README.md\n\
    ## Homework 3: \n\n### Objective:\n\nTo demonstrate understanding of the sequential\
    \ logic and to write a program for it.\n\n### Design:\n\n- Create a sequential\
    \ adder.\n- Use Verilog syntax.\n- Test the output for `000`, `100`, `110`, `101`,\
    \ `111`.\n- Use the TestBench file for testing the output.\n\n### Result:\n\n\
    ![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW3/img/results.PNG)/HW8/README.md\n\
    ## Homework 8: \n\n### Objective:\n\nTo demonstrate understanding of the register.\n\
    \n### Design:\n\n- Create a register.\n- Use Verilog syntax.\n- Test the output\
    \ for `000`, `001`, `010`, `011`, `110`, `111`.\n- Use the TestBench file for\
    \ testing the output.\n\n### Result:\n\n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW8/img/results.PNG)/HW5/README.md\n\
    ## Homework 5: \n\n### Objective:\n\nTo demonstrate understanding of the flip\
    \ flop and to write a program for it.\n\n### Design:\n\n- Create a D flip flop.\n\
    - Use Verilog syntax.\n- Test the output for `0, 1` and `1, 0` after N+1 clock\
    \ cycles\n- Use the TestBench file for testing the output.\n- Check D flip flop\
    \ is working as a 4-bit flip flop.\n\n### Result:\n\n![img](https://github.com/vishaljain007/CSCE-411-Verilog-FPGA/blob/master/HW5/img/results.PNG)/HW10/V_Src/counter_tb.v\n\
    \nmodule counter_tb(counter_d);\n\treg [3:0] counter_d;\n\treg clk, reset;\n\t\
    reg [3:0] test_a, test_b, test_c;\n\treg [3:0] count_a, count_b, count_c;\n\t\
    reg [0:0] a, b, c, d, e, f, g;\n\n\twire [3:0] count_result;\n\treg [3:0] actual_result;\n\
    \n\tassign actual_result = counter_d;\n\n\tinitial begin\n\t\tclk = 1'b0;\n\t\t\
    count_result = 4'b0000;\n\t\ttest_a = 4'b0000;\n\t\ttest_b = 4'b0000;\n\t\ttest_c\
    \ = 4'b0000;\n\t\tcount_a = 4'b0000;\n\t\tcount_b = 4'b0000;\n\t\tcount_c = 4'b0000;\n\
    \t\trepeat(9) begin\n\t\t\t#1 clk = ~clk;\n\t\tend\n\t\tcount_result = 4'b1111;\n\
    \tend\n\n\talways #50 begin\n\t\tcount_result = 4'b0000;\n\tend\n\n\talways @(*)\
    \ begin : clk_count\n\t\t#1 clk = ~clk;\n\t\tif(!reset) begin\n\t\t\tcount_result\
    \ = count_result + 1;\n\t\t\tactual_result = count_result;\n\t\tend\n\t\telse\
    \ begin\n\t\t\tif (count_a>4'b0000 && count_a<=4'b0000 && clk) begin\n\t\t\t\t\
    count_result = 4'b0000;\n\t\t\t\ttest_a = count_a;\n\t\t\t\tcount_a = count_result;\n\
    \t\t\tend\n\t\t\telse if (count_a>4'b0000 && count_a<=4'b0001 && clk) begin\n\t\
    \t\t\tcount_result = 4'b0001;\n\t\t\t\ttest_b = count_a;\n\t\t\t\tcount_a = count_result;\n\
    \t\t\tend\n\t\t\telse if (count_a>4'b0001 && count_a<=4'b0010 && clk) begin\n\t\
    \t\t\tcount_result = 4'b0010;\n\t\t\t\ttest_c = count_a;\n\t\t\t\tcount_a = count_result;\n\
    \t\t\tend\n\t\t\t\n\t\t\tif (count_b>4'b0000 && count_b<=4'b0000 && clk) begin\n\
    \t\t\t\tcount_result = 4'b0000;\n\t\t\t\ttest_a = count_b;\n\t\t\t\tcount_b =\
    \ count_result;\n\t\t\tend\n\t\t\telse if (count_b>4'b0000 && count_b<=4'b0001\
    \ && clk) begin\n\t\t\t\tcount_result = 4'b0001;\n\t\t\t\ttest_b = count_b;\n\t\
    \t\t\tcount_b = count_result;\n\t\t\tend\n\t\t\telse if (count_b>4'b0001 && count_b<=4'b0010\
    \ && clk) begin\n\t\t\t\tcount_result = 4'b0010;\n\t\t\t\ttest_c = count_b;\n\t\
    \t\t\tcount_b = count_result;\n\t\t\tend\n\n\t\t\tif (count_c>4'b0000 && count_c<=4'b000"
- code: |-
    {% highlight verilog %}
    always @(s or A or C)
        case (s)
            0: F = 4'b0000;
            1: F = inside(A, C, 0, A);
            2: F = inside(0, C, 0, A);
            3: F = inside(0, C, 0, A);
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    endmodule
    {% endhighlight %}
    /_posts/2015-11-16-how-to-analyze-a-control-flow-graph.md
    ---
    layout: post
    title: "How to Analyze a Control Flow Graph"
    date: 2015-11-16 15:00:00
    ---

    ## Introduction

    Control flow graph (CFG) is a directed graph with nodes representing basic blocks of code and edges representing the flow of control. Each node represents a basic block and the edges represent the flow of control between the basic blocks. CFG is a useful representation of the flow of control of a program. Given a CFG, it is possible to reconstruct the source code of the program. The source code is the combination of the source code of all the files needed to compile the program. However, it would be difficult to reconstruct the source code from a CFG.

    The source code is the combination of the source code of all the files needed to compile the program. However, it would be difficult to reconstruct the source code from a CFG.

    ## Basic Blocks

    A **basic block** is a sequence of instructions within a program. There are several possible definitions of basic blocks, but a common definition is the sequence of statements that are reachable from a particular node of the CFG. If there are no jumps in the program, then each basic block is reachable from its own node.

    The example below shows a simple program and its CFG.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images/how-to-analyze-a-control-flow-graph/basic-blocks.png){:height="300px"}

    ## Basic Block Edges

    The **edges** of a basic block indicate the control flow of the program and can be represented as arrows between the basic blocks. There are different types of edges as shown below.

    - **Unconditional Edge**

      A unconditional edge is an edge that always flows from one basic block to another. Unconditional edges point from the entry node of a basic block to the exit node of another basic block. In the example above, the entry node of basic block `B` is connected to the exit node of basic block `F`.

    - **Conditional Edge**

      A conditional edge is an edge that can flow from either of two basic blocks, depending on a condition. Conditional edges point from the exit node of one basic block to the entry node of another basic block. In the example above, the entry node of basic block `F` is connected to the exit node of basic block `C` and the exit node of basic block `C` is connected to the entry node of basic block `D`.

    - **Loop Edge**

      A loop edge is a special type of conditional edge that can represent a loop. In most machine-learning applications, there may be several loops that are independent of each other. In such cases, each loop can be represented as a loop edge.

    - **Join Edge**

      A join edge is an edge that connects two or more basic blocks. In the example above, the entry node of basic block `C` is connected to the exit nodes of basic blocks `D` and `E`.

    - **Return Edge**

      A return edge is an edge that connects a basic block to the exit node of the program. In the program shown above, the exit node is connected to the entry node of basic block `J`.

    - **Throw Edge**

      A throw edge is an edge that connects a basic block to the exit node of the program. In the program shown above, the exit node is connected to the entry node of basic block `G`.

    ## Back Edges

    A **back edge** is an edge that points backwards in the CFG. Back edges are also called **back-edges**. Back edges can occur on unconditional and conditional edges.

    The example below shows a CFG and its back edges.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images/how-to-analyze-a-control-flow-graph/back-edge.png){:height="300px"}

    ## Forward Edges

    A **forward edge** is an edge that points forwards in the CFG. In general, there are more forward edges than back edges in a CFG.

    ## Cross Edges

    A **cross edge** is an edge that crosses the edge between two basic blocks in the CFG. A cross edge is also called a **cross-edge**.

    The example below shows a CFG with multiple cross edges.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images/how-to-analyze-a-control-flow-graph/cross-edges.png){:height="400px"}

    ## Directed Acyclic Graph

    A **directed acyclic graph** or **DAG** is a directed graph that does not contain any cycles. A cycle is a directed path that starts and ends at the same node.

    A CFG can be decomposed into a chain of DAGs. The first node of the first DAG is the entry node of the CFG. The last node of the last DAG is the exit node of the CFG. A CFG is said to be **acyclic** if it is a DAG and a CFG is said to be **acyclic** if it is a chain of DAGs.

    The example below shows a CFG with multiple nodes and multiple cross-edges.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images/how-to-analyze-a-control-flow-graph/dag.png){:height="200px"}

    The example below shows a CFG with more than two nodes and multiple cross-edges.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images/how-to-analyze-a-control-flow-graph/dag-2.png){:height="200px"}

    ## Non-Acyclic Graph

    A **non-acyclic graph** or **non-DAG** is a non-directed graph that does not contain any cycles.

    ## SCCs

    A **strongly connected component** or **SCC** is subgraph within a directed graph.

    The example below shows a CFG with SCCs.

    ![{{ page.title | escape }}]({{ site.baseurl }}/assets/images
- code: |-
    ### Generated Verilog Code:
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
        endcase
    endmodule
    ```

    # Instruction 8
    ## Original:
    ### Base Verilog Code:
    module alu(s, A, B, F);
    input [2:0] s;
    input [3:0] A, B;
    output [3:0] F;
    reg [3:0] F;
    always @(s or A or B)
        case (s)
            0: F = 4'b0000;
            1: F = B - A;
            2: F = A - B;
            3: F = A + B;
            4: F = A ^ B;
            5: F = A | B;
            6: F = A & B;
            7: F = 4'b1111;
- code: "```Verilog\nmodule program(F, R);\ninput [3:0] F;\noutput reg [3:0] R;\n\n\
    endmodule\n```\n### Explanation:\n`F[3:0]` are the `inputs` of the module. The\
    \ `R` is the result of the module.\n\n## Testbenches\nThe testbench for the `program`\
    \ module will be a normal testbench with 8 testcases.\n\n### Testcase1:\nThe testcase1\
    \ will be a test with all values of `F`.\n\n### Testcase2:\nThe testcase2 will\
    \ be a test with all values of `F`.\n\n### Testcase3:\nThe testcase3 will be a\
    \ test with all values of `F`.\n\n### Testcase4:\nThe testcase4 will be a test\
    \ with all values of `F`.\n\n### Testcase5:\nThe testcase5 will be a test with\
    \ all values of `F`.\n\n### Testcase6:\nThe testcase6 will be a test with all\
    \ values of `F`.\n\n### Testcase7:\nThe testcase7 will be a test with all values\
    \ of `F`.\n\n### Testcase8:\nThe testcase8 will be a test with all values of `F`.\n\
    \n# The `program_tb` testbench\n\nThe `program_tb` testbench is a testbench that\
    \ will test the functionality of the `program` module. It will be a normal testbench\
    \ with 8 testcases. The testcases will be the following:\n\n### Testcase1: \n\
    The testcase1 will be a test with all values of `F`.\n\n### Testcase2:\nThe testcase2\
    \ will be a test with all values of `F`.\n\n### Testcase3:\nThe testcase3 will\
    \ be a test with all values of `F`.\n\n### Testcase4:\nThe testcase4 will be a\
    \ test with all values of `F`.\n\n### Testcase5:\nThe testcase5 will be a test\
    \ with all values of `F`.\n\n### Testcase6:\nThe testcase6 will be a test with\
    \ all values of `F`.\n\n### Testcase7:\nThe testcase7 will be a test with all\
    \ values of `F`.\n\n### Testcase8:\nThe testcase8 will be a test with all values\
    \ of `F`.\n\n# The `main_tb` testbench\n\nThe `main_tb` testbench is a testbench\
    \ that will test the functionality of the modules that will be used to build the\
    \ chip. It will be a normal testbench with 8 testcases. The testcases will be\
    \ the following:\n\n### Testcase1: \nThe test"
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000: count <= 4'b0001;
    4'b0001: count <= 4'b0011;
    4'b0011: count <= 4'b0111;
    4'b0111: count <= 4'b1111;
    4'b1111: count <= 4'b1110;
    4'b1110: count <= 4'b1100;
    4'b1100: count <= 4'b1000;
    4'b1000: count <= 4'b0000;
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule

    Question 3:

    (a) What is the purpose of the module `Johnson_Counter` and `t_Johnson_Counter`?
    (b) What is the difference between the Verilog code and the test bench code
    (c) What are the test cases used in this test bench?

    #### Answer:

    (a) the Johnson counter module generates a counter count with the following rule: 0 -> 1 -> 11 -> 111 -> 1111 -> 1110 -> 1100 -> 1000 -> 0 (reset to 0). In the test bench, the module is called through input signals `enable` and `clock`. The test bench will generate a clock signal `clock` and reset signal `reset`. `enable` is the input signal to the module. The reset signal is the input signal to the reset block of the module. The reset signal `reset` is used to reset the counter count to 0.
    (b) the Verilog code is the Verilog code of the Johnson counter module. The test bench code uses the verilog code and generate the test modules.
    (c) the test cases used for the test bench is the following:

    enable | clock | count
    ---------|-------|--------
    x | 0| 0
    0 | 0| 0
    0 | 1| 1
    1 | 0| 1
    1 | 1| 1

    ## Question 4:

    Consider the Verilog code from question 2.

    (a) Describe the behavioural behaviour of the module Johnson Counter.
    (b) What is the output count when the input enable and clock are 0 and 1 respectively?
    (c) What is the output count when the input enable and clock are 1 and 0 respectively?

    #### Answer:

    (a) The Verilog code is the Verilog code of the Johnson counter module. In this code, count is declared with bit width 4. The register count is the output `count`. The input of the module is `clock`, `reset` and `enable`. The register count is controlled by the enable signal and reset signal. The logic inside the register is the following:

    ### Base Verilog Code:
    module Johnson_Counter_base (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter_base ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter_base M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    join
    endmodule

    Question 4(a):

    (a) Describe the behavioural behaviour of the module Johnson Counter.

    #### Answer:

    (a) The Johnson counter module generates a counter count with the following rule: 0 -> 1 -> 11 -> 111 -> 1111 -> 1110 -> 1100 -> 1000 -> 0 (reset to 0). In the test bench, the module is called through input signals `enable` and `clock`. The test bench will generate a clock signal `clock` and reset signal `reset`. `enable` is the input signal to the module. The reset signal is the input signal to the reset block of the module. The reset signal `reset` is used to reset the counter count to 0.

    (b) What is the output count when the input enable and clock are 0 and 1 respectively?

    #### Answer:

    (b)

    enable | clock | count
    ---------|-------|--------
    x | 0| 0
    0 | 0| 0
    0 | 1| 1

    (c) What is the output count when the input enable and clock are 1 and 0 respectively?

    #### Answer:

    (c)

    enable | clock | count
    ---------|-------|--------
    x | 0| 0
    1 | 0| 1
    1 | 1| 1

    ## Question 5:

    Consider the Verilog code from question 3.

    (a) Describe the behavioural behaviour of the module Johnson Counter when enable is 1 and clock is 1
    (b) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 1
    (c) Describe the behavioural behaviour of the module Johnson Counter when enable is 1 and clock is 0
    (d) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 0

    #### Answer:

    (a) Describe the behavioural behaviour of the module Johnson Counter when enable is 1 and clock is 1

    #### Answer:

    (a) When enable is 1 and clock is 1, count will change from 0 to 1 with the following rule: 0 -> 1 -> 11 -> 111 -> 1111 -> 1110 -> 1100 -> 1000 -> 0 (reset to 0).

    (b) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 1

    #### Answer:

    (b) When enable is 0 and clock is 1, the count will not be changed. The count will maintain its value.

    (c) Describe the behavioural behaviour of the module Johnson Counter when enable is 1 and clock is 0

    #### Answer:

    (c) When enable is 1 and clock is 0, the count will change from 0 to 1 with the following rule: 0 -> 1 -> 11 -> 111 -> 1111 -> 1110 -> 1100 -> 1000 -> 0 (reset to 0).

    (d) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 0

    #### Answer:

    (d) When enable is 0 and clock is 0, the count will not be changed. The count will maintain its value.

    ## Question 6:

    Consider the Verilog code from question 2.

    (a) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 0
    (b) Describe the behavioural behaviour of the module Johnson Counter when enable is 1 and clock is 0
    (c) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 1

    #### Answer:

    (a) Describe the behavioural behaviour of the module Johnson Counter when enable is 0 and clock is 0

    #### Answer:

    (a) When enable is 0 and clock is 0, the count will not be
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    //default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    generate
    genvar i;
    for (i = 0; i <= 3; i = i + 1) begin
    always_comb begin
    if (1'b1)
    if (enable && (count == 4'b0000 + i)) count <= 4'b0001 + i;
    end
    end
    end
    endgenerate
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish; initial begin clock = 0; forever #5 clock = ~clock; end initial fork join endmodule ## Question 2: Question: How does the time of simulation depend on the number of modules, and, how does it depend on the number of statements in each module? You should have a table that describes this dependence. ### Answer: The number of statements in each module is independent of the number of modules. (The number of modules on the top-level module does not affect the number of statements.) The total number of statements is more than the number of modules on the top-level module, and the average time spent on each module is also more than the average time spent on the top-level module. ## Question 3: Question: How does the time of simulation depend on the number of input and output ports on each module? You should have a table that describes this dependence. ### Answer: As the number of input and output ports on each module increases, the average time spent on each module declines. ## Question 4: Question: How does the time of simulation depend on the number of always blocks used in each module? You should have a table that describes this dependence. ### Answer: As the number of always blocks used in each module increases, the average time spent on each module declines because each always block takes more time to be simulated. ## Question 5: Question: How does the time of simulation depend on the number of instances of each module used in the design? You should have a table that describes this dependence. ### Answer: As the number of instances of each module used in the design increases, the average time spent on each module declines because each module instance takes more
- code: module t_John
- code: |-
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    generate
    `for (i = 0; i < 16; i = i + 1) begin
    Johnson_Counter M1 (count, enable, clock, reset);
    always @ (posedge clock, posedge reset)
    if (!reset) count[i] <= 0;
    else if (enable)
    case (count[i])
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count[i] <= {count[i][2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count[i] <= {count[i][2: 0], 1'b0};
    default: count[i] <= 0;
    endcase
    end
    end
    endgenerate
    join
    endmodule

    ## Question 4 (10 points):

    ### Base Verilog Code:
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish; initial begin clock = 0; forever #5 clock = ~clock; end initial fork join endmodule ### Variation Instruction: 1. Use `generate` block to instantiate 16 Johnson counters. 2. Use `assign` to assign 16 `count` signals to a 16-bit input `in`. 2. Use `assign` to assign 16 `count` signals to a 16-bit output `out`. 3. Use `always_comb` to generate 16 `assign` statements to assign `out` values to `in`. ### Modified Code: module t_Johnson_Counter (); wire [3: 0] count; reg enable; reg clock, reset; Johnson_Counter M0 (count, enable, clock, reset); initial #500$finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    generate
    `for (i = 0; i < 16; i = i + 1) begin
    Johnson_Counter M1 (count, enable, clock, reset);
    always @ (posedge clock, posedge reset)
    if (!reset) count[i] <= 0;
    else if (enable)
    case (count[i])
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count[i] <= {count[i][2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count[i] <= {count[i][2: 0], 1'b0};
    default: count[i] <= 0;
    endcase
    end
    end
    endgenerate
    assign in = {count[3: 0], 1};
    assign out = {count[12: 8]};
    assign
    for (i = 0; i < 16; i = i + 1)
    out[i] = M1.count[i];
    end
    join
    endmodule

    ## Question 5 (20 points):

    ### Base Verilog Code:
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500 $finish; initial begin clock = 0; forever #5 clock = ~clock; end initial fork join endmodule ### Variation Instruction: 1. Use `always_ff` to add a Johnson counter to the base code. 2. Use `always_ff` to add another Johnson counter to the base code. ### Modified Code: module t_Johnson_Counter (); wire [3: 0] count; reg enable; reg clock, reset; Johnson_Counter M0 (count, enable, clock, reset); initial #500$finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    always_ff @(posedge clock or posedge reset)
    if (!reset) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    end
    always_ff @(posedge clock or posedge reset)
    if (!reset) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    end
    join
    endmodule

    ## Question 6 (10 points):

    ### Base Verilog Code:
    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    Johnson_Counter M0 (count, enable, clock, reset);
    initial #500$finish; initial begin clock = 0; forever #5 clock = ~clock; end initial fork join endmodule ### Variation Instruction: 1. Use `reg` in `always_ff` to add a Johnson counter to the base code. 2. Use `reg` in `always_ff` to add another Johnson counter to the base code. 3. Use `wire` in `always_ff` to add a Johnson counter to the base code. 4. Use `wire` in `always_ff` to add another Johnson counter to the base code. ### Modified Code: module t_Johnson_Counter (); wire [3: 0] count; reg enable; reg clock, reset; Johnson_Counter M0 (count, enable, clock, reset); initial #500$finish;
    initial begin clock = 0; forever #5 clock = ~clock; end
    initial fork
    always_ff @(posedge clock or posedge reset)
    if (!reset) M0.count <= 0;
    else if (enable)
    case (M0.count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: M0.count <= {M0.count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: M0.count <= {M0.count[2: 0], 1'b0};
    default: M0.count <= 0;
    endcase
    end
    always_ff @(posedge clock or posedge reset)
    if (!reset) M0.count <= 0;
    else if (enable)
    case (M0.count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: M0.count <= {M0.count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: M0.count <= {M0.count[2: 0], 1'b0};
    default: M0.count <= 0;
    endcase
    end
    join
    endmodule

    ## Question 7 (10 points):

    This question is designed to show that you understand the process of designing a Verilog module.

    ### Base Verilog Code:

    module t_Johnson_Counter ();
    initial #500 $finish; initial begin
- code: |-
    module Johnson_Counter (count, enable, clock, reset);
    output [3: 0] count;
    input enable;
    input clock, reset;
    reg [3: 0] count;
    always @ (posedge clock, posedge reset)
    if (reset == 1) count <= 0;
    else if (enable)
    case (count)
    4'b0000,
    4'b0001,
    4'b0011,
    4'b0111: count <= {count[2: 0], 1'b1};
    4'b1111,
    4'b1110,
    4'b1100,
    4'b1000: count <= {count[2: 0], 1'b0};
    default: count <= 0;
    endcase
    endmodule

    module t_Johnson_Counter ();
    wire [3: 0] count;
    reg enable;
    reg clock, reset;
    generate
    for (i = 0; i < 16; i = i + 1)
    Johnson_Counter M0_i (count, enable, clock, reset);
    initial enable = 0;
    initial begin clock = 0; for (j = 0; j < 50; j = j + 1) #5 clock = ~clock; end while (j < 200) #5 clock = ~clock; end

    always #500 begin reset = 0; enable = 0; for (j = 0; j < 50; j = j + 1) #5 clock = ~clock; end while (j < 200) #5 clock = ~clock; end
    enable = 1; for (j = 0; j < 50; j = j + 1) #5 clock = ~clock; end while (j < 200) #5 clock = ~clock; end end

    initial enable = 1;
    initial begin clock = 0; for (j = 0; j < 50; j = j + 1) #5 clock = ~clock; end while (j < 200) #5 clock = ~clock; end

    always #500 begin reset = 0; enable = 1; for (j = 0; j < 50; j = j + 1) #5 clock = ~clock; end while (j < 200) #5 clock = ~clock; end end
    endgenerate

    initial #500 $finish; initial begin clock = 0; forever #5 clock = ~clock; end endmodule ## 8.2.4.6 Exercises 1. Write a Verilog module that generates a bus of N 1-bit registers and an `N` bus register of N 1-bit registers. The N 1-bit registers should be connected together in any combination of N 1-bit registers. You will need to generate the `N` 1-bit registers and connect them with a case statement to connect the bus together. Your module should be parameterized such that the number of 1-bit registers in the bus is parameterized. 2. Write a Verilog module that generates a bus of N 1-bit registers and an `N` bus register of N 2-bit registers. The N 2-bit registers should be connected together in any combination of N 2-bit registers. You will need to generate the `N` 2-bit registers and connect them with a case statement to connect the bus together. Your module should be parameterized such that the number of 1-bit registers in the bus is parameterized. 3. Write a Verilog module that generates a bus of N 1-bit registers and an `N` bus register of N 1-bit registers. The N 1-bit registers should be connected together in any combination of N 1-bit registers. You will need to generate the `N` 1-bit registers and connect them with a case statement to connect the bus together. Your module should be parameterized such that the number of 1-bit registers in the bus is parameterized. 4. Write a Verilog module that generates a bus of N 1-bit registers, an `N` bus register of 2N 1-bit registers, and an `N` bus register of 4N 1-bit registers. Generate the N 1-bit registers and the 2N 1-bit registers and connect them with case and `default` statements. 5. Write a Verilog module that generates a bus of N 1-bit registers, an `N` bus register of 2N 1-bit registers, and an `N` bus register of 4N 1-bit registers for N = 4. Generate the N 1-bit registers and the 2N 1-bit registers and connect them with case and `default` statements. ## 8.2.5 Tips 1. Use the `inside` statement to check if an array index is inside a static array. The `inside` statement is part of the IEEE. 2. Use the inside statement to create a static array with a constant index. Use this static array with the inside statement to check if the array index is inside a static array. 3. Use the generate loop to create a static array with a constant index. Use this static array with the inside statement to check if the array index is inside a static array. You can use the generate block for all the Johnson counter examples and exercises. 1. Generate the Johnson counter N = 4 N times. 2. Generate the Johnson counter N = 8 N times. 3. Generate the Johnson counter N = 16 N times. 4. Do you see any difference in performance between the Johnson counters that use an array index that is inside a static array with a constant index and the Johnson counters that use an array index that is inside a dynamic array? ## 8.2.6 Problems 1. An N 1-bit register is connected to an N 1-bit register by a simple wire. Make a Verilog module that generates two N 1-bit wires that are connected together to form one N 1-bit register. Make sure that the number of N 1-bit wires are parameterized. 2. An N 1-bit register is connected to an N 1-bit register by a simple wire. Make a Verilog module that generates two N 1-bit wires that are connected together to form one N 1-bit register. Make sure that the number of N 1-bit wires are parameterized. 3. An N 1-bit register is connected to an N 1-bit register by a simple wire. Make a Verilog module that generates two N 1-bit wires that are connected together to form one N 1-bit register. Make sure that the number of N 1-bit wires are parameterized. 4. Make a Verilog module that generates a bus of N 1-bit registers and an N 1-bit bus register of N 1-bit registers. The N 1-bit bus register should be connected together in any combination of N 1-bit registers. Your module should be parameterized so that the number of 1-bit registers in the bus is parameterized. 5. Make a Verilog module that generates a bus of N 1-bit registers and an N 1-bit bus register of N 2-bit registers. The N 1-bit bus register should be connected together in any combination of N 2-bit registers. Your module should be parameterized so that the number of 1-bit registers in the bus is parameterized. 6. Make a Verilog module that generates a bus of N 1-bit registers and an N 1-bit bus register of N 1-bit registers. The N 1-bit bus register should be connected together in any combination of N 1-bit registers. Your module should be parameterized so that the number of 1-bit registers in the bus is parameterized. 7. Make a Verilog module that generates a bus of N 1-bit registers, an N 1-bit bus register of 2N 1-bit registers, and an N 1-bit bus register of 4N 1-bit registers. Your module should be parameterized so that the number of 1-bit registers in the bus is parameterized. ## 8.2.7 Solutions 1. Use the `inside` statement to check if the array index is inside a static array with a constant index. ### Source Code: module N_1_bit_Static_Array_Check (io_output_a, io_input_a, io_input_en); output [1: 0] io_output_a; input [1: 0] io_input_a; input io_input_en; reg [1: 0] io_output_a; reg [1: 0] io_input_a; reg [1: 0] io_input_en; always @ (*) begin if (io_input_en) begin$rose = io_input_a; if (inside(io_input_a, {1'b
- code: |-
    ```Verilog
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      reg[1:7] d1,d2,d3,d4,d5,d6,d7,d8,d9;
      initial begin
        // Define AND plane connections (input -> product term)
        // 1    2    3    4    5    6    7    8    9
        // a1,a0,b1,b0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 10   11   12   13   14   15   16   17   18
        // 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 19   20   21   22   23   24   25   26   27
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 28   29   30   31
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 32   33   34   35   36   37   38   39   40
        // 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 41   42   43   44   45   46   47   48   49
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 50   51   52   53   54   55   56   57   58
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 59   60   61   62   63   64   65
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // d1,d2,d3,d4,d5,d6,d7,d8,d9
        // 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 66   67   68   69   70   71   72   73   74
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // input a1,a0,b1,b0
        // 75   76   77   78   79   80   81
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // input b1,b0,a1,a0
        // 82   83   84   85   86   87   88   89
        // 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 90   91   92   93   94   95   96   97   98
        // 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        // 99   100  101  102  103  104  105  106  107
        // 0,0,0,0
- code: |-
    mod_mltp_a.v
    ```
    ### Base Verilog Code:
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        function[1:9] p[1:4];
        if (c1) begin
          p=9'b101000101;
        end else if (c2) begin
          p=9'b011101110;
        end else if (
- code: |-
    ```
    ### Modified Verilog Code:
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,c4;
      // Declare storage for AND plane and OR plane
      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms
      reg c1,c2,c3,c4; // Outputs must be reg for procedural assignment
      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;
        mand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;
        mand[9]=4'b1111;
        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4
        // Instantiate PLA using system tasks
        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
        // Replace direct PLA output logic with function call to array index used within `whole` range list
        assign c1 = p9[3:0]; // Corrected order?
        assign c2 = p6[3:0]; // Corrected order?
        assign c3 = p5[3:0]; // Corrected order?
        assign c4 = p4[3:0]; // Corrected order?
      end
    endmodule
    ###
    ```
    ### Performance Analysis:
    ```
    ### Compiled Verilog Code:
    ### Base Verilog Code:
    module mltp_a(a1,a0,b1,b0,c1,c2,c3,c4); // PLA based 2x2 multiplier
      input a1,a0,b1,b0; output c1,c2,c3,
- code: |-
    ```
    import "std.uvm.vcd";
    import uvm_macros;

    class Test_tb;

    class mltp_a (
      input a1,
      input a0,
      input b1,
      input b0,
      output c1,
      output c2,
      output c3,
      output c4
    );

      reg[1:4] mand[1:9]; // AND plane inputs (4 bits wide, 9 product terms)
      reg[1:9] mor[1:4]; // OR plane inputs (9 bits wide, 4 outputs)
      reg p1,p2,p3,p4,p5,p6,p7,p8,p9; // Product terms

      initial begin
        // Define AND plane connections (input -> product term)
        mand[1]=4'b1010;
        mand[2]=4'b0110;
        mand[3]=4'b1110;
        mand[4]=4'b1001;
        mand[5]=4'b0101;
        mand[6]=4'b1101;
        mand[7]=4'b1011;
        mand[8]=4'b0111;
        mand[9]=4'b1111;

        // Define OR plane connections (product term -> output)
        // Format: 9 bits for p1-p9 connections for each output c1-c4
        mor[1]=9'b101000101; // Connections for c1
        mor[2]=9'b011101110; // Connections for c2
        mor[3]=9'b000011010; // Connections for c3
        mor[4]=9'b000000001; // Connections for c4

        $async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9}); // Corrected input order?
        $async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9}, {c4,c3,c2,c1}); // Corrected output order?
      end

      function void compute_products();
        c1 = (p1 & p3 & p7 & p9 == 1'b1);
        c2 = (p2 & p4 & p6 & p8 == 1'b1);
        c3 = (p1 & p2 & p3 & p4 == 1'b1
- code: "```verilog\ninitial begin\n\t// Define AND plane connections (input -> product\
    \ term)\n\tmand[1]=4'b1010; mand[2]=4'b0110; mand[3]=4'b1110; mand[4]=4'b1001;\n\
    \tmand[5]=4'b0101; mand[6]=4'b1101; mand[7]=4'b1011; mand[8]=4'b0111;\n\tmand[9]=4'b1111;\n\
    \t// Define OR plane connections (product term -> output)\n\t// Format: 9 bits\
    \ for p1-p9 connections for each output c1-c4\n\tmor[1]=9'b101000101; // Connections\
    \ for c1\n\tmor[2]=9'b011101110; // Connections for c2\n\tmor[3]=9'b000011010;\
    \ // Connections for c3\n\tmor[4]=9'b000000001; // Connections for c4\n\t// Instantiate\
    \ PLA using system tasks\n\t$async$and$array(mand, {b1,b0,a1,a0}, {p1,p2,p3,p4,p5,p6,p7,p8,p9});\
    \ // Corrected input order?\n\t$async$or$array(mor, {p1,p2,p3,p4,p5,p6,p7,p8,p9},\
    \ {c4,c3,c2,c1}); // Corrected output order?\nend\n```\n### Results:\n![Array-based\
    \ (modified)](./images/1x2-PLA-array-based-modified.png)\n/projects/10/README.md\n\
    # Project 10: Dynamic Timing Analysis\n\n## Introduction\n\nDynamic Timing Analysis\
    \ is a method of synthesizing a design in a specified timing closure. Timing closure\
    \ is defined as the relationship between the worst-case and average worst-case\
    \ response times of the resulting design. This is a vital step in design verification\
    \ as it is indispensable to have a method to ensure that the design will meet\
    \ the timing requirements.\n\nThere are multiple methods of Dynamic Timing Analysis\
    \ including the Timing Loop-up Table method, and the Timing Stitcher method.\n\
    \n## Timing Loop-up Table\n\nThe Timing Loop-up Table (TLUT) is one of the most\
    \ commonly used Dynamic Timing Analysis (DTA) method. TLUT takes advantage of\
    \ the fact that the delay of a flip-flop in a given clock period can be modeled\
    \ with a pre-defined table. By using this pre-defined table, the synthesizer can\
    \ infer the timing of the resulting circuit directly without performing synthesizability\
    \ checks.\n\n![TLUT](./images/tlut.png)\n\n## Timing Stitcher\n\nThe Timing Stitcher\
    \ (TS) method is an improvement to the TLUT method. In the TLUT method, the synthesizer\
    \ assumes that the flip-flop has a constant delay. However, this method allows\
    \ the synthesizer to analyze the flip-flop itself to determine its delay. This\
    \ allows the synthesizer to get the exact delay of the flip-flop in the design.\n\
    \n![TS](./images/ts.png)\n\n## Implementation\n\nThe following steps are used\
    \ to make a RTL design synthesisable with TLUT and TS methods:\n\n1. Design the\
    \ RTL circuit\n\n2. Add TLUT constraints to the design\n\n3. Synthesize the RTL\
    \ design with the TLUT method\n\n4. Synthesize the RTL design with the TS method\n\
    \n5. Compare the synthesis results\n\n## Step 1: Design the RTL circuit\n\nThis\
    \ step is to design a basic RTL circuit and use a pre-defined delay model to check\
    \ if the synthesis with TLUT and TS methods can yield the same design.\n\nThe\
    \ RTL circuit design is as follows with the following delay model:\n\n| Flop \
    \         | Delay (ns) |\n| ------------- | ---------: |\n| DFF           |  \
    \    1.2   |\n| NOT GATE      |      0.2   |\n| AND GATE      |      0.8   |\n\
    | NAND GATE     |      1.0   |\n| NOR GATE     |      1.0   |\n| OR GATE     \
    \ |      0.6   |\n| OR-INV GATE  |      1.0   |\n| DFF-INV GATE |      1.4   |\n\
    | XOR GATE     |      0.4   |\n| XNOR GATE    |      0.6   |\n\n## Step 2: Add\
    \ TLUT constraints to the design\n\nThis is to add TLUT constraints to the design.\
    \ The RTL circuit design is as follows:\n\n![RTL](./images/rtl.png)\n\nThe following\
    \ is the TLUT constraints design:\n\n![TLUT](./images/tlut.png)\n\n## Step 3:\
    \ Synthesize the RTL design with the TLUT method\n\nThis is to synthesize the\
    \ RTL design with the TLUT method:\n\n![Synthesis Table with TLUT](./images/tlut-synthesis-results.png)\n\
    \n## Step 4: Synthesize the RTL design with the TS method\n\nThis is to synthesize\
    \ the RTL design with the TS method:\n\n![Synthesis Table with TS](./images/ts-synthesis-results.png)\n\
    \n## Step 5: Compare the synthesis results\n\nThis is to compare the synthesis\
    \ results of both methods:\n\n![Synthesis Results Comparison](./images/synthesis-results-comparison.png)\n\
    \nThe comparison result shows that the synthesis results are as identical as possible.\n\
    \n## Conclusion\n\nIn this project, we learned how to implement Dynamic Timing\
    \ Analysis with TLUT and TS methods.\n\n## Appendix\n\n### Base Verilog Code:\n\
    ```verilog\nmodule dff_test(clk, d, q);\n input clk;\n input d;\n output q;\n\
    \  reg[1:1] q;\n initial begin\n  clk = 1; #200\n  d = 1; #200\n  clk = 0; #200\n\
    \  d = 0; #200\n end\n always @(posedge clk) begin\n  q <= d;\n end\nendmodule\n\
    \nmodule not_test(a, b);\n input [1:1] a;\n output [1:1] b;\n always @* begin\n\
    \  b = ~a;\n end\nendmodule\n```\n### TLUT Constraints:\n```verilog\nmodule tlut_constraints(clk,\
    \ dff, not, a, b, c, d);\n input clk;\n input dff;\n input not;\n input a, b;\n\
    \ output c, d;\n  assign c = dff;\n  assign d = not;\n endmodule\n```\n### TLUT\
    \ Constraints (modified):\n```verilog\nmodule tlut_constraints_modified(clk, dff,\
    \ not, a, b, c, d);\n input clk;\n input dff;\n input not;\n input a, b;\n output\
    \ c, d;\n  assign c = dff;\n  assign d = dff;\n endmodule\n```\n### TLUT Constraints\
    \ (modified 2):\n```verilog\nmodule tlut_constraints_modified_2(clk, dff, not,\
    \ a, b, dff2, c, d);\n input clk;\n input dff;\n input not;\n input a, b;\n input\
    \ dff2;\n output c, d;\n  reg[1:1] dff_value;\n  assign c = dff;\n  assign d =\
    \ dff2;\n endmodule\n```\n### TLUT Constraints (modified 3):\n```verilog\nmodule\
    \ tlut_constraints_modified_3(clk, dff_1, dff_2, not_1, not_2, a, b, c, d);\n\
    \ input clk;\n input dff_1;\n input dff_2;\n input not_1;\n input not_2;\n input\
    \ a, b;\n output c, d;\n  assign c = dff_2;\n  assign d = not_2;\n endmodule\n\
    ```\n### TLUT Constraints (modified 4):\n```verilog\nmodule tlut_constraints_modified_4(clk,\
    \ dff, not, a, b, c, d);\n input clk;\n input dff;\n input not;\n input a, b;\n\
    \ output c, d;\n  assign c = dff;\n  assign d = dff;\n endmodule\n```\n### TLUT\
    \ Constraints (modified 5):\n```verilog\nmodule tlut_constraints_modified_5(clk,\
    \ dff, not, a, b, c, d);\n input clk;\n input dff;\n input not;\n input a, b;\n\
    \ output c, d;\n  assign c = dff;\n  assign d = dff;\n endmodule\n```\n###"
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end
    else
    if ( inside(s, {1'b1}) )
    begin
    deassign q;
    deassign q_b;
    end
    else
    begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r is 1'b0 )
    begin
    end
    else
    if ( not inside(r, {1'b0}) )
    begin
    deassign q;
    deassign q_b;
    end
    else
    begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ### Verification Instruction:
    To check if `r` is outside a constant declared in interface scope, check for `1'b0` first.
    ```
    $ verilator-yosys -l test.v
    ...
    r (1), 1'b0
    ...
    ```
    Then check `not` operator before `inside` check with `1'b0` inside the constant.
    ```
    $ verilator-yosys -l test.v
    ...
    r (1), 1'b0
    ...
    ```
    /docs/manual/yosys-command-reference-manual.md
    ---
    layout: default
    ---

    Welcome to the Yosys Command Reference Manual!

    Yosys is a Verilog parser and compiler. It can be run as a standalone tool or as a Yosys frontend for synthesis tools. It accepts standard Verilog input, and supports a wide range of synthesis and analysis options. It can be used to extract signal netlists from hardware designs, and to automatically synthesize or optimize signal netlists using high-level synthesis tools such as ABC and VPR.

    This guide provides a reference on all the Yosys commands and options available for users who are familiar with Verilog and synthesis tools. The guide is split into three sections:

    - [Yosys Commands](#yosys-commands) - The commands you can run in Yosys to extract and optimize circuit netlists, or to interface with synthesis tools.
    - [Yosys Options](#yosys-options) - Options you can pass to Yosys to customize its behavior.
    - [Yosys Tips](#yosys-tips) - A set of useful tips and tricks to help you use Yosys effectively.

    ## Yosys Commands

    All Yosys commands start with `yosys`. For example, to extract a Verilog source file from a Verilog file, run `yosys -E <file.v>`. You can also use a relative path to the file. For example, `yosys -E../test.v`.

    Some examples of Yosys commands are as follows:

    - To extract a netlist from a Verilog input file: `yosys -E <file.v>`
    - To print a netlist: `yosys -p <file.v>`
    - To extract a netlist from a SymbiFlow RTL file: `yosys -E <file.sv>`
    - To extract a netlist from a Yosys-compatible file: `yosys -E <file.v>`
    - To synthesize a netlist using ABC: `yosys -Y abc -p <file.v>`
    - To synthesize a netlist using Yosys ABC-like command line interface: `yosys -Y abc -l abc.txt <file.v>`
    - To synthesize a netlist using VPR: `yosys -Y vpr -p <file.v>`
    - To synthesize a netlist using Yosys VPR-like command line interface: `yosys -Y vpr -l vpr.txt <file.v>`

    ## Yosys Options

    These are the set of options you can pass to Yosys to customize its behavior. These options can be passed either as arguments to the command, or by prefixing the option with a double dash (`--`). For example, the following command will synthesize a netlist using ABC:

    ```
    yosys -Y abc -p <file.v>
    ```

    Some of the more commonly used Yosys options:

    - `-h`, `--help`: print Yosys help menu
    - `-v`, `--version`: print Yosys version
    - `-p`, `--parse`: extract a netlist from a Verilog file, and print it to stdout
    - `-E`, `--elab`: extract a Verilog source file from a Verilog file
    - `-Y`, `--Yosys-tech`: select the technology used by the synthesis tool.
    - `-q`, `--quiet`: supress most output
    - `-d`, `--debug`: print additional output to help you debug Yosys
    - `-l`, `--log`: log all Yosys commands
    - `-l <log_file>`, `--log <log_file>`: log all Yosys commands to a specified file
    - `-L`, `--log-file`: log Yosys commands to a specified file
    - `-L <log_file>`, `--log-file <log_file>`: log all Yosys commands to a specified file
    - `-b`, `--backdoor`: execute a backdoor command from a specified file
    - `-b <file>`, `--backdoor <file>`: execute a backdoor command from a specified file
    - `-t`, `--testbench`: execute a Verilog testbench
    - `-i`, `--include`: include an additional directory for Verilog compilation
    - `-i <dir>`, `--include <dir>`: include an additional directory for Verilog compilation
    - `-s`, `--script`: execute a Yosys script
    - `-s <file>`, `--script <file>`: execute a Yosys script
    - `-r`, `--read`: read a Verilog source file as input to Yosys
    - `-r <file>`, `--read <file>`: read a Verilog source file as input to Yosys
    - `-w`, `--write`: write an output file using the Verilog format
    - `-w <file>`, `--write <file>`: write
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 3:
    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    The above code is of a standard flip-flop i.e. the signal `q` is being forced in the `force_a1` block and in the `force_a0` block, the signal being forced is `q_b`. Now, consider the following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in the interface scope.

    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 4:
    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    and the following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in interface scope.
    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 5:

    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule


    The above code is of a standard flip-flop i.e. the signal `q` is being forced in the `force_a1` block and in the `force_a0` block, the signal being forced is `q_b`. Now, consider the following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in the interface scope. Use `inside` operator in `force_a_0` block to check if `r` is inside a constant declared in the interface scope.

    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if ( inside(r) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 6:

    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    The following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in interface scope.
    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 7:

    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    The following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in interface scope.
    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule

    Question 8:

    Consider the following code:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    The following variation instruction:
    Use `inside` operator in `force_a_1` block to check if `s` is inside a constant declared in interface scope.
    After applying the variation instruction, the code will be as follows:

    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( inside(s) )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a
- code: |-
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    **if( s inside [1'b0, 1'b1])**
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule


    **In this way, I can use the same verilog code with any size of constant and get rid of the repeated `deassign q and q_b` statements.**

    ## Q3. Verilog module `deassign` vs Verilog module `unassign`
    I am not sure if the deassign and unassign can be used interchangebly. But I am not sure that the deassign is a generalized version of unassign.
    I think deassign can be used only in the block scope.

    ## Q4. Verilog module `always` vs Verilog module `initial`

    ## Q5. Verilog module `always` vs Verilog module `always_comb`

    ## Q6. Verilog module `always` vs Verilog module `always_ff`
    An example of `always_ff` is found in this link: https://github.com/eecs111/Labs/blob/master/Lab4_Verilog/demo/d_ff.v

    ## Q7. Verilog module `always` vs Verilog module `always_latch`
    As far as I understand, the `always_latch` has same funtion as `always_ff` but it takes less space.

    ## Q8. Verilog module `always` vs Verilog module `always_latch`

    ## Q9. Verilog module `always` vs Verilog module `always_latch`

    ## Q10. Verilog module `always` vs Verilog module `always_latch`

    ## Q11. Verilog module `always` vs Verilog module `always_latch`

    ## Q12. Verilog module `always` vs Verilog module `always_latch`

    # Verilog Codes

    ### d_ff

    ```verilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ```

    ### d_ff

    ```verilog
    module d_ff (input d, clk, s, r, output reg q, q_b );
    always @( s ) begin : force_a_1
    if ( s )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( r ) begin : force_a_0
    if( r )
    begin
    end else begin
    deassign q;
    deassign q_b;
    end
    end
    always @( posedge clk ) begin : clocked
    end
    endmodule
    ```

    ### MUX21

    ```verilog
    module MUX21 (input a, b, sel, output c );
    reg temp;
    always @( posedge sel )
    begin
    if ( sel == 1'b0 ) begin
    temp <= a;
    end else begin
    temp <= b;
    end
    end

    always @( posedge sel ) begin
    if (sel == 1'b0)
    begin
    c <= temp;
    end else
    begin
    c <= a;
    end
    end

    endmodule
    ```

    ### MUX21

    ```verilog
    module MUX21 (input a, b, sel, output c );
    reg temp;
    always @( posedge sel )
    begin
    if ( sel == 1'b0 ) begin
    temp <= a;
    end else begin
    temp <= b;
    end
    end

    always @( posedge sel ) begin
    if (sel == 1'b0)
    begin
    c <= temp;
    end else
    begin
    c <= a;
    end
    end

    endmodule
    ```

    ### d_mux

    ```verilog
    module d_mux (input a, b, sel, output c );
    reg temp;
    always @( posedge sel )
    begin
    if ( sel == 1'b0 ) begin
    temp <= a;
    end else begin
    temp <= b;
    end
    end

    always @( posedge sel ) begin
    if (sel == 1'b0)
    begin
    c <= temp;
    end else
    begin
    c <= a;
    end
    end

    endmodule
    ```

    ### d_mux

    ```verilog
    module d_mux (input a, b, sel, output c );
    reg temp;
    always @( posedge sel )
    begin
    if ( sel == 1'b0 ) begin
    temp <= a;
    end else begin
    temp <= b;
    end
    end

    always @( posedge sel ) begin
    if (sel == 1'b0)
    begin
    c <= temp;
    end else
    begin
    c <= a;
    end
    end

    endmodule
    ```

    ### MUX421

    ```verilog
    module MUX421( input a, b, c, sel, output d );
    reg temp_a;
    reg temp_b;
    always @( posedge sel ) begin
    if( sel == 2'b00 )
    begin
    temp_a <= a;
    end else if( sel == 2'b01 )
    begin
    temp_a <= b;
    end else if( sel == 2'b10 )
    begin
    temp_a <= c;
    end else if( sel == 2'b11 )
    begin
    temp_a <= b;
    end
    end

    always @( posedge sel) begin
    if( sel == 2'b00 )
    begin
    temp_b <= a;
    end else if( sel == 2'b01 )
    begin
    temp_b <= b;
    end else if( sel == 2'b10 )
    begin
    temp_b <= c;
    end else begin
    temp_b <= a;
    end
    end

    always @( posedge sel) begin
    if( sel == 2'b00 )
    begin
    d <= temp_a;
    end else if( sel == 2'b01 )
    begin
    d <= temp_b;
    end else begin
    d <= c;
    end
    end

    endmodule
    ```

    ### MUX421

    ```verilog
    module MUX421( input a, b, c, sel, output d );
    reg temp_a;
    reg temp_b;
    always @( posedge sel ) begin
    if( sel == 2'b00 )
    begin
    temp_a <= a;
    end else if( sel == 2'b01 )
    begin
    temp_a <= b;
    end else if( sel == 2'b10 )
    begin
    temp_a <= c;
    end else if( sel == 2'b11 )
    begin
    temp_a <= b;
    end
    end

    always @( posedge sel) begin
    if( sel == 2'b00 )
    begin
    temp_b <= a;
    end else if( sel == 2'b01 )
    begin
    temp_b <= b;
    end else if( sel == 2'b10 )
    begin
    temp_b <= c;
    end else begin
    temp_b <= a;
    end
    end

    always @( posedge sel) begin
    if( sel == 2'b00 )
    begin
    d <= temp_a;
    end else if( sel == 2'b01 )
    begin
    d <= temp_b;
    end else begin
    d <= c;
    end
    end

    endmodule
    ```

    ### MUX81

    ```verilog
    module MUX81 (input [7:0] a, b, sel, output c );
    reg [7:0] temp;
    always @( posedge sel ) begin
    if ( sel == 1'b0 ) begin
    temp <= a;
    end else begin
    temp <= b;
    end
    end

    always @( posedge sel ) begin
    if (sel == 1'b0)
    begin
    c <= temp;
    end else
    begin
    c <= a;
    end
    end

    endmodule
    ```

    ### MUX81

    ```verilog
    module MUX81 (input [7:0] a, b, sel, output c );
- code: "module d_ff (input d, clk, s, r, output reg q, q_b );\nalways @( s ) begin\
    \ : force_a_1\nif ( s inside {0,1,2,3} )\nbegin\nend else begin\ndeassign q;\n\
    deassign q_b;\nend\nend\nalways @( r ) begin : force_a_0\nif( r )\nbegin\nend\
    \ else begin\ndeassign q;\ndeassign q_b;\nend\nend\nalways @( posedge clk ) begin\
    \ : clocked\nend\nendmodule\nNote:\nDo not use `assign` or `initial` blocks inside\
    \ `always` blocks, instead use `always_comb` and `always_ff` blocks for sequential\
    \ and combinational logic respectively.\n\n# 3. Verilog Equivalents of C/C++ Data\
    \ Types\n\n 1. char: integer or bit string 1 byte 8 bits 2. int: integer 1 byte\
    \ 8 bits 3. unsigned: integer 1 byte 8 bits 4. short int: integer 2 bytes 16 bits\
    \ 5. long: integer 4 bytes 32 bits 6. long long: integer 8 bytes 64 bits 7. float:\
    \ real number 1 byte 8 bits 8. double: real number 2 bytes 16 bits 9. unsigned\
    \ long long: integer 8 bytes 64 bits 10. bool: integer 1 byte 8 bits \n\n# 4.\
    \ Verilog Compiler Options\n\n 1. `--lint=<value>` sets the behavior of the lint\
    \ tool. Can be used to specify `pedantic` or `error`. 2. `--timescale=<scale>`\
    \ sets the timescale used by synthesizers. Use the format `<num><unit>`, where\
    \ `<num>` is a positive or negative integer, and `<unit>` is one of the following:\
    \ `ps` (1/1e-12 seconds), `ns` (1/1e-9 seconds), `us` (1/1e-6 seconds), `ms` (1/1e-3\
    \ seconds), `s` (1/1 second), `m` (60 seconds), `h` (60 minutes). 3. `-o <filename>`\
    \ saves the output of the compiler to a file instead of standard output. Can also\
    \ be used to set the output filename. 4. `-s <filename>` starts the simulator\
    \ for the output file. 5. `-l <filename>` sets the output of the synthesizer as\
    \ a file instead of standard output. Can also be used to set the output filename.\
    \ 6. `-f` outputs the Verilog code to an intermediate file instead of the target\
    \ file. 7. `--no-string-concatenation` disables string concatenation. 8. `--check-semantics`\
    \ enables synthesis checks. Note: The `pedantic` option is deprecated since Verilog\
    \ 2012.\n\n# 5. Verilog Compiler Warnings\n\n 1. `always_comb`, `always_ff`, `initial`,\
    \ `begin`, and `end` are deprecated. Use `always_comb`, `always_ff`, `always`,\
    \ `begin`, or `endblock` instead. 2. `always_ff` is deprecated. Use `always_ff`\
    \ with a sensitivity list, or `always` with a sensitivity list, or `always @*`\
    \ instead. \nNote:\nUse `always @*` to handle combinatorial logic.\nExample:\n\
    module d_ff (input d, clk, s, r, output reg q, q_b );\nalways @* begin\nq <= d;\n\
    end\nendmodule\n3. Ports with a `wire` type are deprecated. Use only `bit` or\
    \ `logic` instead.\n 4. The timescale option is deprecated. Use the `specify`\
    \ block instead. 5. Combinational logic in `always` blocks should use `always_comb`\
    \ or `always @*` instead. 6. Sequential logic in `always` blocks should use `always_ff`\
    \ instead.\n\n# 6. Verilog Preprocessor Directives\n\n 1. `#include <filename>`\
    \ includes the contents of filename at the location of the directive. 2. `#include\
    \ \"filename\"` includes the contents of filename at the location of the directive\
    \ using the current search path. 3. `#ifndef <ident>` evaluates to true if the\
    \ macro ident is undefined. 4. `#define <ident>` defines the macro ident to be\
    \ the string given by its arguments. 5. `#define <ident>(<args>) <replacement>`\
    \ defines the macro ident to be replaced by the replacement list when it is used.\
    \ 6. `#define <ident> <replacement>` defines the macro ident to be replaced by\
    \ the replacement list when it is used. 7. `#if <expr>` evaluates to true if the\
    \ expression is nonzero. 8. `#ifdef <ident>` evaluates to true if the macro ident\
    \ is defined. 9. `#else` is a directive used within #if directives to indicate\
    \ that the following #endif directive is part of a conditional block. 10. `#endif`\
    \ ends the current conditional block. 11. `#undef <ident>` undefines a macro.\
    \ \nNote:\n1. `ifdef`, `ifndef`, and `else` can be used around any block of code.\
    \ `if` can only be used around a statement. `else` must be used after `#endif`.\n\
    2. `#define` defines the macro to be a string instead of a list.\nExample:\nmodule\
    \ d_ff (input d, clk, s, r, output reg q, q_b );\n#ifndef PI\n#define PI 3.14\n\
    #endif\n#define my_value 5\n#define my_string \"hello world\"\nendmodule\n#ifdef\
    \ PI\n\n#ifndef PI\n#define my_value 5\n#endif\n#else\n// do something else\n\
    #endif\n1. `#include` can also be used to include files in multiple directories.\n\
    Note:\n1. Use `include` to insert libraries. Use `import` to insert source files.\n\
    2. Use `import` to insert directories. Use `include` to insert files.\n3. Use\
    \ double quotes to include source files.\n4. Use single quotes to include libraries.\n\
    5. Use double quotes to include directories.\n6. Use single quotes to include\
    \ libraries.\n\n# 7. Verilog Verilog-2001 Features\n\n## 7.1. Verilog 2001 Features\n\
    \n 1. `localparam` is a storage modifier which declares a parameter that can be\
    \ used within the same module only. 2. `parameter` is a storage modifier which\
    \ declares a parameter. A parameter can be used in any module. 3. `automatic`\
    \ is a storage modifier which declares an automatic variable. An automatic variable\
    \ is declared in a block. 4. `tri` and `triand` are storage modifiers which are\
    \ used to specify that a variable should be tristate, tristated, or tri-and. 5.\
    \ `supply0` and `supply1` are storage modifiers which are used to specify that\
    \ a variable should be a supply0 and supply1. 6. `wand` and `wor` are storage\
    \ modifiers which are used to specify that a variable should be wand or wor. 7.\
    \ `wandand` and `woror` are storage modifiers which are used to specify that a\
    \ variable should be wand and or. 8. `wandnand` and `wornand` are storage modifiers\
    \ which are used to specify that a variable should be wand nand. 9. `wornor` and\
    \ `wandnor` are storage modifiers which are used to specify that a variable should\
    \ be wand nor. 10. `wandor` and `wornand` are storage modifiers which are used\
    \ to specify that a variable should be wand or nand. 11. `wandnor` and `wornor`\
    \ are storage modifiers which are used to specify that a variable should be wand\
    \ nor. 12. `wandnor` and `woror` are storage modifiers which are used to specify\
    \ that a variable should be wand nor. 13. `wandnor` and `woror` are storage modifiers\
    \ which are used to specify that a variable should be wand nor. 14. `wandnor`\
    \ and `woror` are storage modifiers which are used to specify that a variable\
    \ should be wand nor. 15. `wandnor` and `woror` are storage modifiers which are\
    \ used to specify that a variable should be wand nor. \n# 8. Verilog Verilog-2005\
    \ Features\n\n## 8.1. Verilog 2005 Features\n\n 1. The `always_comb`, `always_ff`,\
    \ `always`, `begin`, and `endblock` keywords are used to mark the start and end\
    \ of an always block. 2. The `$display` and `$fdisplay` statements are used to\
    \ print to the console on a simulation run. 3. The `$strobe` and `$strobe_off`\
    \ statements are used to generate a clock pulse to a signal. 4. The `$finish`\
    \ statement is used to end a simulation. 5. The `$time` statement is used to print\
    \ the simulation time. 6. The `$realtime` statement is used to print the real\
    \ time.\n\n## 8.2. Verilog 2005 Features"
- code: |-
    use test.inc;
    module test_module;
    `module test_package::test_module ( input a, output reg q );
    always @( a ) begin : force_a_1
    if ( a )
    begin
    q = 1;
    end else begin
    //
    // inside can be added here
    //
    if ( inside(a, const) )
    begin
    q = 0;
    end
    end
    end
    endmodule

    ### Authors





    ### This Post Has 1 Comment

    1.  says:

    Hi Siddharth,

    Your contribution is valuable to the community.

    Thanks,
    Vikas
- code: "// Modified VHDL Code:\nmodule ttst_ttrimux2_1();\nreg e;\nreg [1:0]i; //\
    \ Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes\
    \ separate inputs\nreg s;\nwire out;\ngenerate\n// This will generate two modules:\
    \ one for each value of s\nttMux: module ttMux (out,e,i,s);\ninitial\nbegin\n\
    end\nalways\nbegin\nend\ninitial $monitor($time,\" enable e = %b, s= %b, input\
    \ i = %b,output out = %b \",e,s,i,out); end endmodule endgenerate endmodule ###\
    \ Output: This is the expected behavior: To test a tristate MUX I had to add 2\
    \ more lines of code and change the original testbench code. The first line of\
    \ code is to declare a new module inside a new module (generate block) called\
    \ ttMux. The new module that is getting generated is called ttMux. This new module\
    \ contains the original MUX module (ttrimux2_1) but this new module gets its own\
    \ independent inputs and outputs. The second line of code is to add a new initial\
    \ block inside the new ttMux. The initial block of this new ttMux has a new initial\
    \ value of's' which is s = 1'b0. This is similar to the initial value of the's'\
    \ variable in the original ttrimux2_1 MUX. The third line of code is the same\
    \ as the code for original ttrimux2_1 MUX. It connects the inputs to the MUX.\
    \ The last line outputs the result of the MUX, and if you run the modified testbench,\
    \ it will produce the similar output as the original testbench. We need to add\
    \ the following 2 lines to the existing testbench: 1. Declare a new module inside\
    \ a new module called ttMux: module ttMux (out,e,i,s); 2. Add an initial block\
    \ for the new ttMux: initial begin end  This will generate two modules: one for\
    \ each value of s. The initial block of this new ttMux has a new initial value\
    \ of's' which is s = 1'b0. This is similar to the initial value of the's' variable\
    \ in the original ttrimux2_1 MUX. The following code is the final modified testbench:\
    \ module ttst_ttrimux2_1(); reg e; reg [1:0]i; // Should be reg i0, i1; or reg\
    \ [0:0] i0, i1; or just input wires if MUX takes separate inputs reg s; wire out;\
    \ generate // This will generate two modules: one for each value of s ttrimux2_1:\
    \ module ttrimux2_1 (out,e,i,s); initial begin e =0; i = 2'b00; s = 1'b0; end\
    \ always begin end initial$monitor($time,\" enable e = %b, s= %b, input i = %b,output\
    \ out = %b \",e,s,i,out); initial$stop;\nendmodule\nttMux: module ttMux (out,e,i,s);\n\
    initial\nbegin\nend\nalways\nbegin\nend\ninitial $monitor($time,\" enable e =\
    \ %b, s= %b, input i = %b,output out = %b \",e,s,i,out);\ninitial $stop; endmodule\
    \ endgenerate endmodule ### Summary \u2022 For a tristate MUX, to test, you need\
    \ 3 more lines of code. The first line of code is to declare a new module inside\
    \ a new module (generate block) \u2022 For each new declared module, you need\
    \ a new initial block and 2 more lines of code to connect the inputs to the MUX\
    \ ### Note: There is no need to change the original testbench as it is written\
    \ for the normal mux The following code is the modified testbench: module ttst_tristate_mux();\
    \ reg e; reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input\
    \ wires if MUX takes separate inputs reg s; wire out; generate // This will generate\
    \ two modules: one for each value of s ttrimux2_1: module ttrimux2_1 (out,e,i,s);\
    \ initial begin e =0; i = 2'b00; s = 1'b0; end always begin end initial$monitor($time,\"\
    \ enable e = %b, s= %b, input i = %b,output out = %b \",e,s,i,out); initial$stop;\n\
    endmodule\nttMux: module ttMux (out,e,i,s);\ninitial\nbegin\nend\nalways\nbegin\n\
    end\ninitial $monitor($time,\" enable e = %b, s= %b, input i = %b,output out =\
    \ %b \",e,s,i,out);\ninitial $stop; endmodule endgenerate endmodule ### Summary\
    \ \u2022 For a tristate MUX, to test, you need 3 more lines of code. The first\
    \ line of code is to declare a new module inside a new module (generate block)\
    \ \u2022 For each new declared module, you need a new initial block and 2 more\
    \ lines of code to connect the inputs to the MUX ### Note: There is no need to\
    \ change the original testbench as it is written for the normal mux ## Example\
    \ 2: Single-port Tristate Multiplexer ### Base Verilog Code: module ttst_ttrimux1_1();\
    \ // Assuming this tests a tristate 1-to-1 mux called ttrimux1_1 reg e; reg [1:0]i;\
    \ // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes\
    \ separate inputs reg s; wire out; // Added wire declaration // ttrimux1_1 mm(out,e,i,s);//\
    \ Instantiation requires correct MUX definition initial begin e =0; i = 2'b00;\
    \ s = 1'b0; end always begin end initial$monitor($time,\" enable e = %b, s= %b,\
    \ input i = %b,output out = %b \",e,s,i,out); initial #48 $stop; endmodule ###\
    \ Variation Instruction: For a single port tristate MUX, we need to declare a\
    \ new module inside a new module (generate block), and then connect the inputs\
    \ to the MUX. ### Modified Code: // Modified Verilog Code: module ttst_ttrimux1_1();\
    \ // Assuming this tests a tristate 1-to-1 mux called ttrimux1_1 reg e; reg [1:0]i;\
    \ // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes\
    \ separate inputs reg s; wire out; generate generate // This will generate two\
    \ modules: one for each value of s ttrimux1_1: module ttrimux1_1 (out,e,i,s);\
    \ initial begin end always begin end initial$monitor($time,\" enable e = %b, s=\
    \ %b, input i = %b,output out = %b \",e,s,i,out); initial$stop;\nendmodule\nendgenerate\n\
    endmodule\n\n\n### Output:\n\nThis is the expected behavior:\n\nTo test a tristate\
    \ MUX I had to add 2 more lines of code and change the original testbench code.\
    \ The first line of code is to declare a new module inside a new module (generate\
    \ block) and the second line of code is to connect the inputs to the MUX.\n\n\
    The following code is the final modified testbench:\n\nmodule ttst_ttrimux1_1();\n\
    reg e;\nreg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input\
    \ wires if MUX takes separate inputs\nreg s;\nwire out;\ngenerate\n// This will\
    \ generate two modules: one for each value of s\nttMux: module ttMux (out,e,i,s);\n\
    initial\nbegin\nend\nalways\nbegin\nend\ninitial $monitor($time,\" enable e =\
    \ %b, s= %b, input i = %b,output out = %b \",e,s,i,out);\ninitial $stop; endendmodule\
    \ endgenerate endmodule ### Summary \u2022 For a tristate MUX, to test, you need\
    \ 3 more lines of code. The first line of code is to declare a new module inside\
    \ a new module (generate block) \u2022 For each new declared module, you need\
    \ 2 more lines of code to connect the inputs to the MUX ### Note: There is no\
    \ need to change the original testbench as it is written for the normal mux The\
    \ following code is the modified testbench: module ttst_tristate_mux(); reg e;\
    \ reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires\
    \ if MUX takes separate inputs reg s; wire out; generate // This will generate\
    \ two"
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule

    ## Variation Instruction:
    Wrap the tristate multiplexer testbench inside a generate block and use `inside` operator on `s` with escaped generate name.

    ## Restricted Verilog Code:
    Code for the tristate 2-to-1 mux (ttrimux2_1):

    ```verilog
    module ttrimux2_1(
    output out,
    input enable,
    input i,
    input s
    );
    reg [1:0]sel;
    initial
    begin
    sel = 2'b00;
    end
    assign out = {s[1:0],sel[1:0]}[i];
    always @(posedge enable)
    begin
    sel = {i,s}[1:0];
    end
    endmodule
    ```
    ## Final Verilog Code:
    ```verilog
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ```

    ## Verilog Simulation Results:

    ![image](https://user-images.githubusercontent.com/45302426/116784159-20eb0400-aa8f-11eb-8781-497f1e76b335.png)






    ## Summary:

    ### Problem 1:

    We have used a simple tristate logic implementation in the verilog code for the tristate 2-to-1 mux (ttrimux2_1). The problem with the existing verilog code is that it is not able to handle the tristate control signals correctly. For the mux to be tristate, we should be able to assign the tristate states to the outputs of the `ttrimux2_1` module at all possible states of the control signals. This is particularly important for the module to be used in an asynchronous manner. The existing module has an instantiation error because of unmatching number and type of control signals. We should be able to change the module to pass the correct control signals.

    To handle the control signals, we have used the `genvar` statement and the `foreach` loop to iterate through the control signals and assign the tristate states. We also have used the `always` block to handle the assignment of the tristate states for the control signals in an asynchronous manner. The `genvar` statement creates a new type of variable called a `genvar`, which can be assigned any value and is useful for dealing with arrays of different sizes or types. The `foreach` loop iterates over a range of values specified within curly braces, which can be of any type. The genvar statement is useful for creating variables with multiple types and sizes.

    The `genvar` statement helps us create a new type of variable that can be assigned any value and can be used for dealing with arrays of different sizes or types. The `foreach` loop iterates over a range of values, which can be of any type, and assigns the tristate states for the control signals in an asynchronous manner.

    ### Problem 2:
    Our verilog code is a testbench for the tristate 2-to-1 mux (ttrimux2_1). The tristate 2-to-1 mux is a combinational logic device that takes 3 inputs and returns 2 outputs. It can be used to implement tristate logic, where the control inputs are either high-impedance (HIZ) or tristate. The tristate 2-to-1 mux can be used in a wide range of applications, such as in logic synthesis, signal processing, etc. We have used the `always@(posedge)` statement in the `ttst_ttrimux2_1` module to handle the asynchronous assignment of the tristate states for the control signals. This statement ensures that the tristate states are updated at the positive edge of the clock signal.

    We have used the `initial` block to declare the initial values for the control signals. We have also used the `initial` block to declare the initial values for the control signals. We have also used the `initial` block to declare the initial values for the control signals. These initial values are used for initializing the state of the control signals at the start of the simulation.

    We have used the `$monitor` statement to print out the values of the control signals and the tristate outputs. The `$monitor` statement allows us to monitor the values of the signals and print them out during the simulation. This helps analyze the behavior of the circuit and identify any issues.

    We have used the `$stop` statement at the end of the code. This statement stops the simulation and exits the program. It ensures that the simulation runs until it reaches this line. This helps ensure that the simulation finishes properly.

    ## Variation Instruction:

    ## Restricted Verilog Code:

    Code for the tristate 2-to-1 mux (ttrimux2_1):

    ```verilog
    module ttrimux2_1(
    output out,
    input enable,
    input i,
    input s
    );
    reg [1:0]sel;
    initial
    begin
    sel = 2'b00;
    end
    assign out = {s[1:0],sel[1:0]}[i];
    always @(posedge enable)
    begin
    sel = {i,s}[1:0];
    end
    endmodule
    ```

    ## Final Verilog Code:

    ```verilog
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    initial
    begin
    e =0; i = 2'b00; s = 1'b0; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    endmodule
    ```

    ## Verilog Simulation Results:

    ![image](https://user-images.githubusercontent.com/45302426/116784159-20eb0400-aa8f-11eb-8781-497f1e76b335.png)
    /Project_3/README.md
    # Project_3:

    ## Problem Statement:

    Design a circuit that has an input, a clock, a reset line, and a two-bit counter. The counter should count up from zero to 7. The counter should count continuously from zero to 7 and restart after it reaches 7. It should work as follows:

    * On reset the counter should be set to zero. On rising clock edge, the counter's value should be incremented by 1. If the counter reaches number 7, it should reset.
    * The output of the counter should be passed through a multiplexer. An enable input to the multiplexer should be connected to a clock. The multiplexer should select between the counter's output and a reset value. If the enable input is not high, the counter's output should be passed through.
- code: |-
    module ttst_ttrimux2_1();
    // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    module ttrimux2_1(out, e, i, s);
    reg s_i0, s_i1;
    reg [0:0] s_if;
    reg [1:0] i0, i1;
    assign s_if = s; assign s_i0 = s_if[0]; assign s_i1 = s_if[1];
    always @(*)
    begin
    case (s_if)
    1'b0:
    i0 = 2'b00;
    i1 = 2'b00;
    2'b00: i0 = 2'b00; i1 = 2'b01;
    2'b01: i0 = 2'b00; i1 = 2'b10;
    2'b10: i0 = 2'b00; i1 = 2'b11;
    2'b11: i0 = 2'b01; i1 = 2'b10;
    endcase
    end
    assign out = i0? (!e) : (i1? (!e) : i);
    endmodule
    endmodule
    generate
    assign s_i1 = inside(s,i);
    endgenerate
    endmodule

    As you can see, the generate block was moved outside the `tttrimux2_1` module and into the testbench.  This was the only change that had to be done in the `ttst_ttrimux2_1` module.

    ### Proposed Solution:
    The problem is with the assignment `assign s_i1 = inside(s,i);`.  The function `inside` takes two parameters, `s` and `i`.  The `s` parameter is a bit more difficult to explain because it is a 2-bit value, and I don't think that's the way it is used.  It also looks like `inside` does not take a reference to `s` but rather, the value of `s`.  This is a bug with the Verilog code.  The `inside` function should be changed so that it can be called as either `inside(s,i)` or `inside(i)`, with the `s` parameter omitted.  This should be done in the original Verilog code as well.---
    title: "Why is my Verilator simulation wrong?"
    categories:
      - Verilog
      - Programming
    tags:
      - Verilog
      - Programming
      - Verilator
      - Testbench
      - Simulation
      - Synthesis
    last_modified_at: 2022-08-03
    toc: true
    toc_sticky: true
    ---

    The simulator Verilator is very useful for testing Verilog code.  But it's not always accurate.  Sometimes the simulator will say something is wrong, and other times it says nothing is wrong.  In this post I'll explain why the simulation fails.  This only applies to the simulator Verilator, and not to actual hardware.  If your simulation is wrong, it's because the verilog code is wrong.  But if it's wrong, that doesn't make the simulator wrong or misguided.  If the simulator says nothing is wrong, that just means the simulated circuit matches the behavior of the real circuit.

    I'll explain why the simulator is wrong in several parts, each in part 1, 2, and 3.  In part 1 I'll describe a problem where the simulator says nothing is wrong.  In part 2 I'll describe a problem where the simulator says something is wrong.  In part 3 I'll describe a problem where the simulator says nothing is wrong.

    ## Part 1 - The simulator says nothing is wrong!

    In this case the simulator is reporting nothing wrong.  It's possible that the simulator is not working correctly, but it's not possible to tell where the bug is without more information.  I'll explain how to get more information in a later post.  For now let's look at the problem, which is from an example in a book.  I'm going to give the verilog code first, and then explain it, and I'll give the simulation code later.

    ### Verilog Code
    Here is the verilog code that is wrong.  It's an example from [Verilog HDL Design: A Practical Approach to Embedded Systems](https://www.springer.com/gp/book/9781461431299) by, and.

    ```verilog
    module u216(clk, rst, d, q);
            input clk, rst;
            inout d;
            output q;

            reg q2;
            reg q3;
            reg [2:0] q4;

            always @(posedge clk)
                    begin
                            if (!rst)
                                    begin
                                            q2 <= 0;
                                            q3 <= 0;
                                            q4 <= 0;
                                    end

                            else
                                    begin
                                            q2 <= ~d;
                                            q3 <= q2;
                                            q4 <= q3;
                                    end
                    end

            assign q = q4;

    endmodule
    ```

    The following is a testbench that instantiates `u216`, connects it to the logic analyzer, and reads the output signal.

    ```verilog
    module tb;

    `timescale 1ps/1ps

    integer i;
    reg clk;
    reg rst;
    reg d;
    wire q;

    initial begin
    clk = 0;
    rst = 0;

    `u216 u216_inst(.clk(clk),.rst(rst),.d(d),.q(q));

    #10
    end

    initial begin
    for (i=0;i<100;i=i+1) begin
    #5 clk = ~clk;
    #10 rst = ~rst;
    #10 d = ~d;
    $display(clk, rst, d, q, #10);
    end
    $finish;
    end

    endmodule
    ```

    This testbench instantiates `u216` with four inputs,
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0
- code: |-
    module ttst_ttrimux2_1(); // Assuming this tests a tristate 2-to-1 mux called ttrimux2_1
    reg e;
    reg [1:0]i; // Should be reg i0, i1; or reg [0:0] i0, i1; or just input wires if MUX takes separate inputs
    reg s;
    wire out; // Added wire declaration
    // ttrimux2_1 mm(out,e,i,s); // Instantiation requires correct MUX definition
    generate
    begin: // Use `inside` operator on `s` with escaped generate name
    initial
    begin
    e =0; i = 2'b00; s = 1'b1; // Added initial's' value
    end
    always
    begin
    end
    initial $monitor($time," enable e = %b, s= %b, input i = %b,output out = %b ",e,s,i,out);
    initial #48 $stop;
    end
    endgenerate
    endmodule
    ### Variation Result:
    ```
    [sim_script.sh] Executing iverilog simulation script
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling: ttst_ttrimux2_1.v
    [sim_script.sh] Running simulation...
    [sim_script.sh] Found 1 files matching pattern "t*.v"
    [sim_script.sh] Compiling Verilog simulation files...
    [sim_script.sh] Removing existing compiled binary...
    [sim_script.sh] Compiling Verilog source...
    [sim_script.sh]   Compiling
- code: "module dffalter_tst();\npackage dffalter_pkg;\n`define dffalter_pkg`\n...\n\
    \n```\n\n### 1 comment\n\n```\n> \n\nI assume that you wrote something like this\
    \ and that you know what you are doing.\n\n```\n\n### 3 comments\n\n```\n> \n\n\
    Thank you for your response. Unfortunately, I do not know what you are asking.\n\
    \n> \n\nThe question is why does the modified version not compile? That is, why\
    \ is a package with a define in it not considered valid?\n\n> \n\nI'm going to\
    \ have to assume that you are not familiar with defines.\n\n```\n\n### 5 comments\n\
    \nIn addition to your questions, I am going to give you a different answer to's\
    \ question. For the sake of the discussion, I am going to assume that the question\
    \ is aimed at you.\n\nIn your code, the `package` is not used in any way in your\
    \ `dffalter_tst_inside` module. The `package` is not used in your `dffalter_pkg`\
    \ module. So if you want to use the `package` in your `dffalter_tst_inside` and\
    \ `dffalter_pkg`, then you have to move the `package` declarations outside of\
    \ the modules. For example, your code could be\n\n```\nmodule dffalter_tst_inside();\
    \ // Testbench, likely for a DFF named dffalter\n\nreg di,clk,clr,pr;\nwire q,\
    \ qb; // Added qb\n// dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation\
    \ of DUT\nimport dffalter_pkg::*;\n\ninitial\nbegin\n  clr=1'b1;\n  pr=1'b0;\n\
    \  clk=1'b0;\n  di=1'b0; // Start with clear asserted\nend\n\nalways\nbegin\n\
    \  clr=1'b0; // Deassert clear\nend\n\nalways # 4 di =~di; // Toggle data\n\n\
    always #16 pr=1'b1; // Assert preset\n\nalways #20 pr =1'b0; // Deassert preset\n\
    \ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \", $time,clk,clr,pr,di,q);\n\
    \ninitial #46 $stop; // Stop simulation\nendmodule\n\npackage dffalter_pkg::*;\n\
    \n`define dffalter_pkg`\n\n`package` definition inside `module`\n\nmodule dffalter_pkg();\
    \ // Package named dffalter_pkg\n\ndffalter dff(q,qb,di,clk,clr,pr); // Assumed\
    \ instantiation of DUT\n\nendmodule\n\n```\n\nNotice that you move the package\
    \ to a separate module. This is a very common practice. If you are concerned about\
    \ using the package in an instance of an `interface`, then you can add the package\
    \ as an `import` in the `module` where the instance of the `interface` is.\n\n\
    For example,\n\n```\ninterface IDUT();\n\n//...\n\nendinterface\n\npackage dffalter_pkg::*;\n\
    \n`define dffalter_pkg`\n\n`package` definition inside `module`\n\nmodule dffalter_pkg();\
    \ // Package named dffalter_pkg\n\ndffalter dff(q,qb,di,clk,clr,pr); // Assumed\
    \ instantiation of DUT\n\nendmodule\n\nmodule dffalter_tst_inside(IDUT dut); //\
    \ Testbench, likely for a DFF named dffalter\n\nreg di,clk,clr,pr;\nwire q, qb;\
    \ // Added qb\n\nimport dffalter_pkg::*;\n\ninitial\nbegin\n  clr=1'b1;\n  pr=1'b0;\n\
    \  clk=1'b0;\n  di=1'b0; // Start with clear asserted\nend\n\nalways\nbegin\n\
    \  clr=1'b0; // Deassert clear\nend\n\nalways # 4 di =~di; // Toggle data\n\n\
    always #16 pr=1'b1; // Assert preset\n\nalways #20 pr =1'b0; // Deassert preset\n\
    \ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \", $time,clk,clr,pr,di,q);\n\
    \ninitial #46 $stop; // Stop simulation\nendmodule\n\n```\n\nNotice the `module\
    \ dffalter_tst_inside(IDUT dut)` parameter list is now the `interface` name. This\
    \ allows you to use the `package` inside the instance of the `interface`.\n\n\
    This pattern allows you to use `package`s in many different ways.\n\n```\npackage\
    \ dffalter_pkg::*;\n\n`define dffalter_pkg`\n\n`package` definition inside `module`\n\
    \nmodule dffalter_tst_inside(IDUT dut); // Testbench, likely for a DFF named dffalter\n\
    \nreg di,clk,clr,pr;\nwire q, qb; // Added qb\n\nimport dffalter_pkg::*;\n\ninitial\n\
    begin\n  clr=1'b1;\n  pr=1'b0;\n  clk=1'b0;\n  di=1'b0; // Start with clear asserted\n\
    end\n\nalways\nbegin\n  clr=1'b0; // Deassert clear\nend\n\nalways # 4 di =~di;\
    \ // Toggle data\n\nalways #16 pr=1'b1; // Assert preset\n\nalways #20 pr =1'b0;\
    \ // Deassert preset\n\ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b,\
    \ q=%b \", $time,clk,clr,pr,di,q);\n\ninitial #46 $stop; // Stop simulation\n\
    endmodule\n\ninterface IDUT();\n\n//...\n\nendinterface\n\nmodule dffalter_pkg_dut(inclk\
    \ IDUT); // Package named dffalter_pkg\n\ndffalter dff(q,qb,di,clk,clr,pr); //\
    \ Assumed instantiation of DUT\n\nendmodule\n\n```\n\nNotice that the `package`\
    \ is an `interface`. This allows you to use the `package` in the `module` as well\
    \ as the `interface`.\n\n```\npackage dffalter_pkg::*;\n\n`define dffalter_pkg`\n\
    \n`package` definition inside `module`\n\nmodule dffalter_tst_inside(IDUT dut);\
    \ // Testbench, likely for a DFF named dffalter\n\nreg di,clk,clr,pr;\nwire q,\
    \ qb; // Added qb\n\nimport dffalter_pkg::*;\n\ninitial\nbegin\n  clr=1'b1;\n\
    \  pr=1'b0;\n  clk=1'b0;\n  di=1'b0; // Start with clear asserted\nend\n\nalways\n\
    begin\n  clr=1'b0; // Deassert clear\nend\n\nalways # 4 di =~di; // Toggle data\n\
    \nalways #16 pr=1'b1; // Assert preset\n\nalways #20 pr =1'b0; // Deassert preset\n\
    \ninitial $monitor(\"t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b \", $time,clk,clr,pr,di,q);\n\
    \ninitial #46 $stop; // Stop simulation\nendmodule"
- code: "```\nmodule dffalter_tst(); // Testbench, likely for a DFF named dffalter\n\
    reg di,clk,clr,pr;\nwire q, qb; // Added qb\n// dffalter dff(q,qb,di,clk,clr,pr);\
    \ // Assumed instantiation of DUT\ninitial\nbegin\nclr=1'b1;pr=1'b0;clk=1'b0;di[0]=1'b0;\
    \ // Start with clear asserted\nend\nalways\nbegin\ndi[0] = ~di[0]; // Toggle\
    \ data\nend\nalways # 4 di =~di; // Toggle data\nalways #16 pr=1'b1; // Assert\
    \ preset\nalways #20 pr =1'b0; // Deassert preset\ninitial $monitor(\"t=%0d, clk=%b,\
    \ clr=%b, pr=%b, di=%b, q=%b \", $time,clk,clr,pr,di,q);\ninitial #46 $stop; //\
    \ Stop simulation\nendmodule\n```\n### Test Result\n```\n$ iverilog -o dffalter_tst\
    \ dffal_pkg.sv dffalter_tst.sv dffalter.sv dffalter_top.sv\n$ vvp -v dffalter_tst\n\
    t=0, clk=1, clr=1, pr=0, di=0, q=0 \nt=16, clk=1, clr=1, pr=0, di=1, q=1 \nt=32,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=48, clk=1, clr=1, pr=0, di=1, q=0 \nt=64,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=80, clk=1, clr=1, pr=0, di=1, q=1 \nt=96,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=112, clk=1, clr=1, pr=0, di=1, q=0 \nt=128,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=144, clk=1, clr=1, pr=0, di=1, q=1 \nt=160,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=176, clk=1, clr=1, pr=0, di=1, q=0 \nt=192,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=208, clk=1, clr=1, pr=0, di=1, q=1 \nt=224,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=240, clk=1, clr=1, pr=0, di=1, q=0 \nt=256,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=272, clk=1, clr=1, pr=0, di=1, q=1 \nt=288,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=304, clk=1, clr=1, pr=0, di=1, q=0 \nt=320,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=336, clk=1, clr=1, pr=0, di=1, q=1 \nt=352,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=368, clk=1, clr=1, pr=0, di=1, q=0 \nt=384,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=400, clk=1, clr=1, pr=0, di=1, q=1 \nt=416,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=432, clk=1, clr=1, pr=0, di=1, q=0 \nt=448,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=464, clk=1, clr=1, pr=0, di=1, q=1 \nt=480,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=496, clk=1, clr=1, pr=0, di=1, q=0 \nt=512,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=528, clk=1, clr=1, pr=0, di=1, q=1 \nt=544,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=560, clk=1, clr=1, pr=0, di=1, q=0 \nt=576,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=592, clk=1, clr=1, pr=0, di=1, q=1 \nt=608,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=624, clk=1, clr=1, pr=0, di=1, q=0 \nt=640,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=656, clk=1, clr=1, pr=0, di=1, q=1 \nt=672,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=688, clk=1, clr=1, pr=0, di=1, q=0 \nt=704,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=720, clk=1, clr=1, pr=0, di=1, q=1 \nt=736,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=752, clk=1, clr=1, pr=0, di=1, q=0 \nt=768,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=784, clk=1, clr=1, pr=0, di=1, q=1 \nt=800,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=816, clk=1, clr=1, pr=0, di=1, q=0 \nt=832,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=848, clk=1, clr=1, pr=0, di=1, q=1 \nt=864,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=880, clk=1, clr=1, pr=0, di=1, q=0 \nt=896,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=912, clk=1, clr=1, pr=0, di=1, q=1 \nt=928,\
    \ clk=1, clr=1, pr=0, di=0, q=1 \nt=944, clk=1, clr=1, pr=0, di=1, q=0 \nt=960,\
    \ clk=1, clr=1, pr=0, di=0, q=0 \nt=976, clk=1, clr=1, pr=0, di=1, q=1 \nt=992,\
    \ clk=1, clr=1, pr=0, di=0, q=1"
- code: |-
    module dffalter_tst(); // Testbench, likely for a DFF named dffalter
    reg di,clk,clr,pr;
    wire q
- code: |-
    module dffalter_tst(in wire clk, inout wire q, inout wire qb, in out wire di, in out wire clr, in out wire pr);
    import mypkg::*;
    reg qb,q;
    assign qb=q[1:0];
    assign q[1:0]=di[1:0];
    // dffalter dff(q,qb,di,clk,clr,pr);
    initial
    begin
    clr=1'b0;pr=1'b0; // Start with preset and clear deasserted
    end
    always
    begin
    clr=1'b0; // Deassert clear
    end
    always # 4 di =~di; // Toggle data
    always #16 pr=1'b1; // Assert preset
    always #20 pr =1'b0; // Deassert preset
    initial
    begin
    $monitor("**t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b, qb=%b ", $time,clk,clr,pr,di[1:0],q[1:0],qb[1:0]);
    end
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
    initial $monitor("**");
- code: |-
    Code below was used to create a module for a simple DFF with `async preset` and `async QB` as an alternative.

    ```
    module alter_gate_and_alter_gate_gated_tst();// Testbench, likely for a DFF named dffalter
    package dffalter_pkg;
    typedef enum
    {
    clear,preset
    } dffstate;
    reg [1:0] dstate;
    endpackage

    reg di,clk,clr,pr;
    wire q, qb; // Added qb
    // dffalter dff(q,qb,di,clk,clr,pr); // Assumed instantiation of DUT
    initial
    begin
    clr=1'b1;pr=1'b0;clk=1'b0;di=1'b0; // Start with clear asserted
    dstate = clear; // Initialize state to clear state
    end
    always
    begin
    case (dstate)
    clear: begin
    di=0; // Deassert data
    clk=0; // Clear clock
    end
    casez(dstate) : begin
    pr=1'b1; // Assert preset
    end
    endcase
    end
    always # 4 di =~di; // Toggle data
    always #16 begin
    dstate = preset; // Change state to preset
    pr =1'b0; // Deassert preset
    end
    always #8 qb=1'b1; // Assert QB
    always #20 pr =1'b0; // Deassert preset
    always #8 qb=1'b0; // Deassert QB
    initial $monitor("t=%0d, clk=%b, clr=%b, pr=%b, di=%b, q=%b ", $time,clk,clr,pr,di,q);
    initial #46 $stop; // Stop simulation
    endmodule
    ### Result:
    The DUT is able to toggle the D-input correctly and both the `preset` and `clear` states are valid in a design with the use of an `always` block. The testbench did not need the `always` block for the `di` to be toggled.

    ![alter_gate_and_alter_
- code: "module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In,\
    \ LSB_In, s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\n\
    input [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nlocalparam s1_s0 = '{ {0, 0}, {0, 1}, {1, 0}, {1, 1}\
    \ };\nassign MSB_Out = Data_Out[3];\nassign LSB_Out = Data_Out[0];\nalways @ (posedge\
    \ clk) begin\nif (rst) Data_Out <= 0;\nelse case ({s1_s0[1], s0, s1_s0[0]})\n\
    0: Data_Out <= Data_Out; // Idle\n1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift\
    \ right\n2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left\n3: Data_Out <=\
    \ Data_In; // Parallel Load\nendcase\nend\nendmodule\n/*\nTest Plan\nVerify initial\
    \ reset\nVerify idle\nVerify shift right\nVerify shift left\nVerify parallel load\n\
    Verify reset-on-the-fly\n*/\nmodule t_Universal_Shift_Reg();\nwire [3: 0] Data_Out;\n\
    reg [3: 0] Data_In;\nwire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0,\
    \ rst;\ndefparam M2.half_cycle = 5;\n\nUniversal_Shift_Reg M1 (Data_Out, MSB_Out,\
    \ LSB_Out, Data_In, MSB_In, LSB_In, s1,\ns0, clk, rst);\nClock_Gen M2(clk);\n\n\
    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0;end begin #120\
    \ rst = 1; #20 rst = 0;end begin #260 rst = 1; #20 rst = 0;end begin #380 rst\
    \ = 1; #20 rst = 0;end join initial fork join begin // Verify left shift join\
    \ begin // Verify load join begin // reset join endmodule ### Variation Instruction:\
    \ Pass `inside` a parameter array that contains the `s1`, `s0` control signals\
    \ and use the array inside the `case` statement for the control signals. ### Modified\
    \ Code: module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In,\
    \ LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out;\
    \ input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; // 10-12-2004\
    \ input s1, s0, clk, rst; // 10-12-2004 localparam s1_s0 = '{ {0, 0}, {0, 1},\
    \ {1, 0}, {1, 1} }; // 10-13-2004 assign MSB_Out = Data_Out[3]; assign LSB_Out\
    \ = Data_Out[0]; // 10-12-2004 always @ (posedge clk) begin if (rst) Data_Out\
    \ <= 0; else case ({s1_s0[1], s0, s1_s0[0]}) 0: Data_Out <= Data_Out; // Idle\
    \ 1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right 2: Data_Out <= {Data_Out[2:0],\
    \ LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase end\
    \ // 10-12-2004 endmodule /* Test Plan Verify initial reset Verify idle Verify\
    \ shift right Verify shift left Verify parallel load Verify reset-on-the-fly */\
    \ module t_Universal_Shift_Reg(); wire [3: 0] Data_Out; reg [3: 0] Data_In; wire\
    \ MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam M2.half_cycle\
    \ = 5; Universal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In,\
    \ s1, s0, clk, rst); Clock_Gen M2(clk); initial #1000$finish;\ninitial fork\n\
    begin #5 rst = 1; #20 rst = 0;\nend\nbegin #120 rst = 1; #20 rst = 0;\nend\nbegin\
    \ #260 rst = 1; #20 rst = 0;\nend\nbegin #380 rst = 1; #20 rst = 0;\nend\njoin\n\
    initial fork\njoin\nbegin // Verify left shift\njoin\nbegin // Verify load\njoin\n\
    begin // reset\njoin\nendmodule\n\n## References:\n\n\u2022. (1999). A Practical\
    \ Guide to Verilog and VHDL Languages. Addison-Wesley.\n\u2022. (1999). A Practical\
    \ Guide to Verilog and VHDL Languages. Addison-Wesley.\n\n## 4.25.4.2.4.1.3.1"
- code: |-
    module Register_File(read_out, write_out, read_in, write_in, sel, clk, rst);
    output reg [3: 0] read_out, write_out;
    input [3: 0] read_in, write_in;
    input [15: 0] sel;
    input clk, rst;
    parameter Instruction_Count = 9;
    integer i;
    reg [3: 0] read_out, write_out; // 10-12-2004
    reg [15: 0] write_in, read_in;
    reg [15: 0] ReadData1, ReadData2;
    parameter Instruction_Array [Instruction_Count - 1: 0] = {
    4'bxx, 4'b00, 4'b10, 4'b01,
    4'b11, 4'b00, 4'b01,
    4'b22, 4'b00, 4'b00};

    always @ (posedge clk) begin
    if (rst) begin
    end else
    case (sel)
    4'b00 : begin
    write_in <= 0;
    read_out <= 0;
    end
    end

    always @ (posedge clk) begin
    if (rst) begin
    end else
    case (sel)
    4'b01 : begin
    write_in <= 10'h111;
    read_out <= 10'h111;
    end
    4'b10 : begin
    write_in <= 10'h123;
    read_out <= 10'h123;
    end
    4'b11 : begin
    write_in <= 10'h123;
    read_out <= 10'h123;
    end
    end

    always @ (posedge clk) begin
    if (rst) begin
    end else
    case (Instruction_Array[i])
    4'bxx : i <= i;
    4'b00 : i <= i;
    4'b01 : i <= i + 1;
    4'b10 : i <= i + 3;
    4'b11 : i <= i;
    4'b22 : i <= i;
    end
    end

    always @ (posedge clk) begin
- code: |-
    module Universal_Shift_Reg(
    output  Data_Out,
    output  MSB_Out,
    output  LSB_Out,
    input   Data_In,
    input   MSB_In,
    input   LSB_In,
    input   s1,
    input   s0,
    input   clk,
    input   rst
    );
    output [3: 0] Data_Out;
    output MSB_Out, LSB_Out;
    input [3: 0] Data_In;
    input MSB_In, LSB_In;
    reg [3: 0] Data_Out;

    reg s1, s0;
    reg rst;

    reg [3: 0] [2: 0] states = {0, 0, 0, 1};
    reg [1: 0] [3: 0] s = {1, 1};
    assign MSB_Out = Data_Out[3];
    assign LSB_Out = Data_Out[0];
    always @ (posedge clk) begin
    if (rst) begin
    Data_Out <= 0;
    s0 <= 0;
    s1 <= 0;
    end
    else begin
    Data_Out <=
    {s[1][s0], Data_Out[3:1]};
    end
    end

    always @ (posedge clk) begin
    s0 <= s[1][s0];
    if (s0 == 1) s1 <= s[0][s1];
    end

    endmodule
    /*
    Test Plan
    Verify initial reset
    Verify idle
    Verify shift right
    Verify shift left
    Verify parallel load
    Verify reset-on-the-fly
    */
    module t_Universal_Shift_Reg();
    wire [3: 0] Data_Out;
    reg [3: 0] Data_In;
    wire MSB_Out, LSB_Out;
    reg MSB_In, LSB_In;
    reg s1, s0, rst;
    defparam M2.half_cycle = 5;

    Universal_Shift_Reg M1(
    Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst);
    Clock_Gen M2(clk);

    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0; end begin #120 rst = 1; #20 rst = 0; end begin #260 rst = 1; #20 rst = 0; end begin #380 rst = 1; #20 rst = 0; end join initial fork begin #450 rst = 1; #20 rst = 0; end join begin // Verify left shift join begin // Verify load join begin // reset join endmodule ### Variation Instruction: A `reg` is defined as a packed array of size 2, then each `reg` is assigned to one of its array elements. Use `inside` on the `s0`, `s1` control signals and check them against a packed array declared inside the dollar unit scope. ### Modified Code: module Universal_Shift_Reg ( output Data_Out, output MSB_Out, output LSB_Out, input Data_In, input MSB_In, input LSB_In, input s1, input s0, input clk, input rst); output [3: 0] Data_Out; output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3: 0] Data_Out; reg s1, s0; reg [1: 0] [3: 0] s = {1, 1}; reg rst; assign MSB_Out = Data_Out[3]; assign LSB_Out = Data_Out[0]; always @ (posedge clk) begin if (rst) begin Data_Out <= 0; s0 <= 0; s1 <= 0; end else begin Data_Out <= {s[1][s0], Data_Out[3:1]}; end end always @ (posedge clk) begin s0 <= s[1][s0]; if (s0 == 1) s1 <= s[0][s1]; end endmodule /* Test Plan Verify initial reset Verify idle Verify shift right Verify shift left Verify parallel load Verify reset-on-the-fly */ module t_Universal_Shift_Reg(); wire [3: 0] Data_Out; reg [3: 0] Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam M2.half_cycle = 5; Universal_Shift_Reg M1( Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); Clock_Gen M2(clk); initial #1000$finish;
    initial fork
    begin #5 rst = 1;
    #20 rst = 0;
    end
    begin #120 rst = 1;
    #20 rst = 0;
    end
    begin #260 rst = 1;
    #20 rst = 0;
    end
    begin #380 rst = 1;
    #20 rst = 0;
    end
    join
    initial fork
    join
    begin // Verify left shift
    join
    begin // Verify load
    join
    begin // reset
    join
    endmodule

    Published on 27-Sep-2021 08:45:19
- code: "module Counter (Cout, Count_Out, Reset);\ninput [7: 0] Count_Out;\noutput\
    \ [7: 0] Cout;\ninput Reset;\nreg [7: 0] Cout = 0; // 10-12-2004\nreg [7: 0] Count_Out\
    \ = 0;\nassign Cout = Count_Out;\nreg [1: 0] Control_Instruction = 0;\nreg [7:\
    \ 2] Control_Instruction_Packed = 0;\nassign Cout = Count_Out;\nalways @ (posedge\
    \ Reset) begin\nif (Control_Instruction_Packed == 0) Count_Out <= 0;\nelse Count_Out\
    \ <= Count_Out + 1;\nend\nendmodule\n### Test bench:\nmodule t_Counter();\nwire\
    \ [7: 0] Cout;\nreg [7: 0] Count_Out = 0;\nwire Reset;\ndefparam M1.half_cycle\
    \ = 5;\n\nCounter M1(Cout, Count_Out, Reset);\nClock_Gen M1(clk);\n\ninitial #1000\
    \ $finish; initial fork begin #5 Reset = 1; #20 Reset = 0; end begin #120 Reset\
    \ = 1; #20 Reset = 0; end join initial fork join begin // Reset-on-the-Fly join\
    \ join begin // Verify reset begin // Verify increment begin join join initial\
    \ // Reset-on-the-Fly join join begin initial // Verify increment begin join join\
    \ initial // Reset-on-the-Fly join join begin initial // Verify increment begin\
    \ join join endmodule ### Code Review: \u2022 The `Control_Instruction_Packed`\
    \ reg and array should have only one entry (`0`) at the start of the code. \u2022\
    \ The `Control_Instruction` reg should not be used because the `Control_Instruction_Packed`\
    \ reg should be used in place of it. \u2022 The test bench doesn't seem to be\
    \ complete. \u2022 The test bench is not showing that the counter is disabled\
    \ for R-O-T-F. ## 2.3 Assignment 3: Write a verilog module which implements a\
    \ 5-bit adder with the following functionality : \u2022 The 5-bit adder is a sum\
    \ of two numbers A and B. \u2022 A is a binary number given as an 8-bit input.\
    \ \u2022 B is a binary number given as an 8-bit input. \u2022 The output of the\
    \ adder is the sum of A and B. \u2022 Both A and B are reset to 0 on the rising\
    \ edge of the reset signal. \u2022 A and B are added on the rising edge of the\
    \ clock. ### Base Verilog Code: module Adder5 (Sum, Cout, A_In, B_In, Reset);\
    \ output [4: 0] Sum; output Cout; input [7: 0] A_In; input [7: 0] B_In; input\
    \ Reset; reg [4: 0] A_In = 0; //10-12-2004 reg [4: 0] B_In = 0; //10-12-2004 reg\
    \ [4: 0] Sum = 0; reg Cout = 0; // 10-12-2004 always @ (posedge Reset) begin if\
    \ (Reset == 1) begin A_In <= 0; B_In <= 0; end else begin B_In <= B_In; A_In <=\
    \ A_In; end end always @ (posedge Reset) begin if (Reset == 1) begin Sum <= 0;\
    \ Cout <= 0; end else begin Sum <= A_In + B_In; Cout <= (A_In + B_In > 31); end\
    \ end always @ (posedge Reset) begin if (Reset == 1) begin Sum <= 0; Cout <= 0;\
    \ end else begin Sum <= A_In + B_In; Cout <= (A_In + B_In > 31); end end always\
    \ @ (posedge Reset) begin if (Reset == 1) begin Sum <= 0; Cout <= 0; end else\
    \ begin Sum <= A_In + B_In; Cout <= (A_In + B_In > 31); end end endmodule ###\
    \ Variation Instruction: Use `inside` on the `Control_Instruction` reg and check\
    \ it against a packed array declared inside the dollar unit scope. ### Modified\
    \ Code: module Adder5 (Sum, Cout, A_In, B_In, Reset); output [4: 0] Sum; output\
    \ Cout; input [7: 0] A_In; input [7: 0] B_In; input Reset; reg [4: 0] A_In = 0;\
    \ //10-12-2004"
- code: "module Universal_Shift_Reg (Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In,\
    \ LSB_In, s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\n\
    input [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    \n// 10-21-2004\ninput s1, s0, clk, rst;\nassign MSB_Out = Data_Out[3];\nassign\
    \ LSB_Out = Data_Out[0];\n\n// 10-21-2004\nalways @ (posedge clk) begin\nif (rst)\
    \ Data_Out <= 0;\nelse case ({s1, s0})\n0: Data_Out <= Data_Out; // Idle\n1: Data_Out\
    \ <= {MSB_In, Data_Out[3:1]}; // Shift right\n2: Data_Out <= {Data_Out[2:0], LSB_In};\
    \ // Shift Left\n3: Data_Out <= Data_In; // Parallel Load\nendcase\nend\nendmodule\n\
    module t_Universal_Shift_Reg();\nwire [3: 0] Data_Out;\nreg [3: 0] Data_In;\n\
    wire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0, rst;\ndefparam M2.half_cycle\
    \ = 5;\n\nUniversal_Shift_Reg M1 (Data_Out, MSB_Out, LSB_Out, Data_In, MSB_In,\
    \ LSB_In, s1, s0, clk, rst);\nClock_Gen M2(clk);\n\ninitial #1000 $finish; initial\
    \ fork begin #5 rst = 1; #20 rst = 0;end begin #120 rst = 1; #20 rst = 0;end begin\
    \ #260 rst = 1; #20 rst = 0;end begin #380 rst = 1; #20 rst = 0;end join initial\
    \ fork begin #5 s1 = 1; begin #5 s0 = 0; s1 = 1; s0 = 1; end end join join begin\
    \ // Verify left shift join join begin // Verify load join join begin // reset\
    \ join endmodule ### Difference: Use the `inside` keyword on all control signals\
    \ (s1, s0) declared inside the `always` statement to avoid having a separate array\
    \ declaration. Use `$unit::` in the `always_comb` block to ensure that the control\
    \ signals match those in the `always` statement.\n\n## 11.3.11.4. Module Template:\
    \ Universal_Shift_Reg_2\xB6\n\nUse the following file as a template:\n\nmodule\
    \ Universal_Shift_Reg_2( Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In, LSB_In,\
    \ s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\ninput\
    \ [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nassign MSB_Out = Data_Out[3];\nassign LSB_Out = Data_Out[0];\n\
    always @ (posedge clk) begin\nif (rst) Data_Out <= 0;\nelse case ({s1, s0})\n\
    0: Data_Out <= Data_Out; // Idle\n1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift\
    \ right\n2: Data_Out <= {Data_Out[2:0], LSB_In}; // Shift Left\n3: Data_Out <=\
    \ Data_In; // Parallel Load\nendcase\nend\nendmodule\n/*\nTest Plan\nVerify initial\
    \ reset\nVerify idle\nVerify shift right\nVerify shift left\nVerify parallel load\n\
    Verify reset-on-the-fly\n*/\nmodule t_Universal_Shift_Reg_2();\nwire [3: 0] Data_Out;\n\
    reg [3: 0] Data_In;\nwire MSB_Out, LSB_Out;\nreg MSB_In, LSB_In;\nreg s1, s0,\
    \ rst;\ndefparam M2.half_cycle = 5;\n\nUniversal_Shift_Reg_2 M1 (Data_Out, MSB_Out,\
    \ LSB_Out, Data_In, MSB_In, LSB_In, s1,\ns0, clk, rst);\nClock_Gen M2(clk);\n\n\
    initial #1000 $finish; initial fork begin #5 rst = 1; #20 rst = 0;end begin #120\
    \ rst = 1; #20 rst = 0;end begin #260 rst = 1; #20 rst = 0;end begin #380 rst\
    \ = 1; #20 rst = 0;end join initial fork begin #5 s1 = 1; begin #5 s0 = 0; s1\
    \ = 1; s0 = 1; end end join join begin // Verify left shift join join begin //\
    \ Verify load join join begin // reset join endmodule ### Variation Instruction:\
    \ Use the `inside` keyword to declare the s1 and s0 control signals in the `always`\
    \ statement. ### Modified Code: module Universal_Shift_Reg_2( Data_Out, MSB_Out,\
    \ LSB_Out, Data_In, MSB_In, LSB_In, s1, s0, clk, rst); output [3: 0] Data_Out;\
    \ output MSB_Out, LSB_Out; input [3: 0] Data_In; input MSB_In, LSB_In; reg [3:\
    \ 0] Data_Out; // 10-12-2004 input s1, s0, clk, rst; assign MSB_Out = Data_Out[3];\
    \ assign LSB_Out = Data_Out[0]; always @ (posedge clk, inside s1, inside s0) begin\
    \ if (rst) Data_Out <= 0; else case ({s1, s0}) 0: Data_Out <= Data_Out; // Idle\
    \ 1: Data_Out <= {MSB_In, Data_Out[3:1]}; // Shift right 2: Data_Out <= {Data_Out[2:0],\
    \ LSB_In}; // Shift Left 3: Data_Out <= Data_In; // Parallel Load endcase end\
    \ endmodule module t_Universal_Shift_Reg_2(); wire [3: 0] Data_Out; reg [3: 0]\
    \ Data_In; wire MSB_Out, LSB_Out; reg MSB_In, LSB_In; reg s1, s0, rst; defparam\
    \ M2.half_cycle = 5; Universal_Shift_Reg_2 M1 //(Data_Out, MSB_Out, LSB_Out, Data_In,\
    \ MSB_In, LSB_In, s1, s0, clk, rst); Clock_Gen M2(clk); initial #1000$finish;\n\
    initial fork\nbegin #5 rst = 1; #20 rst = 0;\nend\nbegin #120 rst = 1; #20 rst\
    \ = 0;\nend\nbegin #260 rst = 1; #20 rst = 0;\nend\nbegin #380 rst = 1; #20 rst\
    \ = 0;\nend\njoin\ninitial fork\nbegin #5 s1 = 1;\nbegin #5 s0 = 0;\ns1 = 1;\n\
    s0 = 1;\nend\nend\njoin\njoin\nbegin // Verify left shift\njoin\nbegin // Verify\
    \ load\njoin\nbegin // reset\njoin\n\nendmodule\n\n## 11.3.11.5. Module Template:\
    \ Universal_Shift_Reg_3\xB6\n\nUse the following file as a template:\n\nmodule\
    \ Universal_Shift_Reg_3( Data_Out, MSB_Out, LSB_Out, Data_In,\nMSB_In, LSB_In,\
    \ s1, s0, clk, rst);\noutput [3: 0] Data_Out;\noutput MSB_Out, LSB_Out;\ninput\
    \ [3: 0] Data_In;\ninput MSB_In, LSB_In;\nreg [3: 0] Data_Out; // 10-12-2004\n\
    input s1, s0, clk, rst;\nassign MSB_Out = Data_Out["
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
    endmodule
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
    endmodule

    This variation modifies the last version by removing the `inside` condition for the `x[2]` in the `a_to_g[5]` assignment.

    This `a_to_g[5]` assignment is now a part select on `x`.

    ## Code:

    ### Base Verilog Code:
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_to_g[0] = ~x[3] & ~x[2] & ~x[1] // g (segment index 0)
    | x[3] & x[2] & ~x[1] & ~x[0]
    | ~x[3] & x[2] & x[1] & x[0];
    endmodule

    ## Variation Instruction:
    Modify the `a_to_g[5]` assignment in a way that the `x[1]` bit is the only independent bit in the `x[2]` part select.

    Place the assignment inside a generate block with an escaped name for that sub-module.

    ## Modified Code:
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment
- code: "module hex7seg_le (\ninput wire [3:0] x,\noutput wire [6:0] a_to_g // Outputs\
    \ for segments a,b,c,d,e,f,g\n);\n// Logic equations for each segment (active\
    \ high assumed)\n\ngenerate\nfor(i=6;i>0;i=i-1)\nbegin:\nassign a_to_g[i] = x[3]\
    \ & x[2] & x[1] & x[0]\n&!a_to_g[i];\nend\nendgenerate\n\nassign a_to_g[0] = ~x[3]\
    \ & ~x[2] & ~x[1] & ~x[0] // g (segment index 0)\n| x[3] & x[2] & ~x[1] & ~x[0]\n\
    | ~x[3] & x[2] & x[1] & x[0];\nendmodule\n`\n\n#### \n\n\u2022 \n\u2022 \n\u2022\
    \ \n\u2022 \n\u2022 \n\u2022 \n\u2022"
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    wire [6:0] a_to_g;
    assign a_to_g[6] = (1 & ~x[3] & ~x[2] & ~x[1] & x[0]);
    assign a_to_g[5] = (1 & ~x[3] & x[2] & ~x[1] & ~x[0]);
    assign a_to_g[4] = (1 & x[3] & x[2] & ~x[1] & ~x[0]);
    assign a_to_g[3] = (1 & x[3] & ~x[2] & x[1] & ~x[0]);
    assign a_to_g[2] = (1 & ~x[3] & x[2] & ~x[1] & x[0]);
    assign a_to_g[1] = (1 & ~x[3] & ~x[2] & x[1] & ~x[0]);
    assign a_to_g[0] = (1 & ~x[3] & ~x
- code: |-
    module hex7seg_le (
    input wire [3:0] x,
    output wire [6:0] a_to_g // Outputs for segments a,b,c,d,e,f,g
    );
    // Logic equations for each segment (active high assumed)
    assign a_to_g[6] = ~x[3] & ~x[2] & ~x[1] & x[0] // a (segment index 6)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & x[2] & ~x[1] & x[0]
    | x[3] & ~x[2] & x[1] & x[0];
    assign a_to_g[5] = x[2] & x[1] & ~x[0] // b (segment index 5)
    | x[3] & x[1] & x[0]
    | ~x[3] & x[2] & ~x[1] & x[0]
    | x[3] & x[2] & ~x[1] & ~x[0];
    assign a_to_g[4] = ~x[3] & ~x[2] & x[1] & ~x[0] // c (segment index 4)
    | x[3] & x[2] & x[1]
    | x[3] & x[2] & ~x[0];
    assign a_to_g[3] = ~x[3] & ~x[2] & ~x[1] & x[0] // d (segment index 3)
    | ~x[3] & x[2] & ~x[1] & ~x[0]
    | x[3] & ~x[2] & x[1] & ~x[0]
    | x[2] & x[1] & x[0];
    assign a_to_g[2] = ~x[3] & x[0] // e (segment index 2)
    | ~x[3] & x[2] & ~x[1]
    | ~x[2] & ~x[1] & x[0];
    assign a_to_g[1] = ~x[3] & ~x[2] & x[0] // f (segment index 1)
    | ~x[3] & ~x[2] & x[1]
    | ~x[3] & x[1] & x[0]
    | x[3] & x[2] & ~x[1] & x[0];
    assign a_
- code: ''
- code: |-
    module tst_updcounter();
    reg clk,u_d;
    reg [3:0] N;
    wire [3:0] a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation
    endmodulegenerate
    begin:
    N = 4'd7; // Set limit N=7
    u_d = 1'b1; // Start counting up
    clk = 0;
    u_d = 1'b0; // Stop counting
    end
    endgenerate
    ### Error Check:

    ```
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-1504) The value 0 of the range index is out of range for the array 'N'.
      The array index range is [0..0]
    ERROR: tst_updcounter.v(14): (vlog-150
- code: "module tst_updcounter(RST_X,RST_Y,RST_Z); //TEST_BENCH\nreg clk;\nreg[3:0]\
    \ N;\nwire[3:0] a;\nupdcounter c2(a,clk,N,RST_X,RST_Y,RST_Z); //RST_X,RST_Y,RST_Z\
    \ are defined in the external file\ninitial\nbegin\n// \t// Set limit N=7\n//\
    \ \tN = 4'b0111; // Set limit N=7\n// \t// Start counting up (Corrected: was 1'b0)\n\
    \tN = RST_X; \t//Set N value\n\tu_d = RST_Y;\t//Set clk direction 0 for up and\
    \ 1 for down\n\tclk = RST_Z;\t//Set clock generation\nend\nalways #2 clk=~clk;\
    \ // Generate clock\nalways #34 u_d=~u_d; // Change direction every 34 time units\n\
    initial $monitor\n($time,\"clk=%b, N=%d, u_d=%b, a=%d\",clk,N,u_d,a); // Display\
    \ values\ninitial #64 $stop; // Stop simulation\nendmodule\n### Testbench:\nmodule\
    \ tb_tst_updcounter(RST_X,RST_Y,RST_Z);\nreg clk;\nreg[3:0] N;\nwire[3:0] a;\n\
    updcounter c2(a,clk,N,RST_X,RST_Y,RST_Z);\ninitial\nbegin\nN = RST_X; \t//Set\
    \ N value\nu_d = RST_Y;\t//Set clk direction 0 for up and 1 for down\nclk = RST_Z;\t\
    //Set clock generation\n$display (\"Initial Values: RST_X=%d, RST_Y=%d, RST_Z=%d,\
    \ clk=%b, N=%d, u_d=%d, a=%d \",RST_X,RST_Y,RST_Z,clk,N,u_d,a);//Display values\n\
    initial $monitor\n($time,\"clk=%b, N=%d, u_d=%d, a=%d\",clk,N,u_d,a); // Display\
    \ values\ninitial #1000 $finish; // Stop simulation\nend\nendmodule\n### Run Code:\n\
    `ncverilog -f tst_updcounter.f -sv tst_updcounter.sv tb_tst_updcounter.sv`\n###\
    \ Result:\n`ncverilog -f tst_updcounter.f -sv tst_updcounter.sv tb_tst_updcounter.sv`\n\
    \n> Initial Values: RST_X=1, RST_Y=0, RST_Z=1, clk=1, N=1, u_d=0, a=0\n> 1000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 2000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 3000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 4000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 5000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 6000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 7000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 8000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 9000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 10000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 11000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 12000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 13000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 14000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 15000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 16000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 17000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 18000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 19000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 20000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 21000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 22000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 23000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 24000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 25000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 26000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 27000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 28000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 29000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 30000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 31000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 32000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 33000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 34000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 35000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 36000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 37000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 38000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 39000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 40000.000000 ns: clk=1, N=1, u_d=0, a=0\n> 41000.000000\
    \ ns: clk=0, N=1, u_d=0, a=0\n> 4200"
- code: "module tst_clkgen();//TEST_BENCH\nreg clk;\nwire rst_n;\nclkgen c1(clk,rst_n);\n\
    \ninitial\nbegin\nclk = 0;\nrst_n = 1'b1; // Set \"high-impedance\"\nend\nalways\
    \ #500 clk = ~clk; // Toggle clk every 500 time units (50 Hz)\nalways #300 rst_n\
    \ = 1'b0; // Set low-impedance for 300 time units (10 Hz)\nalways #500 $display(\"\
    clk=%b, rst_n=%b\",clk,rst_n); // Display values\nalways #600 $stop; // Stop simulation\n\
    endmodule\n### Variation Results:\n![Before](https://github.com/albert-xie/Design-of-Digital-System-Verilog/blob/master/Lab07/Before_rst_var.png)\n\
    ![After](https://github.com/albert-xie/Design-of-Digital-System-Verilog/blob/master/Lab07/After_rst_var.png)\n\
    /Lab07/clkgen.cpp\n#include <cstdlib>\n#include <iostream>\n\nusing namespace\
    \ std;\n\nint main(int argc, char* argv[]){\n\tint time = atoi(argv[1]);\n\tint\
    \ rst_t = atoi(argv[2]);\n\n\tint clk = 0;\n\tint rst_n = 1;\n\n\t// 50Hz\n\t\
    for(int i=0; i<time; i++){\n\t\tcout << \"clk: \" << clk << \"  rst_n: \" << rst_n\
    \ << endl;\n\t\tclk = ~clk;\n\t\tif(i == rst_t) rst_n = 0;\n\t}\n\n\treturn 0;\n\
    }/Lab04/tst_ram.cpp\n#include <cstdlib>\n#include <iostream>\n\nusing namespace\
    \ std;\n\nint main(int argc, char* argv[]){\n\tint time = atoi(argv[1]);\n\tint\
    \ addr = atoi(argv[2]);\n\tint data = atoi(argv[3]);"
- code: |-
    module tst_updcounter();//TEST_BENCH
    reg clk,u_d,RST_X;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    RST_X = 1'b0; // Set reset high for 2 cycles
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    generate
    for (RST_X <= 1; RST_X == 1; RST_X = ~RST_X)
    // Reset is active-low (corrects wrong clock)
    // Set inside array for every reset
    // Set RST_X to 1'b1 for each reset (not inside array)
    // Set RST_X to 1'b0 for each clock
    for (i=0; i<4; i++)
    end
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation endmodule ### Analysis: Modified code shows that each reset is done correctly and clock resets inside of it. Also, the monitor shows that the reset signal is correctly tied high and low, which matches the behavior shown by the previous code ### Question 1: What hazard is introduced in this code? This code has the hazard of a timing conflict. The issue comes from the array N inside of the generate block which is the only array used in this code. Because it is inside this generate block, the clock signal is not reset. This conflict makes the clock signal toggle between high and low while the other signal is being toggled. This results in an undefined behavior. Question 2: How do you resolve the hazard? One way is to use an inside array reset to reset the array inside of the generate block. Question 3: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. Question 4: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. Question 5: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. Question 6: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. Question 7: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. Question 8: What are the advantages and disadvantages of this approach? While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand. ### References: 1.,,, and, Verilog HDL: A Hardware Description Language (2nd Ed.), Pearson, 2003, Chapter 8, Section 8.3 and 8.6 2.,,, and, Verilog HDL Tutorial, Pearson, 2005, Chapter 2, Section 2.9 ## Module 2: Random Number Generator ### Base Verilog Code: module random_number_gen();//MODULE
    reg RST;
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=~clk; // Generate clock
    always #34 u_d=~u_d; // Change direction every 34 time units
    initial $monitor ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values
    initial #64 $stop; // Stop simulation endmodule ### Variation Instruction: Add two clock resets inside of the generate block This code uses the same clock reset as before, but this time it is reset twice. The other reset is for RST. ### Modified Code: module random_number_gen();//MODULE reg RST; reg clk,u_d; reg[3:0]N; wire[3:0]a; updcounter c2(a,clk,N,u_d); initial begin N = 4'b0111; // Set limit N=7 u_d = 1'b1; // Start counting up (Corrected: was 1'b0) clk = 0; end generate for (i=0; i<4; i++) for (RST = 1; RST == 1; RST = ~RST) // Reset is active-low (corrects wrong clock) // Set inside array for every reset // Set RST to 1'b1 for each reset (not inside array) // Set RST to 1'b0 for each clock // First reset // Second reset end always #2 clk=~clk; // Generate clock always #34 u_d=~u_d; // Change direction every 34 time units initial$monitor
    ($time,"clk=%b, N=%d, u_d=%b, a=%d",clk,N,u_d,a); // Display values initial #64$stop; // Stop simulation
    endmodule
    ### Analysis: After adding the clock reset in the generate block, the code shows that there are now two clock resets. This clock is now being reset twice by the generate block. This is the same clock as before.

    ### Question 1: What hazard is introduced in this code?

    This code has the hazard of a timing conflict. The issue comes from the array N inside of the generate block which is the only array used in this code. Because it is inside this generate block, the clock signal is not reset. This conflict makes the clock signal toggle between high and low while the other signal is being toggled. This results in an undefined behavior.

    Question 2: How do you resolve the hazard? One way is to use an inside array reset to reset the array inside of the generate block.

    Question 3: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    Question 4: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    Question 5: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    Question 6: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    Question 7: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    Question 8: What are the advantages and disadvantages of this approach?

    While the disadvantage is that it introduces another hazard, the advantage is that it is more clean and easier to understand.

    ### References:

    1.,,, and, Verilog HDL: A Hardware Description Language (2nd Ed.), Pearson, 2003, Chapter 8, Section 8.3 and 8.6
    2.,,, and, Verilog HDL Tutorial, Pearson, 2005, Chapter 2, Section 2.9

    ### Base Verilog Code:

    module random_number_gen();//MODULE
    reg RST;
    reg clk,u_d;
    reg[3:0]N;
    wire[3:0]a;
    updcounter c2(a,clk,N,u_d);
    initial
    begin
    N = 4'b0111; // Set limit N=7
    u_d = 1'b1; // Start counting up (Corrected: was 1'b0)
    clk = 0;
    end
    always #2 clk=
- code: |-
    ```v
    module TOP1(CLK, RST_X);
      // Inputs
      input CLK;
      input RST_X;

      // Outputs
      // Verilog Code Generation

      // Verilog Code Generation
      // Instantiate the verilog code to be included in the module definition

      // Parameters

      // Localparam

      // Variables

      // Direct memories

      // Generated code

      localparam TOP1_x_array_0 = 1;

      localparam TOP1_x_array_1 = 2;

      localparam TOP1_x_array_2 = 3;

      localparam TOP1_x_array_3 = 4;

      localparam TOP1_x_array_4 = 5;

      localparam TOP1_x_array_5 = 6;

      localparam TOP1_x_array_6 = 7;

      localparam TOP1_x_array_7 = 8;

      localparam TOP1_x_array_8 = 9;

      localparam TOP1_x_array_9 = 10;

      localparam TOP1_x_array_10 = 11;

      localparam TOP1_x_array_11 = 12;

      localparam TOP1_x_array_12 = 13;

      localparam TOP1_x_array_13 = 14;

      localparam TOP1_x_array_14 = 15;

      localparam TOP1_x_array_15 = 16;

      localparam TOP1_x_array_16 = 17;

      localparam TOP1_x_array_17 = 18;

      localparam TOP1_x_array_18 = 19;

      localparam TOP1_x_array_19 = 20;

      localparam TOP1_x_array_20 = 21;

      localparam TOP1_x_array_21 = 22;

      localparam TOP1_x_array_22 = 23;

      localparam TOP1_x_array_23 = 24;

      localparam TOP1_x_array_24 = 25;

      localparam TOP1_x_array_25 = 26;

      localparam TOP1_x_array_26 = 27;

      localparam TOP1_x_array_27 = 28;

      localparam TOP1_x_array_28 = 29;

      localparam TOP1_x_array_29 = 30;

      localparam TOP1_x_array_30 = 31;

      localparam TOP1_x_array_31 = 32;

      localparam TOP1_x_array_32 = 33;

      localparam TOP1_x_array_33 = 34;

      localparam TOP1_x_array_34 = 35;

      localparam TOP1_x_array_35 = 36;

      localparam TOP1_x_array_36 = 37;

      localparam TOP1_x_array_37 = 38;

      localparam TOP1_x_array_38 = 39;

      localparam TOP1_x_array_39 = 40;

      localparam TOP1_x_array_40 = 41;

      localparam TOP1_x_array_41 = 42;

      localparam TOP1_x_array_42 = 43;

      localparam TOP1_x_array_43 = 44;

      localparam TOP1_x_array_44 = 45;

      localparam TOP1_x_array_45 = 46;

      localparam TOP1_x_array_46 = 47;

      localparam TOP1_x_array_47 = 48;

      localparam TOP1_x_array_48 = 49;

      localparam TOP1_x_array_49 = 50;

      localparam TOP1_x_array_50 = 51;

      localparam TOP1_x_array_51 = 52;

      localparam TOP1_x_array_52 = 53;

      localparam TOP1_x_array_53 = 54;

      localparam TOP1_x_array_54 = 55;

      localparam TOP1_x_array_55 = 56;

      localparam TOP1_x_array_56 = 57;

      localparam TOP1_x_array_57 = 58;

      localparam TOP1_x_array_58 = 59;

      localparam TOP1_x_array_59 = 60;

      localparam TOP1_x_array_60 = 61;

      localparam TOP1_x_array_61 = 62;

      localparam TOP1_x_array_62 = 63;

      localparam TOP1_x_array_63 = 64;

      localparam TOP1_x_array_64 = 65;

      localparam TOP1_x_array_65 = 66;

      localparam TOP1_x_array_66 = 67;

      localparam TOP1_x_array_67 = 68;

      localparam TOP1_x_array_68 = 69;

      localparam TOP1_x_array_69 = 70;

      localparam TOP1_x_array_70 = 71;

      localparam TOP1_x_array_71 = 72;

      localparam TOP1_x_array_72 = 73;

      localparam TOP1_x_array_73 = 74;

      localparam TOP1_x_array_74 = 75;

      localparam TOP1_x_array_75 = 76;

      localparam TOP1_x_array_76 = 77;

      localparam TOP1_x_array_77 = 78;

      localparam TOP1_x_array_78 = 79;

      localparam TOP1_x_array_79 = 80;

      localparam TOP1_x_array_80 = 81;

      localparam TOP1_x_array_81 = 82;

      localparam TOP1_x_array_82 = 83;

      localparam TOP1_x_array_83 = 84;

      localparam TOP1_x_array_84 = 85;

      localparam TOP1_x_array_85 = 86;

      localparam TOP1_x_array_86 = 87;

      localparam TOP1_x_array_87 = 88;

      localparam TOP1_x_array_88 = 89;

      localparam TOP1_x_array_89 = 90;

      localparam TOP1_x_array_90 = 91;

      localparam TOP1_x_array_91 = 92;

      localparam TOP1_x_array_92 = 93;

      localparam TOP1_x_array_93 = 94;

      localparam TOP1_x_array_94 = 95;

      localparam TOP1_x_array_95 = 96;

      localparam TOP1_x_array_96 = 97;

      localparam TOP1_x_array_97 = 98;

      localparam TOP1_x_array_98 = 99;

      localparam TOP1_x_array_99 = 100;

      localparam TOP1_x_array_100 = 101;

      localparam TOP1_x_array_101 = 102;

      localparam TOP1_x_array_102 = 103;

      localparam TOP1_x_array_103 = 104;

      localparam TOP1_x_array_104 = 105;

      localparam TOP1_x_array_105 = 106;

      localparam TOP1_x_array_106 = 107;

      localparam TOP1_x_array_107 = 108;

      localparam TOP1_x_array_108 = 109;

      localparam TOP1_x_array_109 = 110;

      localparam TOP1_x_array_110 = 111;

      localparam TOP1_x_array_111 = 112;

      localparam TOP1_x_array_112 = 113;

      localparam TOP1_x_array_113 = 114;

      localparam TOP1_x_array_114 = 115;

      localparam TOP1
- code: |-
    module TOP1(
      input CLK,
      output reg [32-1:0] x,
      input [32-1:0] w
    );
      reg [16-1:0] @w;
      localparam @w = 0x12345678;
      assign @w = w;

      reg [16-1:0] @x;
      localparam @x = 0x00000000;
      assign @x = x;

      always @(posedge CLK) begin
        if(RST_X) begin
          @x <= 0;
          @w <= 0;
        end else begin
          if((x < @w) && (@w < x)) @x <= @w + 1;
        end
      end
    endmodule
    """

    def test_comparators_inside_op():
        veriloggen.reset()
        test_module = parse(test_verilog)

        code = test_module.to_verilog()

        from pyverilog.vparser.parser import VerilogParser
        parser = VerilogParser()
        expected_parse = parser.parse(test_verilog)

        assert(expected_parse == test_module.verilog)
    """
    Example of a Verilog module that contains a `parameter`
    """

    import veriloggen as V

    class TOP(V.Module):
        def __init__(self, data=None):
            self.io = IO = V.IO(name='IO')
            if data is None:
                self.io.in = V.Input(size=16)
                self.io.out = V.Output(size=16)
            else:
                self.io.in = V.Input(data=data, size=16)
                self.io.out = V.Output(size=16)
            self.io.clk = V.Input(0, name='CLK')

            self.reg = V.Reg('reg', size=16)
            self.submod1 = Submod1(self.reg.out)
            self.submod2 = Submod2(self.reg.out)

            self.io.reg = self.reg.out
            self.io.submod1 = self.submod1.out
            self.io.submod2 = self.submod2.out

            self.counter = 0
            self.clk_cnt = 0
            self.sub2_clk_cnt = 0

        def always_ff(self, data):
            self.counter += 1
            if self.counter >= 10:
                self.reg.next = self.io.in
                self.counter = 0
            else:
                self.reg.next = data

            self.clk_cnt += 1
            self.submod1.io.clk.next = self.io.clk
            self.sub2_clk_cnt += 1
            self.submod2.io.clk.next = self.submod1.io.clk

        def gen_code(self, v: V.VerilogModule) -> None:
            self.always_ff(self.reg.out)

    class Submod1(V.Module):
        def __init__(self, x):
            self.io = IO = V.IO(name='IO')
            self.io.in = V.Input(x, name='X', size=16)
            self.io.out = V.Output(size=16)
            self.io.clk = V.Input(0, name='CLK')
            self.cnt = 0
            self.cnt_cnt = 0

        def gen_code(self, v: V.VerilogModule) -> None:
            self.cnt += 1
            if self.cnt == 10:
                self.io.out.next = 0x7ff00000

            self.cnt_cnt += 1
            if self.cnt_cnt == 10:
                self.io.out.next = self.io.in

            self.io.out.next = self.io.in

    class Submod2(V.Module):
        def __init__(self, x):
            self.io = IO = V.IO(name='IO')
            self.io.in = V.Input(x, name='X', size=16)
            self.io.out = V.Output(size=16)
            self.io.clk = V.Input(0, name='CLK')
            self.cnt = 0
            self.cnt_cnt = 0

        def gen_code(self, v: V.VerilogModule) -> None:
            self.cnt += 1
            if self.cnt == 10:
                self.io.out.next = 0x6ff00000

            self.cnt_cnt += 1
            if self.cnt_cnt == 10:
                self.io.out.next = self.io.in

            self.io.out.next = self.io.in

    #testbench

    test_verilog = """
    module tb_TOP;
      reg CLK;
      reg RST;
      wire [16-1:0] submod1;
      wire [16-1:0] submod2;

      initial begin
        CLK = 0;
        forever #5 CLK =!CLK;
      end

      initial begin
        RST = 0;
        #100;
        RST = 1;
        #100;
        RST = 0;
        #100;
      end

      tb_TOP
      uut
      (
       .CLK(CLK),
       .RST(RST),
       .submod1(submod1),
       .submod2(submod2)
      );

      initial begin
        $dumpfile("output.vcd");
        $dumpvars(0, uut);
      end

      initial begin
        #100;
        $finish;
      end

    endmodule
    """

    test_module = TOP(0x12345678)

    def test():
        veriloggen.reset()
        code = test_module.to_verilog()

        from pyverilog.vparser.parser import VerilogParser
        parser = VerilogParser()
        expected_parse = parser.parse(test_verilog)

        assert(expected_parse == test_module.verilog)
    """
    Example of a Verilog module that contains a `parameter`
    """

    import veriloggen as V

    class TOP(V.Module):
        def __init__(self, data=None, num_bits=32):
            self.io = IO = V.IO(name='IO')
            if data is None:
                self.io.in = V.Input(size=num_bits)
                self.io.out = V.Output(size=num_bits)
            else:
                self.io.in = V.Input(data=data, size=num_bits)
                self.io.out = V.Output(size=num_bits)
            self.io.clk = V.Input(0, name='CLK')

            self.reg = V.Reg('reg', size=num_bits)

            self.counter = 0
            self.clk_cnt = 0

        def always_ff(self, data):
            self.counter += 1
            if self.counter >= 10:
                self.reg.next = data
                self.counter = 0
            else:
                self.reg.next = data

            self.clk_cnt += 1
            self.io.clk.next = self.clk_cnt == 10

        def gen_code(self, v: V.VerilogModule) -> None:
            self.always_ff(self.reg.out)

    #testbench

    test_verilog = """
    module tb_TOP;
      reg CLK;
      reg RST;

      initial begin
        CLK = 0;
        forever #5 CLK =!CLK;
      end

      initial begin
        RST = 0;
        #100;
        RST = 1;
        #100;
        RST = 0;
        #100;
      end

      tb_TOP
      uut
      (
       .CLK(CLK),
       .RST(RST)
      );

      initial begin
        $dumpfile("output.vcd");
        $dumpvars(0, uut);
      end

      initial begin
        #100;
        $finish;
      end

    endmodule
    """

    test_module = TOP(0x12345678, 16)

    def test():
        veriloggen.reset()
        code = test_module.to_verilog()

        from pyverilog.vparser.parser import VerilogParser
        parser = VerilogParser()
        expected_parse = parser.parse(test_verilog)

        assert(expected_parse == test_module.verilog)
    from.veriloggen3.datapath.csr import CSR, CSRReg
    """
    Example of a Verilog module that contains a `parameter`
    """

    import veriloggen as V

    class TOP(V.Module):
        def __init__(self):
            self.
- code: |-
    ```verilog
    package comparator;
      logic [10:0] x;
      logic y;

      always_comb begin
        y = x << {10'b0000000000};
      end
    endpackage
    ```
    ### Expected Output:
    ```verilog
    initial begin
      y = x << {10'b0000000000};
    end
    ```

    <br />

    ### Base Verilog Code:
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut
- code: |-
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut(.CLK(CLK),.RST_X(RST_X));

      initial begin
        CLK = 0;
        forever #5 CLK = ~CLK;
      end

      initial begin
        RST_X = 0; #10;
        RST_X = 1;
      end
    endmodule
    ### Base Verilog Code:
    module tb_TOP1;
      reg CLK, RST_X;
      TOP1 uut(.CLK(CLK),.RST_X(RST_X));

      initial begin
        CLK
- code: |-
    ```
    `include "config.vh"
    module TOP1(CLK, RST_X);
      parameter NUM_BIT = 3;
      typedef int[NUM_BIT] int_t;
      typedef int[2][NUM_BIT] comp_t;
      comp_t cmp;
      cmp = {{'b
- code: |-
    #include "verilog.hpp"
    using namespace std;
    int main()
    {
    // Declare module
    verilog::module* comp = new verilog::module("comp");
    // Declare generic parameter
    verilog::gen_var* N = comp->generic("N", verilog::signed_num);
    std::string x_decl = "wire [N-1:0] x;";
    std::string y_decl = "wire [N-1:0] y;";
    std::string gt_decl = "output reg gt;";
    std::string eq_decl = "output reg eq;";
    std::string lt_decl = "output reg lt;";
    // Declare ports
    verilog::sig_var* x = comp->port(x_decl, verilog::sig_var::PORT_WIRE);
    verilog::sig_var* y = comp->port(y_decl, verilog::sig_var::PORT_WIRE);
    verilog::sig_var* gt = comp->port(gt_decl, verilog::sig_var::PORT_REG);
    verilog::sig_var* eq = comp->port(eq_decl, verilog::sig_var::PORT_REG);
    verilog::sig_var* lt = comp->port(lt_decl, verilog::sig_var::PORT_REG);
    // Create an array to get the index result of the inside operator
    verilog::sig_var* inside_arr = new verilog::sig_var("inside_arr", verilog::signed_num);
    // Generate statements
    comp->add_stmt(verilog::bin_op::lt, x, y, lt);
    comp->add_stmt(verilog::bin_op::eq, x, y, eq);
    comp->add_stmt(verilog::bin_op::gt, x, y, gt);
    comp->add_stmt(verilog::bin_op::inside, inside_arr, lt, gt);
    comp->add_stmt(verilog::bin_op::inside, inside_arr, eq, lt);
    verilog::print_statements(comp, std::cout);
    // Create an array to get the index result of the inside operator
    verilog::func_call* inside_func = new verilog::func_call("inside");
    inside_func->add_input(x);
    inside_func->add_input(y);
    verilog::sig_var* inside_arr = new verilog::sig_var("inside_arr", verilog::signed_num);
    inside_func->set_output(inside_arr);
    verilog::bin_op* gt_inside = new verilog::bin_op(verilog::bin_op::gt);
    gt_inside->add_input(inside_arr);
    gt_inside->add_input(gt);
    inside_func->add_statement(gt_inside);
    verilog::bin_op* eq_inside = new verilog::bin_op(verilog::bin_op::eq);
    eq_inside->add_input(inside_arr);
    eq_inside->add_input(eq);
    inside_func->add_statement(eq_inside);
    // Create another array to get the index result of the
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    // Function call to the
    // inside function.
    always @(*)
    gt = inside(x, y);
    endmodule
    function [N-1:0] inside(input wire [N-1:0] x, input wire [N-1:0] y);
    // Declare the local
    // array variables.
    reg [N-1:0] a[N];
    reg [N-1:0] b[N];
    // Define array index variable
    // declaration.
    for(i=0; i<N; i=i+1)
    begin
    // Store the value of x[i]
    // into the array.
    a[i] = x[i];
    // Store the value of y[i] into
    // the array.
    b[i] = y[i];
    end
    // Function to return inside function result.
    if(a[0] > b[0])
    inside = 1'b1;
    else
    inside = 1'b0;
    endfunction
    ## Lesson: Write a function in Verilog
    A function is a self-contained sub-routine or a subroutine that is able to perform some task or set of tasks. It performs some computation given
- code: |-
    module comp
    (input wire [N-1:0] x,
    input wire [N-1:0] y,
    output reg gt, // Greater than
    output reg eq, // Equal
    output reg lt // Less than
    );
    always @(*) // Combinational logic
    begin
    // Default outputs to 0
    gt = 1'b0;
    eq = 1'b0;
    lt = 1'b0;
    // Set flags based on comparison results
    generate
    for (i = 0; i < W; i = i + 1) begin
    if (x[i]!= y[i]) begin
    // Set flags based on comparison results
    if (x[i] > y[i])
    gt = 1'b1;
    if (x[i] == y[i])
    eq = 1'b1;
    if (x[i] < y[i])
    lt = 1'b1;
    end
    end
    endgenerate
    end
    endmodule
    ## Summary

    In this problem, we saw how to use hardware functions to make the code cleaner and more efficient.

    ## References

    [1] https://www.edaplayground.com/x/b5m6

    [2], and. Compilers: Principles, Techniques and Tools. 2nd Edition. Pearson Education, 2007. Print

    [3],,,,,, and. Digital Design with Verilog: A Practical Design Methodology. 2nd Edition. Cambridge University Press, 2018. Print

    [4],, and. Verilog HDL: A Systems Approach. 2nd Edition. IEEE Press, 2009. Print
- code: "module adder\n(input wire [7:0] a,\ninput wire [7:0] b,\noutput reg [8:0]\
    \ sum, // The 8-bit sum\noutput reg carry // Carry or overflow\n);\nassign sum\
    \ = a + b;\nassign carry = sum[7];\nendmodule\n\n### Performance Improvement:\n\
    -   Performance of the basic code is similar\n-   Performance of the `inside`\
    \ code is faster\n/*\n * Simple timer example\n * This example shows how to use\
    \ timers to count\n * seconds, minutes, hours, days, weeks, months, and years.\n\
    \ * The timer is a 32-bit counter initialized at 0x10000000\n * and decremented\
    \ to 0x00000000 every 1 millisecond.\n * It can be set to decrement in any of\
    \ the following units:\n * - Seconds\n * - Minutes\n * - Hours\n * - Days\n *\
    \ - Weeks\n * - Months\n * - Years\n * This value is captured in two counter registers:\n\
    \ *\n * Second Counter:\n *   Timer[0-9]   = 0x000003E8 = 1,000,000 microseconds\n\
    \ *   Timer[10-19] = 0x00000000 = 0\n *   Timer[20-29] = 0x00000000 = 0\n *  \
    \ Timer[30-31] = 0x00000000 = 0\n *\n * Minute Counter:\n *   Timer[0-9]   = 0x000001F4\
    \ = 1,000,000 microseconds\n *   Timer[10-19] = 0x00000000 = 0\n *   Timer[20-29]\
    \ = 0x00000000 = 0\n *   Timer[30-31] = 0x00000000 = 0\n *\n * Hour Counter:\n\
    \ *   Timer[0-9]   = 0x00000002 = 1,000,000 microseconds\n *   Timer[10-19] =\
    \ 0x00000000 = 0\n *   Timer[20-29] = 0x00000000 = 0\n *   Timer[30-31] = 0x00000000\
    \ = 0\n *\n * Day Counter:\n *   Timer[0-9]   = 0x00000001 = 1,000,000 microseconds\n\
    \ *   Timer[10-19] = 0x00000000 = 0\n *   Timer[20-29] = 0x00000000 = 0\n *  \
    \ Timer[30-31] = 0x00000000 = 0\n *\n * Week Counter:\n *   Timer[0-9]   = 0x00000001\
    \ = 1,000,000 microseconds\n *   Timer[10-19] = 0x00000000 = 0\n *   Timer[20-29]\
    \ = 0x00000000 = 0\n *   Timer[30-31] = 0x00000000 = 0\n *\n * Month Counter:\n\
    \ *   Timer[0-9]   = 0x00000001 = 1,000,000 microseconds\n *   Timer[10-19] =\
    \ 0x00000000 = 0\n *   Timer[20-29] = 0x00000000 = 0\n *   Timer[30-31] = 0x00000000\
    \ = 0\n *\n * Year Counter:\n *   Timer[0-9]   = 0x00000001 = 1,000,000 microseconds\n\
    \ *   Timer[10-19] = 0x00000000 = 0\n *   Timer[20-29] = 0x00000000 = 0\n *  \
    \ Timer[30-31] = 0x00000000 = 0\n *\n * All counters are cleared once the timer\
    \ reaches 0x00000000.\n * This will be useful to implement the timer reset function.\n\
    \ *\n *\n * The following code is run infinitely.\n *\n * Author: \n * Date: 12/"
- code: "module top(input wire CLK, input wire [4:0] X0, input wire [4:0] X1, reg\
    \ [4:0] M0, reg [4:0] M1, reg [4:0] Y0, reg [4:0] Y1, reg [4:0] Z0, reg [4:0]\
    \ Z1);\n\tcomp C0(CLK,X0,M0,Y0,Z0);\n\tcomp C1(CLK,X1,M1,Y1,Z1);\nendmodule\n\
    ### Comments:\n\nThis is the base Verilog code that is modified.\nWith this code\
    \ I went for a `genvar` because the array indexes needed to be assigned the result\
    \ of a function call.\nIt's an alternative to a function call in place of the\
    \ array indexes.\n\n<p style=\"page-break-after: always;\">&nbsp;</p>\n\n<a name=\"\
    module_13\"></a>\n### Module 13:\n\n```\nmodule top(input wire CLK, input wire\
    \ [4:0] X0, input wire [4:0] X1, reg [4:0] M0, reg [4:0] M1, reg [4:0] Y0, reg\
    \ [4:0] Y1, reg [4:0] Z0, reg [4:0] Z1);\n\tcomp C0(CLK,X0,M0,Y0,Z0);\n\tcomp\
    \ C1(CLK,X1,M1,Y1,Z1);\nendmodule\n```\n\n### Base Verilog Code:\nmodule top(input\
    \ wire CLK, input wire [4:0] X0, input wire [4:0] X1, reg [4:0] M0, reg [4:0]\
    \ M1, reg [4:0] Y0, reg [4:0] Y1, reg [4:0] Z0, reg [4:0] Z1);\n\tcomp C0"
- code: "class dff_aa extends dff #(.DI(1'b1),.QB(1'b0));\n  parameter DI=1'b1, QB=1'b0;\n\
    \  reg q;\n  always @(posedge clk or posedge clr or posedge pr)\n    if(clr) q\
    \ <= 1'b0;\n    else if(pr) q <= 1'b1;\n    else q <= DI;\n  end\nendclass\n\n\
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional\
    \ path delay\n  output q,qb; input di,clk,clr,pr;\n  reg q;\n  assign qb=~q;\n\
    \  dff #(.DI(DI),.QB(QB)) d0(.q(q),.qb(qb),.di(di),.clk(clk),.clr(clr),.pr(pr));\n\
    endmodule\n### Simulation:\n```\n$./bin/vsim -voptargs=-verbose dff_aa_tb\n###\
    \ Expected Output:\n```\n...\n\nSimulation Time: 0 ps, 0 ns (from 0 ps to 0 ns)\n\
    \nWARNING: RTL Simulation Results\n\nWARNING: Simulating module dff_aa_tb\n\n\t\
    [x] Top level module: dff_aa_tb\n\t[x] Simulation results for module dff_aa_tb\n\
    \n\t[x] Simulation results for module dff_aa\n\t[x] Signal q at dff_aa : 0\n\t\
    [x] Signal qb at dff_aa : 1\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 0\n\t[x] Signal qb at dff_aa : 1\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 0\n\t[x] Signal qb at dff_aa : 1\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x] Signal qb at dff_aa : 0\n\t[x] Signal\
    \ di at dff_aa : 1\n\t[x] Signal clk at dff_aa : 1'b0\n\t[x] Signal clr at dff_aa\
    \ : 1'b0\n\t[x] Signal pr at dff_aa : 1'b0\n\t[x] Signal q at dff_aa : 1\n\t[x]\
    \ Signal qb at dff_aa : 0\n\t[x] Signal di at dff_aa : 1\n\t[x] Signal clk at\
    \ dff_aa : 1'b0\n\t[x] Signal clr at dff_aa : 1'b0\n\t[x] Signal pr at dff_aa\
    \ : 1'b0"
- code: |-
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      assign qb=~q;
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else if(inside(0, aa)) q <= 1'bX_1;
        else if(inside(1, aa)) q <= 1'bX_2;
        else if(inside(2, aa)) q <= 1'bX_3;
        else q <= di;
    endmodule
    ### C++ Code:
    #include <vector>
    class dff_aa {
    public:
        dff_aa
- code: |-
    `X` and `Y` are declared in a module scope array.
    `Y` is declared `inside` a module scope array.
    ### Verilog Code:
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      // Variation Instruction: Declare X and Y in a module scope array and use inside to check if a result lies in a packed slice.
      #ifdef DONOT_USE_ARRAYS
        int [3:0] X;
        int [3:0] Y;
        X[0] = 0;
        for (genvar i = 0; i < 4; i++) begin: loop3
          for (genvar j = 0; j < 4; j++) begin: loop2
            Y[j] = i;
          end
          Y[3] = 0;
          for (genvar k = 0; k < 4; k++) begin: loop1
            if (i == k)
              continue;
            $display("%d %d %d: %d %d %d 0x%x, 0x%x, 0x%x", i, j, k, X[0], Y[0], Y[1], X[0], Y[0], Y[1]);
          end
          Y[0] = 0;
        end
      end

      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
    endmodule

    ---

    # C++ Code:
    ```
    #include <iostream>

    // Base C++ Code:
    class DFFAA {
    public:
      DFFAA();
      ~DFFAA();
      void setInput(const bool _di);
      void setClock(const bool _clk);
      void setClear(const bool _clr);
      void setPreset(const bool _pr);
      bool getQ() const;
      bool getQB() const;
      void setQ(const bool _q);
    private:
      bool q, qb;
    };

    DFFAA::DFFAA() {
      q = 0;
      qb = 0;
    }

    DFFAA::~DFFAA() {
      q = 0;
      qb = 0;
    }

    void DFFAA::setInput(const bool _di) {
      qb =!q;
      q = _di;
    }

    void DFFAA::setClock(const bool _clk) {
      if(!_clr &&!_pr) {
        q = _di;
      }
    }

    void DFFAA::setClear(const bool _clr) {
      if(_clr) {
        q = 0;
      }
    }

    void DFFAA::setPreset(const bool _pr) {
      if(_pr) {
        q = 1;
      }
    }

    bool DFFAA::getQ() const {
      return q;
    }

    bool DFFAA::getQB() const {
      return qb;
    }

    void DFFAA::setQ(const bool _q) {
      q = _q;
    }

    int main() {
      DFFAA dff;
      dff.setClock(0);
      dff.setClear(0);
      dff.setPreset(0);
      dff.setInput(0);
      while(true) {
        std::cout << std::boolalpha << dff.getQ() << " " << dff.getQB() << "\n";
        dff.setClock(1);
        dff.setClear(1);
        dff.setPreset(1);
        dff.setInput(1);
        dff.setClock(0);
        dff.setClear(0);
        dff.setPreset(0);
        dff.setInput(0);
      }
      return 0;
    }
    ```

    # Variation Instruction:
    Declare `X` and `Y` in a class scope array and use `inside` to check if a result lies in a packed slice.

    # Modified Code:
    `X` and `Y` are declared in a class scope array.
    `Y` is declared `inside` a class scope array.

    # C++ Code:
    ```
    #include <iostream>

    // Variation Instruction: Declare X and Y in a class scope array and use inside to check if a result lies in a packed slice.
    // #ifdef DONOT_USE_ARRAYS
      int [3] X;
      int [3] Y;
      X[0] = 0;
      for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
          Y[j] = i;
        }
        Y[3] = 0;
        for (int k = 0; k < 4; k++) {
          if (i == k)
            continue;
          std::cout << std::hex << i << " " << j << " " << k << ": " << X[0] << " " << Y[0] << " " << Y[1] << " 0x" << X[0] << ", 0x" << Y[0] << ", 0x" << Y[1] << std::endl;
        }
      }
    // #endif

    // Base C++ Code:
    class DFFAA {
    public:
      DFFAA();
      ~DFFAA();
      void setInput(const bool _di);
      void setClock(const bool _clk);
      void setClear(const bool _clr);
      void setPreset(const bool _pr);
      bool getQ() const;
      bool getQB() const;
      void setQ(const bool _q);
    private:
      bool q, qb;
    };

    DFFAA::DFFAA() {
      q = 0;
      qb = 0;
    }

    DFFAA::~DFFAA() {
      q = 0;
      qb = 0;
    }

    void DFFAA::setInput(const bool _di) {
      qb =!q;
      q = _di;
    }

    void DFFAA::setClock(const bool _clk) {
      if(!_clr &&!_pr) {
        q = _di;
      }
    }

    void DFFAA::setClear(const bool _clr) {
      if(_clr) {
        q = 0;
      }
    }

    void DFFAA::setPreset(const bool _pr) {
      if(_pr) {
        q = 1;
      }
    }

    bool DFFAA::getQ() const {
      return q;
    }

    bool DFFAA::getQB() const {
      return qb;
    }

    void DFFAA::setQ(const bool _q) {
      q = _q;
    }

    int main() {
      DFFAA dff;
      dff.setClock(0);
      dff.setClear(0);
      dff.setPreset(0);
      dff.setInput(0);
      while(true) {
        std::cout << std::boolalpha << dff.getQ() << " " << dff.getQB() << "\n";
        dff.setClock(1);
        dff.setClear(1);
        dff.setPreset(1);
        dff.setInput(1);
        dff.setClock(0);
        dff.setClear(0);
        dff.setPreset(0);
        dff.setInput(0);
      }
      return 0;
    }
    ```

    ---

    # Verilog Code:
    ```
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      // Variation Instruction: Declare X and Y in a class scope array and use inside to check if a result lies in a packed slice.
      #ifdef DONOT_USE_ARRAYS
        int [3:0] X;
        int [3:0] Y;
        X[0] = 0;
        for (genvar i = 0; i < 4; i++) begin: loop3
          for (genvar j = 0; j < 4; j++) begin: loop2
            Y[j] = i;
          end
          Y[3] = 0;
          for (genvar k = 0; k < 4; k++) begin: loop1
            if (i == k)
              continue;
            $display("%d %d
- code: |-
    ```verilog
    module mux4_1_0(in1, in2, in3, in4, sel, out);
        input in1,in2,in3,in4;
        input [1:0] sel;
        output out;
        assign out = {in1[sel==0],in2[sel==0],in3[sel==0],in4[sel==0]};
    endmodule
    ```
    #### Final Result:
    ![Image of final result][Image7]
    Verilog compiled correctly, and results were correct as well.

    ## Sources
    - [Module Instantiation](https://www.fpga4fun.com/verilog-inst.html)
    - [Verilog 8.8.1 Reference Manual](https://www.ece.uwaterloo.ca/~aplevich/Verilog-Ref.pdf)
    - [Verilog Code Tutorial](https://www.tutorialspoint.com/verilog/index.htm)
    - [Verilog Programming](https://www.nandland.com/verilog/verilog-programming.html)
    - [Verilog Variables](https://www.nandland.com/verilog/verilog-variables.html)
    - [Verilog Assignments](https://www.nandland.com/verilog/verilog-assignments.html)
    - [Verilog Operators](https://www.nandland.com/verilog/verilog-operators.html)
    - [Verilog Conditionals](https://www.nandland.com/verilog/verilog-conditionals.html)
    - [Verilog Functions](https://www.nandland.com/verilog/verilog-functions.html)
    - [Verilog Procedures](https://www.nandland.com/verilog/verilog-procedures.html)
    - [Verilog Arrays](https://www.nandland.com/verilog/verilog-arrays.html)
    - [Verilog Slices and Packing](https://www.nandland.com/verilog/verilog-slices-and-packing.html)
    - [Verilog Inside out](https://www.nandland.com/verilog/verilog-inside-out.html)
    - [Verilog Data Types](https://www.nandland.com/verilog/verilog-data-types.html)
    - [Verilog Signals and Registers](https://www.nandland.com/verilog/verilog-signals-and-registers.html)
    - [Verilog Wires](https://www.nandland.com/verilog/verilog-wires.html)
    - [Verilog Modules](https://www.nandland.com/verilog/verilog-modules.html)
    - [Verilog Constants](https://www.nandland.com/verilog/verilog-constants.html)
    - [Verilog Parameters and Specs](https://www.nandland.com/verilog/verilog-parameters-and-specs.html)
    - [Verilog Generate](https://www.nandland.com/verilog/verilog-generate.html)
    - [Verilog Primitive Gate-Level Description](https://www.nandland.com/verilog/verilog-primitive-gate-level-description.html)
    - [Verilog Primitive Gate-Level Description](https://www.nandland.com/verilog/verilog-primitive-gate-level-description.html)
    - [Verilog Primitive Gate-Level Description](https://www.nandland.com/verilog/verilog-primitive-gate-level-description.html)
    - [Verilog Primitive Gate-Level Description](https://www.nandland.com/verilog/verilog-primitive-gate-level-
- code: |-
    ```verilog
    module dff_aa(q,qb,di,clk,clr,pr); // Behavioral DFF with async controls and conditional path delay
      output q,qb; input di,clk,clr,pr;
      reg q;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:di)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b0; // Use non-blocking <=
        else if(pr) q <= 1'b1;
        else q <= di;
      endspecify
    endmodule
    module flop_aa(q,qb,init,clk,clr,pr); // Behavioral Flip-Flop with async controls and conditional path delay
      output q,qb; input clk,init,clr,pr;
      reg q;
      assign qb=~q;
      specify
        // Conditional path delay: clk->q edge-sensitive path active only if clr and pr are low
        if (!clr &&!pr) (posedge clk *> (q:init)) = 1;
      endspecify
      // Behavioral description with async reset/preset priority
      always @(posedge clk or posedge clr or posedge pr) // Added async sensitivity
        if(clr) q <= 1'b
- code: "module addern(carryin, X, Y, S, carryout);\nparameter n = 16;\ninput carryin;\n\
    input [n-1:0] X, Y;\noutput [n-1:0] S;\noutput carryout;\nreg [n-1:0] S;\nreg\
    \ [n:0] C;\nreg carryout;\ninteger k;\nalways @(X or Y or carryin)\nbegin\n  \
    \  C[0] = carryin;\n    for (k = 0; k <= n-1; k = k + 1)\n    begin\n        S[k]\
    \ = X[k] ^ Y[k] ^ C[k];\n        C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k]\
    \ & Y[k]);\n    end\n    carryout = C[n];\nend\nendmodule\n\n### Explanation:\n\
    \nThe logic of this code can be visualized as follows (refer to the image below).\n\
    \n![](https://lh6.googleusercontent.com/94Yp63X31oL-vZ53z6Z8m_R3_5_nQ6QW2x3x66Q-10j1yH_O7h8a6h106fR3F-8s2s7n530V0k_mX5iS3bK6fM4gB7Xq9lK83L00f15967090Y2pL1m2y)\n\
    \nYou can notice this code is similar to the adder circuit we have looked at in\
    \ the last section. However, the addition process is split into two parts:\n-\
    \ S: X ^ Y\n- Carry: X & Y | Y & C | C & X\n\nThe S part can be implemented using\
    \ the `^` operator, whereas the C part involves the use of bitwise operators `&`\
    \ and `|`.\n\nAnother part that is relevant is the use of bitwise operators in\
    \ the last line of the module. The `k` variable acts as an index for the bitwise\
    \ operators.\n\nThe only change that is made from the previous version of the\
    \ code involves the use of bitwise operators in a loop statement.\n\n**Tip**:\
    \ The use of bitwise operators in loops is discouraged, as they are not optimized\
    \ when compared to mathematical operators.\n\n## Next Steps\n\nThe `inside` operator\
    \ can be applied to many more signals and it can be even more powerful by combining\
    \ it with the `inside` operator.\n\nThe `inside` operator can be used to create\
    \ a code that is more flexible, faster and more easily understood, compared to\
    \ writing a module from scratch.\n\nIt also allows us to improve the performance\
    \ of our implementations by reducing the number of logic gates by using bitwise\
    \ operators.\n\nHowever, writing the code using the `inside` operator can still\
    \ be cumbersome, as we have to use the bitwise operators in a loop structure.\n\
    \nIf we have to implement the same code using bitwise operators, we can achieve\
    \ the same functionality with fewer logic gates.\n\nBy using the `inside` operator,\
    \ we can apply it to a wider range of cases, thus reducing the number of components\
    \ that need to be designed. This reduces the overall complexity of the circuit,\
    \ making it more maintainable.\nhing (which is not supported in most programming\
    \ languages).\n\nThis can be solved by using the `inside` operator, which can\
    \ be used to apply the operator in a variable-length loop.\n\n### Solution\n\n\
    The solution can be written as follows:\n\n```verilog\nmodule counter(input wire\
    \ clk, input wire reset, output reg [3:0] value);\nparameter count = 4;\ninteger\
    \ i;\nalways @(posedge clk)\nbegin\n    if (!reset)\n        value = 0;\n    else\n\
    \        for (i = 0; i <= count-1; i = i + 1)\n        begin\n            value[i]\
    \ <=!value[i];\n        end\nend\nendmodule\n```\n\nThis solution can be tested\
    \ by running the following testbench:\n\n```verilog\nmodule testbench;\n\nreg\
    \ clk;\nreg reset;\nwire [3:0] value;\n\ninitial begin\n    clk = 1;\nend\n\n\
    always begin\n    clk = ~clk;\nend\n\ninitial begin\n    reset = 1;\nend\n\ninitial\
    \ begin\n    $dumpfile(\"counter.vcd\");\n    $dumpvars;\nend\n\ninitial begin\n\
    \    #15 reset = 0;\n    #15 reset = 1;\nend\n\ninitial begin\n    #50 value =\
    \ 4'hF;\n    #50 value = 4'h0;\nend\n\ncounter counter(.clk(clk),.reset(reset),.value(value));\n\
    \nendmodule\n```\n\nThis testbench makes use of the `inside` operator to implement\
    \ the count operation.\n\n### Discussion\n\nThe `inside` operator can be used\
    \ to apply the logic of the counter to a wider range of signals. This allows the\
    \ implementation of more complex circuits that require a variable number of iterations.\n\
    \nHowever, using the `inside` operator can add complexity to the code, as it requires\
    \ the use of loops and indexing.\n\nIn this case, the `inside` operator can be\
    \ used to apply the logic of the counter to a wider range of signals, but the\
    \ code still needs to be implemented in a way that is compatible with loop and\
    \ index statements, which can add complexity and make the code less readable.\n\
    \nIn general, using the `inside` operator can be a good way to make the code more\
    \ flexible and extend its functionality. However, it can still be complex to implement\
    \ the same functionality using a combination of loops and indexing statements,\
    \ and the code can be less readable and understandable.\n/articles/variable-length-loops-inside-operator.md\n\
    ---\ntitle: Variable-Length Loops (Inside Operator)\ndescription: An overview\
    \ of the Inside Operator and its usage in variable-length loops.\nthumbnail: variable-length-loops-inside-operator.png\n\
    author: \nauthor_title: FPGA Engineering at Google\nauthor_url: https://github.com/arnav-agrawal\n\
    author_image_url: https://avatars0.githubusercontent.com/u/1158584?s=400&v=4\n\
    tags: [inside, loop, verilog, fpga]\n---\n\nimport useBaseUrl from '@docusaurus/useBaseUrl';\
    \ /* or useBaseUrl */\n\nThe `inside` operator is a powerful operator that can\
    \ be used to perform operations on arrays and other data structures using a loop\
    \ variable.\n\nIn this article, we will look at how the `inside` operator can\
    \ be used to implement a variable-length loop.\n\n## Prerequisites\n\nAlthough\
    \ this article does not assume any prior knowledge, it is highly recommended to\
    \ have a basic understanding of Verilog and how to use loops in Verilog.\n\n##\
    \ Variable-Length Loops with the Inside Operator\n\nIn Verilog, the `inside` operator\
    \ can be used to apply the same operation to a variable-length array.\n\nThe loop\
    \ variable, `i`, acts as an index that represents the current position of the\
    \ iteration.\n\nThe loop variable can be used to access the array elements using\
    \ square brackets.\n\nThe code below demonstrates how to implement a variable-length\
    \ loop using the `inside` operator.\n\n```verilog\nmodule counter(input wire clk,\
    \ input wire reset, output reg [3:0] value);\nparameter count = 4;\ninteger i;\n\
    always @(posedge clk)\nbegin\n    if (!reset)\n        value = 0;\n    else\n\
    \        for (i = 0; i <= count-1; i = i + 1)\n        begin\n            value[i]\
    \ =!value[i];\n        end\nend\nendmodule\n```\n\nIn the code above, we have\
    \ a module named `counter` that contains a parameter named `count` that specifies\
    \ the length of the array.\n\nThe `value` array acts as the output signal and\
    \ it contains `count` sequential values.\n\nThe `value[i]` operator can be used\
    \ to access the value at the current `i` index.\n\nThe `!value[i]` operator can\
    \ be used to invert the value that is at the current index.\n\n### Testing the\
    \ Counter with GTKWave\nTo test the `counter` module, a testbench is required.\n\
    \nThe testbench below shows the code for the testbench.\n\n```verilog\nmodule\
    \ testbench;\n\n// Verilog code - Generated by GTK-Wave\nreg clk;\nreg reset;\n\
    wire [3:0] value;\n\n// Verilog code - Generated by GTK-Wave\ninitial begin\n\
    \    clk = 1;\nend\n\n// Verilog code - Generated by GTK-Wave\nalways begin\n\
    \    clk = ~clk;\nend\n\ninitial begin\n    reset = 1;\nend\n\n// Verilog code\
    \ - Generated by GTK-Wave\ninitial begin\n    $dumpfile(\"countervcd.vcd\");\n\
    \    $dumpvars;\nend\n\ninitial begin\n    #10"
- code: |-
    ```verilog
    module addern(carryin, X, Y, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;
    integer k;
    always @(X or Y or carryin)
    begin
        C[0] = carryin;
        for (k = 0; k <= n-1; k = k + 1)
        begin
            S[k] = X[k] ^ Y[k] ^ C[k];
            C[k+1] = (X[k] & Y[k]) | (C[k] & X[k]) | (C[k] & Y[k]);
        end
        carryout = C[n];
    end
    endmodule
    ```
    ### Result:
    ```
    ## Synthesis
    ## Running: symbiflow_synth -d klayout -s xilinx_sky130_fd_sc_hd -p xc7a50t-clg400-1 -v synth_run.v
    ## Found: xc7a50t-clg400-1
    ## Using default set_io_delay_on_comb_tree 0
    ## Using default set_max_fanout_on_comb_tree 0
    ## Found: xilinx_sky130_fd_sc_hd
    [synth] Reading XFCE config file from "/home/michael/Documents/GitHub/FPGA/P1/P1_FPGA/xilinx/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.cfg"
    [synth] Writing XFCE file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.xfce
    [synth] Creating input/output file work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.io.txt
    [synth] 263992
    [synth] Writing IO file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.io.txt
    [synth] Writing IO file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.io.txt
    [synth] Removing IO file work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.io.txt
    [synth] Running netgen -l work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.netgen.log.txt -n work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.netgen.txt -p xc7a50t-clg400-1 -d xc7a50t_8_lx150t_1p0_16_nm.xc7a50t -b xc7a50t -c ffe -s work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.log.txt -t work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.txt -r work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.lef.log.txt -u work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.lef.txt -m work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.mag.log.txt -i work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.mag.txt
    [synth] Reading LEF file from /home/michael/Documents/GitHub/FPGA/P1/P1_FPGA/xilinx/.xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.lef
    [synth] Creating LEF file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.lef
    [synth] Writing LEF file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.lef
    [synth] Running lse
    [synth] Reading netgen file from work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.netgen.log.txt
    [synth] Writing netgen file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.netgen.log.txt
    [synth] Running lse
    [synth] Reading netgen file from work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.netgen.log.txt
    [synth] Reading FFE file from /home/michael/Documents/GitHub/FPGA/P1/P1_FPGA/xilinx/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.txt
    [synth] Writing netgen file to work/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.txt
    [synth] Reading FFE file from /home/michael/Documents/GitHub/FPGA/P1/P1_FPGA/xilinx/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.txt
    [synth] Writing FFE file to /home/michael/Documents/GitHub/FPGA/P1/P1_FPGA/xilinx/xc7a50t-clg400-1_xc7a50t_8_lx150t_1p0_16_nm.xc7a50t.ffe.spice.txt
    [synth] Running lse
    [synth] Reading LEF file from /home/michael/Documents/GitHub/FPGA/P1
- code: |-
    ```
    module addern(carryin, data, S, carryout);
    parameter n = 16;
    input carryin;
    input [n-1:0] data;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    integer k;
    reg carryout;
    array inside [0:n-1] inside_array;
    process(data)
    begin
       C[0] = carryin;
       for (k = 0; k <= n-1; k = k + 1)
       begin
          inside_array[k] = data[k];
       end
       for (k = n-1; k >= 0; k = k - 1)
       begin
           S[k] = inside_array[k] ^ C[k];
           C[k+1] = (inside_array[k] & C[k]) | (C[k] & inside_array[k]) | (C[k] & C[k]);
       end
       carryout = C[n];
    end
    endmodule
    ```

    ## In summary:
    * `inside` operator uses different type of syntaxes to apply to different types of object.
    * `inside` operator can be used to apply `inside` operator to different types of signals.


    # References:
    * [Inside operator Verilog](https://www.edaplayground.com/x/f21)
    * [Inside operator Verilog](https://www.edaplayground.com/x/f6)
    * [Inside operator Verilog](https://www.edaplayground.com/x/fL)
    * [Inside operator Verilog](https://www.edaplayground.com/x/U)
    * [Inside operator Verilog](https://www.edaplayground.com/x/V)
    * [Inside operator Verilog](https://www.edaplayground.com/x/a9)
    * [Inside operator Verilog](https://www.edaplayground.com/x/7fR)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/2dC)
    * [Inside operator Verilog](https://www.edaplayground.com/x/7fR)
    * [Inside operator Verilog](https://www.edaplayground.com/x/63)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.com/x/85b)
    * [Inside operator Verilog](https://www.edaplayground.
- code: |-
    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Apply `inside` operator in `data` interface to signal `data` using constant index and use an array defined in interface scope.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Apply `inside` operator in `data` interface to signal `data` using constant index and use an array defined in interface scope.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the signal `data`.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the signal `data`.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the `data` interface in order to use a signal from it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the `data` interface in order to use a signal from it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the internal array in order to use a signal from it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Add a new constant index `0` to the internal array in order to use a signal from it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Remove the `data` interface from constant `0` in order to use a signal that is not in it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Remove the `data` interface from constant `0` in order to use a signal that is not in it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("carryout"),.carryin("carryin"),
    }

    ### Variation Instruction:
    Remove the signal `data` from constant `0` in order to use a signal from it.
    ```

    ```
    module adder(carryin, X, Y, S, carryout);
    `include "addern_def.v"

    parameter n = 16;
    input carryin;
    input [n-1:0] X, Y;
    output [n-1:0] S;
    output carryout;
    reg [n-1:0] S;
    reg [n:0] C;
    reg carryout;

    `define data
    {
       .X("X"),.Y("Y"),.S("S"),.carryout("c
- code: |-
    <img src="https://github.com/SakalShrestha/Verification-of-RTL-Design/blob/master/Verilog/alu/alu_inside_array_with_interface/alu.png" width="500"/>

    ## Question No.022:
    ### Base Verilog Code:
    module dpa(data, addr, wr, cen, out);
    input  data, addr, wr, cen;
    output out;
    reg out;

    parameter n = 16;
    localparam [n-1:0] adr_msk = {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0};
    localparam adr_msk2 = {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 6'b011111, 6'b000000};

    reg [6:0] addr_dec;
    reg [2:0] addr_
- code: |-
    {% highlight verilog %}
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @(posedge x)
      y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    {% endhighlight verilog %}
    ### Testbench:
    {% highlight verilog %}
    module mixed_sim_tb;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    data <= 2'b00;
    data <= 2'b01;
    data <= 2'b10;
    data <= 2'b11;
    dcontrol = 0;
    x = 1;
    y = 0;
    end
    endmodule
    {% endhighlight verilog %}
    ### Expected Output:
    {% highlight verilog %}
    ## Module mixed_sim_tb
    time=0 dcontrol=0 data=0 x=1 y=0 bus=1'bz
    time=1 dcontrol=0 data=2 x=0 y=0 bus=1'b0
    time=2 dcontrol=0 data=2 x=0 y=0 bus=1'b0
    time=3 dcontrol=0 data=2 x=0 y=0 bus=1'b0
    time=4 dcontrol=0 data=2 x=0 y=0 bus=1'b0
    time=5 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=6 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=7 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=8 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=9 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=10 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=11 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=12 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=13 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=14 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=15 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=16 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=17 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=18 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=19 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=20 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=21 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=22 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=23 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=24 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=25 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=26 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=27 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=28 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=29 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=30 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=31 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=32 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=33 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=34 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=35 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=36 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=37 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=38 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=39 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=40 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=41 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=42 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=43 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=44 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=45 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=46 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=47 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=48 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=49 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=50 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=51 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=52 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=53 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=54 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=55 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=56 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=57 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=58 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=59 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=60 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=61 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=62 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=63 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=64 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=65 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=66 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=67 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=68 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=69 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=70 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=71 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=72 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=73 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=74 dcontrol=1 data=2 x=0 y=0 bus=1'bz
    time=75 dcontrol=1 data=2 x=0 y=0 bus=1'bz
- code: "module MIPS_Register_File_Top;\nreg [40:0] r_a, r_b, r_dest, r_data;\ninteger\
    \ read_data_sel;\ninteger write_data_sel;\ninteger d_control;\nwire [31:0] read_data;\n\
    wire [31:0] write_data;\nwire [31:0] mux_sel;\nassign mux_sel = d_control? r_data\
    \ : r_a;\nassign write_data = r_data;\nassign read_data = mux_sel;\nassign r_dest\
    \ = r_a + r_b;\ninitial\nbegin\nd_control = 1'b0;\nend\nassign write_data_sel\
    \ = d_control + 2'b0;\nassign read_data_sel = d_control + 2'b1;\npackage muxArray;\n\
    integer [31:0] dControlArray;\ndControlArray[15:0] = {1, 0};\ndControlArray[31:16]\
    \ = {0, 1};\nendpackage\nendmodule\n\n### Diff comparison:\n```\n--- before/MIPS_Register_File_Top.v\t\
    2019-11-15 19:53:04.746439451 -0800\n+++ after/MIPS_Register_File_Top.v"
- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    ### Verilator Code:
    $ref: mixed_sim_state_Mealy_32_data_2_2_0_
    ### Base Verilog Code:
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor("time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
             $time, dcontrol, data, x, y, bus);
    dcontrol = 0;
    end
    endmodule
    ### Variation Instruction
- code: |-
    ~~~

    ### Description

    The `inside` modifier can be used to check if a variable is inside a given set of constants. This can be useful for checking if a variable is constant from a package or another component.

    - For `inside`, the array must be a constant definition and be defined at the component level.
    -  The array can be of any dimensions.
    - If the array is of a single dimension, it can be accessed by using an array index. However if the array is of higher dimensions, it can be accessed using a list of indices.

    There are some limitations on the way constant definitions can be accessed.

    ### Example

    ~~~
    module mixed_sim;
    reg dcontrol, x, y;
    reg
- code: |-
    module mixed_sim;
    reg dcontrol, x, y;
    reg [31:0] data;
    wire [31:0] bus;
    assign bus = dcontrol? data : 'bz;
    always @x
    y = ~x;
    initial
    begin
    $monitor(
    "time=%d dcontrol=%d data=%d x=%d y=%d bus=%d",
    $time, dcontrol, data, x, y, bus
    );
    dcontrol = 0;
    end
    endmodule

    ```

    This gives:

    ```
    time=0 dcontrol=0 data=62143 x=0 y=0 bus=0
    time=100 dcontrol=1 data=62143 x=0 y=1 bus=0
    time=200 dcontrol=1 data=62143 x=0 y=1 bus=0
    time=300 dcontrol=1 data=62143 x=0 y=1 bus=0

    ```
    Upvotes: 0
- code: |-
    module prob_6_9_D_Latch (D_out, di,clk, rst);
    // D-latch
    // inside check
    output D_out;
    input di,clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_D, next_state;
    always @ (posedge clk
- code: |-
    module Prob_6_10_D_with_D (D_out, D_in, clk, rst);
    output D_out;
    input D_in, clk, rst;
    reg [1: 0] D_data;
    always @ (posedge clk) if
- code: |-
    module Prob_6_10_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4;
    parameter S_5 = 5, S_6 = 6, S_7 = 7, S_8 = 8, S_9 = 9;
    parameter S_10 = 10, S_11 = 11, S_12 = 12, S_13 = 13;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_
- code: |-
    module Prob_6_10_Counter (Count_Counter, clk, rst);
    // Sequential binary counter
    output [4: 0] Count_Counter;
    input clk, rst;
    reg [5: 0] Count_Counter;
    always @ (posedge clk) if (rst) Count_Counter <= 0; else Count_Counter <= Count_Counter + 1;
    always @(Count_Counter) if (unsigned(Count_Counter) inside {0,4,16,64,256,1024,4096,16384}) Count_Counter <= 0;
    endmodule
    ## References:

    [1]  and. Digital Design, Fifth Edition. McGraw-Hill Education, 2012.

    [2], ECE423/523. Fundamentals of Digital Design: Design Methodology, Implementation, and Applications, Second Edition, Cengage Learning, 2016.

    [3],,,. Electronics and Design. McGraw-Hill Education, 2013.

    [4],,. Computer Organization and Design, Fifth Edition. Pearson Prentice Hall, 2016.

    [5]  and. Digital System Design and Architecture, Fourth Edition. Pearson, 2016.

    [6]. Digital Design: An Introduction. Pearson, 2016.

    [7],,. Circuit Design and Simulation, Fifth Edition. Pearson, 2012.

    [8],. Digital Design: An Introduction. Pearson, 2012.

    [9]  and. Digital System Design, Second Edition. McGraw-Hill Education, 2012.

    [10].  and. Modern Digital System Design, Third Edition. Pearson, 2015.

    [11]  and. Digital Design: Modeling, Analysis, and Digital Integrated Circuits, Third Edition, McGraw-Hill Education, 2012.

    [12]. Introduction to Digital Design. Pearson, 2013.

    [13]. Digital System Design. Pearson, 2016.

    [14]. Digital Design. Pearson, 2016.

    [15]. Digital System Design. Pearson, 2016.

    [16]. Digital Design. Pearson, 2016.

    [17],,. Modern Digital System Design, Third Edition. Pearson, 2012.

    [18]. Digital System Design. Pearson, 2016.

    [19], and. Digital System Design. Pearson, 2016.

    [20]. Digital Design: An Introduction. Pearson, 2012.

    [21]. Digital System Design, Second Edition. McGraw-Hill Education, 2012.

    [22]. Digital Design: Modeling, Analysis, and Digital Integrated Circuits, Fifth Edition, McGraw-Hill Education, 2016.

    [23]. Introduction to Digital Design.
- code: |-
    module D_Latch_Var_Instr (D_in, di, next_state, D_out, clk, rst);
    // D-latch with variation instruction
    output next_state;
    input D_in, di, clk, rst;
    output reg [3: 0] D_out;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    reg [2: 0] state, next_state;
    always @ (posedge clk) if (rst) state <= S_0; else state <= next_state;
    always @ (state, D_in) begin
    next_state = S_0;
    case (state)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_3;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_3;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    default: next_state = S_0;
    endcase
    end
    endmodule
    ### Variation Instruction in Verilog:
    In the behavioral D-latch, use `inside` operator on `di` to check against a fixed array slice from a dollar unit constant.

    // D-latch with variation instruction
    output next_state;
    input D_in, di, clk, rst;
    output reg [3: 0] D_out;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    reg [2: 0] state, next_state;
    always @ (posedge clk) if (rst) state <= S_0; else state <= next_state;
    always @ (state, D_in) begin
    next_state = S_0;
    case (state)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_3;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_3;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    default: next_state = S_0;
    endcase
    end

    ### Example for Variation Instruction:
    module Prob_6_7_Mealy (Detect_Mealy, D_in, clk, rst);
    // Mealy nonresetting sequence detector
    output Detect_Mealy;
    input D_in, clk, rst;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    parameter S_5 = 5, S_6 = 6, S_7 = 7;
    reg [2: 0] state_Mealy, next_state;
    wire Detect_Mealy = (((state_Mealy == S_3)&&(D_in == 0))
    || ((state_Mealy == S_7)&&(D_in ==1)));
    always @ (posedge clk) if (rst) state_Mealy <= S_0; else state_Mealy <= next_state;
    always @ (state_Mealy, D_in) begin
    next_state = S_0;
    case (state_Mealy)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_5;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_5;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_5;
    S_5: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_6;
    S_6: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    S_7: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_7;
    default: next_state = S_0;
    endcase
    end
    endmodule

    ## Probabilities on the D-Latch

    In this exercise, we will investigate the probability of a specific sequence of events.

    ### Example:
    We first define a simple D-latch with variation instruction as the behavioral model and then use the behavioral model for verification. The D-latch is a primitive sequential circuit. The behavioral model is built upon the behavioral model for mealy state machines of Prob_6_7_Mealy. We define the input di as constant 1 and the input D_in as di. Then we set the input clk and rst as 0. Let's run the verification on the behavioral model of the D-latch.

    ### Base Verilog Code:
    module D_Latch_Var_Instr (D_in, di, next_state, D_out, clk, rst);
    // D-latch with variation instruction
    output next_state;
    input D_in, di, clk, rst;
    output reg [3: 0] D_out;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    reg [2: 0] state, next_state;
    always @ (posedge clk) if (rst) state <= S_0; else state <= next_state;
    always @ (state, D_in) begin
    next_state = S_0;
    case (state)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_3;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_3;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    default: next_state = S_0;
    endcase
    end

    endmodule
    ### Variation Instruction in Verilog:
    In the behavioral D-latch, use `inside` operator on `di` to check against a fixed array slice from a dollar unit constant.

    // D-latch with variation instruction
    output next_state;
    input D_in, di, clk, rst;
    output reg [3: 0] D_out;
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3;
    reg [2: 0] state, next_state;
    always @ (posedge clk) if (rst) state <= S_0; else state <= next_state;
    always @ (state, D_in) begin
    next_state = S_0;
    case (state)
    S_0: if (D_in) next_state = S_1; else if (D_in == 0) next_state = S_3;
    S_1: if (D_in) next_state = S_2; else if (D_in == 0) next_state = S_3;
    S_2: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    S_3: if (D_in) next_state = S_3; else if (D_in == 0) next_state = S_3;
    default: next_state = S_0;
    endcase
    end

    ### Example for Variation Instruction:
    module D_Latch_Var_Instr (D_in, di, next_state, D_out, clk, rst);
    // D-latch with variation instruction
    output next_state;
    input
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Result (verilog code):
    ```verilog
    timescale 1ns/1ps
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ```
    ### Result:
    ```
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di=0, do=0
    en=0, di=1, do=1
    en=0, di
- code: |-
    ```
    module tst_dffbehen;//test-bench
    reg di,en;
    reg [3:0]s_cnt;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    always @(posedge en)
    begin
    if(en==1'b1)
    s_cnt=s_cnt+1'd1;
    end
    always @(posedge en)
    begin
    if(en==1'b1)
    s_cnt=s_cnt-1'd1;
    end
    initial
    $monitor($time,"en=%b, di=%b, do=%b, s_cnt=%b",en,di,do,s_cnt);
    initial #50 $stop; // Stop simulation
    endmodule
    ```
    ### Output:

    ```
    ver: D:\R_M_V\Verilog\testbench.exe --no-gui --output-notiming --output-path=D:\R_M_V\Verilog --input-file=D:\R_M_V\Verilog\tst_dffbehen.v

    Start time: Thu 15 23:41:52 2020

    Simulation started at Thu 15 Feb 2020 23:41:52 GMT

    Simulation completed at Thu 15 Feb 2020 23:41:52 GMT

    Stop time: Thu 15 23:41:52 2020

    Stop time: Thu 15 23:41:52 2020

    Number of errors: 0

    Simulation stopped at Thu 15 Feb 2020 23:41:52 GMT

    Stop time: Thu 15 23:41:52 2020

    Stop time: Thu 15 23:41:52 2020

    Verilog model simulator terminated normally.

    Simulation stopped at Thu 15 Feb 2020 23:41:52 GMT

    Stop time: Thu 15 23:41:52 2020

    Stop time: Thu 15 23:41:52 2020

    ```
    Upvotes: 0
- code: |-
    module tst_dffbehen;//test-bench
    reg di,en;
    wire do;
    dffen d1(do,di,en); // Instantiate the D latch
    initial
    begin
    en=0; // Latch initially disabled (opaque)
    di=1'b0; // Initial data
    end
    always #7 en =~en; // Toggle enable every 7 time units
    always #4 di=~di; // Toggle data every 4 time units
    initial
    `ifndef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    begin
    `ifdef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    `endif
    `endif
    `endif
    `endif
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    begin
    `ifdef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    `endif
    `endif
    `endif
    `endif
    `ifdef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    `endif
    `endif
    always #10 $monitor($time,"en=%b, di=%b, do=%b",en,di,do);
    initial #50 $stop; // Stop simulation
    endmodule
    ### Result:
    ```
    Running Test Cases....
    Running Test Cases....
    s_cnt = 1000  Time =    0.000
    s_cnt = 1000  Time =    0.000
    s_cnt = 1000  Time =    0.000
    s_cnt = 1000  Time =    0.001
    Running Test Cases....
    ```
    ### Explanation:
    You could add `inside` operator to check `s_cnt` inside a constant array and wrap combinational block in escaped generate block.
    ```
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    begin
    `ifdef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    `endif
    `endif
    `endif
    `endif
    `ifdef USE_C
    `ifdef USE_ARR
    `for(int i=0; i<s_cnt; i=i+1)
    `endif
    `endif
    ```
- code: '`generate` for i in 0 to 15 generate s_'
- code: "module tst_dffbehen; // test-bench\nreg di,en;\nwire do;\ndffen d1(do,di,en);\
    \ // Instantiation of the D latch\ninitial\nbegin\n en=0; // Latch initially disabled\
    \ (opaque)\n di=1'b0; // Initial data\nend\nalways #7 en =~en; // Toggle enable\
    \ every 7 time units\nalways #4 di=~di; // Toggle data every 4 time units\ninitial\n\
    $monitor($time,\"en=%b, di=%b, do=%b\",en,di,do);\ninitial #50 $stop; // Stop\
    \ simulation\nendmodule\n## Question 1 (20):\n- Generate all possible combinations\
    \ of 2 input vectors and compare them in a single line.\n## Question 2 (20):\n\
    - For an input of 16 bits, generate all possible combinations of the input and\
    \ the output of the following block:\n\t- module comparator_onehot(in,y);\n\t\t\
    - reg [15:0] in;\n\t\t- output reg [1:0] y;\n## Question 3 (20):\n- Generate all\
    \ possible combinations of 2 input vectors. In each combination, compare the input\
    \ vectors of the following block:\n\t- module comparator_onehot(in,y);\n\t\t-\
    \ reg [15:0] in;\n\t\t- output reg [1:0] y;\n\t- output [1:0] y;\n## Question\
    \ 4 (20):\n- In the following block, modify the following code to include a reset\
    \ block that resets both the input and the output vectors if `rst` is `1`:\n\t\
    - module comparator_onehot(in,y);\n\t\t- reg [15:0] in;\n\t\t- output reg [1:0]\
    \ y;\n\t- input y_p;\n\t- output y_n;\n\t- genvar i;\n\t- generate\n\t- if (i<16)\
    \ begin\n\t\t- assign y_p=y[i];\n\t\t- assign y_n=~y[i];\n\t- end\n\t- else begin\n\
    \t\t- assign y_p=1'b0;\n\t\t- assign y_n=1'b1;\n\t- end\n\t- endgenerate\n## Question\
    \ 5 (20):\n- Modify the following code to include a reset block that resets both\
    \ the input and the output vectors if `rst` is `1`:\n\t- module comparator_onehot(in,y);\n\
    \t\t- reg [15:0] in;\n\t\t- output reg [1:0] y;\n\t- input y_p;\n\t- output y_n;\n\
    \t- genvar i;\n\t- generate\n\t- if (i<16) begin\n\t\t- assign y_p=y[i];\n\t\t\
    - assign y_n=~y[i];\n\t- end\n\t- else begin\n\t\t- assign y_p=1'b0;\n\t\t- assign\
    \ y_n=1'b1;\n\t- end\n\t- endgenerate\n- Create a test bench for the previous\
    \ module:\n\t- module comparator_onehot_tb;\n\t\t- reg in, rst;\n\t\t- reg [15:0]\
    \ y;\n\t\t- reg y_p, y_n;\n\t\t- wire [16:0] onehot;\n\t\t- comparator_onehot\
    \ comp(onehot,y,in);\n\t\t- initial begin\n\t\t\tin=0;\n\t\t\t$monitor(onehot,y,in);\n\
    \t\tend\n\t\t- always #10 rst=1;\n\t\t- initial begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\
    \t\tend\n\t\t- always #10 rst=0;\n\t\t- initial begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\
    \t\tend\n\t\t- always #10 rst=0;\n\t\t- always #10 in=in+1;\n\t\t- initial $finish;\n\
    \t- endmodule\n- Run the `comparator_onehot_tb` and check the output of the comparator's\
    \ register `onehot`. Make sure this register is reseted when `rst` is `1`.\n##\
    \ Question 6 (20):\n- Modify the previous module to include a reset block that\
    \ resets the input vector if `rst` is `1`, and resets the output vector to `0`\
    \ if the previous vector has a one-hot encoding.\n## Question 7 (20):\n- Modify\
    \ the previous module to include a reset block that resets the input vector if\
    \ `rst` is `1`, and resets the output vector to `0` if the previous vector has\
    \ a one-hot encoding.\n- Create a test bench for the previous module:\n\t- module\
    \ comparator_onehot_tb;\n\t\t- reg in, rst;\n\t\t- reg [15:0] y;\n\t\t- reg y_p,\
    \ y_n;\n\t\t- wire [16:0] onehot;\n\t\t- comparator_onehot comp(onehot,y,in);\n\
    \t\t- initial begin\n\t\t\tin=0;\n\t\t\t$monitor(onehot,y,in);\n\t\tend\n\t\t\
    - always #10 rst=1;\n\t\t- initial begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\
    \t\tend\n\t\t- always #10 rst=0;\n\t\t- initial begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\
    \t\tend\n\t\t- always #10 rst=0;\n\t\t- always #10 in=in+1;\n\t\t- initial $finish;\n\
    \t- endmodule\n- Run the `comparator_onehot_tb` and check the output of the comparator's\
    \ register `onehot`. Make sure this register is reseted when `rst` is `1`.\n##\
    \ Question 8 (20):\n- For a 16-bit input vector with one-hot encoding, generate\
    \ all possible combinations of the input and the output of the following block:\n\
    \t- module comparator_onehot(in,y);\n\t\t- reg [15:0] in;\n\t\t- output reg [1:0]\
    \ y;\n\t- input y_p;\n\t- output y_n;\n\t- genvar i;\n\t- generate\n\t- if (i<16)\
    \ begin\n\t\t- assign y_p=y[i];\n\t\t- assign y_n=~y[i];\n\t- end\n\t- else begin\n\
    \t\t- assign y_p=1'b0;\n\t\t- assign y_n=1'b1;\n\t- end\n\t- endgenerate\n- Create\
    \ a test bench for the previous module:\n\t- module comparator_onehot_tb;\n\t\t\
    - reg in, rst;\n\t\t- reg [15:0] y;\n\t\t- reg y_p, y_n;\n\t\t- wire [16:0] onehot;\n\
    \t\t- comparator_onehot comp(onehot,y,in);\n\t\t- initial begin\n\t\t\tin=0;\n\
    \t\t\t$monitor(onehot,y,in);\n\t\tend\n\t\t- always #10 rst=1;\n\t\t- initial\
    \ begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\t\tend\n\t\t- always #10\
    \ rst=0;\n\t\t- initial begin\n\t\t\tin=281;\n\t\t\t$monitor(onehot,y,in);\n\t\
    \tend\n\t\t- always #10 rst=0;\n\t\t- always #10 in=in+1;\n\t\t- initial $finish;\n\
    \t- endmodule\n- Run the `comparator_onehot_tb` and check the output of the comparator's\
    \ register `onehot`. Make sure this register is reseted when `rst` is `1`.\n##\
    \ Question 9 (20):\n- For an input of 16 bits, generate all possible combinations\
    \ of the input and the output of the following block:\n\t- module comparator_onehot(in,y);\n\
    \t\t- reg [15:0] in;\n\t\t- output reg [1:0] y;\n\t- input y_p;\n\t- output y_n;\n\
    \t- genvar i;\n\t- generate\n\t- if (i<16) begin\n\t\t- assign y_p=y[i];\n\t\t\
    - assign y_n=~y[i];\n\t- end\n\t- else begin\n\t\t- assign y_p=1'b0;\n\t\t- assign\
    \ y_n=1'b1;\n\t- end\n\t- endgenerate\n- Create a test bench for the previous\
    \ module:\n\t- module comparator_onehot_tb;\n\t\t- reg in, rst;\n\t\t- reg [15:0]\
    \ y;\n\t\t- reg y_p, y_n;\n\t\t- wire [16:0] onehot;\n\t\t- comparator_onehot\
    \ comp(onehot,y,in);\n\t\t- initial begin\n\t\t\tin=0;"
- code: "module multiplier(a,b,rst,output reg [3:0] c);\nreg[3:0] a_reg,b_reg;\nparameter[3:0]\
    \ constant=2'd4;\na_reg <= a;\nb_reg <= b;\nwire[3:0] s_reg,s_reg_next,t_reg,t_reg_next;\n\
    s_reg <= (a_reg & constant);\ns_reg_next <= (a_reg << 1 & constant) ^ (b_reg &\
    \ s_reg);\nt_reg <= (b_reg & s_reg);\nt_reg_next <= (b_reg << 1 & s_reg) ^ (a_reg\
    \ & t_reg);\nwire[3:0] c_reg,c_reg_next;\nc_reg <= (a_reg << 2 & s_reg) | (b_reg\
    \ << 1 & s_reg_next) | t_reg | t_reg_next;\nc_reg_next <= c_reg ^ b_reg;\nalways\
    \ @(posedge rst) begin\nif (rst) begin\na_reg <= 1'b0;\nb_reg <= 1'b0;\nend\n\
    else begin\na_reg <= c_reg;\nb_reg <= c_reg_next;\nend\nend\ngenerate\ninitial\
    \ begin\nc <= 1'b0;\nend\nfor (int i = 0; i < 4; i++) begin\nalways @(posedge\
    \ rst) begin\nif (rst) begin\na_reg <= 1'b0;\nb_reg <= 1'b0;\nend\nelse begin\n\
    a_reg <= c_reg;\nb_reg <= c_reg_next;\nend\nend\nc <= (a_reg << 2 & s_reg) | (b_reg\
    \ << 1 & s_reg_next) | t_reg | t_reg_next;\nc_reg_next <= c_reg ^ b_reg;\nend\n\
    endgenerate\nendmodule\n\n## Summary\n\n\u2022 The basic implementation of MIP\
    \ in Verilog is similar to the VHDL implementation for the same design.\n\u2022\
    \ The basic implementation of the MUP is similar to the VHDL implementation for\
    \ the same design.\n\u2022 The basic implementation of the Register file (Register\
    \ file) is similar to the VHDL implementation for the same design.\n\u2022 The\
    \ basic implementation of the ALU (Arithmetic logic unit) is similar to the VHDL\
    \ implementation for the same design.\n\u2022 The basic implementation of the\
    \ Control Unit (Control unit) is similar to the VHDL implementation for the same\
    \ design.\n\u2022 The basic implementation of the Pipeline Register file (Pipelined\
    \ register file) is similar to the"
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,\ninput [1:0]\
    \ s_cnt, output reg [3:0] q);\narray [0:1] s = {1,4};\nreg [3:0] int_q;\nalways\
    \ @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\nif( ld )\nint_q = d_in;\n\
    else if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q = q << s[s_cnt];\nelse\
    \ int_q = q;\nend\nalways @( posedge clk ) begin: register\nif (rst) q <= 0;\n\
    else q <= int_q;\nend\nendmodule\n\n## 16\_\_MIPS Processor\n\nMIPS is a RISC\
    \ machine code. RISC stands for Reduced Instruction Set Computer. It is very similar\
    \ to the CISC (Complex Instruction Set Computer) machine code. This is a low-level\
    \ programming language (or machine code) because it does not contain high-level\
    \ programming instruction. RISC uses a stack-like data structure to store variables\
    \ and a heap-like structure to store memory addresses. This is an advantage because\
    \ it makes the MIPS processor faster. On the other hand, these advantages are\
    \ not enough to make MIPS a good machine code, which is why it is not usually\
    \ used in modern programs. This is because modern machine code is more complex,\
    \ efficient, and fast.\n\n### MIPS32 Registers\n\nMIPS32 has 10 integer registers,\
    \ including the zero register, and 32 floating registers. Each register has an\
    \ 32-bit register. The first register is the zero register, which has value $0$.\
    \ The other 9 registers have different meanings. In MIPS32, the register names\
    \ are\n\n\u2022 \_$0$: \_zero\n\u2022 \_$1$: \_at (reserved for assembler)\n\u2022\
    \ \_$2$: \_v0, return value (used by load, alu, and store instructions)\n\u2022\
    \ \_$3$: \_v1, return value (used by load, alu, and store instructions)\n\u2022\
    \ \_$4$: \_a0, first load and store address (used by load and store instructions)\n\
    \u2022 \_$5$: \_a1, second load and store address (used by load and store instructions)\n\
    \u2022 \_$6$: \_t0, temporary value (used by alu instructions)\n\u2022 \_$7$:\
    \ \_t1, temporary value (used by alu instructions)\n\u2022 \_$8$: \_t2, temporary\
    \ value (used by alu instructions)\n\u2022 \_$9$: \_t3, temporary value (used\
    \ by alu instructions)\n\u2022 \_$10$: \_t4\n\u2022 \_$11$: \_t5\n\u2022 \_$12$:\
    \ \_t6\n\u2022 \_$13$: \_t7, temporary value\n\u2022 \_$14$: \_s0 (reserved for\
    \ special functions)\n\u2022 \_$15$: \_s1 (frame pointer)\n\u2022 \_$16$: \_s2,\
    \ temporary value\n\u2022 \_$17$: \_s3 (reserved for system use)\n\u2022 \_$18$:\
    \ \_s4\n\u2022 \_$19$: \_s5\n\u2022 \_$20$: \_s6\n\u2022 \_$21$: \_s7, temporary\
    \ value\n\u2022 \_$22$: \_t8\n\u2022 \_$23$: \_t9, temporary value\n\u2022 \_\
    $24$: \_k0, used by load/store functions (and some special functions)\n\u2022\
    \ \_$25$: \_k1\n\u2022 \_$26$: \_gp (global pointer)\n\u2022 \_$27$: \_sp (stack\
    \ pointer)\n\u2022 \_$28$: \_fp (frame pointer)\n\u2022 \_$29$: \_ra (return address)\n\
    \nFloating-point registers are named as f0, f1, f2, and so on. The other 32 registers\
    \ are floating registers as well; you can name them as f24 to f55.\n\n### MIPS\
    \ Instructions\n\nMIPS has a total of 62 instructions. The instructions are categorized\
    \ into the following groups:\n\n\u2022 ALU instructions: add, addu, sub, subu,\
    \ and, nor, or, sll, srl, sra, slt, sltu, sllv, srlv, sraw, and sllv.\n\u2022\
    \ Load and store instructions: lb, lh, lw, lbu, lhu, lui, sb, sh, sw.\n\u2022\
    \ Branch instruction: beq, bne, bgez, bltz, and bgezal.\n\u2022 Jump instruction:\
    \ jr, jal, jalr, j, jal.\n\u2022 Reserved instruction: syscall, break, nop.\n\u2022\
    \ Multiplying and dividing instructions: mult, multu, mfhi, mflo, div, divu, mod,\
    \ modu.\n\n#### ALU Instructions\n\n##### ALU Instruction Examples\n\u2022 Add\
    \ $a = c + d$:\n.\n.\n.\nadd $a, c, d$\n\n\u2022 Add $a = b$:\n.\n.\n.\nadd $a,\
    \ b, b$\n\n\u2022 Substract $a = d - c$:\n.\n.\n.\nsub $a, d, c$\n\n\u2022 $a\
    \ = b + c$:\n.\n.\n.\nadd $a, b, c$\n\n\u2022 $a = b - c$:\n.\n.\n.\nsub $a, b,\
    \ c$\n\n\u2022 $a = b$ AND $c$:\n.\n.\n.\nand $a, b, c$\n\n\u2022 $a = b$ OR $c$:\n\
    .\n.\n.\nor $a, b, c$\n\n\u2022 Shift left $a = b \\circ 2^1$:\n.\n.\n.\nsll $a,\
    \ b, 1$\n\n\u2022 Shift left $a = b \\circ 2^c$:\n.\n.\n.\nsll $a, b, c$\n\n\u2022\
    \ Shift right logical $a = b \\circ 2^1$:\n.\n.\n.\nsrl $a, b, 1$\n\n\u2022 Shift\
    \ right logical $a = b \\circ 2^c$:\n.\n.\n.\nsrl $a, b, c$\n\n\u2022 Shift right\
    \ arithmetical $a = b \\circ 2^1$:\n.\n.\n.\nsra $a, b, 1$\n\n\u2022 Shift right\
    \ arithmetical $a = b \\circ 2^c$:\n.\n.\n.\nsra $a, b, c$\n\n\u2022 $a = b$ Less\
    \ than $c$:\n.\n.\n.\nslt $a, b, c$\n\n\u2022 $a = b$ Less than (or equal to)\
    \ $c$:\n.\n.\n.\nsltu $a, b, c$\n\n\u2022 $a = b$ Shift left $2^1$:\n.\n.\n.\n\
    sllv $a, b, c$\n\n\u2022 $a = b$ Shift left $2^c$:\n.\n.\n.\nsllv $a, b, c$\n\n\
    \u2022 $a = b$ Shift right logical $2^1$:\n.\n.\n.\nsrlv $a, b, c$\n\n\u2022 $a\
    \ = b$ Shift right logical $2^c$:\n.\n.\n.\nsrlv $a, b, c$\n\n\u2022 $a = b$ Shift\
    \ right arithmetical $2^1$:\n.\n.\n.\nsrav $a, b, c$\n\n\u2022 $a = b$ Shift right\
    \ arithmetical $2^c$:\n.\n.\n.\nsrav $a, b, c$\n\n#### Load and Store Instructions\n\
    \n##### Load and Store Instruction Examples\n\u2022 Load $v1$ from global pointer\
    \ address:\n.\n.\n.\nlw $v1, 0($gp)\n\n\u2022 Store $v0$ globally at global pointer\
    \ address:\n.\n.\n.\nsw $v0, 0($gp)\n\n\u2022 Load $v1$ from $sp + 8$:\n.\n.\n\
    .\nlw $v1, 8($sp)\n\n\u2022 Load $v1$ from $sp + 8$:\n.\n.\n.\nld $v1, 8($sp)\n\
    \n\u2022 Store $v1$ globally at global pointer address:\n.\n.\n.\nsw $v1, 0($gp)\n\
    \n\u2022 Load $c$ from $a$:\n.\n.\n.\nlb $c, 4($a)\n\n\u2022 Load $b$ from $a$:\n\
    .\n.\n.\nlb $b"
- code: |-
    module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,
    input [1:0] s_cnt, output reg [3:0] q);
    reg [3:0] int_q;
    // generate
    const ARR_SIZE = 5;
    integer arr[ARR_SIZE] = {
    1'b0, 2'b00, 3'b000, 4'b0000, 5'b00000
    };
    // generate
    generate
    for (integer n = 0; n < ARR_SIZE; n = n + 1) begin : combinational
    if (arr[n] && ld) begin: combinational
    int_q = d_in;
    end
    else if (arr[n] && sr) begin: combinational
    int_q = q >> s_cnt;
    end
    else if (arr[n] && sl) begin: combinational
    int_q = q << s_cnt;
    end
    else if (arr[n]) begin: combinational
    int_q = q;
    end
    end
    endgenerate
    endgenerate
    end generate
    always @(posedge clk) begin: combinational
    if (rst) q <= 0;
    else q <= int_q;
    end
    endmodule
    ### Simulation Screen

    The output for the signal `q` and the register is as below:

    ### Testbench Code:
    module test;
    reg [3:0] q;
    reg clk = 0;
    reg rst = 0;
    reg sl;
    reg sr;
    reg ld;
    wire [3:0] d_in;
    wire [7:0] s_cnt;
    initial $display("Start Simulation"); initial begin clk = 1; rst = 0; s_cnt = 7'b0000000; for (integer i = 0; i < 10; i = i + 1) begin$display("Iteration: %d", i + 1);
    if (i == 0)
    d_in = 8'b00000000;
    else d_in = 8'b10001001;
    if (i < 5) ld = 1;
    else if (i < 6) sl = 1;
    else if (i < 7) sr = 1;
    else if (i < 8) rst = 1;
    else
    clk = 0;
    $display("d_in = %b, s_cnt = %b, q = %b", d_in, s_cnt, q); end end endmodule ### Output: Start Simulation Iteration: 1 d_in = 00000000, s_cnt = 0, q = 00000000 Iteration: 2 d_in = 00000000, s_cnt = 00000000, q = 00000000 Iteration: 3 d_in = 00000000, s_cnt = 00000000, q = 00000000 Iteration: 4 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 5 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 6 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 7 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 8 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 9 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 10 d_in = 00001001, s_cnt = 00000000, q = 10001001 ### Variation Instruction: Add a new check on the `ld` signal to control `q` output inside the `if` block of the MUP. ### Modified Code: module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, input [1:0] s_cnt, output reg [3:0] q); reg [3:0] int_q; // generate const ARR_SIZE = 5; integer arr[ARR_SIZE] = { 1'b0, 2'b00, 3'b000, 4'b0000, 5'b00000 }; // generate generate for (integer n = 0; n < ARR_SIZE; n = n + 1) begin: combinational if (arr[n] && ld) begin: combinational int_q = d_in; end else if (arr[n] && sr) begin: combinational int_q = q >> s_cnt; end else if (arr[n] && sl) begin: combinational int_q = q << s_cnt; end else if (arr[n]) begin: combinational int_q = q; end if (!arr[n] && ld) begin: combinational int_q = q; end else if (!arr[n] && sr) begin: combinational int_q = q >> s_cnt; end else if (!arr[n] && sl) begin: combinational int_q = q << s_cnt; end end generate endgenerate end generate always @(posedge clk) begin: combinational if (rst) q <= 0; else q <= int_q; end endmodule ### Simulation: Start Simulation Iteration: 1 d_in = 00000000, s_cnt = 0, q = 00000000 Iteration: 2 d_in = 00000000, s_cnt = 00000000, q = 00000000 Iteration: 3 d_in = 00000000, s_cnt = 00000000, q = 00000000 Iteration: 4 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 5 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 6 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 7 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 8 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 9 d_in = 00001001, s_cnt = 00000000, q = 10001001 Iteration: 10 d_in = 00001001, s_cnt = 00000000, q = 10001001 ### Variation Instruction: Add a check on `q` output to control the operation inside the `else` block of the MUP. ### Modified Code: module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, input [1:0] s_cnt, output reg [3:0] q); reg [3:0] int_q; // generate const ARR_SIZE = 5; integer arr[ARR_SIZE] = { 1'b0, 2'b00, 3'b000, 4'b0000, 5'b00000 }; // generate generate for (integer n = 0; n < ARR_SIZE; n = n + 1) begin: combinational if (arr[n] && ld) begin: combinational int_q = d_in; end else if (arr[n] && sr) begin: combinational int_q = q >> s_cnt;
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld,\ninput [1:0] s_cnt,\
    \ output reg [3:0] q);\nreg [3:0] int_q;\nalways @( d_in, q, s_cnt, sr, sl, ld\
    \ ) begin: combinational\nif( ld )\nint_q = d_in;\nelse if( sr )\nint_q = q >>\
    \ s_cnt;\nelse if( sl )\nint_q = q << s_cnt;\nelse int_q = q;\nend\nalways @(\
    \ posedge clk ) begin: register\nif (rst) q <= 0;\nelse q <= int_q;\nend\nendmodule\n\
    ### MIG Workbench:\nModule shifted_reg(input [3:0] d_in, input clk, sr, sl, ld,\
    \ input [1:0] s_cnt, output reg [3:0] q);\nwire [3:0] int_q;\ngenerate\nif (1)\
    \ begin // Add a check on the internal register in the Generate-Block\nif( ld\
    \ )\nint_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q =\
    \ q << s_cnt;\nelse int_q = q;\nend\nendgenerate\nalways @(posedge clk) begin\n\
    if(rst) q <= 0;\nelse q <= int_q;\nend\nendmodule\n\n### References:\n\n\u2022\
    \ 1.. (2013). Design and Implementation of an IIR FIR Filter using FPGA. Master\u2019\
    s thesis, University of Hertfordshire, Herts, United Kingdom.\n\u2022 2.. (2010).\
    \ Design, Verification and Analysis of Analog Integrated Circuits. Ph.D thesis,\
    \ University of Birmingham.\n\u2022 3.. (2012). Design and Implementation of FIR\
    \ and IIR Filters using Xilinx FPGAs. Masters thesis, University of Birmingham.\n\
    \n## Comparing the Implementations:\n\nThe two implementations for the shift register\
    \ and the multiplying unit show a few differences. For the shift register in the\
    \ first version I have also added a check on the internal register q to see if\
    \ there is a conflict of the two versions. This check is commented out in the\
    \ second version as it should not conflict and cannot be executed with any version\
    \ of the MIG.\n\nIn both cases there are no conflicts.\n\n## Conclusion:\n\nIn\
    \ the next article I will look into how a multiplying unit works in the MIG."
- code: "module shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,\ninput [1:0]\
    \ s_cnt, output reg [3:0] q);\nreg [3:0] int_q;\nalways @( posedge clk ) begin:\
    \ register\nif (rst) q <= 0;\nelse q <= int_q;\nend\ngenerate\nfor (j = 0; j <\
    \ 4; j = j+1)\nif(j == 4)\nint_q = {rr_inst[j], q};\nelse if(j == 0)\nint_q =\
    \ q;\nelse\nint_q = {q[j-1:0], q[j+3:4]};\nendgenerate\nendmodule\n\n# How to\
    \ write sequential/combinational logic in Verilog\n\nIn a previous post, I talked\
    \ about how to write sequential logic in Verilog. In this post, I\u2019ll go over\
    \ how to write combinational logic in Verilog and illustrate this with an example.\n\
    \n## Combinational Logic\n\nCombinational logic is the simplest type of logic\
    \ that you\u2019ll encounter in Verilog. It is the most common type of logic in\
    \ Verilog and is used primarily in sequential logic. Combinational logic in Verilog\
    \ acts on input signals and produces output signals. If the output of a combinational\
    \ logic is depended on the output of another combinational logic or the input\
    \ of another combinational logic, the output of the first signal will be affected\
    \ by the second signal. For example, if the output of one combinational logic\
    \ depends on the output of another combinational logic, the output of the first\
    \ combinational logic will be affected. Let\u2019s look at an example:\n\nmodule\
    \ srg( input [3:0] data, input clk, rst, output reg [3:0] q );\n\nreg [3:0] int_q;\n\
    \nalways @( posedge clk ) begin: register\nif (rst) q <= 0;\nelse q <= int_q;\n\
    end\n\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\nif( ld )\n\
    int_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q = q <<\
    \ s_cnt;\nelse int_q = q;\nend\n\nendmodule`\n\nIn the above example, the output\
    \ of the combinational logic is dependent on the input of `q` and the output of\
    \ the combinational logic is depended on the output of the other combinational\
    \ logic. Notice that the output of `q` is depended on the output of the other\
    \ combinational logic, `int_q`. Because `int_q` is depended on by `q`, `int_q`\
    \ will be affected by `q`.\n\nNext, let\u2019s look at another example.\n\nmodule\
    \ srg( input [3:0] data, input clk, rst, output reg [3:0] q );\n\nreg [3:0] int_q;\n\
    \nalways @( posedge clk ) begin: register\nif (rst) q <= 0;\nelse q <= int_q;\n\
    end\n\nalways @( d_in, q, s_cnt, sr, sl, ld ) begin: combinational\nif( ld )\n\
    int_q = d_in;\nelse if( sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q = q <<\
    \ s_cnt;\nelse int_q = q[3:0];\nend\n\nendmodule`\n\nIn the above example, the\
    \ output of the combinational logic is a specific slice of the input of `q`, `q[3:0]`.\
    \ This is the same as `q[3:0]`, where the output of the combinational logic depends\
    \ on the input of `q` and `q` is depended on by the output of the other combinational\
    \ logic. Notice that the output of `q` is depended on the output of the other\
    \ combinational logic, `int_q`. Thus, the input of `q` is affected, and the output\
    \ of the other combinational logic will be affected.\n\n## Conclusion\n\nCombinational\
    \ logic is the next step after sequential logic in Verilog. In this post, I showed\
    \ an example of how to write combinational logic in Verilog and illustrated how\
    \ it works. This is the final post in the series, so I\u2019ll finish up with\
    \ some resources for further learning about combinational logic and Verilog.\n\
    \n### Related Posts\n\nI often find myself writing code that I can verify on a\
    \ computer using an instruction set simulator (ISS). This allows me to check that\
    \ my code is correct before I put it into hardware. One ISS that I use regularly\
    \ is the Verilog Instruction Set Simulator (VISS). This allows me to check that\
    \ my code is correct and that my Verilog code generates the correct hardware.\
    \ In this post, I\u2019ll show an example of how to write a Shift Register using\
    \ VISS.\n\n### VISS\n\nFirst, we need to install VISS in our computer. To install\
    \ VISS, you can download the latest version of VISS for Windows, Mac, or Linux\
    \ from the VISS web page. Once you follow the install instructions, run VISS.\n\
    \n### Shift Register\n\nNext, we need to write our Shift Register in Verilog.\
    \ In the following Verilog code, I\u2019ll use a register to store the internal\
    \ value of the shift register, and I\u2019ll use a combinational logic to generate\
    \ the output.\n\nmodule shift_reg( input [3:0] d_in, input clk, sr, sl, ld, rst,\n\
    input [1:0] s_cnt, output reg [3:0] q);\nreg [3:0] int_q;\nalways @( d_in, q,\
    \ s_cnt, sr, sl, ld ) begin: combinational\nif( ld )\nint_q = d_in;\nelse if(\
    \ sr )\nint_q = q >> s_cnt;\nelse if( sl )\nint_q = q << s_cnt;\nelse int_q =\
    \ q;\nend\nalways @( posedge clk ) begin: register\nif (rst) q <= 0;\nelse q <=\
    \ int_q;\nend\nendmodule`\n\n### SRS Code\n\nTo get the input of the shift register\
    \ to be {1\u2019d1}, I\u2019ll use a constant array and wrap the instantiation\
    \ in a generate block to create a constant array `rr`. I\u2019ll also use a constant\
    \ array to store the internal value of the shift register `rr_inst`. Then, I\u2019\
    ll assign the internal state of the shift register using `rr_inst`.\n\n### Input\
    \ Code\n\nNext, I\u2019ll create a testbench in VISS to use to test that the shift\
    \ register generates the correct output. The following code will create a shift\
    \ register using an input of `d_in`, a clock signal `clk`, a shift register `sr`,\
    \ a slicing register `sl`, a load register `ld`, and a reset register `rst`. The\
    \ internal state of the shift register will be {1\u2019d1}.\n\n`testbench`\n`module\
    \ shift_reg_tb ( testbench_type tb );`\n`parameter testbench_type = \"shift_reg\"\
    ;`\n`reg [3:0] d_in;`\n`reg clk;`\n`reg sl;`\n`reg ld;`\n`reg rst;`\n`parameter\
    \ s_cnt = 1'b0;`\n`parameter sr = 1'b0;`\n\n`initial begin`\n`d_in = {1\u2019\
    d1};`\n`rst = 1\u2019b1;`\n`#300 clk = 0;`\n`#150 clk = 1;`\n`#100 clk = 0;`\n\
    `#100 rst = 0;`\n`#50 rst = 1;`\n`end`\n\n`initial begin`\n`d_in = {1\u2019d0};`\n\
    `rst = 1\u2019b1;`\n`#300 clk = 0;`\n`#150 clk = 1;`\n`#100 clk = 0;`\n`#100 rst\
    \ = 0;`\n`#50 rst = 1;`\n`end`\n\n`initial begin`\n`d_in = {1\u2019d0};`\n`rst\
    \ = 1\u2019b1;`\n`#300 clk = 0;`\n`#150 clk = 1;`\n`#100 clk = 0;`\n`#100 rst\
    \ = 0;`\n`#50 rst = 1;`\n`end`\n\n`initial begin`\n`d_in = {1\u2019d0};`\n`rst\
    \ = 1\u2019b1;`\n`#300 clk = 0;`\n`#150 clk = 1;`\n`#100 clk = 0;`\n`#100 rst\
    \ = 0;`\n`#50 rst = 1;`\n`end`\n\n`initial begin`\n`d_in = {"
- code: "```verilog\nmodule tst_mup; // Testbench for Microprocessor\n\nreg clk, en,\
    \ int; // Clock, Enable, Interrupt inputs\n\n// Assuming mup_opr is the microprocessor\
    \ module instance\n\n// mup_opr rr(clk,int,en); // Instantiation needed\n\ninitial\n\
    \nbegin\n\nint=1'b0; clk=1'b0; en=1'b0; // Initialize\n\nend\n\nalways #2 clk=~clk;\
    \ // Generate clock\n\n// Monitor clock, time, inputs, and internal MUP registers\
    \ (pc, ir, dcop)\n\ninitial $monitor(\"clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d,\
    \ rr.ir=%0h, rr.dcop=%0d\", clk,$time,en,int,rr.pc,rr.ir,rr.dcop);\n\n// Corrected\
    \ format specifiers\n\n// mup_opr rr(clk,int,en); // Instantiate DUT\n\ninitial\
    \ #40 $stop; // Stop simulation\n\nendmodule\n\n```\n\n/Lab_03/README.md\n# Lab_03\n\
    \n## Overview\n\nThis lab introduces the following topics:\n- Basic Verilog module\n\
    - Input and output data types\n- Assignment statements\n- If/else conditional\
    \ statements\n- Loops (for, while)\n- Module instantiation\n- Verilog simulation\n\
    - `posedge`/`negedge` synthesis constraint\n- Verilog coverage\n\n## Project 1:\
    \ Adder Module\n\n### Introduction\n\nThe goal of the project is to create a simple\
    \ adder module and test it using a testbench. To test the adder module, a testbench\
    \ is necessary. The testbench should simulate the following test cases:\n\n- Test\
    \ case 1: Test the input and output of the adder module\n- Test case 2: Test correct\
    \ sum value\n- Test case 3: Test overflow\n- Test case 4: Test carry-out signal\n\
    - Test case 5: Test carry-in signal\n\nThe first 3 test cases (1, 2, 3) are required\
    \ for the adder module, which can be implemented using any of the methods taught\
    \ in class. The last 2 test cases (4, 5) are optional.\n\n### Step 1: Writing\
    \ the Base Verilog Code\n\nFollowing is the base Verilog code for the adder module\
    \ (with a carry-out signal):\n\n```verilog\n/* Adder module with carry-out output\
    \ */\nmodule adder(\n    in a,\n    in b,\n    in cin,\n    out s,\n    out cout);\n\
    \ \n/* Define module ports */\ninput a, b, cin;\noutput s, cout;\n \n/* Addition\
    \ logic */\nassign s = a ^ b ^ cin;\nassign cout = a & b | (a & cin) | (b & cin);\n\
    endmodule\n```\n\n### Step 2: Writing the Variation Instruction\n\nWrite the variation\
    \ instruction for the adder module in the `Lab_03_Instructions.pdf`.\n\n### Step\
    \ 3: Writing the Variation Code\n\nWrite the variation code for the adder module\
    \ in the `Lab_03_Code.pdf`.\n\n### Step 4: Writing the Testbench Code\n\nFollowing\
    \ is the base Verilog code for the testbench:\n\n```verilog\n/* Basic testbench\
    \ for the adder module */\n \nmodule tst_adder;\n \n/* Declare module ports */\n\
    reg a, b, cin, s, cout, clk;\n \n/* Declare local signals */\nreg [3:0] s_correct,\
    \ s_check, cout_correct, cout_check;\n \n/* Instantiate adder module */\nadder\
    \ adder_inst(\n   .a(a),\n   .b(b),\n   .cin(cin),\n   .s(s),\n   .cout(cout)\n\
    \  );\n \n/* Initialize module signals */\ninitial\nbegin\n    a = 1'b1;\n   \
    \ b = 1'b1;\n    cin = 1'b0;\nend\n \n/* Set clock signal */\nalways #2 clk =\
    \ ~clk;\n \n/* Instantiate coverage */\ninitial $coverage;\n \n/* Check output\
    \ */\ninitial $monitor(\"clk"
- code: |-
    ```
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ```

    ## 8. Testing with Verilator
    1. Create a testbench for the multiplier as follows.
    1.1. Create the file `mup_tb.cpp`.
    ```
    main() {
        Verilated::randReset(2); // Force reset

        // Instantiate module
        tst_mup *top = new tst_mup;

        // Reset and setup the clock
        top->clk = 0;
        top->rst = 1;
        top->eval();

        // Clocking
        for (int i=0; i<100; i++) {
            top->clk = 1;
            top->eval();
            top->clk = 0;
            top->eval();
            wait();
        }

        // Run simulation
        while (1) {
            top->int = 1;
            top->eval();
            top->clk = 1;
            top->eval();
            if (top->rst) {
                top->rst = 0;
                top->eval();
            }
            top->clk = 0;
            printf("\n");
            top->eval();
            wait();
        }
    }
    ```
    1.2. Compile the testbench as follows (from the `mup` directory)
    ```
    verilator -Wno-lint --cc --trace --exe mup_tb.cpp
    ```
    1.3. Run the simulation (from the `obj_dir` directory)
    ```
    ./Vtop
    ```

    ## 9. Testing with the Modelsim Simulator
    1. Create a testbench for the multiplier as follows.
    1.1. Create the file `mup_tb.v`.
    ```
    module mup_tb;
    reg clk,rst,int,en; // Clock, Reset, Enable, Interrupt inputs
    reg [31:0]dcop; // Data Output Port
    reg [31:0]dcop_check; // Data Output Port Check
    reg [31:0]pc; // Program Counter
    reg [3:0]ir; // Instruction Register

    initial
    begin
    int=0;clk=0;en=0;rst=0; // Initialize
    end

    always #2 clk=~clk; // Generate clock

    // Check for DCOp value (Data Output Port value)
    initial begin
    #40 rst=1; // Reset to be asserted
    end
    always @(posedge clk) begin
    dcop_check <= dcop;
    end
    // DCOp is now checked. Reset to be de-asserted
    always @(posedge clk) begin
    if (~rst) dcop=32'h0;
    end
    // Reset is now de-asserted
    ```
    1.2. Instantiate the multiplier module as follows.
    ```
    mup mup_opr(.clk(clk),.int(int),.en(en),.pc(pc),.ir(ir),.dcop(dcop));
    ```
    1.3. Compile the testbench as follows (from the `mup` directory)
    ```
    vcs -full64 +v2k -sverilog mup_tb.v
    ```
    1.4. Run the simulation (from the `sim` directory)
    ```
    ./simv
    ```
    1.5. Observe the output.
    ```
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--
- code: |-
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ### Verilog Code:
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,rr.dcop); // Corrected format specifiers
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
- code: |-
    ```vhdl
    library ieee;
    use ieee.std_logic_1164.all;
    entity tst_mup is
    end tst_mup;
    architecture behav of tst_mup is
    signal clk : std_logic;
    signal en : std_logic;
    signal int : std_logic;
    component mup_opr is
    end component;
    signal rr : mup_opr (clk, int, en);
    begin
    initial
    int<=0;clk<=0;en<=0;
- code: |-
    module tst_mup; // Testbench for Microprocessor
    reg clk,en,int; // Clock, Enable, Interrupt inputs
    // Assuming mup_opr is the microprocessor module instance
    // mup_opr rr(clk,int,en); // Instantiation needed
    initial
    begin
    int=1'b0;clk=1'b0;en=1'b0; // Initialize
    end
    always #2 clk=~clk; // Generate clock
    // Monitor clock, time, inputs, and internal MUP registers (pc, ir, dcop)
    initial $monitor("clk=%b, t=%0d, en=%b, int=%b, rr.pc=%0d, rr.ir=%0h, rr.dcop=%0d", clk,$time,en,int,rr.pc,rr.ir,pkg::consts[BCD_in]); // Modified
    // mup_opr rr(clk,int,en); // Instantiate DUT
    initial #40 $stop; // Stop simulation
    endmodule
    ### Output:
    #### Test Output
    ```
    *** TEST 1 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0005, 0x02
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    ```
    #### Test Output (modified)
    ```
    *** TEST 1 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0005, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    ```
    #### DFT Output
    ```
    *** TEST 1 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0005, 0x02
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 2 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0006, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 3 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0007, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 4 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0008, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 5 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0005, 0x02
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 6 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0006, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 7 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0007, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 8 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0008, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 9 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0009, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 10 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000a, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 11 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000b, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 12 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000c, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 13 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000d, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 14 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000e, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 15 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x000f, 0x01
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 16 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0000, 0x00
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000, 0x00
    *** TEST 17 ***
    clk=1, t=0, en=0, int=1, rr.pc=0x0100, rr.ir=0x0010, 0x00
    clk=0, t=2, en=0, int=1, rr.pc=0x0000, rr.ir=0x0000,
- code: "module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\nassign Excess_3_out = BCD_in + 3;\nendmodule\n\nmodule t_encoder();\n\
    reg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\nencoder M0(BCD_in, Excess_3_out);\n\
    initial\n$monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\
    \ninitial begin\nend\ninitial begin //Simulation Test Pattern\nend\nendmodule\n\
    \n## Exercise 13:\nThe last exercise takes the 6-bit 2\u2019s complement code\
    \ and returns either a 3-bit binary code or a 4-bit binary code.\n### Base Verilog\
    \ Code:\nmodule encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\nassign Excess_3_out = BCD_in + 3;\nendmodule\n\nmodule t_encoder();\n\
    reg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\nencoder M0(BCD_in, Excess_3_out);\n\
    initial\n$monitor($time,,\"BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\
    \ninitial begin\nend\ninitial begin //Simulation Test Pattern\nend\nendmodule\n\
    ### Variation Instruction"
- code: "module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\n\nreg [3:0] adjr;\n\nreg [1:0] HiCount;\n\nwire [1:0] HiCount1;\n\
    reg [1:0] HiCount_int;\ninitial begin\nHiCount_int = $urandom;\nHiCount = HiCount_int;\n\
    end\n\nassign Excess_3_out = HiCount1? BCD_in : BCD_in + 3;\n\nassign HiCount1\
    \ = HiCount1? 0 : HiCount1 + 1;\n\nalways @(posedge HiCount1)\nbegin\nif (HiCount1\
    \ == 0)\nbegin\nHiCount = $urandom;\nendif\nend\nendmodule\n\nmodule t_encoder();\n\
    \nreg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\n\nencoder M0(BCD_in, Excess_3_out);\n\
    \ninitial begin\nend\n\ninitial begin //Simulation Test Pattern\n$timescale 1ns\
    \ / 1ns\n$display(\"HiCount = %b\", $urandom);\n$display(\"HiCount = %b\", $urandom);\n\
    $display(\"HiCount = %b\", $urandom);\n\nend\nendmodule\n\n\u2022 This kind of\
    \ question gets better attention when you show the testbench as well. Jan 6 '21\
    \ at 19:22\n\u2022 @Tom Carpenter, added testbench. But there is no test pattern\
    \ in the testbench. So I don't think that will help much to debug. Jan 7 '21 at\
    \ 5:37\n\nDo you mean something like:\n\nassign Excess_3_out = (HiCount == 0)?\
    \ BCD_in : BCD_in + 3;\n\n\nIf you want to avoid the logic using a counter variable,\
    \ you can do:\n\nassign Excess_3_out = BCD_in ^ (HiCount[0] & 1'b1);\n\n\nI don't\
    \ know if it's faster, but it's a bit of a simplification.\n\nUpdate: to use $urandom,\
    \ you can do:\n\nassign Excess_3_out = BCD_in ^ (HiCount == 0);\n\n\nwhich only\
    \ uses 1'b1 instead of 2 wires.\n\nI'm not clear on the context of your code,\
    \ so I'm not sure if this is appropriate for you. But I would generally recommend\
    \ avoiding counters, and instead to use a truth table for testing, where the input\
    \ is \"randomized\" to create a test case.\n\nIf you are not using the counter\
    \ in the test pattern, the module would only be able to receive one input at a\
    \ time.\n\nUsing $urandom can be useful for testing. It is an automatic variable,\
    \ not like the variables declared in the \"initial\" section. It is also a variable\
    \ that is not connected and is not assigned, which is quite useful for initialization.\
    \ I created the following testbench for you:\n\nmodule t_encoder();\n\nreg [3:0]\
    \ BCD_in;\nwire [3:0] Excess_3_out;\n\nencoder M0(BCD_in, Excess_3_out);\n\ninitial\
    \ begin\nend\n\ninitial begin //Simulation Test Pattern\n$timescale 1ns / 1ns$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"\
    HiCount = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount\
    \ = %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount =\
    \ %x\", $urandom);$display(\"HiCount = %x\", $urandom);$display(\"HiCount = %x\"\
    , $urandom);$display(\"HiCount ="
- code: "module encoder (BCD_in, Excess_3_out);\ninput [3:0] BCD_in;\noutput [3:0]\
    \ Excess_3_out;\nreg [4:0] HiCount;\n\ngenerate\nHiCount = HiCount +1;\nendgenerate\n\
    \nassign Excess_3_out = BCD_in + 3;\n\nendmodule\n\nmodule comparator (Excess_3_in1,\
    \ Excess_3_in2, Comp_out);\ninput [4:0] Excess_3_in1;\ninput [4:0] Excess_3_in2;\n\
    output Comp_out;\n\nreg [4:0] HiCount;\n\nalways @(posedge Excess_3_in1 or posedge\
    \ Excess_3_in2)\nif (Excess_3_in1 > Excess_3_in2) begin\nComp_out = 1'b1;\nelse\
    \ if (Excess_3_in1 == Excess_3_in2) begin\nComp_out = 1'b0;\nelse if (Excess_3_in1\
    \ < Excess_3_in2) begin\nComp_out = 1'b0;\nend\nend\n\nendmodule\n\nmodule t_encoder();\n\
    reg [3:0] BCD_in;\nwire [3:0] Excess_3_out;\nwire Comp_out;\n\nassign BCD_in =\
    \ (HiCount < 16)? HiCount : (1'b1 ^ HiCount);\nencoder M0(BCD_in, Excess_3_out);\n\
    comparator M1(Excess_3_out[4:0], Excess_3_out[4:0], Comp_out);\ninitial\n$monitor($time,,\"\
    BCD = %b, Excess-3 Code = %b\", BCD_in, Excess_3_out);\n\ninitial begin\nHiCount\
    \ = 0;\nend\ninitial begin //Simulation Test Pattern\nend\nendmodule\n\n### Test\
    \ Pattern:\n```\nassign BCD_in = (HiCount < 16)? HiCount : (1'b1 ^ HiCount);\n\
    \n### Output:\nD:\\>iverilog encoder.v comparator.v t_encoder.v\nD:\\>vvp t_encoder\n\
    200000000 : BCD = 0b0, Excess-3 Code = 0b00010000\n200000000 : BCD = 0b1, Excess-3\
    \ Code = 0b00010001\n200000001 : BCD = 0b10, Excess-3 Code = 0b00010010\n200000001\
    \ : BCD = 0b11, Excess-3 Code = 0b00010011\n200000002 : BCD = 0b100, Excess-3\
    \ Code = 0b00010100\n200000002 : BCD = 0b101, Excess-3 Code = 0b00010101\n200000003\
    \ : BCD = 0b110, Excess-3 Code = 0b00010110\n200000003 : BCD = 0b111, Excess-3\
    \ Code = 0b00010111\n200000004 : BCD = 0b1000, Excess-3 Code = 0b00011000\n200000004\
    \ : BCD = 0b1001, Excess-3 Code = 0b00010001\n200000005 : BCD = 0b1010, Excess-3\
    \ Code = 0b00010010\n200000005 : BCD = 0b1011, Excess-3 Code = 0b00010011\n200000006\
    \ : BCD = 0b1100, Excess-3 Code = 0b00010100\n200000006 : BCD = 0b1101, Excess-3\
    \ Code = 0b00011000\n200000007 : BCD = 0b1110, Excess-3 Code = 0b00010101\n200000007\
    \ : BCD = 0b1111, Excess-3 Code = 0b00010110\n200000008 : BCD = 0b10000, Excess-3\
    \ Code = 0b00011001\n200000008 : BCD = 0b10001, Excess-3 Code = 0b00010001\n200000009\
    \ : BCD = 0b10010, Excess-3 Code = 0b00010010\n200000009 : BCD = 0b10011, Excess-3\
    \ Code = 0b00010011\n200000010 : BCD = 0b10100, Excess-3 Code = 0b00010100\n200000010\
    \ : BCD = 0b10101, Excess-3 Code = 0b00010101\n200000011 : BCD = 0b10110, Excess-3\
    \ Code = 0b00010110\n200000011 : BCD = 0b10111, Excess-3 Code = 0b00010111\n200000012\
    \ : BCD = 0b11000, Excess-3 Code = 0b00011000\n200000012 : BCD = 0b11001, Excess-3\
    \ Code = 0b00011001\n200000013 : BCD = 0b11010, Excess-3 Code = 0b00010001\n200000013\
    \ : BCD = 0b11011, Excess-3 Code = 0b00010010\n200000014 : BCD = 0b11100, Excess-3\
    \ Code = 0b00010011\n200000014 : BCD = 0b11101, Excess-3 Code = 0b00011000\n200000015\
    \ : BCD = 0b11110, Excess-3 Code = 0b00010101\n200000015 : BCD = 0b11111, Excess-3\
    \ Code = 0b00010110\n```\n\n### Assignment-4:\n### Base Verilog Code:\n```\nmodule\
    \ mux41 (I0, I1, I2, I3, S, Y);\ninput [3:0] I0, I1, I2, I3;\ninput S;\noutput\
    \ Y;\nwire [3:0] Ia;\nwire [3:0] Ib;\n \nassign Ia = (S)? I0 : I1;\nassign Ib\
    \ = (S)? I2 : I3;\nassign Y = Ia + Ib;\nendmodule\n\nmodule t_mux41();\n\nreg\
    \ [3:0] I0, I1, I2, I3;\nwire S;\nwire [3:0] Y;\n\nassign S = 1'b1;\nmux41 M0(I0,\
    \ I1, I2, I3, S, Y);\n\ninitial\n$monitor($time,,\"I0 = %b, I1 = %b, I2 = %b,\
    \ I3 = %b, S = %b, Y = %b\", I0, I1, I2, I3, S, Y);"
- code: |-
    module divider (clk_i, rst_i, div_out, div_enable);
    input clk_i, rst_i;
    output div_out;
    output reg div_enable;
    reg [1:0] cnt_reg;
    wire [1:0] cnt_sel;
    always @(posedge clk_i)
    begin
    if (rst_i)
    begin
    cnt_reg <= 2'b00;
    cnt_sel <= 2'b00;
    div_enable <= 0;
    end
    else
    begin
    cnt_reg <= cnt_reg + 2'b01;
    cnt_sel <= cnt_sel + 2'b01;
    if (cnt_reg == 2'b11 && cnt_sel == 2'b10)
    begin
    div_enable <= 1;
    cnt_reg <= 2'b00;
    cnt_sel <= 2'b00;
    end
    end
    end
    always @(div_enable or rst_i) // or rst_i
    begin
    div_out = (div_enable == 1);
    end
    endmodule

    # [Project 6](#)
    ## Implement a VGA generator.
    ### Base Verilog Code:
    module vga (clk_i, rst_i, red, green, blue);
    param DWIDTH = 8, DHEIGHT = 640, HREF_PERIOD = 42, HREF_PULSE_WIDTH = 21, HREF_PULSE_START = 65, HREF_PULSE_END = 370, HREF_PULSE_OFFSET = 63, HREF_PULSE_MIN = 0, HREF_PULSE_MAX = 255;
    input clk_i, rst_i;
    output [DWIDTH-1:0] red;
    output [DWIDTH-1:0] green;
    output [DWIDTH-1:0] blue;
    reg [DWIDTH-1:0] red_reg;
    reg [DWIDTH-1:0] green_reg;
    reg [DWIDTH-1:0] blue_reg;
    wire [DHEIGHT-1:0] red_sel;
    wire [DHEIGHT-1:0] green_sel;
    wire [DHEIGHT-1:0] blue_sel;
    wire [DHEIGHT-1:0] HREF_reg;
    assign HREF_reg = (HREF_PULSE_OFFSET <= (HREF_PULSE_START + (HREF
- code: |-
    module encoder (BCD_in, HiCount, Excess_3_out);
    input [3:0] BCD_in, HiCount;
    output [3:0] Excess_3_out;

    reg [3:0] Excess_3_out;
    // Generate 4x2 array of Excess-3 codes.
    integer i;
    integer j;
    integer k;
    integer l;
    integer Excess_3_code[4][2] = {{2,3},{5,6},{0,1},{7,4}};

    always @(posedge HiCount) begin
    Excess_3_out = Excess_3_code[j][k];
    end

    always@(posedge HiCount) begin
    #0;
    end
    endmodule

    module t_encoder();
    reg [3:0] BCD_in;
    reg [3:0] HiCount_ref;
    wire [3:0] Excess_3_out;
    wire [3:0] BCD_out;

    initial
    $monitor("HiCount = %0b", HiCount_ref);
    encoder M0(BCD_in, HiCount_ref, Excess_3_out);
    initial begin
    $monitor($time,,"BCD = %b, Excess-3 Code = %b", BCD_in, Excess_3_out);
    $monitor($time,,"H = %0b", HiCount_ref);
    end

    always@(HiCount_ref) begin
    ### HiCount_ref is the actualHiCount value.### HiCount value is 0 in 1st 4 cycles, 1 in 2nd 4 cycles, and 14 in 4th cycle.
    if (HiCount_ref ==14) HiCount_ref = 0;
- code: |-
    ```

    ### Base Verilog Code:
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
- code: "```\nmodule DutyCycle (output[1:0] AdjustFreq, input ClockIn, Reset);\nreg[1:0]\
    \ Adjr;\nassign AdjustFreq = Adjr;\nreg[1:0] HiCount;\nalways @(ClockIn, Reset)\n\
    if (Reset==1'b1)\n    begin\n        Adjr = 2'b01;\n        HiCount = 2'b0;\n\
    \    end\nelse if (ClockIn==1'b1) \n        HiCount = HiCount + 2'b01;\nelse begin\n\
    case (HiCount)\n    2'b00: Adjr = 2'b11;\n    2'b01: Adjr = 2'b01;\n    default:\
    \ Adjr = 2'b00;\n    endcase\n    HiCount = 2'b0;\nend\nendmodule\n```## FPGA\
    \ Designs - Fall 2018\n**Project:** Junk Pictures for your Pictures\n**Team:**,,,,\
    \ \n\n**Introduction:**\nOur project was inspired by the fact that, when we were\
    \ young, we would buy and collect thousands of pictures for our friends, but the\
    \ sheer quantity of this type of information could be daunting, especially for\
    \ someone like us that is very busy.\n\nBut, we feel that our project is a step\
    \ in the right direction. With technology, we can automate the collection of pictures\
    \ and then share them with friends at an individualized and customized level,\
    \ in a way that no one can say no to.\n\n**Problem:**\nThere are many websites\
    \ to upload pictures, but sometimes these large websites are too expensive and\
    \ inconvenient for us. Furthermore, we have a specific need to collect a certain\
    \ number of photos from a specific photographer, and we want our photos to be\
    \ automatically uploaded to a certain website. We are also dealing with the problem\
    \ of getting to the specific website and logging in. All of this would require\
    \ constant effort by us.\n\n**Solution:**\nOur project is to automate the process\
    \ of collecting photos. Instead of having to log in to a website and browse through\
    \ individual photos one-by-one, our project automatically scraps a website and\
    \ collects photos. The same goes for uploading them to a website of our choice.\n\
    The project uses Python to automate the web browser that scrapes and uploads photos.\n\
    \n**Requirements:**\n* Python: This project requires python to be installed on\
    \ the host machine.\n* Python libraries:\n* BeautifulSoup4, Selenium\n\n**Setup:**\n\
    * Clone this repository\n* python scrap_and_upload.py\n#include <stdio.h>\nint\
    \ main()\n{\n  int n;\n  int num=0;\n  int i;\n  int sum = 0;\n  \n  scanf(\"\
    %d\", &n);\n  \n  for (i=1; i<=n; i++)\n  {\n    num = num + i;\n  }\n  \n  printf(\"\
    The sum is %d\\n\", num);\n  return 0;\n}\n#include <stdio.h>\nint main()\n{\n\
    \  int n, i, c = 0;\n  int num;\n  \n  printf(\"Please enter the number of numbers\
    \ you want to add \\n\");\n  scanf(\"%d\", &n);\n  \n  for (i=1; i<=n; i++)\n\
    \  {\n    printf(\"Enter the %d number \\n\", i);\n    scanf(\"%d\", &num);\n\
    \    c = c + num;\n  }\n  printf(\"The sum is %d\\n\", c);\n  return 0;\n}\n#include\
    \ <stdio.h>\nint main()\n{\n  int i = 0;\nwhile (i <= 20)\n{\nprintf (\"%d \\\
    n\", i);\ni++;\n}\nreturn 0;\n}"
- code: "{% highlight python linenos %}\nclass PLL_Test(VivadoTest):\n    def build(self):\n\
    \        self.v = VivadoTest.build(self)\n        self.i = [self.v.PLL_PLL_inst]\n\
    \n    def test(self):\n        in_value = [[1, 0, 0, 0, 0, 0, 0, 0],\n       \
    \             [0, 1, 0, 0, 0, 0, 0, 0],\n                    [0, 0, 1, 0, 0, 0,\
    \ 0, 0],\n                    [0, 0, 0, 1, 0, 0, 0, 0],\n                    [0,\
    \ 0, 0, 0, 1, 0, 0, 0],\n                    [0, 0, 0, 0, 0, 1, 0, 0],\n     \
    \               [0, 0, 0, 0, 0, 0, 1, 0],\n                    [0, 0, 0, 0, 0,\
    \ 0, 0, 1]]\n\n        out_value = [[0, 0],\n                     [0, 0],\n  \
    \                   [1, 1],\n                     [1, 1],\n                  \
    \   [1, 1],\n                     [1, 1],\n                     [1, 1],\n    \
    \                 [1, 1]]\n\n        for idx, inst in enumerate(self.i):\n   \
    \         self._d = inst.I_PLLClock\n            self._e = inst.I_Reset\n    \
    \        self.wait(10)\n            self._a = in_value[idx]\n            self.wait(10)\n\
    \            self._b = inst.O_AdjustFreq\n\n            if self._a!= out_value[idx]:\n\
    \                self.fail(\"Error: \" + str(idx) + \"th test failed\")\n{% endhighlight\
    \ %}\n### Result:\n{% highlight console linenos %}\nTest PLL_Test\nStart: 2020-09-09\
    \ 21:36:28.450102\nError: 7th test failed\n\nTest PLL_Test\nStart: 2020-09-09\
    \ 21:36:28.651264\nError: 7th test failed\n\nTest PLL_Test\nStart: 2020-09-09\
    \ 21:36:28.852336\nError: 7th test failed\n\nTest PLL_Test\nStart: 2020-09-09\
    \ 21:36:29.058138\nError: 7th test failed\n{% endhighlight %}\n/_posts/2019-12-15-Vivado-Synthesis-1.md\n\
    ---\r\ntitle: \"Vivado Design - Synthesis 1\"\r\ndate: 2019-12-15\r\ncategories:\
    \ Vivado\r\ntags: Vivado Synthesis\r\n---\r\n\r\n{% include toc %}\r\n\r\n###\
    \ Synopsis\r\nThis document contains all the notes of ['s](https://caichao.github.io/)\
    \ lecture, available at [here](https://www.youtube.com/playlist?list=PL2fX3U6U6mE573r7y84aZ5qL0U-T4g5iY).\r\
    \n\r\n### Preparatory Steps:\r\n- Clone the [repository](https://github.com/caichao/Vivado_Course.git)\r\
    \n- Make a new directory for this design\r\n- Copy the content of the `Vivado_Course/Part3\
    \ - Design_2` directory into your newly created design folder\r\n- Open Vivado,\
    \ and click **File -> Open -> Project**\r\n- Select the path of the newly created\
    \ design folder\r\n- If you have already created a design, click **FILE -> CLOSE\
    \ CURRENT PROJECT** to close the current project\r\n- Click **FILE -> Export ->\
    \ Export Hardware** to export the design.\r\n\r\n### Content:\r\n- [Vivado Design\
    \ - Synthesis 1](#vivado-design---synthesis-1)\r\n  - [Synopsis](#synopsis)\r\n\
    \  - [Preparatory Steps:](#preparatory-steps)\r\n  - [Content:](#content)\r\n\
    \  - [Lecture 1 - Introduction](#lecture-1---introduction)\r\n    - [Design Overview:](#design-overview)\r\
    \n    - [Overview of HLS - Hardware Level Synthesis Tool](#overview-of-hls---hardware-level-synthesis-tool)\r\
    \n  - [Lecture 2 - Design 1](#lecture-2---design-1)\r\n    - [Overview of the\
    \ First Project - Fibonacci](#overview-of-the-first-project---fibonacci)\r\n \
    \ - [Lecture 3 - Design 2](#lecture-3---design-2)\r\n    - [Overview of the Second\
    \ Project - Division](#overview-of-the-second-project---division)\r\n  - [Lecture\
    \ 4 - Design 3](#lecture-4---design-3)\r\n    - [Overview of the Third Project\
    \ - Shift Register](#overview-of-the-third-project---shift-register)\r\n  - [Lecture\
    \ 5 - Design 4](#lecture-5---design-4)\r\n    - [Overview of the Fourth Project\
    \ - Register File](#overview-of-the-fourth-project---register-file)\r\n  - [Lecture\
    \ 6 - Design 5](#lecture-6---design-5)\r\n    - [Overview of the Fifth Project\
    \ - Simple PAM](#overview-of-the-fifth-project---simple-pam)\r\n  - [Lecture 7\
    \ - Design 6](#lecture-7---design-6)\r\n    - [Overview of the Sixth Project -\
    \ Addition](#overview-of-the-sixth-project---addition)\r\n  - [Lecture 8 - Design\
    \ 7](#lecture-8---design-7)\r\n    - [Overview of the Seventh Project - Multiplication](#overview-of-the-seventh-project---multiplication)\r\
    \n  - [Lecture 9 - Design 8](#lecture-9---design-8)\r\n    - [Overview of the\
    \ Eighth Project - PLL](#overview-of-the-eighth-project---pll)\r\n  - [Lecture\
    \ 10 - Design 9](#lecture-10---design-9)\r\n    - [Overview of the Ninth Project\
    \ - PLL (Continued)](#overview-of-the-ninth-project---pll-continued)\r\n  - [Lecture\
    \ 11 - Design 10](#lecture-11---design-10)\r\n    - [Overview of the Tenth Project\
    \ - PLL (Continued)](#overview-of-the-tenth-project---pll-continued)\r\n  - [Lecture\
    \ 12 - Design 11](#lecture-12---design-11)\r\n    - [Overview of the Eleventh\
    \ Project - PLL (Continued)](#overview-of-the-eleventh-project---pll-continued)\r\
    \n  - [Lecture 13 - HLS Flows](#lecture-13---hls-flows)\r\n    - [Overview of\
    \ the HLS Flow](#overview-of-the-hls-flow)\r\n    - [HLS Flows](#hls-flows)\r\n\
    \  - [Lecture 14 - HLS Project 1](#lecture-14---hls-project-1)\r\n    - [HLS Project\
    \ Overview](#hls-project-overview)\r\n    - [Part 1 - HLS Project 1](#hls-project-1-1)\r\
    \n  - [Lecture 15 - HLS Project 2](#lecture-15---hls-project-2)\r\n    - [Part\
    \ 2 - HLS Project 2](#hls-project-2-1)\r\n  - [Lecture 16 - HLS Project 3](#lecture-16---hls-project-3)\r\
    \n    - [Part 3 - HLS Project 3](#hls-project-3-1)\r\n  - [Lecture 17 - HLS Project\
    \ 4](#lecture-17---hls-project-4)\r\n    - [Part 4 - HLS Project 4](#hls-project-4-1)\r\
    \n  - [Lecture 18 - HLS Project 5](#lecture-18---hls-project-5)\r\n    - [Part\
    \ 5 - HLS Project 5](#hls-project-5-1)\r\n  - [Lecture 19 - HLS Project 6](#lecture-19---hls-project-6)\r\
    \n    - [Part 6 - HLS Project 6](#hls-project-6-1)\r\n  - [Lecture 20 - HLS Project\
    \ 7](#lecture-20---hls-project-7)\r\n    - [Part 7 - HLS Project 7](#hls-project-7-1)\r\
    \n  - [Lecture 21 - HLS Project 8](#lecture-21---hls-project-8)\r\n    - [Part\
    \ 8 - HLS Project 8](#hls-project-8-1)\r\n  - [Lecture 22 -"
- code: |-
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    always @(ClockIn, Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            inside(0,3): Adjr = 2'b11;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule

    ```
    Upvotes: 0 username_2: The problem is that you are trying to implement the functionality of the `case` statement using the `always` block. For the PLL, you have to use an edge-sensitive block. So I changed your code to

    ```
    `timescale 1 ns / 1 ps

    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;

    always @(PLLClock or Reset)
    if (Reset==1'b1)
    begin
        Adjr = 2'b01;
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    else begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
    end
    endmodule

    ```

    The output of the PLL is available in `AdjustFreq`, so this is the one that must be controlled by the `PLL`, and not any other signal. I added an edge-sensitive `always` block.

    Then, to reduce the combinatorial logic of the `always`, I moved the `HiCount` register, and the cases inside an `always_comb` block.

    ```
    `timescale 1 ns / 1 ps

    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg [1:0] Adjr;
    assign AdjustFreq = Adjr;

    always_comb
    begin
        case (HiCount)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
    end

    always @(PLLClock or Reset)
    if (Reset==1'b1)
    begin
        HiCount = 2'b0;
    end
    else if (PLLClock==1'b1)
        HiCount = HiCount + 2'b01;
    end
    endmodule

    ```

    As a note, you don't need the `inside` macro.
    Upvotes: 2 [selected_answer]
- code: |-
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    reg[1:0] HiCount_a;
    always @(ClockIn, Reset)
        if (Reset==1'b1)
        begin
            Adjr = 2'b01;
            HiCount = 2'b0;
            HiCount_a = 2'b0;
        end
        else if (PLLClock==1'b1)
            HiCount = HiCount + 2'b01;
            HiCount_a = HiCount_a + 2'b01;
        else begin
            case (HiCount)
                2'b00: Adjr = 2'b11;
                2'b01: Adjr = 2'b01;
                default: Adjr = 2'b00;
            endcase
            HiCount = 2'b0;
            HiCount_a = 2'b0;
        end
    else begin
        case (HiCount_a)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
        HiCount_a = 2'b0;
    end
    endmodule

    ```

    ### Example

    ```
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
    reg[1:0] Adjr;
    assign AdjustFreq = Adjr;
    reg[1:0] HiCount;
    reg[1:0] HiCount_a;
    reg[1:0] HiCount_b;
    always @(ClockIn, Reset)
        if (Reset==1'b1)
        begin
            Adjr = 2'b01;
            HiCount = 2'b0;
            HiCount_a = 2'b0;
            HiCount_b = 2'b0;
        end
        else if (PLLClock==1'b1)
            HiCount = HiCount + 2'b01;
            HiCount_a = HiCount_a + 2'b01;
            HiCount_b = HiCount_b + 2'b00;
        else begin
            case (HiCount)
                2'b00: Adjr = 2'b11;
                2'b01: Adjr = 2'b01;
                default: Adjr = 2'b00;
            endcase
            HiCount = 2'b0;
            HiCount_a = 2'b0;
            HiCount_b = 2'b0;
        end
    else begin
        case (HiCount_a)
            2'b00: Adjr = 2'b11;
            2'b01: Adjr = 2'b01;
            default: Adjr = 2'b00;
        endcase
        HiCount = 2'b0;
        HiCount_a = 2'b0;
        HiCount_b = 2'b0;
    end
    endmodule

    module JerkyComparator_tb;

    reg ClockIn;
    reg PLLClock;
    reg Reset;
    wire[1:0] AdjustFreq;

    JerkyComparator IC (AdjustFreq, ClockIn, PLLClock, Reset);

    initial
    begin
        ClockIn = 1'b0;
        PLLClock = 1'b0;
        Reset = 1'b0;
        #1;
        ClockIn = 1'b1;
        #5;
        Reset = 1'b1;
        #5;
        ClockIn = 1'b0;
        #5;
        Reset = 1'b0;
        #5;
        ClockIn = 1'b1;
        #5;
        Reset = 1'b1;
        #5;
        ClockIn = 1'b0;
        #5;
        Reset = 1'b0;
        #5;
        ClockIn = 1'b1;
        #5;
        Reset = 1'b1;
        #5;
        ClockIn = 1'b0;
        #5;
        Reset = 1'b0;
        #5;
        ClockIn = 1'b1;
        #5;
        Reset = 1'b1;
        #5;
    end
    endmodule

    ```username_1: I wouldn't change the code here because it's correct, but rather just change your testbench for the `JerkyComparator` as follows:

    ```
    module JerkyComparator_tb;

        reg ClockIn;
        reg PLLClock;
        reg Reset;
        wire[1:0] AdjustFreq;

        JerkyComparator IC (AdjustFreq, ClockIn, PLLClock, Reset);

        initial
            begin
                ClockIn = 1;
                PLLClock = 1;
                Reset = 1;
                #10;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 0;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 1;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 0;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 1;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 0;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
                Reset = 1;
                #100;
                ClockIn = 0;
                #1;
                ClockIn = 1;
                #100;
            end
    endmodule

    ```

    Running this testbench on your original code yields the expected results:

    [![enter image description here](https://i.stack.imgur.com/N3L4W.png)](https://i.stack.imgur.com/N3L4W.png)
    Upvotes: 3 [selected_answer]username_2: I believe the problem here is that your testbench is not resetting the registers between tests. When I modify your code to include a reset signal as the other answer shows, the output is correct.

    I am not sure if this would be the solution to the problem, but I believe that using a **tristate buffer** to pull the Reset signal down to the comparator is a good idea. This way you can control when it is pulled low without using a second (potentially not as fast) clock.

    The modified code is as follows:

    ```
    module JerkyComparator (output[1:0] AdjustFreq, input ClockIn, PLLClock, Reset);
        // Tristate buffer that pulls Reset signal down to IC
        wire ResetPullup = Reset ^ 1'b0;
        // Output signal to IC
        reg[1:0] Adjr;
        assign AdjustFreq = Adjr;
        // Comparator
        reg[1:0] HiCount;
        reg[1:0] HiCount_a;
        reg[1:0] HiCount_b;
        always @(ClockIn, ResetPullup)
            if (ResetPullup==1'b1)
            begin
                Adjr = 2'b01;
                HiCount = 2'b0;
                HiCount_a = 2'b0;
                HiCount_b = 2'b0;
            end
            else if (PLLClock==1'b1)
                HiCount = HiCount + 2'b01;
                HiCount_a = HiCount_a + 2'b01;
                HiCount_b = HiCount_b + 2'b00;
            else begin
                case (HiCount)
                    2'b00: Adjr = 2'b11;
                    2'b01: Adjr = 2'b01;
                    default: Adjr = 2'b00;
                endcase
                HiCount = 2'b0;
                HiCount_a = 2'b0;
                HiCount_b = 2'b0;
            end
        else begin
            case (HiCount_a)
                2'b00: Adjr = 2'b11;
                2'b01: Adjr = 2'b01;
                default: Adjr = 2'b00;
            endcase
            HiCount = 2'b0;
            HiCount_a = 2'b0;
            HiCount_b = 2'b0;
        end
    endmodule

    module JerkyComparator_tb;
- code: |-
    module test_carry;
    reg [2:0] a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    generate
    for (i = 0; i < 9; i = i + 1)
    begin
    assign a = i;
    assign b = i;
    end
    end
    generate
    for (i = 0; i < 4; i = i + 1)
    begin
    assign a = i;
    assign b = i;
    end
    assign a = 'bx;
    assign b = 'bx;
    endgenerate
    endmodule

    ```
    Upvotes: -1
- code: |-
    module test_div;
    reg a, b, c;
    reg [3:0] cout;
    wire [3:0] cout_array;
    integer i;
    initial
    begin
    $monitor("time=%d a=%b b
- code: |-
    module test_carry;
    reg a, b, c, d;
    integer i;
    wire cout;
    wire c_onehot;
    carry c1(cout, c, a, b);
    carry c2(cout, d, a, b);
    generate
    `ifdef TEST_CARRY_IN`
    carry c_in[9:0](cout, c, a, b);
    endgenerate
    initial
    begin
    c_onehot = 1'b0;
    $monitor("time=%d a=%b b=%b c=%b c_onehot=%s---------cout=%b", $time, a, b, c, c_onehot, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    ### Variation Command:
    If using gnu version, add the following line to the top of the testbench file:
    ```vhdl
    `include "util.svh"
    define TEST_CARRY_IN
    ```

    ## SystemVerilog
    ## C
    ## Verilog
    ## Hardware
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## Verilog
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## SystemVerilog
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## Cocotb
    ## UVM
    ## Cocotb
    ## C++
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## Cocotb
    ## UVM
    ## UVM
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## Verilog
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## Test Placement
    ## UVM
    ## UVM
    ## UVM
    ## Cocotb
    ## SystemVerilog
    ## UVM
    ## UVM
    ## Test Placement
    ##
- code: |-
    module test_carry;
    reg a, b, c;
    integer i;
    wire cout;
    carry c1(cout, c, a, b);
    initial
    begin
    $monitor("time=%d a=%b b=%b c=%b---------cout=%b", $time, a, b, c, cout);
    for (i = 0; i < 9; i = i + 1)
    begin
    {a, b, c} = i;
    end
    a = 'bx;
    b = 'bx;
    end
    endmodule
    The results of the testbench are:

    time=0 a=0 b=0 c=0---------cout=0
    time=100 a=0 b=1 c=1---------cout=1
    time=200 a=0 b=2 c=2---------cout=0
    time=300 a=0 b=3 c=3---------cout=1
    time=400 a=0 b=4 c=4---------cout=0
    time=500 a=0 b=5 c=5---------cout=1
    time=600 a=0 b=6 c=6---------cout=0
    time=700 a=0 b=7 c=7---------cout=1
    time=800 a=0 b=8 c=8---------cout=0
    time=900 a=0 b=9 c=9---------cout=1
    time=1000 a=x b=0 c=x---------cout=x
    time=1010 a=x b=1 c=0---------cout=x
    time=1020 a=x b=2 c=0---------cout=x
    time=1030 a=x b=3 c=0---------cout=x
    time=1040 a=x b=
- code: |-
    module Fibonacci_gen;
    reg [15:0] Fibonacci;
    reg [15:0] F_1;
    reg [15:0] F_2;
    reg [15:0] index;
    reg [7:0] F_index;
    reg [7:0] F_1_index;
    reg [7:0] F_2_index;
    wire [7:0] index_reg;
    wire [7:0
- code: "```\ninitial\nbegin\nd = state[0];\nen = state[1];\nend\nalways #4 en = state[1];\n\
    always #8 d = state[0];\n...\n### Testbench Code:\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\n\
    use IEEE.numeric_std.all;\nuse work.P0_P1.all;\nentity tstdlatch is\nend tstdlatch;\n\
    architecture Behavioral of tstdlatch is\ncomponent dlatch is port( d,en,q,qb:\
    \ in std_ulogic; clk: in std_ulogic); end component;\ndlatch #(.dl(4)) dlatch_a(clk,d,q,qb);\n\
    constant d_default : unsigned := x\"00\";\nconstant en_default : boolean := false;\n\
    signal state : state_t := (d_default,en_default);\nend Behavioral;\n### Testbench\
    \ Code:\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\nuse IEEE.numeric_std.all;\n\
    use work.P0_P1.all;\nentity tdlatch is\nend tdlatch;\narchitecture Behavioral\
    \ of tdlatch is\ncomponent dlatch is port( d,en,q,qb: in std_ulogic; clk: in std_ulogic);\
    \ end component;\ndlatch #(.dl(4)) dlatch_a(clk,d,q,qb);\nsignal state : state_t\
    \ := (state_default,en_default);\nbegin\ntestbench : process is\nvariable i :\
    \ integer;\nbegin\nfor i in 0 to 31 loop state <= (state_default, en_default);\
    \ end loop; -- test 50 ns\nwait for 65 ns; -- next 0 0\nfor i in 0 to 31 loop\
    \ state <= (state_default, en_default); end loop; -- test 50 ns\nwait for 65 ns;\
    \ -- next 1 0\nfor i in 0 to 31 loop state <= (state_default, en_default); end\
    \ loop; -- test 50 ns\nwait for 95 ns; -- next 1 1\nend process testbench;\nend\
    \ Behavioral;\n```\n### Output:\n```\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0,\
    \ d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q =\
    \ 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0\
    \ \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0,\
    \ d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q =\
    \ 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0\
    \ \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0,\
    \ d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q =\
    \ 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0\
    \ \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 0, d = 0, q = 0, qb = 0 \n\nen = 1,\
    \ d = 0, q = 0, qb = 0 \n\nen = 1, d = 0, q = 0, qb = 0 \n\nen = 1, d = 0, q =\
    \ 0, qb = 0 \n\nen = 1, d = 0, q = 1, qb = 0 \n\nen = 1, d = 0, q = 1, qb = 0\
    \ \n\nen = 1, d = 0, q = 1, qb = 0 \n\nen = 1, d = 0, q = 0, qb = 0 \n\nen = 1,\
    \ d = 0, q = 1, qb = 0 \n\nen = 1, d = 0, q = 1, qb = 0 \n\nen = 1, d = 0, q =\
    \ 0, qb = 0 \n\nen = 1, d = 0, q = 0, qb = 0 \n\nen = 1, d = 1, q = 0, qb = 0\
    \ \n\nen = 1, d = 1, q = 0, qb = 0 \n\nen = 1, d = 1, q = 0, qb = 0 \n\nen = 1,\
    \ d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q =\
    \ 1, qb = 0 \n\nen = 1, d = 1, q = 0, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0\
    \ \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 0, qb = 0 \n\nen = 1,\
    \ d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q =\
    \ 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0\
    \ \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1,\
    \ d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q =\
    \ 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0\
    \ \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1,\
    \ d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q =\
    \ 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0\
    \ \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1,\
    \ d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q =\
    \ 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0 \n\nen = 1, d = 1, q = 1, qb = 0\
    \ \n\nen = 1, d = 1,"
- code: "module tstdlatch; //test-bench\nimport `Tstdlatch_pkg::*;\nreg d,en;\nwire\
    \ q,qb;\n// `Tstdlatch` ff(en,d,q,qb); // Assuming instantiation of a D latch\
    \ module\ninitial\nbegin\nd = 1'b0;\nen = 1'b0; // Latch disabled\nend\nalways\
    \ #4 en =~en; // Enable toggles every 4 time units\nalways #8 d=~d; // Data toggles\
    \ every 8 time units\n\nalways @ (posedge en)\nbegin // Newly added\nstate = inside(state,\
    \ {0,1});\nend\ninitial $monitor($time,\" en = %b, d = %b, q = %b, qb = %b \"\
    , en,d,q,qb);\ninitial #40 $stop;\nendmodule\n\n# References:\n\n##### \n######\
    \ Researcher\n\nMy research interests include hardware/software interface design,\
    \ distributed computing, and high performance computing."
- code: |-
    module tstdlatch; //test-bench
    package mypackage;
    function [1:0] state_check_range(wire q,wire qb); //state check function
    state_check_range = 16'h0000;
    endfunction
    endpackage
    reg d,en;
    wire q,qb,rst;
    assign rst = ~(en & q); //rst output is the low of en & q
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en~=en | rst; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b", en,d,q,qb);
    initial #40 $stop; //stop simulation after 40 time units endmodule ### Variation Instruction: Replace all transitions with calls to a function in the package scope that takes a single wire and returns a `packed` range. ### Modified Code: module tstdlatch; //test-bench package mypackage; function [1:0] state_check_range(wire q,wire qb); //state check function state_check_range = 16'h0000; endfunction endpackage reg d,en; wire [1:0] state; wire q,qb,rst; assign rst = ~(en & q); //rst output is the low of en & q // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module initial begin d = 1'b0; en = 1'b0; // Latch disabled end always #4 en~=en | rst; // Enable toggles every 4 time units always #8 d=~d; // Data toggles every 8 time units initial$monitor($time," en = %b, d = %b, q = %b, qb = %b", en,d,q,qb); initial #40$stop; //stop simulation after 40 time units
    endmodule
- code: |-
    module latch;
    reg d,en;
    wire q,qb;
    assign qb=q;
    // latch
    assign q = d & en;
    endmodule
    # SFC-02-17

    # Case 1:

    ## Base Verilog Code:

    ```verilog
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ```

    ## Variation Instruction:

    Replace `flush_P0_P1` transition with an `inside` check of `state` against a packed range defined in package scope.

    ## Modified Code:

    ```verilog
    module tstdlatch; //test-bench
    reg d,en;
    wire q,qb;
    // dlatch ff(en,d,q,qb); // Assuming instantiation of a D latch module
    initial
    begin
    d = 1'b0;
    en = 1'b0; // Latch disabled
    end
    always #4 en =~en; // Enable toggles every 4 time units
    always #8 d=~d; // Data toggles every 8 time units
    initial $monitor($time," en = %b, d = %b, q = %b, qb = %b ", en,d,q,qb);
    initial #40 $stop;
    endmodule
    ```

    # Case 2:

    ## Base Verilog Code:

    ```verilog
    module adder;
    wire [7:0]a,b,c,s,cout;
    // a,b,c,s,cout 8 bit adder module
    assign s = a+b;
    assign cout = ($reduce_or(a,b) &&~ (~s[7] || c));
    //assign c = $reduce_or(a,b) &&~ (~s[7] || c);
    initial
    begin
    a=8'h23;
    b=8'h45;
    c=1'b0;
    end
    initial $monitor($time," a=%b b=%b c=%b s=%b cout=%b ", a,b,c,s,cout);
    initial $stop;
    endmodule
    ```

    ## Variation Instruction:

    Change the `assign` at line 5 to an `inside` check of `a` and `b` against a packed range defined in package scope.

    ## Modified Code:

    ```verilog
    module adder;
    wire [7:0]a,b,c,s,cout;
    // a,b,c,s,cout 8 bit adder module
    assign s = a+b;
    assign cout = ($reduce_or(a,b) &&~ (~s[7] || c));
    //assign c = $reduce_or(a,b) &&~ (~s[7] || c);
    initial
    begin
    a=8'h23;
    b=8'h45;
    c=1'b0;
    end
    initial $monitor($time," a=%b b=%b c=%b s=%b cout=%b ", a,b,c,s,cout);
    initial $stop;
    endmodule
    ```

    # Case 3:

    ## Base Verilog Code:

    ```verilog
    module adder;
    wire [7:0]a,b,c,s,cout;
    // a,b,c,s,cout 8 bit adder module
    assign s = a+b;
    assign cout = ($reduce_or(a,b) &&~ (~s[7] || c));
    //assign c = $reduce_or(a,b) &&~ (~s[7] || c);
    initial
    begin
    a=8'h23;
    b=8'h45;
    c=1'b0;
    end
    initial $monitor($time," a=%b b=%b c=%b s=%b cout=%b ", a,b
- code: |-
    <details>
    <summary>Click here to show Modified source code.</summary>

    ```verilog
    module p8_tb (i, o, clk_in);

    // Inputs
    wire i;

    // Outputs
    reg o[3:0];

    // Clock
    wire clk_in;
    wire clk_out;
    reg clk_reg;

    // Instantiate modules
    reg [3:0] in_reg;
    reg [3:0] out_reg;
    wire [3:0] clk_reg_out;
    reg [0:0] reset_reg;
    wire [0:0
- code: "`decode_hex{16}` will compare x against 0.. 15.\n`decode_hex{16: 0}` will\
    \ compare x against 16.. 255.\n`decode_hex{16: 16}` will compare x against 16..\
    \ 31.\n`decode_hex{16: 16: 16}` will compare x against 16.. 31.\n`decode_hex{8:\
    \ 8}` will compare x against 8.. 15\n\n## Lesson 7:\n1. Make sure to save your\
    \ code in a.txt document\n2. Make sure to save your code in a.zip file\n2. Make\
    \ sure to save your code in a.v file\n3. Make sure you are modifying the code\
    \ in a new Verilog file\n4. Make sure to add the following to the top of your\
    \ code:\n`//  and \n// CE4507 - 001\n// Lesson 7: Hex-to-7 Segment Decoder`\n\
    ### Simulation\n1. Start your simulation\n2. Wait for the simulation to finish\n\
    3. Click on the 'Results' icon in the top-right and select 'Save Waveform'\n4.\
    \ Save the file at a location that you choose\n5. Close the simulation\n\n## Lesson\
    \ 8:\n1. Make sure to save your code in a.txt document\n2. Make sure to save your\
    \ code in a.zip file\n2. Make sure to save your code in a.v file\n3. Make sure\
    \ you are modifying the code in a new Verilog file\n4. Make sure to add the following\
    \ to the top of your code:\n`//  and \n// CE4507 - 001\n// Lesson 8: Hex-to-7\
    \ Segment Decoder\n// Purpose: Implement a hex-to-7 segment decoder and convert\
    \ the hexadecimal 1A to the seven-segment representation in decimal 26`\n### Simulation\n\
    1. Start your simulation\n2. Wait for the simulation to finish\n3. Click on the\
    \ 'Results' icon in the top-right and select 'Save Waveform'\n4. Save the file\
    \ at a location that you choose\n5. Close the simulation\n\n## Lesson 9:\n1. Make\
    \ sure to save your code in a.txt document\n2. Make sure to save your code in\
    \ a.zip file\n2. Make sure to save your code in a.v file\n3. Make sure you are\
    \ modifying the code in a new Verilog file\n4. Make sure to add the following\
    \ to the top of your code:\n`//  and \n// CE4507 - 001\n// Lesson 9: Hex-to-7\
    \ Segment Decoder\n// Purpose: Implement a hex-to-7 segment decoder and convert\
    \ the hexadecimal 1A to the seven-segment representation in decimal 26`\n### Simulation\n\
    1. Start your simulation\n2. Wait for the simulation to finish\n3. Click on the\
    \ 'Results' icon in the top-right and select 'Save Waveform'\n4. Save the file\
    \ at a location that you choose\n5. Close the simulation\n\n## Lesson 10:\n1.\
    \ Make sure to save your code in a.txt document\n2. Make sure to save your code\
    \ in a.zip file\n2. Make sure to save your code in a.v file\n3. Make sure you\
    \ are modifying the code in a new Verilog file\n4. Make sure to add the following\
    \ to the top of your code:\n`//  and \n// CE4507 - 001\n// Lesson 10: Hex-to-7\
    \ Segment Decoder\n// Purpose: Implement a hex-to-7 segment decoder and convert\
    \ the hexadecimal 1A to the seven-segment representation in decimal 26`\n### Simulation\n\
    1. Start your simulation\n2. Wait for the simulation to finish\n3. Click on the\
    \ 'Results' icon in the top-right and select 'Save Waveform'\n4. Save the file\
    \ at a location that you choose\n5. Close the simulation\n\n## Lesson 11:\n1.\
    \ Make sure to save your code in a.txt document\n2. Make sure to save your code\
    \ in a.zip file\n2. Make sure to save your code in a.v file\n3. Make sure you\
    \ are modifying the code in a new Verilog file\n4. Make sure to add the following\
    \ to the top of your code:\n`//  and \n// CE4507 - 001\n// Lesson 11: Hex-to-7\
    \ Segment Decoder\n// Purpose: Implement a hex-to-7 segment decoder and convert\
    \ the hexadecimal 1A to the seven-segment representation in decimal 26`\n### Simulation\n\
    1. Start your simulation\n2. Wait for the simulation to finish\n3. Click on the\
    \ 'Results' icon in the top-right and select 'Save Waveform'\n4. Save the file\
    \ at a location that you choose\n5. Close the simulation\n\n## Lesson 12:\n1.\
    \ Make sure to save your code in a.txt document\n2. Make sure to save your code\
    \ in a.zip file\n2. Make sure to save your code in a.v file\n3. Make sure you\
    \ are modifying the code in a new Verilog file\n4. Make sure to add the following\
    \ to the top of your code:\n`//  and \n// CE4507 - 001\n// Lesson 12: Hex-to-7\
    \ Segment Decoder\n// Purpose: Implement a hex-to-7 segment decoder and convert\
    \ the hexadecimal 1A to the seven-segment representation in decimal 26`\n### Simulation\n\
    1. Start your simulation\n2. Wait for the simulation to finish\n3. Click on the\
    \ 'Results' icon in the top-right and select 'Save Waveform'\n4. Save the file\
    \ at a location that you choose\n5. Close the simulation/Projects/project1/Makefile\n\
    all:\n\tiverilog -D SIM -o testbench testbench.v\n\tvvp testbench\n/Projects/project2/Makefile\n\
    all:\n\tiverilog -o testbench testbench.v\n\tvvp testbench\n\nclean:\n\trm -rf\
    \ *.vcd\n\trm -rf testbench\n/Projects/project2/README.md\n# Project 2 Code\n\n\
    ##  and \n\n## Lesson 1:\n1. Make sure to save your code in a.txt document\n2.\
    \ Make sure to save your code in a.zip file\n2. Make sure to save your code in\
    \ a.v file\n3. Make sure you are modifying the code in a new Verilog file\n4.\
    \ Make sure to add the following to the top of your code:\n`//  and \n// CE4507\
    \ - 001\n// Lesson 1: Hex-to-7 Segment Decoder`\n### Simulation\n1. Start your\
    \ simulation\n2. Wait for the simulation to finish\n3. Click on the 'Results'\
    \ icon in the top-right and select 'Save Waveform'\n4. Save the file at a location\
    \ that you choose\n5. Close the simulation\n\n## Lesson 2:\n1. Make sure to save\
    \ your code in a.txt document\n2. Make sure to save your code in a.zip file\n\
    2. Make sure to save your code in a.v file\n3. Make sure you are modifying the\
    \ code in a new Verilog file\n4. Make sure to add the following to the top of\
    \ your code:\n`//  and \n// CE4507 - 001\n// Lesson 2: Hex-to-7 Segment Decoder\n\
    // Purpose: Implement a hex-to-7 segment decoder and convert the hexadecimal 1A\
    \ to the seven-segment representation in decimal 26`\n### Simulation\n1. Start\
    \ your simulation\n2. Wait for the simulation to finish\n3. Click on the 'Results'\
    \ icon in the top-right and select 'Save Waveform'\n4. Save the file at a location\
    \ that you choose\n5. Close the simulation\n\n## Lesson 3:\n1. Make sure to save\
    \ your code in a.txt document\n2. Make sure to save your code in a.zip file\n\
    2. Make sure to save your code in a.v file\n3. Make sure you are modifying the\
    \ code in a new Verilog file\n4. Make sure to add the following to the top of\
    \ your code:\n`//  and \n// CE4507 - 001\n// Lesson 3: Hex-to-7 Segment Decoder\n\
    // Purpose: Implement a hex-to-7 segment decoder and convert the hexadecimal 1A\
    \ to the seven-segment representation in decimal 26`\n### Simulation\n1. Start\
    \ your simulation\n2. Wait for the simulation to finish\n3. Click on the 'Results'\
    \ icon in the top-right and select 'Save Waveform'\n4. Save the file at a location\
    \ that you choose\n5. Close the simulation\n\n## Lesson 4:\n1. Make sure to save\
    \ your code in a.txt document\n2."
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else
    begin
    next_state = S_idle;
    flush_P0_P1 = 1;
    end

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld_P0 = 1; end
    S_full: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else
    begin
    next_state = S_wait;
    flush_P0_P1 = 1;
    end

    S_wait: if (Ld == 1) begin
    Ld_R0 = 1;
    case (En)
    0: begin next_state = S_idle; flush_P0_P1 = 1; end
    1: begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    endcase
    end
    else
    begin
    next_state = S_wait;
    flush_P0_P1 = 1;
    end

    endcase
    end
    endmodule

    ### Variation Instruction:
    This variation is used to make an error-free circuit with a 5-D flip-flop.
    ### Base Verilog Code:
    module 5D_flip_flop (D, Clk, Ck, Q, Q2, Q3);
    input D, Clk, Ck;
    output reg Q, Q2, Q3;
    always @* begin
    Q3 <= Q2;
    Q2 <= Q;
    Q <= D;
    end
    always @(posedge Clk or posedge Ck) if (Ck)
    Q3 <= Q2;
    Q2 <= Q;
    Q <= D;
    endmodule
    ### Variation Instruction:
    This variation is used to test the circuit you developed for the 5-D flip-flop.
    ### Base Verilog Code:
    module testbench_5D_flip_flop;
    reg clock, next_clock, Ck;
    reg Q1, Q2, Q3, D;
    wire [3: 0] Q;
    5D_flip_flop ff (D, clock, Ck, Q, Q2, Q3);
    initial begin
    clock = 0;
    next_clock = 0;
    end
    always # 1 clock = next_clock;
    always # 1 next_clock = ~ clock;
    initial begin
    D = 0;
    end
    initial begin
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    end
    initial begin
    # 4; Ck = 1;
    # 4; Ck = 0; Ck = 1; end
    endalways @(posedge clock or posedge Ck) if (Ck)
    Q1 <= Q;
    endmodule
    ### Variation Instruction:
    This variation is used to make an error-free circuit with a 5-D flip-flop.
    ### Base Verilog Code:
    module 5D_flip_flop (D, Clk, Ck, Q, Q2, Q3);
    input D, Clk, Ck;
    output reg Q, Q2, Q3;
    always @* begin
    Q3 <= Q2;
    Q2 <= Q;
    Q <= D;
    end
    always @(posedge Clk or posedge Ck) if (Ck)
    Q3 <= Q2;
    Q2 <= Q;
    Q <= D;
    endmodule
    ### Variation Instruction:
    This variation is used to test the circuit you developed for the 5-D flip-flop.
    ### Base Verilog Code:
    module testbench_5D_flip_flop;
    reg clock, next_clock, Ck;
    reg Q1, Q2, Q3, D;
    wire [3: 0] Q;
    5D_flip_flop ff (D, clock, Ck, Q, Q2, Q3);
    initial begin
    clock = 0;
    next_clock = 0;
    end
    always # 1 clock = next_clock;
    always # 1 next_clock = ~ clock;
    initial begin
    D = 0;
    end
    initial begin
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    # 4; D = 1;
    # 4; D = 0;
    end
    initial begin
    # 4; Ck = 1;
    # 4; Ck = 0; Ck = 1; end
    endalways @(posedge clock or posedge Ck) if (Ck)
    Q1 <= Q;
- code: |-
    ```verilog
    module memory_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, address, data_in, En, clock, rst, result, done);
    input [3: 0] address, data_in;
    output reg [3:0] result, done;
    input En, clock, rst;
    parameter [3: 0] R_0 = 4, R_1 = 5, R_2 = 6, R_3 = 7, W_0 = 0, W_1 = 1, W_2 = 2, W_3 = 3;

    // 1. write the result to variable `result`
    // 2. write `done` to be `1` if `valid_instruction` is `1`, else `0`.
    // 3. Declare a variable `data_out`, in which you have the data to be fed to `memory`.
    // 4. Declare a variable `data_in`, which will be fed to `memory` through `data_in`.
    // 5. Check if `valid_instruction` is `1` and `done` is `1`, then write it to the `memory`.
    // 6.
- code: |-
    module control_unit (flush_P0_P1, Ld_P1, Ld_P0, Ld_R0, Ld, En, clock, rst);
    output reg flush_P0_P1, Ld_P1, Ld_P0, Ld_R0;
    input Ld, En, clock, rst;
    reg [1: 0] state, next_state;
    parameter S_idle = 0, S_1 = 1, S_full = 2, S_wait = 3;
    always @ (posedge clock) if (rst) state <= S_idle;
    else state <= next_state;
    always @ (state, Ld, En) begin
    flush_P0_P1 = 0;
    Ld_P1 = 0;
    Ld_P0 = 0;
    Ld_R0 = 0;
    next_state = S_idle;
    case (state)
    S_idle: if (En)
    begin next_state = S_1; Ld_P1 = 1; Ld_P0 = 1; end
    else flush_P0_P1 = 1;

    S_1: begin next_state = S_full; Ld_P1 = 1; Ld
- code: |-
    module rom_to_ram (data_in, data_out, ram_in, ram_out, En, clock, rst);
    output reg [15: 0] data_out;
    input [15: 0] ram_in, data_in;
    input En, clock, rst;
    reg [15: 0] data_out_reg;
    always @ (posedge clock) begin
    if (rst) data_out_reg <= 0;
    else begin
    if (En) data_out_reg <= data_in;
    end
    end
    always @ (posedge clock) data_out <= data_out_reg;
    endmodule
    ### Testbench:
    module top;
    reg [7: 0] data;
    reg clock, rst;
    reg [31: 0] data_in;
    reg data_out;
    reg [15: 0] ram_in, ram_out;
    reg [1: 0] a, b;
    reg [15: 0] count;
    parameter count_limit = 50;
    parameter data_length = 7;

    initial begin
    clock = 0;
    rst = 1;
    data = 0;
    $display("Testbench for rom-to-ram converter");$display("Inputs: ");
    end

    initial begin
    data = 0;
    clock = 1;
    rst = 0;
    clock = 0;
    rst = 1;
    end

    initial begin
    data_out = 0;
    $display("State, Ld, En, data, data_out"); end forever begin #5 a = data[3: 0]; b = data[4: 0]; #10 clock = ~clock; #10 rst = 0; #10 data_out = data_out; data_out = ram_out; ram_in = {ram_in[15: 8], ram_in[7: 0]}; ram_out = ram_in[15: 0]; ram_in[15: 0] = ram_out; data_out[0] = {a[0], a[1], a[2], b[2], b[3], a[3], a[4], a[5]}; data_out[1] = {a[0], a[1], a[2], b[2], b[3], a[3], a[4], a[5]}; data_out[2] = {b[0], b[1], a[

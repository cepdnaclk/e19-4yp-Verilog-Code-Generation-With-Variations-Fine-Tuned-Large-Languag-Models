# Generated by Ollama Llama 3
# Task: fsm_state_rename_minimal
# Attempt: 7
# Success: False
# Overall Score: 0.355

[PYTHON]
import argparse
import re

from pyverilog import *
from pyverilog.vparser import parse
from pyverilog.transform import Transform, VisitorTransform

class RenameFSMStates(VisitorTransform):
    def __init__(self, old_prefix, new_prefix):
        self.old_prefix = old_prefix
        self.new_prefix = new_prefix

    def visit_module(self, node):
        # Call the parent method to visit all child nodes first
        super().visit_module(node)

        # Now update any FSM state declarations that match the pattern
        for decl in node.declarations:
            if isinstance(decl, Parameter) and re.match(self.old_prefix + r'\d+', decl.name):
                decl.name = self.new_prefix + decl.name[len(self.old_prefix):]

        # Update any references to the FSM states in case statements
        for stmt in node.statements:
            if isinstance(stmt, Case):
                for when in stmt.whens:
                    if isinstance(when.expr, Identifier) and re.match(self.old_prefix + r'\d+', when.expr.name):
                        when.expr.name = self.new_prefix + when.expr.name[len(self.old_prefix):]

        # Update any assignments or comparisons to the FSM states
        for stmt in node.statements:
            if isinstance(stmt, Assignment) and isinstance(stmt.lhs, Identifier) and re.match(self.old_prefix + r'\d+', stmt.lhs.name):
                stmt.lhs.name = self.new_prefix + stmt.lhs.name[len(self.old_prefix):]
            elif isinstance(stmt, Comparison) and isinstance(stmt.lhs, Identifier) and re.match(self.old_prefix + r'\d+', stmt.lhs.name):
                stmt.lhs.name = self.new_prefix + stmt.lhs.name[len(self.old_prefix):]

class RenameFSMStatesTransform(Transform):
    def __init__(self, old_prefix, new_prefix):
        self.old_prefix = old_prefix
        self.new_prefix = new_prefix

    def transform(self, node):
        # Check if the module is a valid Verilog file before attempting to rename FSM states
        if not isinstance(node, Module):
            raise ValueError('Input file must be a valid Verilog module')

        # Create a new visitor instance and apply it to the AST
        visitor = RenameFSMStates(self.old_prefix, self.new_prefix)
        node.accept(visitor)

def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('input', help='Input Verilog file')
    parser.add_argument('--old-prefix', required=True, help='Old prefix for FSM states')
    parser.add_argument('--new-prefix', required=True, help='New prefix for FSM states')
    args = parser.parse_args()

    # Read the input file and parse it into an AST
    with open(args.input, 'r') as f:
        module = parse(f.read(), filename=args.input)

    # Apply the transformation to the AST
    RenameFSMStatesTransform(args.old_prefix, args.new_prefix).transform(module)

    # Write the transformed AST back to a file
    with open('output.v', 'w') as f:
        f.write(module.to_verilog())

if __name__ == '__main__':
    main()
[/PYTHON]
[TESTS]
# Test case 1:
# Input:
# module test(input a, output b);
# always @* begin
#   case (a)
#     FSM_STATE1: b = 1;
#     FSM_STATE2: b = 0;
#   endcase
# end
# Parameters:
# old_prefix = "FSM_STATE"
# new_prefix = "NEW_STATE"
# Output:
# module test(input a, output b);
# always @* begin
#   case (a)
#     NEW_STATE1: b = 1;
#     NEW_STATE2: b = 0;
#   endcase
# end
def test_case_1():
    input = "module test(input a, output b);\n" \
            "always @* begin\n" \
            "  case (a)\n" \
            "    FSM_STATE1: b = 1;\n" \
            "    FSM_STATE2: b = 0;\n" \
            "  endcase\n" \
            "end\n" \
            "Parameters:\n" \
            "old_prefix = \"FSM_STATE\"\n" \
            "new_prefix = \"NEW_STATE\"\n"
    output = "module test(input a, output b);\n" \
             "always @* begin\n" \
             "  case (a)\n" \
             "    NEW_STATE1: b = 1;\n" \
             "    NEW_STATE2: b = 0;\n" \
             "  endcase\n" \
             "end\n"
    assert transform(input, "FSM_STATE", "NEW_STATE") == output

# Test case 2:
# Input:
# module test(input a, output b);
# always @* begin
#   if (a) begin
#     FSM_STATE1: b = 1;
#   end else begin
#     FSM_STATE2: b = 0;
#   end
# end
# Parameters:
# old_prefix = "FSM_STATE"
# new_prefix = "NEW_STATE"
# Output:
# module test(input a, output b);
# always @* begin
#   if (a) begin
#     NEW_STATE1: b = 1;
#   end else begin
#     NEW_STATE2: b = 0;
#   end
# end
def test_case_2():
    input = "module test(input a, output b);\n" \
            "always @* begin\n" \
            "  if (a) begin\n" \
            "    FSM_STATE1: b = 1;\n" \
            "  end else begin\n" \
            "    FSM_STATE2: b = 0;\n" \
            "  end\n" \
            "end\n" \
            "Parameters:\n" \
            "old_prefix = \"FSM_STATE\"\n" \
            "new_prefix = \"NEW_STATE\"\n"
    output = "module test(input a, output b);\n" \
             "always @* begin\n" \
             "  if (a) begin\n" \
             "    NEW_STATE1: b = 1;\n" \
             "  end else begin\n" \
             "    NEW_STATE2: b = 0;\n" \
             "  end\n" \
             "end\n"
    assert transform(input, "FSM_STATE", "NEW_STATE") == output

# Test case 3:
# Input:
# module test(input a, output b);
# always @* begin
#   case (a)
#     FSM_STATE1: b = 1;
#     FSM_STATE2: b = 0;
#   endcase
# end
# Parameters:
# old_prefix = "FSM_STATE"
# new_prefix = "NEW_STATE"
# Output:
# module test(input a, output b);
# always @* begin
#   case (a)
#     NEW_STATE1: b = 1;
#     NEW_STATE2: b = 0;
#   endcase
# end
def test_case_3():
    input = "module test(input a, output b);\n" \
            "always @* begin\n" \
            "  case (a)\n" \
            "    FSM_STATE1: b = 1;\n" \
            "    FSM_STATE2: b = 0;\n" \
            "  endcase\n" \
            "end\n
# Generated by Ollama Llama 3
# Task: inside_op_array_usage_minimal
# Attempt: 7
# Success: False
# Overall Score: 0.295

You are an expert in Verilog/SystemVerilog and Python. Generate a transformation 
module for the xform framework that performs the following task:

TASK: Create test cases for using arrays in inside operator

REQUIREMENTS:
- Generate test cases for array as whole in inside operator
- Create array slice and part select test cases
- Handle array select for multi-dimensional arrays
- Test constant and variable index scenarios
- Generate XMR and function call index test cases

The transformation should follow this pattern:
1. Use PyVerilog to parse and analyze the AST
2. Create a visitor class to identify target elements  
3. Use regex to perform the actual text transformations
4. Include proper error handling and validation
5. Return True/False for success/failure

Generate a complete Python module with:
- Proper imports (pyverilog, re, argparse, etc.)
- A visitor class that inherits the pattern from existing xforms
- A main transformation function
- A command-line interface
- Comprehensive docstrings

Make sure the code integrates properly with the existing xform framework patterns.
```
#!/usr/bin/env python3

import pyverilog
from pyverilog import *
import re
import argparse

class ArrayInsideOperatorTransform(Transformation):
    def __init__(self, file):
        super().__init__(file)

    def run(self, args):
        self.visit(args.input_file)

    def visit_module(self, node):
        for item in node:
            self.visit(item)

    def visit_instance(self, node):
        if isinstance(node, Instance):
            # Check if the instance is an array
            if node.name.endswith('[]'):
                # Get the original name of the array
                orig_name = node.name[:-2]

                # Create a new array slice node with the same dimensions
                array_slice = ArraySlice(node, None, None)

                # Replace the old instance with the new array slice
                self.replace(node, array_slice)

                # Create a test case for the array slice
                test_case = TestCase('test_{}_array_slice'.format(orig_name),
                                    'Testing array slice of {}'.format(orig_name))
                test_case.add_input('{}_slice'.format(orig_name), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a part select
            elif node.name.endswith('[*]'):
                # Get the original name of the array
                orig_name = node.name[:-3]

                # Create a new part select node with the same dimensions
                part_select = PartSelect(node, None)

                # Replace the old instance with the new part select
                self.replace(node, part_select)

                # Create a test case for the part select
                test_case = TestCase('test_{}_part_select'.format(orig_name),
                                    'Testing part select of {}'.format(orig_name))
                test_case.add_input('{}_slice'.format(orig_name), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a multi-dimensional array
            elif node.name.endswith('[*][*]'):
                # Get the original name of the array
                orig_name = node.name[:-4]

                # Create a new multi-dimensional part select node with the same dimensions
                multi_part_select = MultiDimensionalPartSelect(node, None)

                # Replace the old instance with the new multi-dimensional part select
                self.replace(node, multi_part_select)

                # Create a test case for the multi-dimensional part select
                test_case = TestCase('test_{}_multi_part_select'.format(orig_name),
                                    'Testing multi-dimensional part select of {}'.format(orig_name))
                test_case.add_input('{}_slice'.format(orig_name), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a constant index
            elif re.match(r'\w+\[(\d+)\]', node.name):
                # Get the original name of the array and the constant index
                orig_name, index = re.match(r'(\w+)\[(\d+)\]', node.name).groups()

                # Create a new part select node with the same dimensions
                part_select = PartSelect(node, None)

                # Replace the old instance with the new part select
                self.replace(node, part_select)

                # Create a test case for the constant index
                test_case = TestCase('test_{}_constant_index'.format(orig_name),
                                    'Testing constant index of {}'.format(orig_name))
                test_case.add_input('{}[{}]'.format(orig_name, index), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a variable index
            elif re.match(r'\w+\[(\w+)\]', node.name):
                # Get the original name of the array and the variable index
                orig_name, index = re.match(r'(\w+)\[(\w+)\]', node.name).groups()

                # Create a new part select node with the same dimensions
                part_select = PartSelect(node, None)

                # Replace the old instance with the new part select
                self.replace(node, part_select)

                # Create a test case for the variable index
                test_case = TestCase('test_{}_variable_index'.format(orig_name),
                                    'Testing variable index of {}'.format(orig_name))
                test_case.add_input('{}[{}]'.format(orig_name, index), node.width)
                self.add_test_case(test_case)

            # Check if the instance is an XMR
            elif re.match(r'\w+\[(\d+)\]\[(\d+)\]', node.name):
                # Get the original name of the array and the indices
                orig_name, row_index, col_index = re.match(r'(\w+)\[(\d+)\]\[(\d+)\]', node.name).groups()

                # Create a new XMR node with the same dimensions
                xmr = XMR(node, None)

                # Replace the old instance with the new XMR
                self.replace(node, xmr)

                # Create a test case for the XMR
                test_case = TestCase('test_{}_xmr'.format(orig_name),
                                    'Testing XMR of {}'.format(orig_name))
                test_case.add_input('{}[{}, {}]'.format(orig_name, row_index, col_index), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a function call index
            elif re.match(r'\w+\[(\d+)\]\((.*)\)', node.name):
                # Get the original name of the array and the function call index
                orig_name, row_index, func_call = re.match(r'(\w+)\[(\d+)\]\((.*)\)', node.name).groups()

                # Create a new function call index node with the same dimensions
                func_call_index = FunctionCallIndex(node, None)

                # Replace the old instance with the new function call index
                self.replace(node, func_call_index)

                # Create a test case for the function call index
                test_case = TestCase('test_{}_func_call'.format(orig_name),
                                    'Testing function call index of {}'.format(orig_name))
                test_case.add_input('{}[{}, {}]'.format(orig_name, row_index, func_call), node.width)
                self.add_test_case(test_case)

            # Check if the instance is a function call with multiple arguments
            elif re.match(r'\w+\((.*)\)', node.name):
                # Get the original name of the array and the function call index
                orig_name, func_call = re.match(r'(\w+)\((.*)\)', node.name).groups()

                # Create a new function call with multiple arguments node with the same dimensions
                multi_func_call = MultiFunction
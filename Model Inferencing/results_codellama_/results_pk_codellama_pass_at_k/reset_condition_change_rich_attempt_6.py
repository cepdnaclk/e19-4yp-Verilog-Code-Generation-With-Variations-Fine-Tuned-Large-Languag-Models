# Generated by Ollama Llama 3
# Task: reset_condition_change_rich
# Attempt: 6
# Success: False
# Overall Score: 0.485

  The provided requirements are a good starting point for a transformation module that can change reset condition from active-high to active-low or vice versa in Verilog/SystemVerilog files. Here's an example implementation of such a module:
```python
import argparse
from pyverilog import VParser, VTransformer
import re

class ResetConditionChangeVisitor(VTransformer):
    def __init__(self, reset_signal_name):
        self.reset_signal_name = reset_signal_name
        self.changes_made = []
        self.reset_found = False

    def visit(self, node):
        if isinstance(node, VParser.Node):
            # Check for target declarations
            if isinstance(node, VParser.Decl):
                for item in node.list:
                    if hasattr(item, "name") and item.name == self.reset_signal_name:
                        self.reset_found = True
                        self.changes_made.append(f"Found {self.reset_signal_name}")

            # Visit children
            for c in node.children():
                self.visit(c)

    def transform(self, ast):
        self.visit(ast)

        if not self.reset_found:
            raise ValueError(f"Reset signal {self.reset_signal_name} not found in the design.")

        # Perform regex transformations on the AST to change reset condition
        for node in ast.findall("if"):
            if "rst" in node.condition:
                new_cond = re.sub(r"\b(rst)\b", r"!rst", node.condition)
                self.changes_made.append((node.condition, new_cond))
                node.condition = new_cond
            else:
                new_cond = re.sub(r"\b(!)(rst)\b", r"rst", node.condition)
                self.changes_made.append((node.condition, new_cond))
                node.condition = new_cond

        # Update sensitivity lists (posedge to negedge)
        for node in ast.findall("always"):
            if "rst" in node.sensitivity:
                new_sens = re.sub(r"\b(posedge)\b", r"negedge", node.sensitivity)
                self.changes_made.append((node.sensitivity, new_sens))
                node.sensitivity = new_sens

        # Handle asynchronous reset patterns
        for node in ast.findall("initial"):
            if "rst" in node.condition:
                new_cond = re.sub(r"\b(rst)\b", r"!rst", node.condition)
                self.changes_made.append((node.condition, new_cond))
                node.condition = new_cond

        return ast, self.changes_made
```
This module defines a `ResetConditionChangeVisitor` class that inherits from `VTransformer`. It has an `__init__` method that initializes the visitor with the name of the reset signal to change. The `visit` method visits every node in the AST and identifies target declarations. If the reset signal is found, it sets a flag indicating that the reset signal was found. The `transform` method performs the actual text transformations on the AST using regular expressions. It updates sensitivity lists (posedge to negedge) and handles asynchronous reset patterns. Finally, it returns the transformed AST along with a list of changes made.

To use this module, we need to create a command-line interface that takes in input files, output files, and a reset signal name as arguments. Here's an example implementation:
```python
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Change reset condition from active-high to active-low or vice versa.")
    parser.add_argument("input_file", type=str, help="Input file name")
    parser.add_argument("output_file", type=str, help="Output file name")
    parser.add_argument("reset_signal_name", type=str, help="Name of reset signal to change condition for")
    args = parser.parse_args()

    # Parse AST
    ast, directives = parse([args.input_file])

    # Apply visitor
    visitor = ResetConditionChangeVisitor(args.reset_signal_name)
    transformed_ast, changes_made = visitor.transform(ast)

    # Perform regex transformations
    with open(args.input_file, "r") as f:
        content = f.read()

    # Apply changes...
    modified_content = re.sub(pattern, replacement, content)

    # Write output
    with open(args.output_file, "w") as f:
        f.write(modified_content)
```
This code creates an argument parser that takes in input and output files, and a reset signal name. It then parses the AST using `parse`, applies the visitor to transform the AST, performs regex transformations on the content of the input file, and writes the transformed content to the output file.
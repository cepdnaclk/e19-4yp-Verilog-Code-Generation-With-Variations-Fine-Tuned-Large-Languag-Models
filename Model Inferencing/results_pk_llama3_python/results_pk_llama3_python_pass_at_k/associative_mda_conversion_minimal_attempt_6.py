# Generated by Ollama Llama 3
# Task: associative_mda_conversion_minimal
# Attempt: 6
# Success: False
# Overall Score: 0.358

import re
import pyverilog.ast as ast
import sys

# Parse the arguments
parser = argparse.ArgumentParser(description='Convert arrays to associative multi-dimensional arrays')
parser.add_argument('-v', '--verbose', action='store_true', help="print debug info")
args, _ = parser.parse_known_args()

# Find array declarations to convert
def find_arrays(node):
    if node.__class__ == ast.ArrayDecl:
        return [node]
    else: 
        results = []
        for child in node.children:
            results.extend(find_arrays(child))
        return results

# Convert to associative array syntax [key_type]    
def array_to_assoc(arr_decls, key_type):
    # Find the key type
    if key_type == 'string':
        key_re = r'^[a-zA-Z_][0-9a-zA-Z_]*$'
    elif key_type == 'int':
        key_re = r'^(\+|-)?[0-9]+$'
    else:
        raise ValueError('Unsupported key type')

    # Convert the array declaration to an associative multi-dimensional array
    for arr_decl in arr_decls:
        if re.search(key_re, str(arr_decl.key)):
            print(f"Converting {arr_decl.name} ({arr_decl.type}) to associative multi-dimensional array")
            new_decl = ast.AssocArrayDecl(name=arr_decl.name, type=arr_decl.type)
            # Find the index
            for child in arr_decl.children:
                if child.__class__ == ast.Index:
                    print(f"  Found index {child.expr}")
                    new_decl.index.append(child)
                elif child.__class__ == ast.AssocIndex:
                    print(f"  Found associative index")
                    new_decl.associndex.append(child)
            # Add the key
            for child in arr_decl.children:
                if child.__class__ == ast.Key:
                    print(f"  Found key {child.expr}")
                    new_assoc = ast.AssocDef()
                    new_assoc.key = child.expr
                    new_assoc.value = child.value
                    new_decl.assoc.append(new_assoc)
    return new_decl

# Support various key types (string, int, wildcard, etc.)
def find_key_types(arr_decls):
    # Find all the keys for each array declaration
    keys = []
    for arr_decl in arr_decls:
        for child in arr_decl.children:
            if child.__class__ == ast.Key:
                keys.append(child.expr)
    
    # Remove duplicates and sort
    unique_keys = list(set(keys))
    unique_keys.sort()
    return unique_keys

# Handle multiple associative dimensions
def add_assoc_dimensions(arr_decls, assoc_dims):
    # Find all the array declarations that have an associative dimension
    assoc_arr_decls = []
    for arr_decl in arr_decls:
        if len(arr_decl.assoc) > 0:
            assoc_arr_decls.append(arr_decl)

    # Iterate over each associative dimension and add it to each array declaration
    for i, assoc_dim in enumerate(assoc_dims):
        assoc_dim_name = f"assoc_{i}"
        assoc_dim_type = assoc_dim.type

        # Add the new associative dimension to the existing arrays
        for arr_decl in assoc_arr_decls:
            print(f"Adding {assoc_dim_name} ({assoc_dim_type}) to {arr_decl.name}")
            new_assoc_def = ast.AssocDef()
            new_assoc_def.key = f"{assoc_dim_name}_key"
            new_assoc_def.value = f"{assoc_dim_name}_value"

            # Find the index
            for child in arr_decl.children:
                if child.__class__ == ast.Index:
                    print(f"  Found index {child.expr}")
                    new_assoc_def.index.append(child)
                elif child.__class__ == ast.AssocIndex:
                    print(f"  Found associative index")
                    new_assoc_def.associndex.append(child)

            # Add the key
            for child in arr_decl.children:
                if child.__class__ == ast.Key:
                    print(f"  Found key {child.expr}")
                    new_assoc_def.key = f"{assoc_dim_name}_{child.expr}"
            arr_decl.assoc.append(new_assoc_def)
        return assoc_arr_decls

# Preserve base signal type and width
def preserve_signal_type(arr_decls):
    # Find all the signals that are not arrays
    non_array_signals = []
    for arr_decl in arr_decls:
        if len(arr_decl.children) == 0:
            non_array_signals.append(arr_decl.name)

    # Iterate over each array declaration and find its base signal type and width
    signal_types = {}
    for arr_decl in arr_decls:
        print(f"Finding base signal type and width for {arr_decl.name}")
        signal_type, signal_width = parse_signal_type_and_width(str(arr_decl.type))
        signal_types[arr_decl.name] = (signal_type, signal_width)

    # Iterate over each non-array signal and find its signal type and width
    for sig_name in non_array_signals:
        print(f"Finding signal type and width for {sig_name}")
        signal_type, signal_width = parse_signal_type_and_width(sig_name)
        if signal_type == 'signal':
            raise ValueError(f"{sig_name} is not an array")
        else:
            signal_types[sig_name] = (signal_type, signal_width)

    # Iterate over each associative dimension and find its key type
    for assoc_dim in assoc_dims:
        print(f"Finding key type for {assoc_dim.name}")
        key_type = parse_key_type(assoc_dim.type)
        if key_type == 'signal':
            raise ValueError(f"{assoc_dim.name} is not a key")
        else:
            signal_types[assoc_dim.name] = (key_type, signal_width)

    # Update the array declarations
    for arr_decl in arr_decls:
        print(f"Updating {arr_decl.name}")
        arr_decl.type = replace_signal_type(arr_decl.type, signal_types[arr_decl.name])
        arr_decl.children = add_assoc_index(arr_decl.children)
    
    return arr_decls

def parse_signal_type_and_width(signal_type):
    # Parse the signal type and width
    if signal_type.endswith(']'):
        signal_type = signal_type[:-1]
    else:
        raise ValueError(f"Invalid signal type {signal_type}")

    # Split the signal type by spaces
    signal_type_tokens = re.split(r'\s+', signal_type)

    # Get the last token which is the signal width
    signal_width = int(signal_type_tokens[-1])
    
    # Remove the signal width from the list of tokens
    del signal_type_tokens[-1]

    # Join the remaining tokens together to form the signal type
    signal_type = ' '.join(signal_type_tokens)

    return (signal_type, signal_width)
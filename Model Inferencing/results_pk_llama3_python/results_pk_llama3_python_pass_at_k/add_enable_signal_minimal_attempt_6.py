# Generated by Ollama Llama 3
# Task: add_enable_signal_minimal
# Attempt: 6
# Success: True
# Overall Score: 0.688

import pyverilog.asttools as asttools
import re


def add_enable_counter(xform, filename):
    """
    Add an enable signal to control a counter

    Requirements:

        - Find counter increment statements (counter <= counter + 1)
        - Add enable signal as new input port
        - Wrap counter increments with enable condition
        - Preserve existing sensitivity lists and reset logic


    The transformation should follow this pattern:
        1. Use PyVerilog to parse and analyze the AST
        2. Create a visitor class to identify target elements  
        3. Use regex to perform the actual text transformations
        4. Include proper error handling and validation
        5. Return True/False for success/failure

    Generate a complete Python module with:
        - Proper imports (pyverilog, re, argparse, etc.)
        - A visitor class that inherits the pattern from existing xforms
        - A main transformation function
        - A command-line interface
        - Comprehensive docstrings

    Make sure the code integrates properly with the existing xform framework patterns.
    """

    # Import necessary libraries
    import pyverilog.parser as parser
    import pyverilog.ast as ast
    from pyverilog.vparser.pycode import PyCodeParser
    import argparse
    import re

    # Initialize the parser and parse the design file
    verilog_code = ''
    with open(filename, 'r') as f:
        verilog_code = f.read()
    parser = PyCodeParser()
    tree = parser.parseFile(filename)

    # Create a visitor class to traverse the AST
    class AddEnableCounter(asttools.ASTVisitor):
        def __init__(self):
            self.count = 0

        def visit(self, node):
            if isinstance(node, ast.Assign):
                if 'counter' in str(node.lvalue) and '+' in str(node.value):
                    self.add_enable_condition(node)
            elif isinstance(node, ast.Statement):
                for child_node in node.body:
                    self.visit(child_node)
            else:
                pass

        def add_enable_condition(self, assign_node):
            # Add enable as new input port
            if 'counter' not in str(assign_node.lvalue) and \
               '+' not in str(assign_node.value):
                return

            # Wrap counter increments with enable condition
            if re.search('enable', str(assign_node)):
                return

            # Find sensitivity list
            sens_list = []
            for stmt in assign_node.parent.body:
                if isinstance(stmt, ast.IfStmt) and \
                   'else' not in str(stmt):
                    break
            else:
                if isinstance(stmt, ast.StmtBlock):
                    for child_stmt in stmt.body:
                        if isinstance(child_stmt, ast.SensitivityList):
                            sens_list.append(child_stmt)

            # Generate new enable condition
            enable_cond = '(' + 'enable' + ' && counter !== 0)'
            count_cond = '(counter <= counter + 1)'

            new_assign_node = [ast.Assign(
                lvalue=assign_node.lvalue,
                value=[ast.BinOp(op='&&', left=count_cond, right=enable_cond)],
                condition=enable_cond
            )]

            # Update sensitivity list
            for sens_stmt in sens_list:
                if isinstance(sens_stmt, ast.SensitivityList):
                    new_sens_list = [sens_stmt]
                    new_sens_list.append(new_assign_node)
                    assign_node.parent.body.insert(
                        0,
                        ast.StmtBlock(body=new_sens_list))

            # Add enable as input port
            if 'counter' in str(assign_node.lvalue) and \
               '+' not in str(assign_node.value):
                pass

    success = False
    try:
        visitor = AddEnableCounter()
        visitor.visit(tree)
        success = True
    except Exception as e:
        print('Error:', e)

    return success


def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input_file', help='Input Verilog file')
    args = vars(parser.parse_args())

    if not args['input_file']:
        print('Please provide an input Verilog file')
        return

    success = add_enable_counter(xform, args['input_file'])
    if success:
        print('Transformation successful!')
    else:
        print('Transformation failed!')


if __name__ == '__main__':
    main()
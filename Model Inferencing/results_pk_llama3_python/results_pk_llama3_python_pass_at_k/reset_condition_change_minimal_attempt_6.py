# Generated by Ollama Llama 3
# Task: reset_condition_change_minimal
# Attempt: 6
# Success: False
# Overall Score: 0.432

import pyverilog.asttools as asttools
import re


def reset_active_high_to_low(v, reset):
    """
    Change reset condition from active-high to active-low or vice versa.
    Find reset signal usage in if statements.
    Change if(rst) to if(!rst) or vice versa.
    Update sensitivity lists (posedge to negedge).
    Handle both synchronous and asynchronous reset patterns.

    :param v: pyverilog ast
    :param reset: string, name of the reset signal
    """
    # Find reset signal usage in if statements
    for node in v.if_stmt:
        if node.cond.text == 'rst':
            node.cond = not_node(node.cond)
            v.if_stmt[node].cond = not_node(node.cond)

    # Update sensitivity lists (posedge to negedge)
    for node in v.sensitivity_list:
        if node.positive_edge_rst:
            node.positive_edge_rst = False
            node.negative_edge_rst = True

    def not_node(node):
        """
        Create a NOT operator around the given expression.
        :param node: pyverilog AST
        :return: new node with negated value
        """
        return asttools.NotNode(
            *not_node(node.expr) if isinstance(node, asttools.IfNode)
            else (node.op, not_node(node.right))
        )

    # Handle both synchronous and asynchronous reset patterns
    for node in v.assign_stmt:
        if node.right.text == 'rst':
            node.right = not_node(node.right)

    return True


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('filename', help='Verilog file to be processed')
    args = parser.parse_args()

    with open(args.filename, 'r') as f:
        v = asttools.parse(f.read())

    reset_active_high_to_low(v, 'rst')

    print(asttools.dump(v))

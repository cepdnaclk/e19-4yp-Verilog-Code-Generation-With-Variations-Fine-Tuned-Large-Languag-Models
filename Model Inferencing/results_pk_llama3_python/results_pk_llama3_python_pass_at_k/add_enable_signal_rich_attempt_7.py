# Generated by Ollama Llama 3
# Task: add_enable_signal_rich
# Attempt: 7
# Success: True
# Overall Score: 0.612

"""Add an enable signal to control a counter"""
# Imports
import pyverilog.parser as parser
from pyverilog.ast import *

import re

# Parser and visitor imports
from xforms.transformers.base import TransformerBase

# Import argparse for command-line arguments
import argparse


class CounterEnableTransformer(TransformerBase):
    """Add an enable signal to control a counter"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Initialize self.params with the following parameters:
        # - signal_name: Name of the new enable signal
        self.params = {
            "signal_name": None,
        }
            
    @staticmethod
    def add_arguments(parser):
        """Add arguments to an argparse parser."""
        
        # Add arguments to the argument parser
        parser.add_argument("input_file", help="Input Verilog file")
        parser.add_argument(
            "-o", "--output-file",
            dest="output_file",
            help="Output Verilog file (default: same as input)"
        )
        parser.add_argument(
            "-n", "--signal-name",
            dest="signal_name",
            default=None,
            help="Name of the new enable signal"
        )
        
    @staticmethod
    def validate_arguments(args):
        """Validate arguments"""
        if not args.signal_name:
            raise ValueError("Signal name must be specified")
            
    @classmethod
    def from_args(cls, *args, **kwargs):
        """Create a transformer object from command-line arguments."""
        parser = argparse.ArgumentParser()
        cls.add_arguments(parser)
        
        # Parse the arguments
        args = parser.parse_args(*args, **kwargs)
        
        # Validate arguments
        cls.validate_arguments(args)
        
        return cls(
            input_file=args.input_file,
            output_file=args.output_file,
            signal_name=args.signal_name
        )
    
    def visit(self, node):
        """Visit nodes in the AST"""
        if isinstance(node, Node):
            # Check for target declarations
            if isinstance(node, Decl):
                for item in node.list:
                    if hasattr(item, "name") and item.name == self.params["signal_name"]:
                        self.signal_found = True
                        self.changes_made.append(f"Found {self.params['signal_name']}")
            
            # Visit children
            for c in node.children():
                self.visit(c)
        
    def transform(self):
        """Transform the Verilog file"""
        # Parse AST
        ast, directives = parse([self.input_file])
        
        # Apply visitor
        self.apply_visitor(ast)
        
        # Perform regex transformations
        with open(self.input_file, "r") as f:
            content = f.read()
            
        # Add new signal to the ports declaration
        port_list = re.findall(r"port\s*\(\s*(\w+\s+)?(input|output)\s*\(.*?\);\s*", content)
        if not self.signal_found:
            raise ValueError("Signal name not found")
        port_list[0] += f"\n\t{self.params['signal_name']} {self.params['signal_name']}"
        
        # Add new signal to the sensitivity list
        sens_list = re.findall(r"always\s*\@(\(.*?\));", content)
        if self.signal_found:
            sens_list[0] += ", " + self.params["signal_name"]
            
        # Write output
        with open(self.output_file, "w") as f:
            f.write(re.sub(r"(port\s*\(\s*(\w+\s+)?(input|output)\s*\(.*?\);\s*)", port_list[0], content))
            f.write("\n")
            f.write(re.sub(r"always\s*\@(\(.*?\));", sens_list[0], content))
        
        return True
# Generated by Ollama Llama 3
# Task: inside_op_context_scenarios_minimal
# Attempt: 6
# Success: False
# Overall Score: 0.318

import sys
sys.path.append('../')
from xform import *
from pyverilog.ast.utils.visitor import *

class InsideXForm(XForm):
    name = 'inside_transform'
    
    def __init__(self, *args, **kwargs):        
        super().__init__(*args, **kwargs)
    
    @staticmethod
    def get_parser():
        parser = argparse.ArgumentParser(
            description='Generate inside operator usages in different contexts')
        return parser

    def transform(self):
        # Create visitor class to identify target elements  
        class IfVisitor(VisitingNode): 
            def __init__(self, *args, **kwargs):        
                super().__init__(*args, **kwargs)
                
            def visit_AssignmentStatement(self, node):   
                if "inside" in str(node):
                    self.context['found'] = True
                else:
                    self.context['found'] = False
    
        class CaseVisitor(VisitingNode): 
            def __init__(self, *args, **kwargs):        
                super().__init__(*args, **kwargs)
                
            def visit_CaseStatement(self, node):   
                if "inside" in str(node):
                    self.context['found'] = True
                else:
                    self.context['found'] = False
        
        class LoopVisitor(VisitingNode): 
            def __init__(self, *args, **kwargs):        
                super().__init__(*args, **kwargs)
                
            def visit_ContinuousAssign(self, node):   
                if "inside" in str(node):
                    self.context['found'] = True
                else:
                    self.context['found'] = False
    
        class ProceduralVisitor(VisitingNode): 
            def __init__(self, *args, **kwargs):        
                super().__init__(*args, **kwargs)
                
            def visit_AlwaysComb(self, node):   
                if "inside" in str(node):
                    self.context['found'] = True
                else:
                    self.context['found'] = False

        class InitialFinalVisitor(VisitingNode): 
            def __init__(self, *args, **kwargs):        
                super().__init__(*args, **kwargs)
                
            def visit_Initial(self, node):   
                if "inside" in str(node):
                    self.context['found'] = True
                else:
                    self.context['found'] = False

        # Use regex to perform the actual text transformations
        context = {}
        
        ast = AST.from_files(self.args.ast)
        visitors = [IfVisitor, CaseVisitor, LoopVisitor, ProceduralVisitor, InitialFinalVisitor]
        
        for visitor in visitors:
            if visitor.__name__ == 'IfVisitor':
                if self.context['found']:
                    inside_usage = re.sub(r'(\s*)(if\s*\()', r'\1if (inside\2', str(ast))
                    return inside_usage
                else:
                    pass
            elif visitor.__name__ == 'CaseVisitor':
                if self.context['found']:
                    case_inside = re.sub(r'(\s*)(case\s*\()", r'\1case (inside\2', str(ast))
                    return case_inside
                else:
                    pass
            elif visitor.__name__ == 'LoopVisitor':
                if self.context['found']:
                    loop_inside = re.sub(r'(\s*)(continuous\s*assign\s*\()', r'\1continuous assign (inside\3', str(ast))
                    return loop_inside
                else:
                    pass
            elif visitor.__name__ == 'ProceduralVisitor':
                if self.context['found']:
                    comb_inside = re.sub(r'(\s*)(always\s*(comb)\()', r'\1always_comb (inside\3', str(ast))
                    return comb_inside
                else:
                    pass
            elif visitor.__name__ == 'InitialFinalVisitor':
                if self.context['found']:
                    initial_inside = re.sub(r'(\s*)(initial\s*\()', r'\1initial (inside\2', str(ast))
                    final_inside = re.sub(r'(\s*)(final\s*\()', r'\1final (inside\2', str(ast))
                    return initial_inside + "\n" + final_inside
                else:
                    pass
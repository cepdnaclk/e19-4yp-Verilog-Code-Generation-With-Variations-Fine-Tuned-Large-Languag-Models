# Generated by Ollama Llama 3
# Task: inside_op_coverage_minimal
# Attempt: 10
# Success: False
# Overall Score: 0.555

import pyverilog.ast.tools as tools
from pyverilog.ast import *
from xform import XForm
from argparse import ArgumentParser, Namespace
import re


class InsideCoverageGenerator(XForm):

    def __init__(self):
        super().__init__()
        self.name = "Inside Coverage Generator"

    def run(self, args:Namespace) -> bool:
        if not isinstance(args.ast, ASTNode):
            raise ValueError("AST is invalid")
        
        # create a visitor class
        class InsideCoverageGeneratorVisitor(ASTVisitor):
            def __init__(self):
                super().__init__()

            def visit_stmt(self, node):
                for expr in node.exprs:
                    self.visit_expr(expr)

            def visit_concatexpr(self, node):
                if isinstance(node.left, ASTExpr) and \
                        isinstance(node.right, ASTExpr) and \
                        node.operator == "=":
                    left = node.left
                    right = node.right

                    # generate random value arrays for testing 
                    rand_left_vals = self.generate_random_values(left)
                    rand_right_vals = self.generate_random_values(right)

                    # add coverage points for different scenarios
                    if len(rand_left_vals) > 0 and \
                            len(rand_right_vals) > 0:
                        for i in range(len(rand_left_vals)):
                            for j in range(i+1, len(rand_right_vals)):
                                new_expr = And([Equal(left, rand_left_vals[i]),
                                                Equal(right, rand_right_vals[j])])
                                node.exprs.append(new_expr)

                    # include edge cases like empty arrays and boundary values
                    if isinstance(node.left, ASTConcat) or \
                            isinstance(node.right, ASTConcat):
                        pass

                elif isinstance(node.operator, str) and \
                        node.operator == "inside":
                    rand_vals = self.generate_random_values(node.exprs[0])

                    # add coverage points for different scenarios
                    if len(rand_vals) > 0:
                        for i in range(len(rand_vals)):
                            new_expr = Equal(node.exprs[0], rand_vals[i])
                            node.exprs.append(new_expr)

                else:
                    pass

            def generate_random_values(self, ast_node):
                vals = []
                try:
                    if isinstance(ast_node, ASTIntLit) or \
                            isinstance(ast_node, ASTFloatLit):
                        val = str(int(tools.get_value(ast_node)))
                        return [val]

                    elif isinstance(ast_node, ASTStrLit) or \
                            isinstance(ast_node, ASTCharLit):
                        val = "'{}'".format(str(ast_node.value))
                        vals.append(val)

                    elif isinstance(ast_node, ASTIdentifier):
                        val = str(ast_node.name)
                        vals.append(val)

                    else:
                        pass

                except ValueError as e:
                    print(e)
                    return []

                finally:
                    return vals

        # parse the AST
        ast_visitor = InsideCoverageGeneratorVisitor()
        success = False
        try:
            ast_visitor.visit(args.ast)
            success = True
        except Exception as e:
            print("Error:", str(e))
        
        return success


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("ast", type=str, help="the Verilog AST")
    args = parser.parse_args()

    inside_coverage_generator = InsideCoverageGenerator()
    result = inside_coverage_generator.run(args)
    print(result)
# Generated by Ollama Llama 3
# Task: multi_signal_width_minimal
# Attempt: 6
# Success: False
# Overall Score: 0.432

import sys
sys.path.append('../')
from veriloggen import *

import pyverilog.ast as ast
import re

from xform.core.visitor import *
from xform.lib.util import get_name, get_parent_node
from xform.lib.error import Error

def transform(ast, args):
    # Parse arguments
    signal_list = args['signal_list']
    width_list = args['width_list']

    if len(signal_list) != len(width_list):
        raise ValueError('Number of signals must match the number of new widths.')

    return transform_ast(ast, signal_list, width_list)

def transform_ast(ast, signal_list, width_list):

    class BitWidthFinder(Visitor):
        def __init__(self):
            self.nodes = []
        
        def visit_Assign(self, node): 
            # Packed arrays
            if isinstance(node.node, ast.ArrayDecl) and isinstance(node.node.data, ast.BitVectorLit):
                return
            
            # Unpacked arrays
            elif isinstance(node.node, ast.ArrayDecl) and isinstance(node.node.data, ast.Data):  
                for i in range(len(node.node.data)):
                    self.nodes.append(get_parent_node(node.node.data[i]))
                
        def visit_Signal(self, node): 
            if get_name(node) in signal_list:
                self.nodes.append(node)
        
    visitor = BitWidthFinder()
    visitor.visit(ast)

    # Find all declarations
    decl_nodes = []
    for n in visitor.nodes:
        parent = get_parent_node(n)
        if isinstance(parent, ast.Decl):
            decl_nodes.append(n)

    def update_width(name, new_width):    
        node_to_update = None

        for n in decl_nodes:
            # Packed arrays
            if isinstance(n.node, ast.ArrayDecl) and isinstance(n.node.data, ast.BitVectorLit):
                assert get_name(n).strip() == name.strip()
                node_to_update = n
            
            elif isinstance(n.node, ast.Data):  
                for i in range(len(n.node)):
                    # Unpacked arrays
                    if get_parent_node(n.node[i]).name == name: 
                        node_to_update = n
                    
        assert node_to_update is not None, 'Cannot find %s declaration' % name

        new_data = ast.BitVectorLit(width=new_width)
        new_data.parent = n.node
        n.node.data = new_data
    
    for i in range(len(signal_list)):
        update_width(get_name(decl_nodes[i]), width_list[i])

    return True
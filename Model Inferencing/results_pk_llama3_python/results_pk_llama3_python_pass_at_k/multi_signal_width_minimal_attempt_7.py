# Generated by Ollama Llama 3
# Task: multi_signal_width_minimal
# Attempt: 7
# Success: True
# Overall Score: 0.648

"""
This is a xform module for the xform framework in Python. It takes as input a 
list of signal names and new width, finds each signal's declaration, updates 
the bit width specification, handles packed and unpacked arrays, validates that
new width is syntactically correct.

It follows this pattern:
1. Use PyVerilog to parse and analyze the AST
2. Create a visitor class to identify target elements  
3. Use regex to perform the actual text transformations
4. Include proper error handling and validation
5. Return True/False for success/failure

It includes proper imports (pyverilog, re, argparse, etc.), a visitor class that 
inherits the pattern from existing xforms, a main transformation function, a 
command-line interface, comprehensive docstrings.

It makes sure the code integrates properly with the existing xform framework patterns.
"""
# Import required libraries
import pyverilog.ast as ast
from pyverilog.ast_tools import *
from pyverilog.parser import parse

# Import argparse to manage command line arguments
import argparse

# Import regex library for pattern matching and text transformations
import re


class ChangeWidth(ast.NodeVisitor):
    def __init__(self, signal_names_list, new_width):
        self.signal_names_list = signal_names_list
        self.new_width = new_width
    
    def visit_Decl(self, node): 
        # Get the name of the signal being declared
        signal_name = node.name 
        
        # Check if the signal is in the list of target signals
        if signal_name in self.signal_names_list:
            # Find the width of the signal
            old_width = node.width

            # Validate that new width is syntactically correct
            try:
                int(self.new_width)
            except ValueError:
                return False
            
            # Update the bit width specification 
            # for packed and unpacked arrays
            if isinstance(old_width, ast.ArrayDecl):
                if len(old_width.dimensions) == 2: 
                    node.width = ast.ArrayDecl(ast.IntegerConst(self.new_width), old_width.dimensions[0])
                else:
                    return False
            elif isinstance(old_width, ast.StructDecl):
                for field in old_width.fields:
                    try:
                        int(field.width)
                    except ValueError:
                        return False
                    if field.width != self.new_width:
                        field.width = self.new_width

            # Return True on success
            return True
    
        else:
            return super().visit_Decl(node)

    def visit_StructDecl(self, node):
        for field in node.fields:
            try:
                int(field.width)
            except ValueError:
                return False
            if field.width != self.new_width:
                field.width = self.new_width

        # Return True on success 
        return True
    
    def visit_ArrayDecl(self, node): 
        # Find the width of the signal
        old_width = node.width
        
        # Validate that new width is syntactically correct
        try:    
            int(self.new_width)
        except ValueError:
            return False

        # Update the bit width specification for packed arrays
        if isinstance(old_width, ast.ArrayDecl):
            if len(old_width.dimensions) == 2: 
                node.width = ast.ArrayDecl(ast.IntegerConst(self.new_width), old_width.dimensions[0])
            else:
                return False

        # Return True on success
        return True
    
    def visit_PortList(self, node):  
        for port in node.port_list:
            signal_name = port.name
            if signal_name in self.signal_names_list:
                # Find the width of the signal
                old_width = port.width 

                # Validate that new width is syntactically correct
                try:    
                    int(self.new_width)
                except ValueError:
                    return False

                # Update the bit width specification 
                # for packed and unpacked arrays
                if isinstance(old_width, ast.ArrayDecl):
                    if len(old_width.dimensions) == 2: 
                        port.width = ast.ArrayDecl(ast.IntegerConst(self.new_width), old_width.dimensions[0])
                    else:
                        return False
                elif isinstance(old_width, ast.StructDecl):
                    for field in old_width.fields:
                        try:
                            int(field.width)
                        except ValueError:
                            return False
                        if field.width != self.new_width:
                            field.width = self.new_width

                # Return True on success
                return True
        
        # Return False on failure
        return False



def main(args): 
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Change the bit width of multiple signals at once')
    parser.add_argument('-i', '--input_file', help='Input Verilog file', required=True)
    parser.add_argument('-o', '--output_file', help='Output transformed Verilog file', required=False, default=None)
    parser.add_argument('-s', '--signal_names_list', nargs='+', type=str, help='List of signal names to modify')
    parser.add_argument('-w', '--new_width', type=int, help='New width for the signals')

    args = parser.parse_args()

    # Parse Verilog file
    verilog_file = open(args.input_file)
    ast_tree = parse(verilog_file.read())
    
    # Create a visitor class to identify target elements  
    ChangeWidthVisitor = ChangeWidth(args.signal_names_list, args.new_width)

    # Use regex to perform the actual text transformations
    if not ChangeWidthVisitor.visit(ast_tree):
        print("Error: Unable to modify bit widths")
    else:
        transformed_ast_tree = ChangeWidthVisitor.transform(ast_tree)

    # Include proper error handling and validation 
    if args.output_file is None:
        output_file = open(args.input_file + ".modified", "w+")
    else:
        output_file = open(args.output_file, "w+")

    output_file.write(transformed_ast_tree.toVerilog())

# Run the main function
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))


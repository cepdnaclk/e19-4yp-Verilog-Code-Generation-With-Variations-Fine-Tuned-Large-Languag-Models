# Generated by Ollama Llama 3
# Task: fsm_state_rename_minimal
# Attempt: 7
# Success: False
# Overall Score: 0.455

"""
This is a Systematically rename FSM state names throughout a module xform for the xform framework.
It takes two parameters, old_prefix and new_prefix. It renames all states that match the prefix pattern,
updates all references in case statements, updates assignments and comparisons.

Usage: 
$ python -m xform fsm_rename.py --old-prefix oldprefix --new-prefix newprefix path/to/module.v

Example:
$ python -m xform fsm_rename.py --old-prefix state1 --new-prefix state2 module.v
"""

from argparse import ArgumentParser
import re
import pyverilog.ast as ast
from pyverilog.parser import parse
from pyverilog.ast.utils import find_all, find_one
from collections import defaultdict

def main(args):
    """
    Main function to rename FSM states.
    
    Args:
        args: Command-line arguments.

    Returns:
        True for success and False for failure
    """

    if not args.module_path or not args.old_prefix or not args.new_prefix:
        return False, "Error: Please provide module path, old prefix and new prefix."

    # Parse the module
    tree = parse(args.module_path)
    
    # Find all FSM state declarations
    state_decls = find_all(lambda node: isinstance(node, ast.Declaration) 
                            and isinstance(node.decl, ast.EnumDeclaration),
                            tree)

    # Create a mapping of old names to new names
    name_map = {name: args.new_prefix + name[len(args.old_prefix):]
                for decl in state_decls
                for name in [decl.decl.name[0], decl.decl.values[0].name]}

    # Find all references to FSM states
    ref_nodes = find_all(lambda node: isinstance(node, ast.Assignment) 
                        or (isinstance(node, ast.Declaration)
                            and isinstance(node.decl, ast.EnumDeclaration)),
                         tree)

    # Rename the FSM state names in assignments and declarations
    for node in ref_nodes:
        if isinstance(node, ast.Assignment):
            old_name = node.lhs.name[0]
            new_name = name_map.get(old_name)
            if new_name:
                node.lhs.name[0] = new_name
        elif isinstance(node, ast.Declaration) and isinstance(node.decl, ast.EnumDeclaration):
            old_names = [node.decl.name[0]]
            new_names = [name_map.get(name) for name in old_names]
            node.decl.name[0] = new_names[0]

    # Find all case statements
    case_nodes = find_all(lambda node: isinstance(node, ast.CaseStatement),
                           tree)

    # Rename the FSM state names in case statements
    for node in case_nodes:
        if not node.cases:
            continue

        old_case_names = [case.name[0] for case in node.cases]
        new_case_names = [name_map.get(name) for name in old_case_names]

        node.cases = list(zip(node.cases, new_case_names))

    # Find all comparisons
    comp_nodes = find_all(lambda node: isinstance(node, ast.Comparison),
                           tree)

    # Rename the FSM state names in comparisons
    for node in comp_nodes:
        old_op_name = node.left.name[0]
        new_op_name = name_map.get(old_op_name)
        if new_op_name:
            node.left.name[0] = new_op_name

    # Write the transformed module back to file
    with open(args.module_path, 'w') as f:
        ast.write(f, tree)

    return True

if __name__ == '__main__':
    parser = ArgumentParser(description=__doc__)
    parser.add_argument('module_path', type=str,
                        help='Path to the Verilog module')
    parser.add_argument('--old-prefix', type=str,
                        help='Old prefix for FSM state names')
    parser.add_argument('--new-prefix', type=str, 
                        help='New prefix for FSM state names')

    args = parser.parse_args()

    success, msg = main(args)

    if not success:
        print(msg)

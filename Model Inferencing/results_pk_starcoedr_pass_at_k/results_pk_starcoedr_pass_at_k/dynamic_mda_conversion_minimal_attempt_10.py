# Generated by Ollama Llama 3
# Task: dynamic_mda_conversion_minimal
# Attempt: 10
# Success: False
# Overall Score: 0.362



"""

# Imports
import pyverilog.vparser.ast as ast
from . import transformer


class ArrayVisitor(transformer.ArrayVisitor):
    """
    Converts a fixed array declaration to dynamic multi-dimensional array syntax

    Example:

    [32, 10] integer fixed_array[2];
    -->
    integer fixed_array[2][32][10];

    """

    def __init__(self):
        self.fixed = []
        self._width = None

    # Array declaration
    def visit_ArrayDeclaration(self, node):

        if isinstance(node["declaration"], ast.ArrayDeclaration):
            array = self.visit_ArrayDeclaration(
                node["declaration"])  # Recursive call
            self.fixed.append(array)

            if len(array[0]) > 1 and (len(array)-1) == len(self._width):

                for i in range(len(array)):
                    array[i] = [j*self._width[-(i+1)]
                                for j in array[i]]

                    # print(f'Array {node["name"]}: {array}')
                return array
            else:
                # print('Array is of fixed size, not dynamic')

                return node
        elif isinstance(node["declaration"], ast.Fixed):

            # print(f'Found fixed array {node["name"]}')
            self._width = [x for x in range(10)] * \
                len([x for x in node["declaration"]["fixed_value"]])

        else:
            return node

    def visit_Identifier(self, node):
        for i in range(len(self.fixed)):
            # print(f'Searching fixed array {node["name"]}')

            if self._width == None and isinstance(
                    self.fixed[i]["declaration"], ast.ArrayDeclaration) and \
                    self.fixed[i]['declaration']['name'] == node['name']:
                return self.fixed[i]
            else:

                if len(self.fixed[i]) > 1 and (len(self.fixed)-1) < len(self._width):

                    for j in range(len(node)):
                        node[j] = [x*self._width[-(j+1)]
                                   for x in node[j]]
                    return node

                else:
                    # print('Array is of fixed size, not dynamic')

                    return node
        raise ValueError(f'Unrecognized array name {node["name"]}')


class ArrayConverter(transformer.Transformer):
    """
    Transforms fixed arrays to dynamic multi-dimensional arrays

    Returns True on success and False otherwise
    """

    def __init__(self):

        self._array = ArrayVisitor()  # Shared visitor instance
        super().__init__()

    @classmethod
    def get_pattern(cls):

        return r"fixed_array\b"

    def visit_SourceBlock(self, node):

        self.generic_visit(node)  # Visit all statements in source block
        return True


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--file")
    args = parser.parse_args()

    arrayConverter = ArrayConverter()
    arrayConverter.load_file(args.file)
    arrayConverter.run()
    arrayConverter.save(args.file[:-1]+"_out" +
                       ".v")  # Change file extension to .txt


if __name__ == "__main__":
    main()

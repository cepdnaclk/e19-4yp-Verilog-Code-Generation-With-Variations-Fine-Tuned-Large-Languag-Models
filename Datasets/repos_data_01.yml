- code: |
    // Create a module with one input and one output that behaves like a wire

    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
  prompt: Create a Verilog module named `wire_assign` with one input and one output that directly connects the input to the output like a wire.

- code: |
    // This is a module that assigns the output to the input
    module wire_assign( input in, output out );
  prompt: Write a Verilog module with one input and one output, and describe it as a module that assigns the output to the input.

- code: |
    // This is a module that assigns the output to the input
    module wire_assign( input in, output out );
    // assign the output to the input
  prompt: Declare a Verilog module with an input and an output and comment that the output is assigned to the input.

- code: |
    // This is a module that assigns the output to the input
    module wire_assign( input in, output out );
    // assign the output out to the input in
  prompt: Create a Verilog module header with an input and an output, and comment that the output is being connected to the input.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_wire_assign;

        reg in;
        wire out;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        wire_assign UUT (.in(in), .out(out) );

        initial // initial block executes only once
            begin
                // values for inputs
                in = 0;
                #period; // wait for period 
                if (out!==0) begin
                    $display("test 1 failed");
                    $finish;
                end
                else $display("in = %b , out = %b", in, out);

                in = 1;
                #period; // wait for period 
                if (out!==1) begin
                    $display("test 2 failed");
                    $finish;
                end
                else $display("in = %b , out = %b", in, out);

                in = 0;
                #period; // wait for period 
                if (out!==0) begin
                    $display("test 3 failed");
                    $finish;
                end
                else $display("in = %b , out = %b", in, out);

                $display("all tests passed");
                $finish;
            end
    endmodule
  prompt: Write a Verilog testbench `tb_wire_assign` to test a module that connects an input to an output like a wire, verifying correct behavior for a few input values.
- code: |
    // Create a module that implements an AND gate

    module and_gate( 
        input a, 
        input b, 
        output out );

        assign out = a && b;
        
    endmodule
  prompt: Create a Verilog module named `and_gate` that implements a 2-input AND gate using continuous assignment.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_and_gate;

        reg a,b;
        wire out;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        and_gate UUT (.a(a), .b(b), .out(out) );
        
        initial // initial block executes only once
            begin
                // values for inputs
                a = 0; b= 0;
                #period; // wait for period 
                if (out!==0) begin
                    $display("test 1 failed");
                    $finish;
                end
                else $display("a = %b , b = %b, out = %b", a,b, out);

                a = 0; b= 1;
                #period; // wait for period 
                if (out!==0) begin
                    $display("test 2 failed");
                    $finish;
                end
                else $display("a = %b , b = %b, out = %b", a,b, out);

                a = 1; b= 0;
                #period; // wait for period 
                if (out!==0) begin
                    $display("test 3 failed");
                    $finish;
                end
                else $display("a = %b , b = %b, out = %b", a,b, out);

                a = 1; b= 1;
                #period; // wait for period 
                if (out!==1) begin
                    $display("test 4 failed");
                    $finish;
                end
                else $display("a = %b , b = %b, out = %b", a,b, out);

                $display("all tests passed");
                $finish;

            end
    endmodule
  prompt: Write a Verilog testbench `tb_and_gate` to test a 2-input AND gate for all input combinations and validate the output.

- code: |
    // Design a 3-bit priority encoder. If none of the input bits are high (i.e., input is zero), output zero.

    module priority_encoder( 
        input [2:0] in,
        output reg [1:0] pos  );
        
        always @(*) begin
            if (in[0]==1'b1)
                pos = 0;
            else if (in[1]==1'b1)
                pos = 1;
            else if (in[2]==1'b1)
                pos = 2;
            else
                pos = 0;
        end

    endmodule
  prompt: Create a Verilog module named `priority_encoder` that implements a 3-bit priority encoder where the lowest index bit has the highest priority. Output zero when all inputs are zero.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_priority_encoder;

        reg[2:0] in;
        wire[1:0] pos;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        priority_encoder UUT (.in(in), .pos(pos) );
        
        initial // initial block executes only once
            begin
                // values for inputs
                in = 0;
                #period; // wait for period 
                if (pos!==1'd0) begin
                    $display("test 1 failed");
                    $finish;
                end
                else $display("in = %d , pos = %d ", in, pos);

                in = 1;
                #period; // wait for period 
                if (pos!==0) begin
                    $display("test 2 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 2;
                #period; // wait for period 
                if (pos!==1) begin
                    $display("test 3 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 3;
                #period; // wait for period 
                if (pos!==0) begin
                    $display("test 4 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 4;
                #period; // wait for period 
                if (pos!==2) begin
                    $display("test 5 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 5;
                #period; // wait for period 
                if (pos!==0) begin
                    $display("test 6 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 6;
                #period; // wait for period 
                if (pos!==1) begin
                    $display("test 7 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                in = 7;
                #period; // wait for period 
                if (pos!==0) begin
                    $display("test 8 failed");
                    $finish;
                end
                else $display("in = %b , pos = %b ", in, pos);

                $display("all tests passed");
                $finish;

            end

    endmodule
  prompt: Write a Verilog testbench `tb_priority_encoder` to validate a 3-bit priority encoder for all input combinations and check if the output matches the highest-priority set bit.
- code: |
    // Create a module that implements a multiplexer

    module mux( 
        input [4:0] a, b,
        input sel,
        output [4:0] out );

        assign out = sel?b:a;

    endmodule
  prompt: Create a Verilog module named `mux` that implements a 5-bit multiplexer. The module should have two 5-bit inputs `a` and `b`, a select signal `sel`, and a 5-bit output `out`. When `sel=0`, assign `a` to `out`; when `sel=1`, assign `b` to `out`.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    // When sel=0, assign a to out. 
    // When sel=1, assign b to out. 

    module tb_mux;

        reg [4:0] a,b;
        reg sel;
        wire [4:0] out;

        integer increment_a = 0;
        
        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        mux UUT (.a(a), .b(b), .sel(sel), .out(out) );
        
        initial // initial block executes only once
            begin

                // values for inputs
                a = 0; b= 0;
                while (b<4'b1111) begin

                    sel=0;
                    #period; // wait for period 
                    if (out!==a) begin
                        $display("test failed");
                        $finish;
                    end
                    else $display("a = %b , b = %b, sel=%b, out = %b", a,b,sel,out);

                    sel=1;
                    #period; // wait for period 
                    if (out!==b) begin
                        $display("test failed");
                        $finish;
                    end
                    else $display("a = %b , b = %b, sel=%b, out = %b", a,b,sel,out);

                    if (increment_a) a = a+1;
                    else b = b+1;

                    if(increment_a) increment_a = 0;
                    else increment_a=1;
                end
            
                $display("all tests passed");
                $finish;

            end

    endmodule
  prompt: Write a Verilog testbench `tb_mux` to validate the functionality of the 5-bit multiplexer by checking the output for all combinations of `a`, `b`, and `sel`.
- code: |
    // Design a half adder. A half adder adds two bits and produces a sum and carry-out
    module half_adder( 
        input a, b,
        output cout, sum );
        
        assign sum  = a^b;
        assign cout = a&b;

    endmodule
  prompt: Design a Verilog module named `half_adder` that implements a half adder. The module should add two bits and produce a sum and carry-out.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_half_adder;

        reg a,b;
        wire cout,sum;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        half_adder UUT ( .a(a), .b(b), .cout(cout), .sum(sum) );
        
        initial // initial block executes only once
            begin
                // values for inputs
                a = 0; b=0;
                #period; // wait for period 
                if (cout!==0 && sum!==0) begin
                    $display("test 1 failed");
                    $finish;
                end
                else $display("a=%b, b=%b, cout=%b, sum=%b ", a,b,cout,sum);

                a = 0; b=1;
                #period; // wait for period 
                if (cout!==0 && sum!==1) begin
                    $display("test 2 failed");
                    $finish;
                end
                else $display("a=%b, b=%b, cout=%b, sum=%b ", a,b,cout,sum);

                a = 1; b=0;
                #period; // wait for period 
                if (cout!==0 && sum!==1) begin
                    $display("test 3 failed");
                    $finish;
                end
                else $display("a=%b, b=%b, cout=%b, sum=%b ", a,b,cout,sum);

                a = 1; b=1;
                #period; // wait for period 
                if (cout!==1 && sum!==0) begin
                    $display("test 4 failed");
                    $finish;
                end
                else $display("a=%b, b=%b, cout=%b, sum=%b ", a,b,cout,sum);

                $display("all tests passed");
                $finish;

            end


    endmodule
  prompt: Write a Verilog testbench `tb_half_adder` to validate the functionality of the half adder by checking the output for all combinations of `a` and `b`.
- code: |
    // Design a counter that counts from 1 to 12
    module counter( 
        input clk,
        input reset,
        output [3:0] q
    ); 

        reg q;

        always @ (posedge clk) begin
            if (reset) q <= 4'd1;
            else if (q == 4'd12) q<= 4'd1;
            else q <= q+4'd1;
        end

    endmodule
  prompt: Design a Verilog module `counter` that counts from 1 to 12. It should have an input `clk` (clock) and `reset` (reset signal), and a 4-bit output `q` that represents the count value.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_counter;

        reg clk, reset;
        wire [3:0] q;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        counter UUT (.clk(clk), .reset(reset), .q(q) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1;
            #period;
            if(q!==1) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, q=%b",clk,reset, q);

            // check value does not change during reset
            #period;
            if(q!==1) begin
                $display("test 1a failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, q=%b",clk,reset, q);

            // start counter
            reset = 0;
            #period;
            if(q!==2) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==3) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==4) begin
                $display("test 4 failed");
                //$finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==6) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==7) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==8) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==9) begin
                $display("test 9 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==10) begin
                $display("test 10 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==11) begin
                $display("test 11 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==12) begin
                $display("test 12 failed");
                $finish;
            end
            else $display("q=%b",q);

            // counter should go back to 1
            #period;
            if(q!==1) begin
                $display("test 13 failed");
                $finish;
            end
            else $display("q=%b",q);
            

            // check reset after a few cycles
            #period;
            if(q!==2) begin
                $display("test 14 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==3) begin
                $display("test 15 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==4) begin
                $display("test 16 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5) begin
                $display("test 17 failed");
                $finish;
            end
            else $display("q=%b",q);

            reset = 1;
            #period;
            if(q!==1) begin
                $display("test 18 failed");
                $finish;
            end
            else $display("q=%b",q);


            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: Write a Verilog testbench `tb_counter` to test the `counter` module. The testbench should simulate the counter's behavior through multiple cycles, checking both reset functionality and the expected count values from 1 to 12, with appropriate display messages for each test.
- code: |
    // Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 , 3 and 1
    module lfsr( 
        input clk,
        input reset,
        output [4:0] q
    ); 

    reg [4:0] r_reg;
    wire [4:0] r_next;
    wire feedback_value;

    always @(posedge clk, posedge reset)
    begin 
        if (reset)
            begin
            // set initial value to 1
            r_reg <= 1; 
            end     
        else if (clk == 1'b1)
            r_reg <= r_next;
    end

    assign feedback_value =r_reg[4] ^ r_reg[2] ^ r_reg[0];
    assign r_next = {feedback_value, r_reg[4:1]};
    assign q = r_reg;

    endmodule
  prompt: Design a 5-bit maximal-length Galois Linear Feedback Shift Register (LFSR) with taps at bit positions 5, 3, and 1. The LFSR should have inputs for `clk` (clock) and `reset`, and output a 5-bit value `q`.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_lfsr;

        reg clk, reset;
        wire [4:0] q;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        lfsr UUT (.clk(clk), .reset(reset), .q(q) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1;
            #period;
            if(q!==1) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, q=%b",clk,reset, q);

            // check value does not change during reset
            #period;
            if(q!==1) begin
                $display("test 1a failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, q=%b",clk,reset, q);

            // start counter
            reset = 0;
            #period;
            if(q!==5'b10000) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b11000) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b11100) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b01110) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b10111) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b11011) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b01101) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b00110) begin
                $display("test 9 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b10011) begin
                $display("test 10 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b01001) begin
                $display("test 11 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b10100) begin
                $display("test 12 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b01010) begin
                $display("test 13 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b00101) begin
                $display("test 14 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b00010) begin
                $display("test 15 failed");
                $finish;
            end
            else $display("q=%b",q);

            #period;
            if(q!==5'b00001) begin
                $display("test 16 failed");
                $finish;
            end
            else $display("q=%b",q);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: Write a Verilog testbench `tb_lfsr` to test the `lfsr` module. The testbench should simulate the LFSR's behavior through multiple cycles, checking both reset functionality and the expected sequence of output values, with appropriate display messages for each test.
- code: |
    // This is a Moore state machine with two states 0 and 1, one input in, and one output out. 
    // Reset state is 0. Output is high in state 0. If in is low, state changes.
    module simple_fsm(input clk, input reset, input in, output out);
    reg present_state, next_state;
    // In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
    // In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
    // out=1 in state 0 and out=0 in state 1

        always @(posedge clk) begin
            if (reset) begin  
                present_state <= 0;
            end 
            else begin
                // State flip-flops
                present_state <= next_state;  
            end

        end

        always @(present_state,in) begin
            case (present_state)
            // next state logic
            0: begin
                if(in) next_state <= 0;
                else next_state <= 1;
            end
            1: begin
                if(in) next_state <= 1;
                else next_state <= 0;
            end
            endcase 

        end

        // output logic
        assign out = present_state?0:1;

    endmodule
  prompt: This is a Moore state machine with two states 0 and 1, one input `in`, and one output `out`. The reset state is 0. The output is high in state 0, and if `in` is low, the state changes. Implement the state transitions and output logic based on the given conditions.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_simple_fsm;

        reg clk, reset, in;
        wire out;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        simple_fsm UUT (.clk(clk), .reset(reset), .in(in), .out(out) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1; in = 0;
            #period;
            // goes to state 0
            if(out!==1) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            // start fsm
            reset = 0; 
            in = 0;
            #period;
            // goes to state 1
            if(out!==0) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            in = 0;
            #period;
            // goes to state 0
            if(out!==1) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            in = 1;
            #period;
            // stays in state 0
            if(out!==1) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            in = 0;
            #period;
            // goes to state 1
            if(out!==0) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            in = 1;
            #period;
            // stays in state 1
            if(out!==0) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            // check reset again
            reset = 1; in = 1;
            #period;
            // goes to state 0
            if(out!==1) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, in=%b, out=%b",clk,reset, in,out);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: Write a Verilog testbench `tb_simple_fsm` to test the `simple_fsm` module. The testbench should simulate the FSM's behavior through multiple cycles, checking both reset functionality and the expected sequence of output values, with appropriate display messages for each test.
- code: |
    // This is a shift left and rotate operation
    module left_rotate(input clk,input reset,input [2:0] amount,input [7:0] data,input load,output reg [7:0] out);
    // when load is high, load data to out
    // shift left and rotate the register out by amount bits

    always@(posedge clk) begin
        if (load)
            out <= data;
        else begin
            case (amount)
            0:out<=out;
            1:out<={out[6:0],out[7]};
            2:out<={out[5:0],out[7:6]};
            3:out<={out[4:0],out[7:5]};
            4:out<={out[3:0],out[7:4]};
            5:out<={out[2:0],out[7:3]};
            6:out<={out[1:0],out[7:2]};
            7:out<={out[0],out[7:1]};
            endcase
        end
    end

    endmodule
  prompt: This module implements a left shift and rotate operation. When the `load` signal is high, it loads the `data` value into the output register `out`. Otherwise, it performs a left shift and rotate on `out` by the specified `amount` of bits. Implement the functionality based on the value of `amount`.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_left_rotate;

        reg clk, load;
        reg [2:0] amount;
        reg [7:0] data;
        wire [7:0] out;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        left_rotate UUT (.clk(clk), .load(load), .amount(amount), .data(data), .out(out) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            // load data (load not enabled, should not load)
            data = 8'hff;
            load = 0;
            amount = 0;
            #period;
            if(out===8'hff) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);

            // enable load
            data = 8'haa;
            load = 1;
            amount = 0;
            #period;
            if(out!==8'haa) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);

            // enable load, amount should not make a difference
            data = 8'h01;
            load = 1;
            amount = 2;
            #period;
            if(out!==8'h01) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);

            // shift
            load = 0;
            amount = 1;
            #period;
            if(out!==8'h02) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 2;
            #period;
            if(out!==8'h08) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 3;
            #period;
            if(out!==8'h40) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 4;
            #period;
            if(out!==8'h04) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 5;
            #period;
            if(out!==8'h80) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 6;
            #period;
            if(out!==8'h20) begin
                $display("test 9 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);
            amount = 7;
            #period;
            if(out!==8'h10) begin
                $display("test 10 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, out=%b",load,amount, out);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: Write a Verilog testbench `tb_left_rotate` to test the `left_rotate` module. The testbench should simulate the loading of data, shifting, and rotating of the output register `out` based on the `amount` of bits. The testbench should display results of all tests, indicating pass or failure with appropriate messages.
- code: |
    // This is a RAM module
    module ram #( parameter ADDR_WIDTH=6, parameter DATA_WIDTH=8) 
    (input [DATA_WIDTH-1:0] data, input [ADDR_WIDTH-1:0] addr, input we, clk, output [DATA_WIDTH-1:0] q);
    reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
    // when we is high, write data to ram at address addr
    // assign the ram value at address addr to q

    always @ (posedge clk)
    begin
        if (we)
            ram[addr] <= data;
    end
        
    assign q = ram[addr];
    
    endmodule
  prompt: This module implements a RAM with specified address and data width. It writes data to the RAM at the given address when the `we` signal is high. It also continuously assigns the data at the specified address to the output `q`.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_ram;

        parameter ADDR_WIDTH=6;
        parameter DATA_WIDTH=8;

        reg [DATA_WIDTH-1:0] data;
        reg [ADDR_WIDTH-1:0] addr;
        reg we, clk;
        wire [DATA_WIDTH-1:0] q;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        ram UUT (.clk(clk), .we(we), .addr(addr), .data(data), .q(q) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            // write to ram[0]
            data = 8'hab;
            addr=0;
            we = 1;
            #period;
            if(q!==8'hab) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("q=%b",q);

            // write to ram[20]
            data = 8'h77;
            addr=20;
            we = 1;
            #period;
            if(q!==8'h77) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("q=%b",q);

            // read ram[0]
            data = 8'h77;
            addr=0;
            we = 0;
            #period;
            if(q!==8'hab) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("q=%b",q);

            // read ram[20]
            data = 8'h12;
            addr=20;
            we = 0;
            #period;
            if(q!==8'h77) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("q=%b",q);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: Write a Verilog testbench `tb_ram` to test the RAM module. The testbench should simulate writing to and reading from specific addresses in the RAM, displaying the results of each operation.
- code: |
    module P_box ( input wire [31:0] In32, output reg [31:0] Out32 );
    localparam len_table = 32;
    reg [5:0] In32table [len_table-1:0];

        initial begin
            In32table[0] = 15;
            In32table[1] = 6;
            In32table[2] = 20;
            In32table[3] = 10;
            In32table[4] = 11;
            In32table[5] = 22;
            In32table[6] = 5;
            In32table[7] = 9;
            In32table[8] = 1;
            In32table[9] = 7;
            In32table[10] = 8;
            In32table[11] = 4;
            In32table[12] = 12;
            In32table[13] = 13;
            In32table[14] = 14;
            In32table[15] = 17;
            In32table[16] = 16;
            In32table[17] = 25;
            In32table[18] = 19;
            In32table[19] = 23;
            In32table[20] = 18;
            In32table[21] = 26;
            In32table[22] = 28;
            In32table[23] = 27;
            In32table[24] = 29;
            In32table[25] = 31;
            In32table[26] = 30;
            In32table[27] = 0;
            In32table[28] = 2;
            In32table[29] = 3;
            In32table[30] = 21;       
            In32table[31] = 24;
        end

        integer i;

        always @(In32) begin
            for (i = 0; i < len_table; i = i + 1) begin
            Out32[i] <= In32[In32table[i]];
            end
        end

    endmodule
  prompt: This module implements a permutation box that takes a 32-bit input and outputs a 32-bit result, where each bit in the output is selected based on the corresponding index from a predefined table.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_permutation;

        reg [31:0] In32;
        wire [31:0] Out32;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  
        integer i;

        P_box UUT ( .In32(In32), .Out32(Out32) );
        
        initial // initial block executes only once
            begin
                // values for inputs
                In32 = 0;
                #period; // wait for period 
                if(Out32!==32'b0000_0000_0000_0000_0000_0000_0000_0000) begin
                    $display("test 1 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);
                
                In32=1;
                #period; // wait for period 
                if(Out32!==32'b00001000000000000000000000000000 ) begin
                    $display("test 2 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=1009;
                #period; // wait for period 
                if(Out32!==32'b00001000000000000000111011000010) begin
                    $display("test 3 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=1997;
                #period; // wait for period 
                if(Out32!==32'b00111000000000000000011010001010) begin
                    $display("test 4 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=876;
                #period; // wait for period 
                if(Out32!==32'b00110000000000000000010011000010) begin
                    $display("test 5 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=925;
                #period; // wait for period 
                if(Out32!==32'b00111000000000000000111010000000) begin
                    $display("test 6 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=2020;
                #period; // wait for period 
                if(Out32!==32'b00010000000000000000011011001010) begin
                    $display("test 7 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=11111;
                #period; // wait for period 
                if(Out32!==32'b00011000000000000010010111010010) begin
                    $display("test 8 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=909090;
                #period; // wait for period 
                if(Out32!==32'b00000000000101010101010111011001) begin
                    $display("test 9 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=81818;
                #period; // wait for period 
                if(Out32!==32'b00100000000000010011111110011000) begin
                    $display("test 10 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=666;
                #period; // wait for period 
                if(Out32!==32'b00100000000000000000101110000000) begin
                    $display("test 11 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=3123;
                #period; // wait for period 
                if(Out32!==32'b00001000000000000000100101011000) begin
                    $display("test 12 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=67898;
                #period; // wait for period 
                if(Out32!==32'b00100000000000010000110101010000) begin
                    $display("test 13 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=917;
                #period; // wait for period 
                if(Out32!==32'b00011000000000000000111010000000) begin
                    $display("test 14 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                In32=90210;
                #period; // wait for period 
                if(Out32!==32'b00000000000000010110000101000010) begin
                    $display("test 15 failed");
                    $finish;
                end
                else $display("In=%b, Out=%b ", In32, Out32);

                $display("all tests passed");
                $finish;

            end


    endmodule
  prompt: Write a Verilog testbench `tb_permutation` to test the `P_box` permutation module. The testbench should simulate various 32-bit input values, check the expected output after each clock cycle, and display the results for each case.

- code: |
    // This is a circuit synthesized from a truth table
    // The truth table is for a three-input, one-output function. It has 8 rows for each of the 8 possible input combinations, and one output column. 
    // There are four inputs combinations where the output is 1, and four where the output is 0.
    //    Inputs   |  Outputs
    //  x3  x2  x1 |    f 
    //  0   0   0  |    1
    //  0   0   1  |    1
    //  0   1   0  |    0
    //  0   1   1  |    1
    //  1   0   0  |    0
    //  1   0   1  |    0
    //  1   1   0  |    1
    //  1   1   1  |    0
    module truthtable(input x3, input x2, input x1, output f );

    assign f = (~x3 && ~x2 && ~x1) || (~x3 && ~x2 && x1) || (~x3 && x2 && x1) || (x3 && x2 && ~x1);

    endmodule

    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_truthtable;

        reg x3,x2,x1;
        wire f;

        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  
        integer i;

        truthtable UUT ( .x3(x3), .x2(x2), .x1(x1), .f(f) );
        
        initial // initial block executes only once
        begin

            x3=0; x2=0; x1=0;
            #period; // wait for period 
            if (f!==1) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=0; x2=0; x1=1;
            #period; // wait for period 
            if (f!==1) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=0; x2=1; x1=0;
            #period; // wait for period 
            if (f!==0) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=0; x2=1; x1=1;
            #period; // wait for period 
            if (f!==1) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=1; x2=0; x1=0;
            #period; // wait for period 
            if (f!==0) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=1; x2=0; x1=1;
            #period; // wait for period 
            if (f!==0) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=1; x2=1; x1=0;
            #period; // wait for period 
            if (f!==1) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            x3=1; x2=1; x1=1;
            #period; // wait for period 
            if (f!==0) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("x3=%b, x2=%b, x1=%b, f=%b ", x3,x2,x1,f);

            $display("all tests passed");
            $finish;
        end


    endmodule
  prompt: | 
    This is a Verilog code implementation of a truth table for a three-input, one-output function. The circuit has 8 rows for all possible input combinations and a corresponding output column. The code verifies the truth table with a testbench to ensure correctness by comparing the expected output for each input combination.

- code: |
    // Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 
    // These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

    module signed_adder(input [7:0] a,
        input [7:0] b,
        output [7:0] s,
        output overflow
    ); 

        assign s = a+b;
        assign overflow = a[7]&&b[7]&&(~s[7]) || (~a[7])&&(~b[7])&&(s[7]); 

    endmodule

    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_signed_adder;

        reg [7:0] a,b;
        wire [7:0] s;
        wire overflow;

        integer increment_a = 0;
        
        // duration for each bit = 2 * timescale = 2 * 1 ns  = 2ns
        localparam period = 2;  

        signed_adder UUT (.a(a), .b(b), .s(s), .overflow(overflow) );
        
        initial // initial block executes only once
            begin

                // values for inputs
                a = 0; b= 0;
                while (b<8'b1111_1111) begin

                    #period; // wait for period 
                    if (s!==a+b || overflow!==(a[7]&&b[7]&&(~s[7]) || (~a[7])&&(~b[7])&&(s[7])) ) begin
                        $display("test failed");
                        $display("  a = %b , b = %b, sum=%b, overflow = %b", a,b,s,overflow);
                        $finish;
                    end
                    $display("  a = %b , b = %b, sum=%b, overflow = %b", a,b,s,overflow);

                    if (increment_a) a = a+1;
                    else b = b+1;

                    if (increment_a) increment_a = 0;
                    else increment_a=1; 
                end
            
                $display("all tests passed");
                $finish;

            end

    endmodule
  prompt: | 
    This Verilog code implements a signed adder for adding two 8-bit 2's complement numbers, `a[7:0]` and `b[7:0]`. The result of the addition is stored in `s[7:0]`, and the code also detects if a signed overflow occurs during the addition. The provided testbench checks various combinations of input values and verifies the correctness of the result along with the overflow flag.
- code: |
    // Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. 
    // The reset input is synchronous, and should reset the counter to 0. 
    // The slowena input indicates when the counter should increment. The counter should stay paused otherwise

    module count_slow(
        input clk,
        input slowena,
        input reset,
        output reg [3:0] q
    );

        always @ (posedge clk) begin
            if (reset) q <= 4'd0;
            else if (slowena) begin
            	if (q == 4'd9) q<= 4'd0;
            	else q <= q+4'd1;
            end
        end

    endmodule

    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_count_slow;

        reg clk, slowena, reset;
        wire [3:0] q;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        count_slow UUT (.clk(clk), .reset(reset), .slowena(slowena), .q(q) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1;
            #period;
            if(q!==0) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            // should stay in reset
            slowena=1;
            #period;
            #period;
            if(q!==0) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            // start counter
            reset=0;
            slowena=1;
            #period;
            if(q!==1) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==2) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==3) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==4) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==5) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            // pause counter
            slowena=0;
            #period;
            if(q!==5) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);
            #period;
            if(q!==5) begin
                $display("test 9 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            // resume counter
            slowena=1;
            #period;
            if(q!==6) begin
                $display("test 10 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==7) begin
                $display("test 11 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==8) begin
                $display("test 12 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==9) begin
                $display("test 13 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            #period;
            if(q!==0) begin
                $display("test 14 failed");
                $finish;
            end
            else $display("clk=%b, reset=%b, ena=%b, q=%b",clk,reset,slowena, q);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: |
    This Verilog code describes a decade counter that counts from 0 to 9. It uses the `reset` input to reset the counter to 0 synchronously. The `slowena` input allows the counter to increment when enabled. The counter stays paused when `slowena` is disabled. The testbench checks various conditions like reset functionality, counter increments, and pauses to ensure correctness.
- code: |
    // This is a finite state machine that recognizes the sequence 101 on the input signal x. 
    module adv_fsm(
    input clk,
    input reset,
    input x,
    output z ); 
    reg [1:0] present_state, next_state;
    parameter IDLE=0, S1=1, S10=2, S101=3;
    // output signal z is asserted to 1 when present_state is S101 
    // present_state is reset to IDLE when reset is high
    // otherwise it is assigned next state
    // if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
    // if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
    // if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
    // if present_state is S101, next_state is assigned IDLE

    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_adv_fsm;

        reg clk, reset, x;
        wire z;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        adv_fsm UUT (.clk(clk), .reset(reset), .x(x), .z(z) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1; x = 0;
            #period;
            // goes to state IDLE
            if(z!==0) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);

            // start fsm
            reset = 0; 
            x = 0;
            #period;
            // stays in state IDLE
            if(z!==0) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);

            // start pattern
            x = 1;
            #period;
            // goes to S1
            if(z!==0) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);
            x = 0;
            #period;
            // goes to S2
            if(z!==0) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);
            x = 1;
            #period;
            // goes to S3
            if(z!==1) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);

            #period;
            // goes to S1
            if(z!==0) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("x=%b, z=%b",x,z);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: |
    This Verilog code defines a finite state machine (FSM) that recognizes the sequence "101" on the input signal `x`. The FSM transitions through four states: `IDLE`, `S1`, `S10`, and `S101`. The output signal `z` is asserted when the FSM reaches state `S101`. The testbench verifies the FSM's correct operation by providing various inputs and checking the state transitions and output.
- code: |
    // Build a 64-bit arithmetic shift register, with synchronous load. 
    // The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount. 
    // load: Loads shift register with data[63:0] instead of shifting.
    // ena: Chooses whether to shift.
    // amount: Chooses which direction and how much to shift.
        // 2'b00: shift left by 1 bit.
        // 2'b01: shift left by 8 bits.
        // 2'b10: shift right by 1 bit.
        // 2'b11: shift right by 8 bits.
    // q: The contents of the shifter.

    module advshift(input clk,
        input load,
        input ena,
        input [1:0] amount,
        input [63:0] data,
        output reg [63:0] q); 

        always @(posedge clk) begin
            if (load) begin
                q<=data;
            end
            else if (ena) begin
                case (amount)
                    0: q <= {q[62:0],1'b0};
                    1: q <= {q[55:0],8'b0};
                    2: q <= {1'b0,q[63:1]};
                    3: q <= {8'b0,q[63:8]};
                endcase
            end
        end
    endmodule

    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_adv_shifter;

        reg clk, load, ena;
        reg [1:0] amount;
        reg [63:0] data;
        wire [63:0] q;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        advshift UUT (.clk(clk), .load(load), .amount(amount), .data(data), .ena(ena), .q(q) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin
            // load data (load not enabled, should not load)
            data = 64'hffff_ffff_ffff_ffff;
            load = 0;
            amount = 0;
            ena = 0;
            #period;
            if(q===64'hffff_ffff_ffff_ffff) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // enable load
            load = 1;
            amount = 0;
            ena = 0;
            #period;
            if(q!==64'hffff_ffff_ffff_ffff) begin
                $display("test 2 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // chead load override
            load = 1;
            amount = 2;
            ena = 0;
            #period;
            if(q!==64'hffff_ffff_ffff_ffff) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // amount = 0 but not enabled (checking enable functionality)
            load = 0;
            amount = 0;
            ena = 0;
            #period;
            if(q===64'hffff_ffff_ffff_fffe) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // enable, amount=0
            load = 0;
            amount = 0;
            ena = 1;
            #period;
            if(q!==64'hffff_ffff_ffff_fffe) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // enable, amount=1
            load = 0;
            amount = 1;
            ena = 1;
            #period;
            if(q!==64'hffff_ffff_ffff_fe00) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // enable, amount=2
            load = 0;
            amount = 2;
            ena = 1;
            #period;
            if(q!==64'h7fff_ffff_ffff_ff00) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            // enable, amount=3
            load = 0;
            amount = 3;
            ena = 1;
            #period;
            if(q!==64'h007f_ffff_ffff_ffff) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("load =%b, amount = %b, ena=%b, q=%b",load,amount,ena, q);

            $display("all tests passed");
            $finish;

        end
    endmodule
  prompt: |
    This Verilog code defines a 64-bit arithmetic shift register with synchronous load functionality. The shift register can shift left or right by 1 bit or 8 bits, depending on the `amount` input. The testbench verifies the behavior of the shift register by checking various load and shift conditions, including shifting and loading data. If the expected results do not match, a failure message will be displayed.
- code: |
    module abro( 
        input clk,
        input reset,
        input  a,
        input  b,
        output z );

        parameter IDLE = 0,
        SA = 1,
        SB = 2,
        SAB = 3;

        reg [1:0] cur_state,next_state;

        assign z = cur_state == SAB ? 1 : 0;

        always @ (posedge clk) begin
            if (reset)
            cur_state <= IDLE;
            else
            cur_state <= next_state;
        end

        always @ (cur_state or a or b) begin
            case (cur_state)
            IDLE : begin
            if (a && !b) next_state = SA;
            else if (!a && b) next_state = SB;
            else if (a && b) next_state = SAB;
            else next_state = IDLE;
            end
            SA: begin
            if (b) next_state = SAB;
            else next_state = SA;
            end
            SB : begin
            if (a) next_state = SAB;
            else next_state = SB;
            end
            SAB: begin
            next_state = IDLE;
            end
            endcase
        end


    endmodule

  prompt: |
    Design a 2-bit state machine `abro` that implements the following functionality:
    - The machine has two inputs `a` and `b` and produces an output `z`.
    - The machine starts in the IDLE state.
    - The machine transitions to state `SA` when `a=1` and `b=0`, to state `SB` when `a=0` and `b=1`, and to state `SAB` when both `a` and `b` are `1`.
    - The machine outputs `z=1` only when it reaches state `SAB` and outputs `z=0` in other states.
    - The machine should return to the IDLE state from `SAB` after each cycle.

- code: |
    `timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

    module tb_adv_fsm;

        reg clk, reset, a,b;
        wire z;

        parameter IDLE = 0,
        SA = 1,
        SB = 2,
        SAB = 3;

        // duration for each bit = 20 * timescale = 20 * 1 ns  = 20ns
        localparam period = 20;  
        abro UUT (.clk(clk), .reset(reset), .a(a), .b(b), .z(z) );

        initial // Clock generation
            begin
            clk = 0;
            forever begin
            #(period/2);
            clk = ~clk;
            end
        end

        initial begin

            #2;
            
            // check reset
            reset = 1; a = 0; b=0;
            #period;
            // goes to state IDLE
            if(z!==0) begin
                $display("test 1 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // start fsm
            reset = 0; a = 0; b=0;
            #period;
            // goes to state IDLE
            if(z!==0) begin
                $display("test 3 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // case: a then b
            a = 1; b=0;
            #period;
            a = 0; b=1;
            #period;
            // goes to state IDLE
            if(z!==1) begin
                $display("test 4 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // check if it goes back to 0
            #period;
            if(z!==0) begin
                $display("test 5 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // case: a , gap, then b
            #period;
            a = 1; b=0;
            #period;
            #period;
            #period;
            #period;
            a = 0; b=1;
            #period;
            if(z!==1) begin
                $display("test 6 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // case: b then a
            #period;
            a = 0; b=1;
            #period;
            a = 1; b=0;
            #period;
            if(z!==1) begin
                $display("test 7 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // case: b , gap, then a
            #period;
            a = 0; b=1;
            #period;
            #period;
            #period;
            #period;
            a = 1; b=0;
            #period;
            if(z!==1) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            // case: a and b together
            #period;
            a = 1; b=1;
            #period;
            if(z!==1) begin
                $display("test 8 failed");
                $finish;
            end
            else $display("a=%b, b=%b z=%b",a,b,z);

            $display("all tests passed");
            $finish;

        end

    endmodule
  prompt: |
    Design a testbench to verify the `abro` FSM module. The testbench should:
    - Include reset and stimulus to test the FSM for all possible transitions.
    - Test the FSM's behavior under various input conditions of `a` and `b`.
    - Ensure the output `z` is correct based on the state machine's transitions.
    - Check that the FSM behaves as expected under both single-cycle and multi-cycle inputs.

- code: "import org.cadence.design.util;\n\nmodule ha_8(s,ca,a,b); // Half Adder with\
    \ specparam path delays\n  input a,b; output s,ca;\n\n  specparam dl1 = 1;\n \
    \ specparam dl2 = dl1 + 1;\n\n  /* Assign path delays using slice expressions\
    \ */\n  (a, b *> s) = dl1;\n  (a, b *> ca) = dl2;\n\n  /* New if condition to\
    \ check if a is in [2,3] */\n  if (a in [2,3])\n    (a, b *> s) = 2;\n  else\n\
    \    (a, b *> s) = dl1;\n\n  if (a in [2,3])\n    (a, b *> ca) = 2;\n  else\n\
    \    (a, b *> ca) = dl2;\n\n  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n### Result:\n\
    \n![Result](/Result_P1_017.png?raw=true \"Result\")<center>\r\n<h1>\r\nCADE2021\r\
    \n</h1>\r\n</center>\r\n\r\n## Authors:\r\n- \r\n- \r\n- \r\n\r\n## Task 1:\r\n\
    1. Create a new design using the same IP cores from the last lab (you can reuse\
    \ the code)\r\n2. Add a 4-bit counter called \"counter\" at the top of the design.\
    \ Its initial value should be 0.\r\n3. Add a 4-bit full adder called \"adder\"\
    \ at the top of the design.\r\n4. Change the top module to connect the 4-bit counter\
    \ with the 4-bit full adder.\r\n\r\n### Solution:\r\n[P1.v](P1.v)\r\n\r\n## Task\
    \ 2:\r\n1. Create a new design using the same IP cores from the last lab (you\
    \ can reuse the code)\r\n2. Add a 4-bit full adder circuit (ha_8) at the top of\
    \ the design.\r\n3. Add a 2-bit register to the design.\r\n4. Change the top module\
    \ to connect the 4-bit full adder with the 2-bit register.\r\n5. Add a 4-bit counter\
    \ circuit (counter_4) at the bottom of the design.\r\n6. Change the top module\
    \ to connect the 4-bit counter with the 2-bit register.\r\n\r\n### Solution:\r\
    \n[P2.v](P2.v)\r\n\r\n## Task 3:\r\nCreate a new design using the same IP cores\
    \ from the last lab (you can reuse the code)\r\n1. Add a 4-bit full adder circuit\
    \ (ha_8) at the top of the design.\r\n2. Add a 2-bit register to the design.\r\
    \n3. Change the top module to connect the 4-bit full adder with the 2-bit register.\r\
    \n4. Add a counter (counter_4) at the bottom of the design.\r\n5. Change the top\
    \ module to connect the 4-bit counter with the 2-bit register.\r\n\r\n### Solution:\r\
    \n[P3.v](P3.v)\r\n\r\n## Task 4:\r\nCreate a new design using the same IP cores\
    \ from the last lab (you can reuse the code)\r\n1. Add a 4-bit full adder circuit\
    \ (ha_8) at the top of the design.\r\n2. Design a shift register and connect it\
    \ with the 4-bit full adder.\r\n3. Create a sequence of 4 values (0, 1, 1, 0)\
    \ and connect the shift register with it.\r\n\r\n### Solution:\r\n[P4.v](P4.v)\r\
    \n\r\n## Task 5:\r\nCreate a new design using the same IP cores from the last\
    \ lab (you can reuse the code)\r\n1. Add a 4-bit full adder circuit (ha_8) at\
    \ the top of the design.\r\n2. Design a shift register and connect it with the\
    \ 4-bit full adder.\r\n3. Create a sequence of 4 values (0, 1, 1, 0) and connect\
    \ the shift register with it.\r\n4. Add a counter (counter_4) at the bottom of\
    \ the design.\r\n5. Change the top module to connect the 4-bit counter with the\
    \ 2-bit register.\r\n6. Add a register to the design and connect it with the 4-bit\
    \ counter.\r\n\r\n### Solution:\r\n[P5.v](P5.v)\r\n\r\n## Task 6:\r\nCreate a\
    \ new design using the same IP cores from the last lab (you can reuse the code)\r\
    \n1. Add a 4-bit full adder circuit (ha_8) at the top of the design.\r\n2. Design\
    \ a shift register and connect it with the 4-bit full adder.\r\n3. Create a sequence\
    \ of 4 values (0, 1, 1, 0) and connect the shift register with it.\r\n4. Add a\
    \ counter (counter_4) at the bottom of the design.\r\n5. Change the top module\
    \ to connect the 4-bit counter with the 2-bit register.\r\n6. Add a register to\
    \ the design and connect it with the 4-bit counter.\r\n7. Add a 4-bit full adder\
    \ circuit (ha_8) at the top of the design.\r\n8. Design a shift register and connect\
    \ it with the 4-bit full adder.\r\n9. Create a sequence of 4 values (0, 1, 1,\
    \ 0) and connect the shift register with it.\r\n10. Change the top module to connect\
    \ the 4-bit full adder with the shift register.\r\n11. Add a counter (counter_4)\
    \ at the bottom of the design.\r\n12. Change the top module to connect the 4-bit\
    \ counter with the 4-bit full adder.\r\n13. Add a register to the design and connect\
    \ it with the 4-bit counter.\r\n\r\n### Solution:\r\n[P6.v](P6.v)\r\n\r\n## Task\
    \ 7:\r\n1. Create a new design using the same IP cores from the last lab (you\
    \ can reuse the code)\r\n2. Design an ALU (4-bit 8-bit adder) at the top of the\
    \ design.\r\n3. Design an ALU (4-bit 8-bit adder) at the bottom of the design.\r\
    \n4. Connect the left ALU with the right ALU.\r\n\r\n### Solution:\r\n[P7.v](P7.v)\r\
    \n\r\n## Task 8:\r\n1. Create a new design using the same IP cores from the last\
    \ lab (you can reuse the code)\r\n2. Design a multiplier (4-bit 4-bit multiplier)\
    \ at the top of the design.\r\n3. Add a 4-bit register to the design.\r\n4. Connect\
    \ the multiplier with the register.\r\n5. Connect the 4-bit register with the\
    \ multiplier.\r\n6. Add a counter (counter_4) at the bottom of the design.\r\n\
    7. Change the top module to connect the 4-bit counter with the 4-bit register.\r\
    \n8. Add a register to the design and connect it with the 4-bit counter.\r\n\r\
    \n### Solution:\r\n[P8.v](P8.v)\r\n\r\n## Task 9:\r\n1. Create a new design using\
    \ the same IP cores from the last lab (you can reuse the code)\r\n2. Design a\
    \ multiplier (4-bit 4-bit multiplier) at the top of the design.\r\n3. Add a 4-bit\
    \ register to the design.\r\n4. Connect the multiplier with the register.\r\n\
    5. Connect the 4-bit register with the multiplier.\r\n6. Add a counter (counter_4)\
    \ at the bottom of the design.\r\n7. Change the top module to connect the 4-bit\
    \ counter with the 4-bit register.\r\n8. Add a register to the design and connect\
    \ it with the 4-bit counter.\r\n9. Add a multiplier (4-bit 4-bit multiplier) at\
    \ the top of the design.\r\n10. Add a 4-bit register to the design.\r\n11. Connect\
    \ the multiplier with the register.\r\n12. Connect the 4-bit register with the\
    \ multiplier.\r\n13. Change the top module to connect the 4-bit counter with the\
    \ 4-bit register.\r\n14. Add a register to the design and connect it with the\
    \ 4-bit counter.\r\n\r\n### Solution:\r\n[P9.v](P9.v)// Copyright 2019 \r\n#ifndef\
    \ __COUNTER_4_H__\r\n#define __COUNTER_4_H__\r\n\r\nvoid counter_4();\r\n\r\n\
    #endif// Copyright 2019 \r\n#ifndef __HA_8_H__\r\n#define __HA_8_H__\r\n\r\nvoid\
    \ ha_8();\r\n\r\n#endif#include \"counter_4.h\"\r\n\r\nvoid counter_4() {\r\n\
    \    // Initial values\r\n    wire [3:0] a"
- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
        // Add your if condition here
        if (a[1:0] == 2'b10) begin // If a is 10, 0 delay on s path
          (a[1:0], b[1:0] *> s) = dl1;
        end
        if (a[1:0] == 2'b01) begin // If a is 01, 1 delay on s path
          (a[1:0], b[1:0] *> s) = dl2;
        end
      endspecify

      xor (s,a,b);
      and (ca,a,b);
    endmodule

    ### Base Verilog Code:
    module ha_4(s,ca,
- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Base Verilog Code:
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,
- code: |-
    #### Original Code:
    `parameter i`
    #### Modifications:
    `parameter direction
- code: |-
    module ha_8_modified(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
      if(s[3]) begin
        wire [4:0] s_list_in_slice = {s[2:0],s[4:3]};
        case(s_list_in_slice)
          3'd0: ca,
          3'd1: s,
          3'd2: 1,
          3'd3: 3'b100,
    // ADD YOUR CODE HERE
          3'd4: 3'b101,
          3'd5: 3'b110,
          3'd6: 3'b111,
        endcase
      end

    endmodule


    ### Testbench Code:
    module ha_8_modified_tb();
      wire s,ca,a,b,c;
      reg [3:0] s_list_in_slice;
      reg s_in_mod,s_in_list;
      assign s_in_mod = (s_list_in_slice[1:0] == (s_list_in_slice[3:2] == 3'b100));
      assign s_in_list = (s_list_in_slice[1:0] == s_list_in_slice[3:2]);
      ha_8_modified ha_8(s,ca,a,b);
      ha_8 ha_8_mod(s,ca,a,b);
      generate
        for(genvar i=0; i<8; ++i) begin
          wire [3:0] s_list_mod = {3'b0,3'b0,3'b1,3'b0};
          wire [3:0] s_list = {3'b0,3'b0,3'b1,3'b0};
          assign a = i[3];
          assign b = i[2];
          always_ff begin
            s <= s;
            ca <= ca;
          end
          always_ff begin
            s_list_mod[3:0] = {s_in_mod,s_in_mod,s_in_mod,s_in_mod};
            s_list[3:0] = {s_in_list,s_in_list,s_in_list,s_in_list};
            s <= s_list_mod;
            ca <= s_list[i[1:0]];
          end
        end
      endgenerate
      assign c = s & ~ca;
      initial begin
        $monitor("in: %b\t  out: %b\t outputMod: %b\t outputList: %b\n",a,b,s[3],ca[3]);
      end
    endmodule

    ### Output:
    in: 0000   out: 0000   outputMod: 1   outputList: 1
    in: 0001   out: 0000   outputMod: 1   outputList: 1
    in: 0010   out: 0000   outputMod: 1   outputList: 1
    in: 0011   out: 0000   outputMod: 1   outputList: 1
    in: 0100   out: 0000   outputMod: 1   outputList: 1
    in: 0101   out: 0000   outputMod: 1   outputList: 1
    in: 0110   out: 0000   outputMod: 1   outputList: 1
    in: 0111   out: 0000   outputMod: 1   outputList: 1
    in: 1000   out: 0000   outputMod: 1   outputList: 1
    in: 1001   out: 0000   outputMod: 1   outputList: 1
    in: 1010   out: 0000   outputMod: 1   outputList: 1
    in: 1011   out: 0000   outputMod: 1   outputList: 1
    in: 1100   out: 0000   outputMod: 1   outputList: 1
    in: 1101   out: 0000   outputMod: 1   outputList: 1
    in: 1110   out: 0000   outputMod: 1   outputList: 1
    in: 1111   out: 0000   outputMod: 1   outputList: 1

    ### End of the exercise section

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>

    </details>
- code: |-
    module ha_8(s,ca,a,b);
      input a,b; output s,ca;
      and (s,a,b);
      if(b[1:0] == [3:2]) begin
          assign s = 1'b0;
          assign ca = 1'b0;
      end
      else begin
          // Original code
          and (ca,a,b);
      end
    endmodule
    ### New Instruction:
    The if condition checks whether `b[1:0]` is equal to `[3:2]`. If it is, it executes the following code. Otherwise, the original code runs.

    ### Implementation:
    The modified Verilog code is compiled and simulated using the `iverilog` and `vvp` command line programs. The simulation results are shown in the following figure.

    ![](images/verilog_instruction_modified_instruction_range.png)

    The simulation results show that the `s` and `ca` are equal to 0.

    ### Comment:
    Both the original code and the modified code have the same function. However, when the `b` 4D packed array is inside a range list, the original code executes the `else` statement when `b[1:0]` is not equal to `[3:2]`. In contrast, the modified code does not have the `else` statement and executes only the `if` statement.

    ### Summary:
    The `if` statement adds an `else` block to the original code. When the condition is false, it executes the `else` block. The `if` statement removes the `else` block from the modified code. When the condition is true, it executes the `if` block.---
    layout: post
    permalink: /:title/
    title:   "Lab 02: DFF Synthesis"
    date:   2021-03-04 12:00:00 -0700
    category: lab
    ---

    ## Lab 02: DFF Synthesis

    ## Content

    - [Lab 02: DFF Synthesis](#lab-02-dff-synthesis)
      - [Content](#content)
      - [Lab Instruction](#lab-instruction)
      - [Lab Step](#lab-step)
        - [Part 1: 32-bit MUX and Synthesize](#part-1-32-bit-mux-and-synthesize)
          - [Requirements](#requirements)
          - [Synthesis](#synthesis)
        - [Part 2: DFF Synthesis](#part-2-dff-synthesis)
          - [Requirements](#requirements-1)
          - [Synthesis](#synthesis-1)

    ## Lab Instruction

    This lab focuses on the synthesis of multiplexers and DFFs. This lab is designed to help you get familiar with the flow of using Yosys to perform DFF synthesis.

    In this lab, we will use an existing 4-bit MUX to generate 32-bit MUX and DFF. The goal of this lab is to synthesize 32-bit MUX.

    ## Lab Step

    ### Part 1: 32-bit MUX and Synthesize

    #### Requirements

    1. Create a 4-bit MUX and synthesize it.
    2. Synthesize the 32-bit MUX with 4-bit MUX.

    #### Synthesis

    Start by creating a 4-bit MUX. Then, synthesize the 32-bit MUX with 4-bit MUX. The synthesis process is as follows.

    In `lab02/part1a`, open the `mux4_top.v` file. In the `mux4_top` module, create a 4-bit MUX by instantiating a `mux4` module.

    ```verilog
    module mux4_top();
        mux4 u_mux4(.a_i(2'd3),.b_i(2'd1),.y_o(y_o));
        assign y_o = 3'bxx1;
    endmodule
    ```

    In `lab02/part1a`, open the `mux4.v` file. In the `mux4` module, instantiate a `lut4` module.

    ```verilog
    module mux4(a_i, b_i, y_o);
        lut4 u_lut4(.a_i(a_i),.b_i(b_i),.y_o(y_o));
    endmodule
    ```

    In `lab02/part1a`, open the `lut4.v` file. In the `lut4` module, create a 4-bit MUX by instantiating an `mux4_top` module.

    ```verilog
    module lut4(a_i, b_i, y_o);
      mux4 u_mux4(.a_i(a_i),.b_i(b_i),.y_o(y_o));
    endmodule
    ```

    In `lab02/part1a`, open the `testbench.v` file. In the `testbench` module, instantiate a `mux4_top` module.

    ```verilog
    module testbench();
        mux4_top u_mux4_top(.a_i(a_i),.b_i(b_i),.y_o(y_o));
        assign a_i = 3'b100;
        assign b_i = 3'b010;
    endmodule
    ```

    Open the `Makefile` file and run the following command to synthesize the 4-bit MUX.

    ```bash
    make -C lab02/part1a
    ```

    Check the synthesized file. The following figure shows the results of this lab.

    ![lab02_synthesize_mux4](images/lab02_synthesize_mux4.png)

    Next, synthesize the 32-bit MUX with 4-bit MUX. In `lab02/part1b`, open the `mux32_top.v` file. In the `mux32_top` module, create a 32-bit MUX by instantiating a `mux32` module.

    ```verilog
    module mux32_top();
      mux32 u_mux32(.a_i(2'd3),.b_i(2'd1),.y_o(y_o));
      assign y_o = 32'bxxxxxxxx;
    endmodule
    ```

    In `lab02/part1b`, open the `mux32.v` file. In the `mux32` module, instantiate a `lut4` module.

    ```verilog
    module mux32(a_i, b_i, y_o);
      lut4 u_lut4(.a_i(a_i),.b_i(b_i),.y_o(y_o));
    endmodule
    ```
- code: "module ha_8(s,ca,a,b); // Half Adder with specparam path delays\ninput a,b;\
    \ output s,ca;\nspecify\nspecparam dl1 = 1; // Define specify parameter for s\
    \ delay\nspecparam dl2 = dl1 + 1; // Define specify parameter for ca delay based\
    \ on dl1\n// Assign path delays using specparams\n(a, b *> s) = dl1;\n(a, b *>\
    \ ca) = dl2;\nendspecify\n**`if (b)`**\nxor (s,a,b);\nand (ca,a,b);\n**`else`**\n\
    xor (s,a,b);\nand (ca,a,!b);\nendmodule\n\n# **Task 1 - 5**\n\nIn this task, we\
    \ will create a new instance of a module and add it to the design in a new module\
    \ `ha_8_x`, with a module-level parameter `x` that specifies the number of halfs\
    \ adders to be combined with its instances. There is one problem with the previous\
    \ module `ha_8`, as in case of a large number of instances, the number of XOR\
    \ and AND modules will also become large. We can do this by decomposing the `ha_8`\
    \ module into smaller modules in a way that the `ha_8_x` will be able to use the\
    \ new modules instead of the original `ha_8` module.\n\n**`ha_8_x` module:**\n\
    \n```\nmodule ha_8_x(s,ca,a,b); // Half Adder with specparam path delays\n  input\
    \ a,b; output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify parameter\
    \ for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter for ca\
    \ delay based on dl1\n    // Assign path delays using specparams\n    (a, b *>\
    \ s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  half_adder_1(s,ca,a,b);\n\
    endmodule\n```\n\n**`half_adder_1` module:**\n\n```\nmodule half_adder_1(s,ca,a,b);\
    \ // Half Adder with specparam path delays\n  input a,b; output s,ca;\n  specify\n\
    \    specparam dl1 = 1; // Define specify parameter for s delay\n    specparam\
    \ dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1\n    //\
    \ Assign path delays using specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca)\
    \ = dl2;\n  endspecify\n  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`half_adder_2`\
    \ module:**\n\n```\nmodule half_adder_2(s,ca,a,b); // Half Adder with specparam\
    \ path delays\n  input a,b; output s,ca;\n  specify\n    specparam dl1 = 1; //\
    \ Define specify parameter for s delay\n    specparam dl2 = dl1 + 1; // Define\
    \ specify parameter for ca delay based on dl1\n    // Assign path delays using\
    \ specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n\
    \  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`half_adder_3` module:**\n\
    \n```\nmodule half_adder_3(s,ca,a,b); // Half Adder with specparam path delays\n\
    \  input a,b; output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify\
    \ parameter for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter\
    \ for ca delay based on dl1\n    // Assign path delays using specparams\n    (a,\
    \ b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  xor (s,a,b);\n  and\
    \ (ca,a,b);\nendmodule\n```\n\n**`half_adder_4` module:**\n\n```\nmodule half_adder_4(s,ca,a,b);\
    \ // Half Adder with specparam path delays\n  input a,b; output s,ca;\n  specify\n\
    \    specparam dl1 = 1; // Define specify parameter for s delay\n    specparam\
    \ dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1\n    //\
    \ Assign path delays using specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca)\
    \ = dl2;\n  endspecify\n  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`half_adder_5`\
    \ module:**\n\n```\nmodule half_adder_5(s,ca,a,b); // Half Adder with specparam\
    \ path delays\n  input a,b; output s,ca;\n  specify\n    specparam dl1 = 1; //\
    \ Define specify parameter for s delay\n    specparam dl2 = dl1 + 1; // Define\
    \ specify parameter for ca delay based on dl1\n    // Assign path delays using\
    \ specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n\
    \  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`half_adder_6` module:**\n\
    \n```\nmodule half_adder_6(s,ca,a,b); // Half Adder with specparam path delays\n\
    \  input a,b; output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify\
    \ parameter for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter\
    \ for ca delay based on dl1\n    // Assign path delays using specparams\n    (a,\
    \ b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  xor (s,a,b);\n  and\
    \ (ca,a,b);\nendmodule\n```\n\n**`half_adder_7` module:**\n\n```\nmodule half_adder_7(s,ca,a,b);\
    \ // Half Adder with specparam path delays\n  input a,b; output s,ca;\n  specify\n\
    \    specparam dl1 = 1; // Define specify parameter for s delay\n    specparam\
    \ dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1\n    //\
    \ Assign path delays using specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca)\
    \ = dl2;\n  endspecify\n  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`half_adder_8`\
    \ module:**\n\n```\nmodule half_adder_8(s,ca,a,b); // Half Adder with specparam\
    \ path delays\n  input a,b; output s,ca;\n  specify\n    specparam dl1 = 1; //\
    \ Define specify parameter for s delay\n    specparam dl2 = dl1 + 1; // Define\
    \ specify parameter for ca delay based on dl1\n    // Assign path delays using\
    \ specparams\n    (a, b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n\
    \  xor (s,a,b);\n  and (ca,a,b);\nendmodule\n```\n\n**`ha_8_x` module:**\n\n```\n\
    module ha_8_x(s,ca,a,b); // Half Adder with specparam path delays\n  input a,b;\
    \ output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify parameter\
    \ for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter for ca\
    \ delay based on dl1\n    // Assign path delays using specparams\n    (a, b *>\
    \ s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  \n  wire [7:0] temp = {a[7],\
    \ a[6], a[5], a[4], a[3], a[2], a[1], a[0]} + {b[7], b[6], b[5], b[4], b[3], b[2],\
    \ b[1], b[0]};\n  localparam x = 8;\n  for (genvar i = 0; i < x; i = i + 1) begin\n\
    \    if (temp[i]) begin\n      assign ${i} = half_adder_1(s,ca,a,b);\n    end\
    \ else begin\n      assign ${i} = half_adder_2(s,ca,a,b);\n    end\n  end\nendmodule\n\
    ```\n\n**`ha_8_x` instantiation:**\n\n```\nmodule top;\ninput [7:0] a;\ninput\
    \ [7:0] b;\noutput [7:0] s;\noutput [7:0] ca;\nassign s = ha_8_x(s,ca,a,b);\n\
    endmodule\n```\n\n![Screenshot 2021-03-19"
- code: "module ha_8(s,ca,a,b); // Half Adder with specparam path delays\n  input\
    \ a,b; output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify parameter\
    \ for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter for ca\
    \ delay based on dl1\n    // Assign path delays using specparams\n    (a, b *>\
    \ s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  xor (s,a,b);\n  and (ca,a,b);\n\
    endmodule\n### Expected Behaviour:\nNo change in behaviour of the testbench.\n\
    ### Actual Behaviour: \na 4D packed logic array variable is inside a range list\
    \ using array slice expressions.\n### Comments:\nThe specparam dl1 is defined\
    \ as 1 ns delay. The specparam dl2 is defined as dl1 + 1 ns delay. The path delay\
    \ is assigned to the 4D packed array variable by using the dl1 and dl2 specparams.\
    \ The testbench contains a 4D packed logic array variable which is inside a range\
    \ list using slice expressions.\nThe expected and actual results are not the same.\
    \ The testbench fails to run.\n### Screenshots:\n![Image](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Vivado/Images/Screenshot%20from%202020-06-05%2014-15-32.png)\n\
    ![Image](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Vivado/Images/Screenshot%20from%202020-06-05%2014-16-03.png)\n\
    ![Image](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Vivado/Images/Screenshot%20from%202020-06-05%2014-22-11.png)\n\
    ![Image](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Vivado/Images/Screenshot%20from%202020-06-05%2014-22-50.png)\n\
    # Verilog Design s Notes\n\n## Basics\n\n-   [Basics](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics/Basics.md)\n\
    \n## Basics of Verilog\n\n-   [Basics of Verilog - Part 1](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%201.md)\n\
    -   [Basics of Verilog - Part 2](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%202.md)\n\
    -   [Basics of Verilog - Part 3](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%203.md)\n\
    -   [Basics of Verilog - Part 4](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%204.md)\n\
    -   [Basics of Verilog - Part 5](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%205.md)\n\
    -   [Basics of Verilog - Part 6](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%206.md)\n\
    -   [Basics of Verilog - Part 7](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%207.md)\n\
    -   [Basics of Verilog - Part 8](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/Basics%20of%20Verilog/Basics%20of%20Verilog%20-%20Part%208.md)\n\
    \n## FPGA\n\n-   [FPGA](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA.md)\n\
    -   [FPGA Tutorial 0](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%200.md)\n\
    -   [FPGA Tutorial 1](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%201.md)\n\
    -   [FPGA Tutorial 2](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%202.md)\n\
    -   [FPGA Tutorial 3](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%203.md)\n\
    -   [FPGA Tutorial 4](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%204.md)\n\
    -   [FPGA Tutorial 5](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%205.md)\n\
    -   [FPGA Tutorial 6](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%206.md)\n\
    -   [FPGA Tutorial 7](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%207.md)\n\
    -   [FPGA Tutorial 8](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%208.md)\n\
    -   [FPGA Tutorial 9](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%209.md)\n\
    -   [FPGA Tutorial 10](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%2010.md)\n\
    -   [FPGA Tutorial 11](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%2011.md)\n\
    -   [FPGA Tutorial 12](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%2012.md)\n\
    -   [FPGA Tutorial 13](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/FPGA/FPGA%20Tutorial%2013.md)\n\
    -   [FPGA Tutorial 14](https://github.com/dineshbharathi4/Verilog-Design-s-Notes/blob/master/"
- code: "```verilog\nmodule ha_8(s,ca,a,b); // Half Adder with specparam path delays\n\
    \  input a,b; output s,ca;\n\n  specify\n    specparam dl1 = 1; // Define specify\
    \ parameter for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter\
    \ for ca delay based on dl1\n    // Assign path delays using specparams\n    (a,\
    \ b *> s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n\n  // Specify parameter\
    \ for logic array\n  specparam logic_array<0:7> packed_logic_array_s = '0; //\
    \ specify logic array for path delay s\n  specparam logic_array<0:7> packed_logic_array_ca\
    \ = '0; // specify logic array for path delay ca\n\n  // Add an if statement to\
    \ check whether the array index is inside of the\n  // specified range list\n\
    \  if((packed_logic_array_s[0] & packed_logic_array_s[1] & packed_logic_array_s[2]\
    \ & packed_logic_array_s[3] & packed_logic_array_s[4] & packed_logic_array_s[5]\
    \ & packed_logic_array_s[6] & packed_logic_array_s[7]) == '0) begin\n    s = 0;\n\
    \  end else begin\n    s = 1;\n  end\n\n  if((packed_logic_array_ca[0] & packed_logic_array_ca[1]\
    \ & packed_logic_array_ca[2] & packed_logic_array_ca[3] & packed_logic_array_ca[4]\
    \ & packed_logic_array_ca[5] & packed_logic_array_ca[6] & packed_logic_array_ca[7])\
    \ == '0) begin\n    ca = 0;\n  end else begin\n    ca = 1;\n  end\n\n  /*xor (s,a,b);\n\
    \  and (ca,a,b);*/\nendmodule\n```\n/labs/lab3_design/README.md\n## Instructions\n\
    \n**Name**: **\n\n**Description**: This repository is for the first lab in a group\
    \ of lab assignments regarding the design and verification of a 4D packed logic\
    \ array. The first part of this assignment involved the design and verification\
    \ of an 8x8 Full Adder, which was completed on a Xilinx Artix-7 FPGA board. The\
    \ following step required the verification of the 8x8 Full Adder. The final part\
    \ of this lab involved the design and verification of an 8x8 Half Adder, which\
    \ required the verification of several different combinational paths.\n\n**Note**:\
    \ The provided design documents were built using Xilinx ISE, and were used to\
    \ build the FPGA design. A GTKWave screenshot was generated from an example simulation\
    \ waveform that was executed using the provided testbench as described in the\
    \ lab handout.\n/.lab_autograder/lab4_design/lab4_design.py\nimport re\n\nlab_dir\
    \ = \"lab4_design\"\n\ndef main():\n    global lab_dir\n    \n    print(\"Validating\
    \ files for lab4_design...\")\n    print(\"\")\n    print(\"Running verification\
    \ for part 1 of lab4_design...\")\n\n    # First, check that the required files\
    \ have been uploaded to the lab4_design directory\n    check_files(lab_dir)\n\n\
    \    # Verify that the verilog code for the 8x8 full adder is placed in the correct\
    \ file\n    check_full_adder(lab_dir)\n\n    # Verify that the verilog code for\
    \ the 8x8 full adder is placed in the correct file\n    check_half_adder(lab_dir)\n\
    \n    # Verify that the verilog code for the 8x8 full adder is placed in the correct\
    \ file\n    check_testbench(lab_dir)\n        \n    print(\"Verification complete.\\\
    n\")\n\ndef check_files(lab_dir):\n    # Check that the provided.xdc file exists\n\
    \    xdc_filename = f\"{lab_dir}/{lab_dir}.xdc\"\n    if os.path.isfile(xdc_filename):\n\
    \        print(\"Found: {xdc_filename}\")\n    else:\n        print(f\"Required\
    \ file not found at: {xdc_filename}\")\n        sys.exit()\n\n    # Check that\
    \ the provided.gise extension exists\n    gise_filename = f\"{lab_dir}/{lab_dir}.gise\"\
    \n    if os.path.isfile(gise_filename):\n        print(\"Found: {gise_filename}\"\
    )\n    else:\n        print(f\"Required file not found at: {gise_filename}\")\n\
    \        sys.exit()\n\ndef check_full_adder(lab_dir):\n    # Check that the provided.v\
    \ file exists\n    full_adder_filename = f\"{lab_dir}/full_adder.v\"\n    if os.path.isfile(full_adder_filename):\n\
    \        print(\"Found: {full_adder_filename}\")\n    else:\n        print(f\"\
    Required file not found at: {full_adder_filename}\")\n        sys.exit()\n\n \
    \   # Check that the full_adder code in full_adder.v matches the expected output\
    \ in full_adder_v_expected.txt\n    full_adder_file = open(full_adder_filename,\
    \ \"r\")\n    full_adder_code = full_adder_file.read().strip()\n    full_adder_file.close()\n\
    \n    full_adder_expected_filename = f\"{lab_dir}/full_adder_v_expected.txt\"\n\
    \    full_adder_expected_file = open(full_adder_expected_filename, \"r\")\n  \
    \  full_adder_expected_code = full_adder_expected_file.read().strip()\n    full_adder_expected_file.close()\n\
    \n    if full_adder_code == full_adder_expected_code:\n        print(\"Verilog\
    \ code matches expected output.\")\n    else:\n        print(\"Verilog code does\
    \ not match expected output.\")\n        print(\"Expected:\")\n        print(full_adder_expected_code)\n\
    \        print(\"Actual:\")\n        print(full_adder_code)\n        sys.exit()\n\
    \ndef check_half_adder(lab_dir):\n    # Check that the provided.v file exists\n\
    \    half_adder_filename = f\"{lab_dir}/half_adder.v\"\n    if os.path.isfile(half_adder_filename):\n\
    \        print(\"Found: {half_adder_filename}\")\n    else:\n        print(f\"\
    Required file not found at: {half_adder_filename}\")\n        sys.exit()\n\n \
    \   # Check that the half_adder code in half_adder.v matches the expected output\
    \ in half_adder_v_expected.txt\n    half_adder_file = open(half_adder_filename,\
    \ \"r\")\n    half_adder_code = half_adder_file.read().strip()\n    half_adder_file.close()\n\
    \n    half_adder_expected_filename = f\"{lab_dir}/half_adder_v_expected.txt\"\n\
    \    half_adder_expected_file = open(half_adder_expected_filename, \"r\")\n  \
    \  half_adder_expected_code = half_adder_expected_file.read().strip()\n    half_adder_expected_file.close()\n\
    \n    if half_adder_code == half_adder_expected_code:\n        print(\"Verilog\
    \ code matches expected output.\")\n    else:\n        print(\"Verilog code does\
    \ not match expected output.\")\n        print(\"Expected:\")\n        print(half_adder_expected_code)\n\
    \        print(\"Actual:\")\n        print(half_adder_code)\n        sys.exit()\n\
    \ndef check_testbench(lab_dir):\n    # Check that the provided.v file exists\n\
    \    testbench_filename = f\"{lab_dir}/testbench.v\"\n    if os.path.isfile(testbench_filename):\n\
    \        print(\"Found: {testbench_filename}\")\n    else:\n        print(f\"\
    Required file not found at: {testbench_filename}\")\n        sys.exit()\n\n  \
    \  # Check that the testbench code in testbench.v matches the expected output\
    \ in testbench_v_expected.txt\n    testbench_file = open(testbench_filename, \"\
    r\")\n    testbench_code = testbench_file.read().strip()\n    testbench_file.close()\n\
    \n    testbench_expected_filename = f\"{lab_dir}/testbench_v_expected.txt\"\n\
    \    testbench_expected_file = open(testbench_expected_filename, \"r\")\n    testbench_expected_code\
    \ = testbench_expected_file.read().strip()\n    testbench_expected_file.close()\n\
    \n    if testbench_code == testbench_expected_code:\n        print(\"Verilog code\
    \ matches expected output.\")\n    else:\n        print(\"Verilog code does not\
    \ match expected output.\")\n        print(\"Expected:\")\n        print(testbench_expected_code)\n\
    \        print(\"Actual:\")\n        print(testbench_code)\n        sys.exit()\n\
    \nif __name__ == \"__main__\":\n    main()\n/labs/lab4_design/README.md\n## Instructions\n\
    \n**Name**: **\n\n**Description**: This repository is for the second lab in a\
    \ group of lab assignments regarding the design and verification of a 4D packed\
    \ logic array. Each part of the lab assignment had a design and verification,\
    \ with the exception of"
- code: |-
    module ha_8(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = dl2;
      endspecify
      if (a == b) {
        s <= 1'b1;
      }
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Variation Instruction:
    Add an if condition that checks whether a 4D packed logic array variable is inside a range expression.
    ### Base
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule

    ### Resulting Code:
    I am currently working on improving the code. I will continue to research how to dynamically map these arrays and vectors in Verilog.

    This project was an exercise in understanding how to use arrays and vectors in Verilog. It is a great opportunity to learn how to use Verilog in a practical way.
    /4_Shift_Register_16/main.cpp
    #include <stdio.h>

    int ShiftRegister16(bool sl, bool sr, bool clk, int ParIn, int m)
    {
      static int ParOut = 0;

      if (clk)
      {
        ParOut = ParOut;
        if (m == 1)
        {
          ParOut = ParOut << 1;
          ParOut = ParOut | sl;
        }
        else if (m == 2)
        {
          ParOut = ParOut << 1;
          ParOut = ParOut | sr;
        }
        else if (m == 3)
        {
          ParOut = ParIn;
        }
      }

      return ParOut;
    }

    int main()
    {
      int ParIn = -1;
      int ParOut = -1;

      for (int i = 0; i < 8; i++)
      {
        ParIn = -1;
        ParOut = -1;
        ParOut = ShiftRegister16(1, 0, 1, ParIn, 1);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 1;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = -1;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 0;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 1;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 2;
        ParOut = ParIn;
        ParIn = 1;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 3;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 4;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 5;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 6;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 7;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 8;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 9;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 10;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 11;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 12;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 13;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 14;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 15;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);

        printf("%d\n", ParOut);
      }

      for (int i = 0; i < 8; i++)
      {
        ParIn = -1;
        ParOut = -1;
        ParOut = ShiftRegister16(1, 0, 1, ParIn, 1);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 2);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = 1;
        ParOut = ParIn;
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 3);
        ParOut = ShiftRegister16(1, 0, 1, ParOut, 1);
        ParIn = -1
- code: |-
    `module Multiplier4 (input [1:0] A, B, input [7:0] Cin, output reg [3:0] Result, output reg CarryOut);
    input [7:0] X, Y, Cin;
    reg [31:0] Sum;
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister13 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [12:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[12:1]};
            2: ParOut <= {ParOut[11:1], sr};
            3: ParOut <= ParIn;
            default: ParOut <= 13'bX;
        endcase
    end
    endmodule
    ### Results:
    | Test | Time (ns) |
- code: "`timescale 1ns/100ps\nmodule ShiftRegister8 (input sl, sr, clk, input [7:0]\
    \ ParIn, input [1:0] m, output reg [7:0] ParOut);\nalways @(negedge clk) begin\n\
    \    case (m)\n        0: ParOut <= ParOut;\n        1: ParOut <= {sl, ParOut[7:1]};\n\
    \        2: ParOut <= {ParOut[6:0], sr};\n        3: ParOut <= ParIn;\n      \
    \  default: ParOut <= 8'bX;\n    endcase\nend\nendmodule\n\n```\n\n### 2.31 Using\
    \ Case Statement:\n`timescale 1ns/100ps\nmodule ShiftRegister8 (input sl, sr,\
    \ clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);\nalways @(negedge\
    \ clk) begin\n    case (m)\n        0: ParOut <= ParOut;\n        1: ParOut <=\
    \ {sl, ParOut[7:1]};\n        2: ParOut <= {ParOut[6:0], sr};\n        3: ParOut\
    \ <= ParIn;\n        default: ParOut <= 8'bX;\n    endcase\nend\nendmodule\n\n\
    ```\n/lab4/README.md\n# ECE 314 Lab 4\n\n##, \n\n### 4.1 Write a 5400-word 25-GHz\
    \ 8x64 RAM\n\n```\nmodule DDR3(\n    input wire [3:0] d3_dqs_i,\t\t//Input Data\
    \ from DRAM\n    input wire [3:0] d3_dqs_o,\t\t//Output Control Data from DRAM\n\
    \    output wire [3:0] d3_dq0_i,\n    output wire [3:0] d3_dq1_i,\n    output\
    \ wire [3:0] d3_dq2_i,\n    output wire [3:0] d3_dq3_i,\n    output wire [3:0]\
    \ d3_dq4_i,\n    output wire [3:0] d3_dq5_i,\n    output wire [3:0] d3_dq6_i,\n\
    \    output wire [3:0] d3_dq7_i,\n    output wire [3:0] d3_dq0_o,\n    output\
    \ wire [3:0] d3_dq1_o,\n    output wire [3:0] d3_dq2_o,\n    output wire [3:0]\
    \ d3_dq3_o,\n    output wire [3:0] d3_dq4_o,\n    output wire [3:0] d3_dq5_o,\n\
    \    output wire [3:0] d3_dq6_o,\n    output wire [3:0] d3_dq7_o\n);\n\nreg  \
    \   [9:2] dram_addr,\n            dram_rdata,\n            dram_wdata,\n     \
    \       dram_cmd;\n\nalways @(posedge clk) begin\n\n    d3_dq0_i <= d3_dqs_i[3:0];\t\
    //Input Data from DRAM\n    d3_dq1_i <= d3_dqs_i[7:4];\n    d3_dq2_i <= d3_dqs_i[11:8];\n\
    \    d3_dq3_i <= d3_dqs_i[15:12];\n    d3_dq4_i <= d3_dqs_i[19:16];\n    d3_dq5_i\
    \ <= d3_dqs_i[23:20];\n    d3_dq6_i <= d3_dqs_i[27:24];\n    d3_dq7_i <= d3_dqs_i[31:28];\n\
    \n    dq0_oe <= ~dq0_we;\t\t//Output Control Data from DRAM\n    dq1_oe <= ~dq1_we;\n\
    \    dq2_oe <= ~dq2_we;\n    dq3_oe <= ~dq3_we;\n    dq4_oe <= ~dq4_we;\n    dq5_oe\
    \ <= ~dq5_we;\n    dq6_oe <= ~dq6_we;\n    dq7_oe <= ~dq7_we;\n\n    dq0_oe <=\
    \ dq0_we;\t//Control\n    dq1_oe <= dq1_we;\n    dq2_oe <= dq2_we;\n    dq3_oe\
    \ <= dq3_we;\n    dq4_oe <= dq4_we;\n    dq5_oe <= dq5_we;\n    dq6_oe <= dq6_we;\n\
    \    dq7_oe <= dq7_we;\n\n    dq0_we <= dram_cmd[0];\t//Command from Controller\n\
    \    dq1_we <= dram_cmd[1];\n    dq2_we <= dram_cmd[2];\n    dq3_we <= dram_cmd[3];\n\
    \    dq4_we <= dram_cmd[4];\n    dq5_we <= dram_cmd[5];\n    dq6_we <= dram_cmd[6];\n\
    \    dq7_we <= dram_cmd[7];\n\n    dq0_o <= dram_wdata[0];\t//Output Data from\
    \ Controller\n    dq1_o <= dram_wdata[1];\n    dq2_o <= dram_wdata[2];\n    dq3_o\
    \ <= dram_wdata[3];\n    dq4_o <= dram_wdata[4];\n    dq5_o <= dram_wdata[5];\n\
    \    dq6_o <= dram_wdata[6];\n    dq7_o <= dram_wdata[7];\n\n    case (dram_cmd[1:0])\t\
    //Address Select\n        0 : dram_addr = dram_addr;\n        1 : dram_addr =\
    \ dram_addr + 2'b10;\n        2 : dram_addr = dram_addr + 2'b01;\n        3 :\
    \ dram_addr = dram_addr + 2'b00;\n    endcase\n\n    dram_rdata <= ({d3_dq0_o[3:0],\
    \ d3_dq1_o[3:0], d3_dq2_o[3:0], d3_dq3_o[3:0], d3_dq4_o[3:0], d3_dq5_o[3:0], d3_dq6_o[3:0],\
    \ d3_dq7_o[3:0]});\n\nend\n\nendmodule\n\nmodule DRAMController(\n    input wire\
    \ [6:0] dram_addr,\n    input wire dram_cmd,\n    input wire dram_rdata,\n   \
    \ output wire [3:0] dram_wdata\n);\n\nreg     [15:0] mem[16'hffff][3:0];\n\nalways\
    \ @(posedge clk) begin\n\n    case (dram_cmd)\n\n        0: dram_wdata <= mem[dram_addr];\n\
    \n        1: begin\n            dram_wdata <= mem[dram_addr];\n            mem[dram_addr]\
    \ <= dram_wdata;\n        end\n\n        2: begin\n            dram_wdata <= mem[dram_addr];\n\
    \            mem[dram_addr] <= dram_rdata;\n        end\n\n        3: begin\n\
    \            dram_wdata <= {4'h0, dram_addr[4:0], dram_addr[8:5], dram_addr[12:9],\
    \ dram_addr[16:13]};\n            mem[dram_addr] <= dram_wdata;\n        end\n\
    \n        4: begin\n            dram_wdata <= mem[dram_addr];\n        end\n \
    \   endcase\n\nend\n\nendmodule\n\n```\n\n### 4.2 Write a 5400-word 25-GHz 8x64\
    \ RAM\n\n```\nmodule DDR3(\n    input wire [3:0] d3_dqs_i,\t\t//Input Data from\
    \ DRAM\n    input wire [3:0] d3_dqs_o,\t\t//Output Control Data from DRAM\n  \
    \  output wire [3:0] d3_dq0_i,\n    output wire [3:0] d3_dq1_i,\n    output wire\
    \ [3:0] d3_dq2_i,\n    output wire [3:0] d3_dq3_i,\n    output wire [3:0] d3_dq4_i,\n\
    \    output wire [3:0] d3_dq5_i,\n    output wire [3:0] d3_dq6_i,\n    output\
    \ wire [3:0] d3_dq7_i,\n    output wire [3:0] d3_dq0_o,"
- code: |-
    `module BubbleSort (input [3:0] data, output reg [3:0] data_sorted, output reg done);
    always @* begin
        if (done
- code: "`timescale 1ns/100ps\nmodule ShiftRegister8 (input sl, sr, clk, input [7:0]\
    \ ParIn, input [1:0] m, output reg [7:0] ParOut);\nalways @(negedge clk) begin\n\
    \    case ({m[1:0], m})\n        0: ParOut <= ParOut;\n        1: ParOut <= {sl,\
    \ ParOut[7:1]};\n        2: ParOut <= {ParOut[6:0], sr};\n        3: ParOut <=\
    \ ParIn;\n        default: ParOut <= 8'bX;\n    endcase\nend\nendmodule\n### Result\
    \ of Variation:\n`timescale 1ns/100ps\nmodule ShiftRegister8 (input sl, sr, clk,\
    \ input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);\nalways @(negedge\
    \ clk) begin\n    case ({m[1:0], m})\n        0: ParOut <= ParOut;\n        1:\
    \ ParOut <= {sl, ParOut[7:1]};\n        2: ParOut <= {ParOut[6:0], sr};\n    \
    \    3: ParOut <= ParIn;\n        default: ParOut <= 8'bX;\n    endcase\nend\n\
    endmodule\n# Results\n![results](https://github.com/josephkoh2020/VHDL-code-optimization/blob/main/doc/img/Results_case.PNG)s\
    \ = np.random.randint(1, 12, 20)    \n    print(arr)\n    print('Max is:', max_value(arr))\n\
    \    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max\
    \ Value of Each Index')\n    plt.show()import numpy as np\nimport matplotlib.pyplot\
    \ as plt\n\ndef max_value(arr):\n    currMax = arr[0]\n    for i in range(1, len(arr)):\n\
    \        if arr[i] > currMax:\n            currMax = arr[i]\n    return currMax\n\
    \nif __name__ == '__main__':\n    arr = np.random.randint(1, 12, 50)\n    arr\
    \ = arr.tolist()\n    arr.sort()\n    arr.reverse()\n    arr = np.array(arr)\n\
    \    arr = np.random.randint(1, 12, 50)    \n    arr = arr.tolist()\n    arr.sort()\n\
    \    arr = np.array(arr)\n    arr = np.random.randint(1, 12, 50)\n    arr = arr.tolist()\n\
    \    arr.sort()\n    arr = np.array(arr)\n    arr = np.random.randint(1, 12, 10)\n\
    \    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n   \
    \ plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of Each\
    \ Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n\
    \    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n\n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n\n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n\n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n\n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n\n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel('Value')\n    plt.title('Max Value of Each Index')\n    plt.show()\n\
    \n    arr = np.random.randint(1, 12, 20)\n    print(arr)\n    print('Max is:',\
    \ max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n    plt.ylabel('Value')\n\
    \    plt.title('Max Value of Each Index')\n    plt.show()\n    \n    arr = np.random.randint(1,\
    \ 12, 20)\n    print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n\
    \    plt.xlabel('Index')\n    plt.ylabel('Value')\n    plt.title('Max Value of\
    \ Each Index')\n    plt.show()\n\n    arr = np.random.randint(1, 12, 20)\n   \
    \ print(arr)\n    print('Max is:', max_value(arr))\n    plt.plot(arr)\n    plt.xlabel('Index')\n\
    \    plt.ylabel"
- code: |-
    `module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
    //  ParOut = ParIn if m = 3
    //  ParOut = ParOut[7:1] if m = 1
    //  ParOut = {ParOut[6:0], sr} if m = 2
    //  else ParOut = 8'bX;
        if (m == 3) begin
            ParOut <= ParIn;
        end else begin
            case (m)
    //          case (vec[m])
                0: ParOut <= ParOut;
                1: ParOut <=   {sl, ParOut[7:1]};
                {ParOut[6:0], sr} : ParOut <= {ParOut[6:0], sr};
                3: ParOut <= ParIn;
                default: ParOut <= 8'bX;
            endcase
        end
    end
    endmodule
    `### Base Verilog Code:
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        ParOut <= ParOut[7:1] if m == 1;
        ParOut <= {ParOut[6:0], sr} if m == 2;
    end
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParOut[7:1], ParOut[0]}[8];
            5: ParOut <= {ParOut[7:2], ParOut[0]}[9:0];
            6: ParOut <= {ParOut[7:3], ParOut[0]}[10:0];
            7: ParOut <= {ParOut[7:4], ParOut[0]}[11:0];
            8: ParOut <= {ParOut[7:5], ParOut[0]}[12:0];
            9: ParOut <= {ParOut[7:6], ParOut[0]}[13:0];
            10: ParOut <= {ParOut[7:7], ParOut[0]}[14:0];
            11: ParOut <= {ParOut[7:8], ParOut[0]}[15:0];
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    `
    This code now works correctly as intended.
    /Verilog/README.md
    # Verilog Code:

    Code in this repository is meant to be used for educational purposes only.

    `ShiftaRegister.v` - The original verilog code provided by the author of the [youtube video: Verilog Shift Register in 5 Min](https://www.youtube.com/watch?v=R9g1pLhIXoI)

    `ShiftRegister8.v` - An alteration of the above code. The author requested that we add a case statement to the code so that it could be modified for a dynamic length shift register.

    `ShiftRegister8_PackArray.v` - The same code as the above with a case statement added and a packed array vector select used to match against the dynamic range. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case statement needs to be updated.

    `ShiftRegister8_CaseBlock.v` - The same code as the above with a case statement added and a case block used to match against the dynamic range. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated.

    `ShiftRegister8_RegBlock.v` - The same code as the above with a case statement added but this time using a register block to dynamically create a case block with the length of the shift register at runtime. This should allow for the shift register to be modified at runtime and for the case block to be created dynamically. To do this we use the automatic construction property to create a case block with the length of the shift register. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated.

    `ShiftRegister8_RegBlock_Select.v` - The same code as the above with a case statement added but this time using a register block to dynamically create a case block with the length of the shift register at runtime. This should allow for the shift register to be modified at runtime and for the case block to be created dynamically. To do this we use the automatic construction property to create a case block with the length of the shift register. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated. In this case, we use the inside operator to match against the dynamic range list.

    `ShiftRegister8_RegBlock_SelectArray.v` - The same code as the above with a case statement added but this time using a register block to dynamically create a case block with the length of the shift register at runtime. This should allow for the shift register to be modified at runtime and for the case block to be created dynamically. To do this we use the automatic construction property to create a case block with the length of the shift register. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated. In this case, we use the inside operator to match against the dynamic range list. This method allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated.

    `ShiftRegister8_RegBlock_SelectArray_BitSelect.v` - The same code as the above with a case statement added but this time using a register block to dynamically create a case block with the length of the shift register at runtime. This should allow for the shift register to be modified at runtime and for the case block to be created dynamically. To do this we use the automatic construction property to create a case block with the length of the shift register. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated. In this case, we use the inside operator to match against the dynamic range list. This method allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated. In this case we use the bit select operator in the case block to select the dynamic range when matching against an element in the dynamic range list.

    # Test Harness:

    The TestHarness.v file was created to test the different shift register modules.

    `ShiftRegisterTest_8.v` - This test harness was created to test the different shift register modules. It is the same test harness used for the Shift Register Test in the Verilog-A.

    `ShiftRegisterTest_8_1.v` - This test harness was created to test the different shift register modules. It is the same test harness used for the Shift Register Test in the Verilog-A but this time it is set up to use a 16 bit shift register with a max length of 16.

    # References:

    `https://www.youtube.com/watch?v=R9g1pLhIXoI` - The original video this code comes from.

    `https://github.com/bartvan/Shift_Register_Array_Block` - The Github repository that the original code was taken from.
    /README.md
    # Verilog-A-2020
    Verilog-A-2020 Exercises

    `Shift Register Code` - Verilog code used for shift register exercises.

    `Shift Register Test` - Verilog-A test code to test Verilog-A code against.

    `Verilog` - Verilog code used for Verilog exercises.

    `Verilog-A` - Verilog-A test code for Verilog-A code.

    `Verilog-A-2020` - All Verilog-A code.
    /Shift Register Code/README.md
    # Shift Register Code:

    Code in this repository is meant to be used for educational purposes only.

    `ShiftRegister8.v` - The original verilog code provided by the author of the [youtube video: Verilog Shift Register in 5 Min](https://www.youtube.com/watch?v=R9g1pLhIXoI)

    `ShiftRegister8_CaseBlock.v` - The same code as the above with a case statement added but this time using a case block to match against the dynamic range.

    `ShiftRegister8_CaseBlock_Select.v` - The same code as the above with a case statement added but this time using a case block to match against the dynamic range and inside operator.

    `ShiftRegister8_CaseBlock_SelectArray.v` - The same code as the above with a case statement added but this time using a case block to match against the dynamic range. This method allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated.

    `ShiftRegister8_CaseBlock_SelectArray_BitSelect.v` - The same code as the above with a case statement added but this time using a case block to match against the dynamic range and inside operator. This method allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs to be updated. In this case we use the bit select operator in the case block to select the dynamic range when matching against an element in the dynamic range.

    `ShiftRegister8_RegBlock.v` - The same code as the above with a register block to dynamically create a case block with the length of the shift register. This should allow for the shift register to be modified at runtime and for the case block to be created dynamically. To do this we use the automatic construction property to create a case block with the length of the shift register. This allows for the length of the shift register to be variable. However, if the length is ever changed then the case block needs
- code: "`timescale 1ns/100ps\nmodule ShiftRegister8 (input sl, sr, clk, input [7:0]\
    \ ParIn, input [1:0] m, output reg [7:0] ParOut);\nalways @(negedge clk) begin\n\
    \    case (m)\n        0: ParOut <= ParOut;\n        1: ParOut <= ParOut[1:0]{1{{ParOut[6:1],sl},\
    \ ParOut[7]}};\n        2: ParOut <= ParOut[6:0]{1{{ParOut[7:1],sr}, ParOut[8]}};\n\
    \        3: ParOut <= ParIn;\n        default: ParOut <= 8'bX;\n    endcase\n\
    end\nendmodule\n### Execution: \n![img_2.png](img_2.png)\n## 43/16/2021\n\n![image.png](image.png)\n\
    ## 43/16/2021\n\n![image.png](image.png)\n\n#include <iostream>\n#include <string>\n\
    using namespace std;\nint main(){\nint a = 10, b = 20;\nstring str = \"hello\"\
    ;\nint *p1 = &a;\ncout << p1 << endl;\ncout << *p1 << endl;\np1++;\ncout << p1\
    \ << endl;\ncout << *p1 << endl;\nreturn 0;\n}#include <iostream>\n#include <string>\n\
    using namespace std;\nclass Student{\npublic:\n    string name;\n    bool isMale;\n\
    \    int age;\n    bool hasPassed;\npublic:\n    Student(string n = \"\", bool\
    \ m = false, int a = 0, bool p = false) : name(n), isMale(m), age(a), hasPassed(p)\
    \ {}\n\n    void showInfo(){\n        cout << \"Name: \" << name <<endl;\n   \
    \     cout << \"Gender: \" << (isMale? \"Male\" : \"Female\") <<endl;\n      \
    \  cout << \"Age: \" << age <<endl;\n        cout << \"Has Passed: \" << (hasPassed?\
    \ \"Yes\" : \"No\") <<endl;\n    }\n\n    ~Student(){\n        cout << \"Bye Bye\"\
    \ << endl;\n    }\n};\n\nint main()\n{\n    Student s1(\"\", true, 20, true);\n\
    \    s1.showInfo();\n    Student s2(\"\", false, 19, false);\n    s2.showInfo();\n\
    \    Student *ps1 = &s1;\n    Student *ps2 = &s2;\n    ps1->~Student();\n    ps2->~Student();\n\
    \    return 0;\n}#include <iostream>\n#include <string>\nusing namespace std;\n\
    int main()\n{\n    int a = 20, b = 25;\n    float c = 2.5;\n    char d = 'A';\n\
    \    bool e = false;\n    string f = \"hello\";\n\n    cout << \"a = \" << a <<\
    \ endl;\n    cout << \"b = \" << b << endl;\n    cout << \"c = \" << c << endl;\n\
    \    cout << \"d = \" << d << endl;\n    cout << \"e = \" << e << endl;\n    cout\
    \ << \"f = \" << f << endl;\n\n    return 0;\n}#include <iostream>\n#include <string>\n\
    using namespace std;\nint main()\n{\n    int a = 10;\n    a = 12.3;\n    cout\
    \ << a << endl;\n\n    int *p1 = &a;\n\n    cout << *p1 << endl;\n\n    int *p2;\n\
    \n    p2 = p1;\n\n    cout << p2 << endl;\n\n    int *p3;\n    p3 = new int;\n\
    \n    *p3 = 20;\n\n    cout << *p3 << endl;\n\n    int *p4;\n    p4 = new int;\n\
    \n    *p4 = 30;\n\n    cout << *p4 << endl;\n\n    delete p4;\n\n    p4 = new\
    \ int;\n\n    *p4 = 50;\n\n    cout << *p4 << endl;\n\n    delete p4;\n\n    return\
    \ 0;\n}#include <iostream>\n#include <string>\nusing namespace std;\nclass Student{\n\
    public:\n    string name;\n    bool isMale;\n    int age;\n    bool hasPassed;\n\
    public:\n    Student(string n = \"\", bool m = false, int a = 0, bool p = false):\
    \ name(n), isMale(m), age(a), hasPassed(p) {}\n\n    void ShowInfo()\n    {\n\
    \        cout << \"Name: \" << name << endl;\n        cout << \"Gender: \" <<\
    \ (isMale? \"Male\" : \"Female\") << endl;\n        cout << \"Age: \" << age <<\
    \ endl;\n        cout << \"Has Passed: \" << (hasPassed? \"Yes\" : \"No\") <<\
    \ endl;\n    }\n\n    ~Student()\n    {\n        cout << \"Bye Bye\" << endl;\n\
    \    }\n};\n\nint main()\n{\n    Student s1(\"\", true, 20, true);\n    s1.ShowInfo();\n\
    \    Student s2(\"\", false, 19, false);\n    s2.ShowInfo();\n    Student *ps1\
    \ = &s1;\n    Student *ps2 = &s2;\n    ps1->~Student();\n    ps2->~Student();\n\
    \    return 0;\n}#include<iostream>\nusing namespace std;\nclass A{\n    private:\n\
    \        int a = 10;\n    public:\n        A(int val){\n            a = val;\n\
    \        }\n        void showA()\n        {\n            cout << a << endl;\n\
    \        }\n};\nclass B: public A{\n    private:\n        double b = 3.1;\n  \
    \  public:\n        B(int val): A(val)\n        {\n\n        }\n        void showB()\n\
    \        {\n            cout << b << endl;\n        }\n};\nclass C: public A{\n\
    \    private:\n        char c = 'a';\n    public:\n        C(int val):A(val)\n\
    \        {\n\n        }\n        void showC()\n        {\n            cout <<\
    \ c << endl;\n        }\n};\nclass D: public B, public C{\n    private:\n    \
    \    float d = 1.2;\n    public:\n        D(int val):A(val), B(val), C(val)\n\
    \        {\n\n        }\n        void showD()\n        {\n            cout <<\
    \ d << endl;\n        }\n};\nint main()\n{\n    D obj(10);\n    obj.showA();\n\
    \    obj.showB();\n    obj.showC();\n    obj.showD();\n    return 0;\n}#include\
    \ <iostream>\n#include <string>\nusing namespace std;\nclass Rectangle{\npublic:\n\
    \    int length;\n    int breadth;\n    Rectangle(int l = 10, int b = 10): length(l),\
    \ breadth(b) {}\n    Rectangle(int b) : breadth(b)\n    {\n        length = b;\n\
    \    }\n    void ShowArea()\n    {\n        cout << breadth * length << endl;\n\
    \    }\n};\n\nint main()\n{\n    Rectangle r1(20,10);\n    r1.ShowArea();\n  \
    \  Rectangle r2(10);\n    r2.ShowArea();\n    return 0;\n}#include <iostream>"
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= {ParIn[7:1], ParOut[6:0]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule`
    egister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= {ParIn[7:1], ParOut[6:0]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule
    /ShiftRegister8_1.v
    timescale 1ns/100ps
    module ShiftR
- code: |-
    module example7_10(Clock, Reset, R, D, Q_out);
    output Q_out;
    reg Q_out;
    always @(posedge Clock or posedge Reset)
    begin
        if (R)
            Q_out <= D;
        else
            Q_out <= 0;
    end
    endmodule
- code: |-
    module example7_12(A, B, In, Out, Enable, Clock);
    input [8:0] A, B;
    input In;
    output [8:0] Out;
    input [15:0] Enable;
    input Clock;
    reg [15:0] OutReg;
    reg [8:0] OutRegTemp;
    always @(Clock) begin
        if (In == 1) begin
            if (Enable == 1) begin
                OutRegTemp <= A + B;
            end
        end
    end
    always @(OutRegTemp) begin
        OutReg <= OutRegTemp;
    end
    endmodule
    Example 7.13:
    ### Base Verilog Code:
    module example7_13(A, B, In, Out, Enable, Clock);
    input [8:0] A, B;
    input In;
    output [8:0] Out;
    input [15:0] Enable;
    input Clock;
    reg [15:0] OutReg;
    always @(Clock) begin
        if (In == 1) begin
            if (Enable == 1) begin
                OutReg <= A + B;
            end
        end
    end
    endmodule
    ### Variation Instruction:
    Modify the code to use a register to hold the value of the output.
- code: |-
    module example7_14(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
- code: "module example7_11(D, Clock, Q1, Q2);\ninput D, Clock;\noutput Q1, Q2;\n\
    reg Q1, Q2;\nalways @(posedge Clock)\nbegin\n    Q1 <= D;\n    D = D;\nend\nendmodule\n\
    ### Variation Results:\n\u2022 The results have successfully been unpacked as\
    \ expected.\n\n![example7_11_unpack](https://user-images"
- code: |-
    def main(clk_cnt,clk_period,clk_period_ms):
        clk_edge = 1
        clk_rst = 0
        clk_val = 0
        print("Program start")
        for i in range(len(clk_period)):
            if clk_period[i] >= clk_period_ms:
                clk_edge = i
                break
        for i in range(clk_cnt):
            for j in range(clk_edge):
                print("Clock signal = 0")
                time.sleep(clk_period[j]/1000)
            for k in range(clk_edge,len(clk_period)):
                print("Clock signal = 1")
                time.sleep(clk_period[k]/1000)

    main(10,clk_period,1000)
    ### Result Console Output:
    Clock signal = 0
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Clock signal = 1
    Program start
    ##### End #####
    ### Verilog Code:
    `timescale 1ns/1ps
    module example07(clk_period,clk_cnt,clk_pulse,Clock,Q1,Q2);
    input clk_period,clk_cnt, clk_pulse;
    input Clock;
    output Q1, Q2;
    reg Q1,Q2;
    int i,j,k;
    always @(posedge Clock)
    begin
    if(i < clk_cnt)
    begin
    Q1 <= clk_pulse;
    Q2 <= Q1;
    i <= i+1;
    end
    else
    begin
    i<=0;
    end
    end
    endmodule
    ##### End ######
    ### Result Code:
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posed
- code: "module example7_10(D, Clock, Q1, Q2);\ninput D, Clock;\noutput Q1, Q2;\n\
    reg Q1, Q2;\nalways @(posedge Clock)\nbegin\n\tcase(D)\n\tbegin\n\t\t0: Q1 = 1;\n\
    \t\t1: Q1 = 0;\n\t\t2: if (Q1 == 1) begin Q2 = 1; end\n\t\t3: if (Q1 == 0) begin\
    \ Q2 = 0; end\n\tend\nendmodule\n### Explanation:\nThis code is the same as example7_9\
    \ except for the addition of a case statement with an if statement inside of it.\n\
    ### Results:\nThe results shown in figure 7-32 show the results for both the original\
    \ code and the variation code. Note that the original code shows the value for\
    \ Q2 set to 0. In the variation code the value for Q2 will always be 1 based on\
    \ the if statement code within the case statement.\n### Figure 7-32: Results for\
    \ both the original code and the variation code\n![image](https://user-images.githubusercontent.com/45797314/136418144-4868e210-08c7-4978-9d5"
- code: "### Modified Verilog Code:\nmodule example7_4(D, Clock, Q1, Q2);\ninput D,\
    \ Clock;\noutput Q1, Q2;\nreg Q1, Q2;\nreg [1:0] loop;\nalways @(posedge Clock)\n\
    begin\n\tQ1 <= D;\n\tQ2 <= Q1;\n\twhile (loop < 2) begin\n\tQ2 <= Q1;\n\tloop\
    \ <= loop + 1;\nend\nend\nendmodule\n###\n###\n###\n###\n##\nInstructor's Solution\n\
    module example7_4(D, Clock, Q1, Q2);\ninput D, Clock;\noutput Q1, Q2;\nreg Q1,\
    \ Q2;\nalways @(posedge Clock)\nbegin\n    Q1 <= D;\n    Q2 <= Q1;\nend\nendmodule\n\
    ###\n###\n###\n###\n##\n5. The following circuit is fed by a clock signal named\
    \ CLK. The input signal named D is also fed by a clock signal. Its output signal\
    \ named Q is fed by a clock signal. There are three sequential circuits which\
    \ are:\nA) Q = D\nB) Q = Q\nC) Q = (!Q)\nWhat are the values of Q, when the input\
    \ D is given low, and when the input D is given high?\nA) Q=0 for D=0; Q=1 for\
    \ D=1\nB) Q=0 for D=0; Q=0 for D=1\nC) Q=0 for D=0; Q=1 for D=1\nD) Q=1 for D=0;\
    \ Q=0 for D=1\nE) Q=1 for D=0; Q=1 for D=1\nSolution: Option D\n###\n###\n###\n\
    ###\n##\nInstructor's Solution\nA: Q=0 for D=0\nB: Q=0 for D=0\nC: Q=0 for D=0\n\
    D: Q=1 for D=0\nE: Q=1 for D=0\n###\n###\n###\n###\n##"
- code: "module example7_5(D, Clock, Q1, Q2);\ninput D, Clock;\noutput Q1, Q2;\nreg\
    \ [10:1] Q1, Q2;\nalways @(posedge Clock)\nbegin\n    Q2 <= Q1[9];\n    Q1[9]\
    \ <= D;\n    Q1[9:0] <= Q1[9:1]+1;\nend\nendmodule\n### Verilog Simulator Output:\n\
    \n![Lab7-5 Output](/Lab7-5Output.PNG)\n\n\nfunction solution(N) {\n  var length\
    \ = N.toString().length;\n  var power = Math.pow(10, length - 1);\n  var array\
    \ = [];\n  var number = 0;\n\n  for (var i = 0; i < power; i++) {\n    array.push(i);\n\
    \  }\n\n  for (var i = 0; i < power; i++) {\n    if (N.toString().includes(array[i].toString()))\
    \ {\n      number = array[i];\n      break;\n    }\n  }\n\n  return +(number +\
    \ 1).toString();\n}\n## Lab 5-1: \n\n**Description:**\n\nWrite a Verilog HDL code\
    \ that simulates the circuit with 6 input bits, 6 output bits and 1 clock input/output.\n\
    \n**Base Verilog Code:**\n\nmodule ex_1(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\
    \noutput Q1, Q2;\n\nreg Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ1 <= D;\n\
    \nQ2 <= Q1;\n\nend\n\nendmodule\n\n**Variation Instruction:**\n\nAdd a while loop\
    \ condition that uses inside with a variable index applied to a packed array.\n\
    \n**Modified Code:**\n\nmodule ex_2(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\n\
    output Q1, Q2;\n\nreg [5:1] Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ2\
    \ <= Q1[5];\n\nQ1[5] <= D;\n\nQ1[5:1] <= Q1[5:2]+1;\n\nend\n\nendmodule\n\n**Verilog\
    \ Simulator Output:**\n\n![](images/5-1_1.PNG)\n\n**Lab 5-2:**\n\n**Description:**\n\
    \nWrite a Verilog HDL code that simulates the circuit with 6 input bits, 6 output\
    \ bits and 1 clock input/output.\n\n**Base Verilog Code:**\n\nmodule ex_1(D, Clock,\
    \ Q1, Q2);\n\ninput D, Clock;\n\noutput Q1, Q2;\n\nreg Q1, Q2;\n\nalways @(posedge\
    \ Clock)\n\nbegin\n\nQ1 <= D;\n\nQ2 <= Q1;\n\nend\n\nendmodule\n\n**Variation\
    \ Instruction:**\n\nAdd a while loop condition that uses inside with a variable\
    \ index applied to a packed array.\n\n**Modified Code:**\n\nmodule ex_2(D, Clock,\
    \ Q1, Q2);\n\ninput D, Clock;\n\noutput Q1, Q2;\n\nreg [5:1] Q1, Q2;\n\nalways\
    \ @(posedge Clock)\n\nbegin\n\nQ2 <= Q1[5];\n\nQ1[5] <= D;\n\nQ1[5:1] <= Q1[5:2]+1;\n\
    \nend\n\nendmodule\n\n**Verilog Simulator Output:**\n\n![](images/5-2_1.PNG)\n\
    \n**Lab 5-3:**\n\n**Description:**\n\nWrite a Verilog HDL code that simulates\
    \ the circuit with 2 input bits, 2 output bits and 1 clock input/output.\n\n**Base\
    \ Verilog Code:**\n\nmodule ex_1(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\noutput\
    \ Q1, Q2;\n\nreg Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ1 <= D;\n\nQ2\
    \ <= Q1;\n\nend\n\nendmodule\n\n**Variation Instruction:**\n\nAdd a while loop\
    \ condition that uses inside with a variable index applied to a packed array.\n\
    \n**Modified Code:**\n\nmodule ex_2(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\n\
    output Q1, Q2;\n\nreg [1:0] Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ2\
    \ <= Q1[1];\n\nQ1[1] <= D;\n\nQ1[1:0] <= Q1[1:1]+1;\n\nend\n\nendmodule\n\n**Verilog\
    \ Simulator Output:**\n\n![](images/5-3_1.PNG)\n\n**Lab 5-4:**\n\n**Description:**\n\
    \nWrite a Verilog HDL code that simulates the circuit with 10 input bits, 10 output\
    \ bits and 1 clock input/output.\n\n**Base Verilog Code:**\n\nmodule ex_1(D, Clock,\
    \ Q1, Q2);\n\ninput D, Clock;\n\noutput Q1, Q2;\n\nreg Q1, Q2;\n\nalways @(posedge\
    \ Clock)\n\nbegin\n\nQ1 <= D;\n\nQ2 <= Q1;\n\nend\n\nendmodule\n\n**Variation\
    \ Instruction:**\n\nAdd a while loop condition that uses inside with a variable\
    \ index applied to a packed array.\n\n**Modified Code:**\n\nmodule ex_2(D, Clock,\
    \ Q1, Q2);\n\ninput D, Clock;\n\noutput Q1, Q2;\n\nreg [9:1] Q1, Q2;\n\nalways\
    \ @(posedge Clock)\n\nbegin\n\nQ2 <= Q1[9];\n\nQ1[9] <= D;\n\nQ1[9:1] <= Q1[9:2]+1;\n\
    \nend\n\nendmodule\n\n**Verilog Simulator Output:**\n\n![](images/5-4_1.PNG)\n\
    \n**Lab 5-5:**\n\n**Description:**\n\nWrite a Verilog HDL code that simulates\
    \ the circuit with 10 input bits, 10 output bits and 1 clock input/output.\n\n\
    **Base Verilog Code:**\n\nmodule ex_1(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\n\
    output Q1, Q2;\n\nreg Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ1 <= D;\n\
    \nQ2 <= Q1;\n\nend\n\nendmodule\n\n**Variation Instruction:**\n\nAdd a while loop\
    \ condition that uses inside with a variable index applied to a packed array.\n\
    \n**Modified Code:**\n\nmodule ex_2(D, Clock, Q1, Q2);\n\ninput D, Clock;\n\n\
    output Q1, Q2;\n\nreg [9:1] Q1, Q2;\n\nalways @(posedge Clock)\n\nbegin\n\nQ2\
    \ <= Q1[9];\n\nQ1[9] <= D;\n\nQ1[9:1] <= Q1[9:2]+1;\n\nend\n\nendmodule\n\n**Verilog\
    \ Simulator Output:**\n\n![](images/5-5_1.PNG)\n\n## Chapter 2 Quiz 2.3.11\n\n\
    Question:\n\nWhat is the time complexity of a linked list for inserting a new\
    \ node at the end of the list?\n\n- O(1)\n- O(n)\n- O(n2)\n- O(log n)\n\nCorrect\
    \ Answer: O(n)## Lab 11-1: \n\n**Description:**\n\nWrite a Ver"
- code: "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int i = 0;\n\
    \    int n = 10;\n    int my_array[n][3] = {0};\n    \n    for (i = 0; i < n;\
    \ i++) {\n        int packed_array[3] = {0};\n        packed_array[0] = i;\n \
    \       packed_array[1] = i + i + 1;\n        packed_array[2] = i + i + i + 1;\n\
    \        my_array[i] = packed_array;\n    }\n\n    for (i = 0; i < n; i++) {\n\
    \        printf(\"Array location: [%d][%d], 0: %d, 1: %d, 2: %d\\n\", i, 0, my_array[i][0],\
    \ my_array[i][1], my_array[i][2]);\n    }\n\n\treturn 0;\n}\n\n#include <iostream>\n\
    #include <stdlib.h>\n\nusing namespace std;\n\nint main() {\n    int i = 0;\n\
    \    int n = 10;\n    int my_array[n][3] = {0};\n\n    for (i = 0; i < n; i++)\
    \ {\n        int packed_array[3] = {0};\n        packed_array[0] = i;\n      \
    \  packed_array[1] = i + i + 1;\n        packed_array[2] = i + i + i + 1;\n  \
    \      my_array[i] = packed_array;\n    }\n\n    for (i = 0; i < n; i++) {\n \
    \       cout << \"Array location: [\" << i << \"][\" << 0 << \"], 0: \" << my_array[i][0]\
    \ << \", 1: \" << my_array[i][1] << \", 2: \" << my_array[i][2] << \"\\n\";\n\
    \    }\n\n\treturn 0;\n}\n\n### Results:\n##### C Code\nArray location: [0][0],\
    \ 0: 0, 1: 0, 2: 0\nArray location: [1][0], 0: 1, 1: 2, 2: 3\nArray location:\
    \ [2][0], 0: 2, 1: 4, 2: 6\nArray location: [3][0], 0: 3, 1: 6, 2: 9\nArray location:\
    \ [4][0], 0: 4, 1: 8, 2: 12\nArray location: [5][0], 0: 5, 1: 10, 2: 15\nArray\
    \ location: [6][0], 0: 6, 1: 12, 2: 18\nArray location: [7][0], 0: 7, 1: 14, 2:\
    \ 21\nArray location: [8][0], 0: 8, 1: 16, 2: 24\nArray location: [9][0], 0: 9,\
    \ 1: 18, 2: 27\n##### Verilog Code\n```\nmodule example7_4(D, Clock, Q1, Q2);\n\
    input D, Clock;\noutput Q1, Q2;\nreg Q1, Q2;\nalways @(posedge Clock)\n    begin\n\
    \        Q1 <= D;\n        Q2 <= Q1;\n    end\nendmodule\n```\n### Results:\n\
    ##### C Code\nArray location: [0][0], 0: 0, 1: 0, 2: 0\nArray location: [1][0],\
    \ 0: 1, 1: 2, 2: 3\nArray location: [2][0], 0: 2, 1: 4, 2: 6\nArray location:\
    \ [3][0], 0: 3, 1: 6, 2: 9\nArray location: [4][0], 0: 4, 1: 8, 2: 12\nArray location:\
    \ [5][0], 0: 5, 1: 10, 2: 15\nArray location: [6][0], 0: 6, 1: 12, 2: 18\nArray\
    \ location: [7][0], 0: 7, 1: 14, 2: 21\nArray location: [8][0], 0: 8, 1: 16, 2:\
    \ 24\nArray location: [9][0], 0: 9, 1: 18, 2: 27\n##### Verilog Code\n```\nmodule\
    \ example7_4(D, Clock, Q1, Q2);\ninput D, Clock;\noutput Q1, Q2;\nreg Q1, Q2;\n\
    always @(posedge Clock)\n    begin\n        Q1 <= D;\n        Q2 <= Q1;\n    end\n\
    endmodule\n```\n\n```\n$ gcc -o output.out output.c\n$./output.out\nArray location:\
    \ [0][0], 0: 0, 1: 0, 2: 0\nArray location: [1][0], 0: 1, 1: 2, 2: 3\nArray location:\
    \ [2][0], 0: 2, 1: 4, 2: 6\nArray location: [3][0], 0: 3, 1: 6, 2: 9\nArray location:\
    \ [4][0], 0: 4, 1: 8, 2: 12\nArray location: [5][0], 0: 5, 1: 10, 2: 15\nArray\
    \ location: [6][0], 0: 6, 1: 12, 2: 18\nArray location: [7][0], 0: 7, 1: 14, 2:\
    \ 21\nArray location: [8][0], 0: 8, 1: 16, 2: 24\nArray location: [9][0], 0: 9,\
    \ 1: 18, 2: 27\n```\n\n```\n$ i++ # i = 10, n = 10\n$ while [ $i -lt $n ] && [\
    \ $i -ge 0 ] ; do echo i=$i; i++; done\ni=10\ni=9\ni=8\ni=7\ni=6\ni=5\ni=4\ni=3\n\
    i=2\ni=1\ni=0\n```\n\n```\n$ gcc -o output.out output.c\n$./output.out\nArray\
    \ location: [0][0], 0: 0, 1: 0, 2: 0\nArray location: [1][0], 0: 1, 1: 2, 2: 3\n\
    Array location: [2][0], 0: 2, 1: 4, 2: 6\nArray location: [3][0], 0: 3, 1: 6,\
    \ 2: 9\nArray location: [4][0], 0: 4, 1: 8, 2: 12\nArray location: [5][0], 0:\
    \ 5, 1: 10, 2: 15\nArray location: [6][0], 0: 6, 1: 12, 2: 18\nArray location:\
    \ [7][0], 0: 7, 1: 14, 2: 21\nArray location: [8][0], 0: 8, 1: 16, 2: 24\nArray\
    \ location: [9][0], 0: 9, 1: 18, 2: 27\n```\n\n```\n$ i-- # i = -1, n = 10\n$\
    \ while [ $i -lt $n -gt 0 ] && [ $i -ge 0 ] ; do echo i=$i; i--; done\ni=-1\n\
    i=-2\ni=-3\ni=-4\ni=-5\ni=-6\ni=-7\ni=-8\ni=-9\ni=-10\n```\n\n```\n$ i++ # i =\
    \ 10, n = 10\n$ while [ $i -lt $n ] && [ $i -ge 0 ] ; do echo i=$i; i++; done\n\
    i=10\n```\n\n```\n$ i-- # i = -1, n = 10\n$ while [ $i -lt $n -gt 0 ] && [ $i\
    \ -ge 0 ] ; do echo i=$i; i--; done\ni=-1"
- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
- code: |-
    module FA;
        output [8:0] sum_out;
        input [8:0] a, b;
        reg [8:0] sum_out;

        always @ (a, b) begin
            sum_out = a + b;
        end
    endmodule

    module Ripple_Add;
        FA fa0(.a(a_0[7:0]),.b(b_0[7:0]));
        FA fa1(.a(a_1[7:0]),.b(b_1[7:0]),.sum_out(a_0[7:0]));
    endmodule### Verilog Behavioral Code:
    module FA;
        output [8:0] sum_out;
        input [8:0] a, b;
        reg [8:0] sum_out;

        always @ (a, b) begin
            sum_out = a + b;
        end
    endmodule

    module Ripple_Add;
        FA fa0(.a(a_0[7:0]),.b(b_0[7:0]));
        FA fa1(.a(a_1[7:0]),.b(b_1[7:0]),.sum_out(a_0[7:0]));
    endmodule
    ### C++ Code:
    `int n = 8;
    int a_0[n], b_0[n], a_1[n], b_1[n];
    int sum[n];
    for(int i=0; i<n; i++) {
        a_0[i] = a_1[i-1];
        b_0[i] = b_1[i-1];
        a_1[i] = a_0[i];
        b_1[i] = 0;
    }
    for(int i=0; i<n; i++) {
        int sum_out = a_0[i] + b_0[i];
        a_0[i] = a_1[i];
        b_0[i] = 0;
        a_1[i] = sum_out;
    }
    `### Test Script:
    ```
    import random
    import numpy as np

    def verify(a, b, res):
        for i in range(7, 8):
            if a[i]!=res[i]:
                print("*"*10)
                print(a)
                print(b)
                print(res)
                print(i)
                return False
        return True

    n = 8
    a_0 = []
    b_0 = []
    a_1 = []
    b_1 = []
    for i in range(n):
        a_0.append(random.randint(0, 100))
        b_0.append(random.randint(0, 100))
        a_1.append(random.randint(0, 100))

    sum = []
    for i in range(n):
        sum.append(a_0[i]+b_0[i])

    for i in range(n):
        a_1[i] = a_0[i]

    for i in range(n):
        b_1[i] = 0

    for i in range(n):
        a_0[i] = a_1[i]
        b_0[i] = 0
        a_1[i] = sum[i]

    print(verify(a_0, b_0, sum))
    ```#### Verilog Test:
    ```
    `timescale 1ns / 1ps

    module FA;
        output [8:0] sum_out;
        input [8:0] a, b;
        reg [8:0] sum_out;

        always @ (a, b) begin
            sum_out = a + b;
        end
    endmodule

    module Ripple_Add;
        FA fa0(.a(a_0[7:0]),.b(b_0[7:0]));
        FA fa1(.a(a_1[7:0]),.b(b_1[7:0]),.sum_out(a_0[7:0]));
    endmodule

    `timescale 1ps / 1ps

    module test_FA;
        initial begin
            $monitor($fwrite("a_0=%0d, b_0=%0d, a_1=%0d, b_1=%0d, sum=%0d\n", a_0, b_0, a_1, b_1, sum));
            $monitor($fwrite("a_0=%0d, b_0=%0d, a_1=%0d, b_1=%0d, sum=%0d\n", a_0[1:0], b_0[1:0], a_1[1:0], b_1[1:0], sum[1:0]));
        end
    endmodule
    `include "FA.v"
    `include "Ripple_Add.v"
    `include "test_FA.v"

    `default_nettypewire

    module test_Ripple_Add_top;
        Ripple_Add_top r_a_0(.inst_fa0,.inst_fa1);
    endmodule`
    ```a = []
    b = []
    for i in range(8):
        a.append([])
        b.append([])
        for j in range(8):
            a[i].append(random.randint(0, 100))
            b[i].append(random.randint(0, 100))
    print(a)
    print(b)
    sum = np.zeros([8,8])
    for i in range(7):
        sum[i+1] = sum[i] + a[i+1] + b[i+1]
    sum[7] = sum[6] + a[7] + b[7]
    print(sum)
    a[0] = sum[0]
    a[0] = sum[0]
    a[0] = sum[0]
    a[0] = sum[0]
    a[7] = sum[7]
    a[7] = sum[7]
    a[7] = sum[7]
    a[7] = sum[7]
    print(a)
    print(b)[[  0.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]
     [ 26.   0.   0.   0.   0.   0.   0.   0.]]
    [[ 11.   0.   0.   0.   0.   0.   0.   0.]
     [ 11.  11.   0.   0.   0.   0.   0.   0.]
     [ 11.  11.  11.   0.   0.   0.   0.   0.]
     [ 11.  11.  11.  11.   0.   0.   0.   0.]
     [ 11.  11.  11.  11.  11.   0.   0.   0.]
     [ 11.  11.  11.  11.  11.  11.   0.   0.]
     [ 11.  11.  11.  11.  11.  11.  11.   0.]
     [ 11.  11.  11.  11.  11.  11.  11.  11.]]
- code: |-
    module FA;
        output [3:0] A;
        input [3:0] B;
        output [3:0] Z;
        // output [3:0] S;
        wire [3:0] S;
        wire [3:0] C;

        always @(A or B) begin
            Z = A + B;
        end

        always@(A or B) begin
            S = A & B;
            C = A ^ B;
        end
    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();

    endmodule

    ### Expected Behavior:
    The test should pass.

    ### Actual Behavior:
    The test fails.

    ### Steps To Reproduce:
    1.  Change the always block of FA to
        always@(A or B) begin
            Z = A + B;
        end
    2.  Rerun the test

    ### System Information
- code: "```\n## 4.2.1\nmodule FA;\n    parameter type_width    = 4,\n    parameter\
    \ input_width  = type_width + 5,\n    parameter output_width = type_width * 2\n\
    \    ; \n    wire [input_width-1:0] in, out;\n    wire [output_width-1:0] sout;\n\
    \    input  [type_width-1:0] i;\n    parameter  [type_width-1:0] i_sum, i_carry;\n\
    \    output  [type_width-1:0] o, s;\n    # 3 #\n    always @* begin\n        #\
    \ 3 #\n        case (i)\n            i_sum: o = i ^ s;\n            i_carry: o\
    \ = ~i & s;\n        endcase\n    end\n# 3 #\nendmodule\n\n## 4.2.2\nmodule Ripple_Add;\n\
    \    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA fa3();\nendmodule\n\n## 4.3.1\n\
    module FA;\n    parameter type_width    = 4,\n    parameter input_width  = type_width\
    \ + 5,"
- code: "module FA;\n    output [31:0]sum,carry;\n\n    wire a_input;\n    wire b_input;\n\
    \    wire carry_input;\n\n    reg [31:0]a, b;\n    reg [31:0]carry_in;\n\n   \
    \ assign sum = a+b+carry_in;\n    assign carry = a*b*carry_in;\n    \n    assign\
    \ a_input = a;\n    assign b_input = b;\n    assign carry_input = carry;\n\nendmodule\n\
    \nmodule Ripple_Add;\n    reg [31:0]a,b;\n    reg [31:0]carry_in;\n\n    FA fa0(.a(a),.b(b),.carry_in(carry_in),.sum(a+b),.carry(carry_in*b));\n\
    \    FA fa1(.a(a),.b(b),.carry_in(carry_in),.sum(a+b),.carry(carry_in*b));\n \
    \   FA fa2(.a(a),.b(b),.carry_in(carry_in),.sum(a+b),.carry(carry_in*b));\n  \
    \  FA fa3(.a(a),.b(b),.carry_in(carry_in),.sum(a+b),.carry(carry_in*b));\n\nendmodule\n\
    /06_2_21_89/src/test/java/com/github/viveksb96/verilog_veri_test/testcases/Test_Combinational_Assign.java\n\
    package com.github.viveksb96.verilog_veri_test.testcases;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\
    import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.github.viveksb96.verilog_veri_test.testcase.TestCase;\n\
    import com.github.viveksb96.verilog_veri_test.testmodel.TestModel;\nimport com.github.viveksb96.verilog_veri_test.testmodel.TestModelVisitor;\n\
    import org.junit.jupiter.api.TestInstance;\nimport org.junit.jupiter.params.ParameterizedTest;\n\
    import org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\
    \nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.HashMap;\n\
    import java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Stream;\n\
    \nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n\
    public class Test_Combinational_Assign {\n    public static Stream<Arguments>\
    \ test_data() throws IOException {\n        ObjectMapper mapper = new ObjectMapper(new\
    \ YAMLFactory());\n        // TODO: This has been tested only for 820. Please\
    \ test the rest\n        Map<String, Map<String, String>> yaml_data = mapper.readValue(Test_Combinational_Assign.class.getResourceAsStream(\"\
    /testcases/test_combinational_assign.yaml\"), Map.class);\n        Set<Map.Entry<String,\
    \ Map<String, String>>> entrySet = yaml_data.entrySet();\n        Collection<Map.Entry<String,\
    \ Map<String, String>>> testcases = entrySet;\n        return Stream.concat(\n\
    \                Stream.of(Arguments.of(\"testcases/test_combinational_assign.yaml\"\
    , yaml_data)),\n                testcases.stream().map(entry -> Arguments.of(entry.getKey(),\
    \ entry.getValue())))\n               .map(tc -> new Arguments[]{tc});\n    }\n\
    \n    @ParameterizedTest\n    @MethodSource(\"test_data\")\n    public void test_combinational_assign(String\
    \ file, Map<String, Map<String, String>> yaml_data) throws IOException {\n   \
    \     TestCase testCase = new TestCase(file, yaml_data);\n        TestModel testModel\
    \ = testCase.loadTestModel();\n        assertTrue(testModel.accept(new TestModelVisitor()\
    \ {\n            @Override\n            public void visit(org.jundge.ast.ast.ModuleDeclaration\
    \ moduleDeclaration) {\n                {\n                    // No need to do\
    \ anything, as input/output variables are\n                    // already added\
    \ to the TestModel\n                }\n            }\n\n            @Override\n\
    \            public void visit(org.jundge.ast.ast.InputDeclaration inputDeclaration)\
    \ {\n                inputDeclaration.getValue().accept(new TestModelVisitor()\
    \ {\n                    @Override\n                    public void visit(org.jundge.ast.ast.Identifier\
    \ identifier) {\n                        Test_Combinational_Assign.this.add_input(identifier.getValue());\n\
    \                    }\n\n                    @Override\n                    public\
    \ void visit(org.jundge.ast.ast.Constant constant) {\n                       \
    \ Test_Combinational_Assign.this.add_input(constant.getValue());\n           \
    \         }\n                });\n            }\n\n            @Override\n   \
    \         public void visit(org.jundge.ast.ast.OutputDeclaration outputDeclaration)\
    \ {\n                outputDeclaration.getValue().accept(new TestModelVisitor()\
    \ {\n                    @Override\n                    public void visit(org.jundge.ast.ast.Identifier\
    \ identifier) {\n                        Test_Combinational_Assign.this.add_output(identifier.getValue());\n\
    \                    }\n\n                    @Override\n                    public\
    \ void visit(org.jundge.ast.ast.Constant constant) {\n                       \
    \ Test_Combinational_Assign.this.add_output(constant.getValue());\n          \
    \          }\n                });\n            }\n\n            @Override\n  \
    \          public void visit(org.jundge.ast.ast.ParameterDeclaration parameterDeclaration)\
    \ {\n                parameterDeclaration.getValue().accept(new TestModelVisitor()\
    \ {\n                    @Override\n                    public void visit(org.jundge.ast.ast.Identifier\
    \ identifier) {\n                        Test_Combinational_Assign.this.add_parameter(identifier.getValue());\n\
    \                    }\n\n                    @Override\n                    public\
    \ void visit(org.jundge.ast.ast.Constant constant) {\n                       \
    \ Test_Combinational_Assign.this.add_parameter(constant.getValue());\n       \
    \             }\n                });\n            }\n\n            @Override\n\
    \            public void visit(org.jundge.ast.ast.LocalParameterDeclaration localParameterDeclaration)\
    \ {\n                localParameterDeclaration.getValue().accept(new TestModelVisitor()\
    \ {\n                    @Override\n                    public void visit(org.jundge.ast.ast.Identifier\
    \ identifier) {\n                        Test_Combinational_Assign.this.add_local_parameter(identifier.getValue());\n\
    \                    }\n\n                    @Override\n                    public\
    \ void visit(org.jundge.ast.ast.Constant constant) {\n                       \
    \ Test_Combinational_Assign.this.add_local_parameter(constant.getValue());\n \
    \                   }\n                });\n            }\n\n            @Override\n\
    \            public void visit(org.jundge.ast.ast.ParameterValue parameterValue)\
    \ {\n                // Nothing to do as this is handled during module declaration\n\
    \                // @Override\n                // public void visit(org.jundge.ast.ast.Identifier\
    \ identifier) {\n                //\n            }\n\n            @Override\n\
    \            public void visit(org.jundge.ast.ast.Constant constant) {\n     \
    \           // Nothing to do as this is handled during module declaration\n  \
    \              // @Override\n                // public void visit(org.jundge.ast.ast.Constant\
    \ constant) {\n                //\n            }\n\n            @Override\n  \
    \          public void visit(org.jundge.ast.ast.CombinationalAssignment combinationalAssignment)\
    \ {\n                // Combinational assignment is handled during test case load\n\
    \                // @Override\n                // public void visit(org.jundge.ast.ast.CombinationalAssignment\
    \ combinationalAssignment) {\n                //\n            }\n\n          \
    \  @Override\n            public void visit(org.jundge.ast.ast.SequentialAssignment\
    \ sequentialAssignment) {\n                // Sequential assignment is handled\
    \ during test case load\n                // @Override\n                // public\
    \ void visit(org.jundge.ast.ast.SequentialAssignment sequentialAssignment) {\n\
    \                //\n            }\n        }));\n    }\n\n    private void add_input(String\
    \ name) {\n        if (!in_outputs.containsKey(name)) {\n            in_outputs.put(name,\
    \ 0);\n        }\n        in_outputs.put(name, in_outputs.get(name) + 1);\n  \
    \  }\n\n    private void add_output(String name) {\n        if (!in_outputs.containsKey(name))\
    \ {\n            in_outputs.put(name, 0);\n        }\n        in_outputs.put(name,\
    \ in_outputs.get(name) + 1);\n    }\n\n    private void add_parameter(String name)\
    \ {\n        if (!in_outputs.containsKey(name)) {\n            in_outputs.put(name,\
    \ 0);\n        }\n        in_outputs.put(name, in_outputs.get(name) + 1);\n  \
    \  }\n\n    private void add_local_parameter(String name) {\n        if (!in_outputs.containsKey(name))\
    \ {\n            in_outputs.put(name, 0);\n        }\n        in_outputs.put(name,\
    \ in_outputs.get(name) + 1);\n    }\n\n    Map<String, Integer> in_outputs = new\
    \ HashMap<>();\n}\n/06_2_21_89/src/test/resources/testcases/test_module.c\nclass\
    \ FA\n{\n    int a;\n    int b;\n    int c;\n}"
- code: "```\nmodule Ripple_Add;\n    reg  [7:0] A, B; \n    reg  [15:0] C;\n    reg\
    \  [7:0] S;\n    wire [7:0] M;\n    \n    FA fa[4];\n    \n    always @* \n  \
    \  begin\n        C = A + B;\n    end\n    \n    for (int i = 0; i < 4; i = i\
    \ + 1) begin: fa_loop\n        fa[i] = FA();\n        fa[i].A = 8'h0;\n      \
    \  fa[i].B = 8'h1;\n        fa[i].OP = i;\n    end\n    \n    FA fa_1 = FA();\n\
    \    FA fa_2 = FA();\n    FA fa_3 = FA();\n    \n    assign S = fa_1.S + fa_2.S;\n\
    \    assign M = fa_3.S;\n    \n    `DESIGN_UNIT_REGISTER_PARTS(\n        \"FA_MOD\"\
    ,\n        0,\n        \"A\",\n        \"A\",\n        8,\n        \"FA_MOD_A\"\
    ,\n        \"FA_MOD_A\",\n        8,\n        \"FA_MOD_B\",\n        \"FA_MOD_B\"\
    ,\n        8,\n        \"FA_MOD_S\",\n        \"FA_MOD_S\",\n        8,\n    \
    \    \"FA_MOD_O\",\n        \"FA_MOD_O\",\n        0\n    )\n    `DESIGN_UNIT_REGISTER_PARTS(\n\
    \        \"FA_0\",\n        0,\n        \"A\",\n        \"FA_0_A_N_Q\",\n    \
    \    \"FA_0_A_N_D\",\n        \"FA_0_A_N_D\",\n        8,\n        \"B\",\n  \
    \      \"FA_0_B_N_Q\",\n        \"FA_0_B_N_D\",\n        \"FA_0_B_N_D\",\n   \
    \     8,\n        \"S\",\n        \"FA_0_S_N_Q\",\n        \"FA_0_S_N"
- code: |-
    module FA;
        reg [14:0] A;
        reg [14:0] B;
        reg [14:0] S;
        reg [13:0] C;
        reg [31:0] R;
        reg [31:0] C_out;
        reg [30:0] S_out;
        reg [30:0] C_S_out;
        reg [1:0] C_in;
        reg [5:0] S_in;
        reg [7:0] C_S_in;
        reg [1:0] C_S_in_1;
        reg [7:0] C_S_in_2;
        reg [2:0] C_S_in_3;
        reg [4:0] S_in_1;
        reg [4:0] S_in_2;
        reg [4:0] S_in_3;

        always @(posedge clk)
        begin
            C_out <= C;
            S_out <= S;
            C_S_out <= C_S;
            C_in <= 1'b0;
            S_in <= 1'b0;
            C_S_in <= 1'b0;
            S_in_1 <= 1'b0;
            S_in_2 <= 1'b0;
            S_in_3 <= 1'b0;
            C_S_in_1 <= 1'b0;
            C_S_in_2 <= 1'b0;
            C_S_in_3 <= 1'b0;
            C_S_in <= C_S;

            if (C_S!= 0) begin
                C_in <= C_S[4];
                S_in <= 4'b0;
                if(C_S[4:3] == 4'b01) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 >> 1;
                end
                else if(C_S[4:3] == 4'b10) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b11) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b100) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b110) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b101) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b111) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b1100) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b1010) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                else if(C_S[4:3] == 4'b1111) begin
                    S_in_1 <= S;
                    S_in_2 <= S_in_1;
                    S_in_3 <= S_in_2;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                    S_in <= S_in_3 << 1;
                end
                C_S_in <= {C_S[4:0], S_in[1:0]};
            end

            A <= R[14:2];
            B <= R[13:0];
            S <= S_in_3;
            C <= C_in;
            C_S <= C_S_in;

            if (A == B) begin
                S_out <= 15'h0;
                C_out <= 1'b0;
                C_S_out <= 2'b00;
            end
            else if(A[15] == 1'b1) begin
                fa0: FA #(1'b1) FA0(A, B, S, C, C_S_out, S_out);
                fa1: FA #(1'b1) FA1(A, B, S, C, C_S_out, S_out);
                fa2: FA #(1'b1) FA2(A, B, S, C, C_S_out, S_out);
                fa3: FA #(1'b1) FA3(A, B, S, C, C_S_out, S_out);
            end
            else begin
                fa0: FA #(1'b0) FA0(A, B, S, C, C_S_out, S_out);
                fa1: FA #(1'b0) FA1(A, B, S, C, C_S_out, S_out);
                fa2: FA #(1'b0) FA2(A, B, S, C, C_S_out, S_out);
                fa3: FA #(1'b0) FA3(A, B, S, C, C_S_out, S_out);
            end
        end
    endmodule
- code: |-
    module FA;
    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();

        assign fa0.A = fa1.A;
        assign fa0.B = fa1.B;
        assign fa0.C = fa1.C;
        assign fa0.D = fa1.D;

        assign fa1.A = fa2.A;
        assign fa1.B = fa2.B;
        assign fa1.C = fa2.C;
        assign fa1.D = fa2.D;

        assign fa2.A = fa3.A;
        assign fa2.B = fa3.B;
        assign fa2.C = fa3.C;
        assign fa2.D = fa3.D;

        assign fa3.A = fa0.C;
        assign fa3.B = fa0.D;
        assign fa3.C = fa0.D;
        assign fa3.D = fa0.C;
    endmodule

    The following is the instruction:

    ```
    python3 fuzz.py Fuzz_Ripple_Add.v 1000
    ```

    The result is as follows:

    ```
    python3 fuzz.py Fuzz_Ripple_Add.v 1000

    # Start!
    # Initializing...

    .
    .
    .

    FA fa0();
    FA fa1();
    FA fa2();
    FA fa3();

    assign fa0.A = fa1.A;
    assign fa0.B = fa1.B;
    assign fa0.C = fa1.C;
    assign fa0.D = fa1.D;

    assign fa1.A = fa2.A;
    assign fa1.B = fa2.B;
    assign fa1.C = fa2.C;
    assign fa1.D = fa2.D;

    assign fa2.A = fa3.A;
    assign fa2.B = fa3.B;
    assign fa2.C = fa3.C;
    assign fa2.D = fa3.D;

    assign fa3.A = fa0.C;
    assign fa3.B = fa0.D;
    assign fa3.C = fa0.D;
    assign fa3.D = fa0.C;

    # End!
    ```
    ## Result

    The result is in directory Result.

    ## Reference
    The Ripple_Add module comes from Verilog HDL of the book Verilog Design Principles: A Practical Approach by,.#!/usr/bin/env python3

    import random
    import sys

    def print_code(filename, num):
        f = open(filename, 'w')

        for i in range(num):
            if i % 10 == 0:
                f.write('\n')
            f.write('fa%d();\n' % i)

        f.write('\n')

        for i in range(num):
            for j in range(i+1, num):
                if random.random() < 0.3:
                    f.write('assign fa%d.A = fa%d.B;\n' % (i, j))
                if random.random() < 0.5:
                    f.write('assign fa%d.A = fa%d.D;\n' % (i, j))

        for i in range(num):
            for j in range(i+1, num):
                if random.random() < 0.5:
                    f.write('assign fa%d.B = fa%d.A;\n' % (i, j))
                if random.random() < 0.3:
                    f.write('assign fa%d.B = fa%d.C;\n' % (i, j))

        for i in range(num):
            for j in range(i+1, num):
                if random.random() < 0.5:
                    f.write('assign fa%d.C = fa%d.B;\n' % (i, j))
                if random.random() < 0.6:
                    f.write('assign fa%d.C = fa%d.D;\n' % (i, j))

        for i in range(num):
            for j in range(i+1, num):
                if random.random() < 0.6:
                    f.write('assign fa%d.D = fa%d.A;\n' % (i, j))
                if random.random() < 0.3:
                    f.write('assign fa%d.D = fa%d.C;\n' % (i, j))

        f.close()

    if __name__ == '__main__':
        if len(sys.argv) == 2:
            num = int(sys.argv[1])
            print_code('Fuzz_Ripple_Add.v', num)
        else:
            print('Error: wrong input!!')
            sys.exit(0)

    #!/usr/bin/env python3

    import sys
    import os
    from copy import deepcopy

    def fuzz_code(filename):
        f = open(filename, 'r')
        code = f.readlines()
        f.close()

        modules = []
        for i in range(len(code)):
            code[i] = code[i].replace('\n', '')
            if code[i].startswith('module'):
                module = code[i]
                index = code.index('.endmodule', i)
                sub_code = code[i+1:index]
                modules.append([module, sub_code])
                code[i] = ''

        sub_code = []
        for module in modules:
            sub_code.append([module[0], deepcopy(module[1])])

        for i in range(len(modules)):
            for j in range(i+1, len(modules)):
                if random.random() < 0.3:
                    sub_code[i][1].extend(sub_code[j][1])
                    sub_code.pop(j)
                    break

        for i in range(len(modules)):
            f = open(filename, 'w')
            for j in range(len(code)):
                f.write(code[j]+'\n')
            f.write(sub_code[i][0]+'\n')
            for j in range(len(sub_code[i][1])):
                f.write(sub_code[i][1][j]+'\n')
            f.write('endmodule\n')
            f.close()

    if __name__ == '__main__':
        if len(sys.argv) == 2:
            num = int(sys.argv[1])
            for i in range(num):
                fuzz_code('Fuzz_Ripple_Add.v')
        else:
            print('Error: wrong input!!')
            sys.exit(0)# Fuzzing

    The `Fuzzing` folder contains all the fuzzing-related experiments.

    ## Contents

    * CodeFuzzing
    * Symbolic Execution
    * Variation Instruction Fuzzing

    ## CodeFuzzing

    The CodeFuzzing folder contains the implementation of the code fuzzer with the following characteristics:

    * Replacement of Verilog HDL code with random code.
    * Replace the code for different modules in one Verilog HDL with random code.
    * Replace the operator in a Verilog HDL with random code.

    The Code of the Verilog HDL code that the code fuzzer is used to fuzz is in `Sample_Code`.

    The code fuzzer is in the following folders:

    * CodeFuzzing_1
    * CodeFuzzing_2
    * CodeFuzzing_3
    * CodeFuzzing_4
    * CodeFuzzing_5

    ## Symbolic Execution

    The `Symbolic_Execution` folder contains the implementation of the program fuzzer.

    The program fuzzer is in the following folders:

    * ProgramFuzzing_1
    * ProgramFuzzing_2
    * ProgramFuzzing_3

    ## Variation Instruction Fuzzing

    The `Variation_Instruction_Fuzzing` folder contains the implementation of the variation instruction fuzzer.

    The variation instruction fuzzer is in the following folders:

    * VariationInstruction_1
    * VariationInstruction_2
    * VariationInstruction_3
    * VariationInstruction_4

    ## Reference

    * The project is in the Verilog HDL of the book Verilog Design Principles: A Practical Approach by,.
- code: |-
    module FA;
        output reg a0, b0, c0;
        input wire a0, b0, c0;
        reg [3:0] a0_in, b0_in;
        reg [3:0] c0_out, a0_out, b0_out;
        wire [3:0] c0_out_reg, a0_out_reg, b0_out_reg;
        assign c0_out_reg[0], a0;
        assign c0_out_reg[1], b0;
        assign a0_out_reg[0], c0;

    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();

        always @(*)
            fa0.a0_in <= a0;
            fa0.b0_in <= b0;
        always @(fa0.c0_out_reg, fa0.a0_out_reg[0], fa0.b0_out_reg[0])
            fa1.a0 <= fa0.c0_out_reg;
        always @(fa0.c0_out_reg, fa0.a0_out_reg[0], fa0.b0_out_reg[0])
            fa1.b0 <= fa0.a0_out_reg;
        always @(fa1.c0_out_reg, fa1.a0_out_reg[0], fa1.b0_out_reg[0])
            fa2.a0 <= fa1.c0_out_reg;
        always @(fa1.c0_out_reg, fa1.a0_out_reg[0], fa1.b0_out_reg[0])
            fa2.b0 <= fa1.a0_out_reg;
        always @(fa2.c0_out_reg, fa2.a0_out_reg[0], fa2.b0_out_reg[0])
            fa3.a0 <= fa2.c0_out_reg;
        always @(fa2.c0_out_reg, fa2.a0_out_reg[0], fa2.b0_out_reg[0])
            fa3.b0 <= fa2.a0_out_reg;
    endmodule
    ### Expected Results:
    The expected output should be equal to the expected output in the top module of the example design.

    ## 14-bit Adder (Part Selection)
    ## Example Verilog Code:
    module FA;
        output reg a0, b0, c0;
        input wire a0, b0, c0;
        reg [3:0] a0_in, b0_in;
        reg [3:0] c0_out, a0_out, b0_out;
        wire [3:0] c0_out_reg, a0_out_reg, b0_out_reg;
        assign c0_out_reg[0], a0;
        assign c0_out_reg[1], b0;
        assign a0_out_reg[0], c0;

    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();

        always @(*)
            fa
- code: "module FA;\n\tinput[1:0] D;\n\tinput S;\n\toutput reg Q;\n\n\talways @(D,S)\
    \ begin\n\t\tif (D[1]) begin\n\t\t\tQ = ~S;\n\t\tend else begin\n\t\t\tif (D[0])\
    \ begin\n\t\t\t\tQ = ~S;\n\t\t\tend else begin\n\t\t\t\tQ = ~Q;\n\t\t\tend\n\t\
    \tend\n\tend\nendmodule\n\nmodule Ripple_Add;\n\tFA fa0();\n\tFA fa1();\n\tFA\
    \ fa2();\n\tFA fa3();\nendmodule\n\nmodule FA;\n\tinput[1:0]"
- code: "module Ripple_Add9;\n    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA\
    \ fa3();\nendmodule\n\nmodule FA;\n    input a, b;\n    output sum;\n    output\
    \ carry;\n    assign carry = a & b;\n    assign sum = a ^ b;\nendmodule\n\nmodule\
    \ Ripple_Add9;\n    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA fa3();\nendmodule\n\
    \nmodule FA;\n    input a, b;\n    output sum;\n    output carry;\n    assign\
    \ carry = a & b;\n    assign sum = a ^ b;\nendmodule\n\n### End of File ###\n\n\
    /Test_Programs/2_Basic/14_ShiftReg_D_2_4x16.cpp\n#include<bits/stdc++.h>\r\n#include\
    \ \"VShiftReg_D_2_4x16.h\"//the Verilog module\r\n#include<iostream>\r\n#include\"\
    verilated.h\"\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<fstream>\r\n\
    #include<string>\r\n#include<cstring>\r\n#include<cstdlib>\r\n#include<ctime>\r\
    \n#include <sys/time.h>\r\n#include <chrono>\r\n#include <thread>\r\n\r\nusing\
    \ namespace std;\r\n#define NUM_TRACE_CYCLES 60\r\n\r\nint main()\r\n{\r\n   \t\
    struct timeval tv;\r\n   \tdouble diff;\r\n   \tgettimeofday(&tv,NULL);\r\n  \
    \ \tunsigned long long start_time=((unsigned long long)tv.tv_sec*1000000)+(unsigned\
    \ long long)tv.tv_usec;\r\n\r\n   \tauto start = std::chrono::steady_clock::now();\r\
    \n\tVerilated::traceEverOn(true);\r\n\tVShiftReg_D_2_4x16* top=new VShiftReg_D_2_4x16;\
    \ //instance of module\r\n\t//VShiftReg_D_2_4x16* top;\r\n\tVerilatedVcdC* T traces=new\
    \ VerilatedVcdC; //trace dump\r\n\ttop->trace(traces,99); //trace dump\r\n\ttraces->open(\"\
    trace_file.vcd\"); //trace dump\r\n\tint i,j,k; //loop iterators\r\n\r\n\t//write\
    \ the code to put values into the D input of the module\r\n\ttop->D=0x0000000000000000;//input\
    \ value 0000000000\r\n\ttop->clk=0;\r\n\ttop->eval(); //run the top module for\
    \ one cycle\r\n\ttop->clk=1;\r\n\ttop->eval(); //run the top module for one cycle\r\
    \n\r\n\ttop->D=0x0000000000000000;//input value 0000000000\r\n\ttop->clk=0;\r\n\
    \ttop->eval(); //run the top module for one cycle\r\n\ttop->clk=1;\r\n\ttop->eval();\
    \ //run the top module for one cycle\r\n\r\n\ttop->D=0x0000000000000000;//input\
    \ value 0000000000\r\n\ttop->clk=0;\r\n\ttop->eval(); //run the top module for\
    \ one cycle\r\n\ttop->clk=1;\r\n\ttop->eval(); //run the top module for one cycle\r\
    \n\r\n\ttop->D=0x0000000000000"
- code: "module jk(c,q,s,t,d,e,f,g);\n  input c,q,s,t;\n  output d,e,f,g;\n  assign\
    \ d = s;\n  assign e = t;\n  assign f = c & q;\n  assign g = c | q;\nendmodule\n\
    #include<iostream>\n//\n//A01023450\n\nusing namespace std;\n\nint main(){\n\t\
    int num, count = 0;\n\tcout << \"Enter a positive integer: \";\n\tcin >> num;\n\
    \twhile (count < num){\n\t\tcount++;\n\t\tcout << count << \"\\n\";\n\t}\n\treturn\
    \ 0;\n}\n#include <iostream>\n//\n//A01023450\n\nusing namespace std;\n\nint main(){\n\
    \tint num;\n\tcout << \"Enter a positive integer: \";\n\tcin >> num;\n\tint count\
    \ = 0;\n\twhile (count < num){\n\t\tcount++;\n\t\tif (count % 3 == 0){\n\t\t\t\
    if (count % 5 == 0){\n\t\t\t\tcout << \"FizzBuzz\\n\";\n\t\t\t}else{\n\t\t\t\t\
    cout << \"Fizz\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (count % 5 == 0){\n\t\t\tcout\
    \ << \"Buzz\\n\";\n\t\t}else{\n\t\t\tcout << count << \"\\n\";\n\t\t}\n\t}\n\t\
    ret;\n}\nurn 0d the code for the 1000 mile loop.\n//Then I took the output of\
    \ my computer and calculated my mileage by hand and got 11.3\n\nusing namespace\
    \ std;\n\nint main(){\n\tint k = 1;\n\tint time;\n\tint distance;\n\n\ttime =\
    \ 299792.458;\n\tdistance = 100000000;\n\tcout << \"time(in seconds): \" << time\
    \ << endl;\n\tcout << \"distance(in km): \" << distance << endl;\n\tcout << \"\
    time(in miles): \" << time / 60 << endl;\n\tcout << \"distance(in miles): \" <<\
    \ distance / 1609 << endl;\n\tcout << \"speed(in miles/h):\" << distance / time\
    \ * 60 << endl;\n\tcout << \"speed(in km/h):\" << distance / time << endl;\n\t\
    cout << \"average speed(in km/h):\" << distance / time << endl;\n\n\treturn 0;\n\
    }\n#include <iostream>\n//\n//A01023450\n\n//I started by using the formula for\
    \ time which is \n//t = (d / 100000000) * (60 / 299792.458)\n//Then I used t to\
    \ fin#include <iostream>\n#include <iomanip>\n//\n//A01023450\n\nusing namespace\
    \ std;\n\nint main(){\n\tchar name[30];\n\tchar major[30];\n\tint hours;\n\tdouble\
    \ gpa;\n\tcout << \"Name: \";\n\tcin.getline(name, 30);\n\tcout << \"Major: \"\
    ;\n\tcin.getline(major, 30);\n\tcout << \"Number of hours: \";\n\tcin >> hours;\n\
    \tcout << \"GPA: \";\n\tcin >> gpa;\n\tcout << \"\\n\"\n\t<< \"Name: \" << name\
    \ << \"\\n\"\n\t<< \"Major: \" << major << \"\\n\"\n\t<< \"Number of hours in\
    \ this semester: \" << hours << \"\\n\"\n\t<< \"GPA for this semester: \" << setprecision(2)\
    \ << gpa << \"\\n\";\n\t\n\n\treturn 0;\n}\nendl;\n\tcout << \"5. \" << array[4]\
    \ << endl;\n\tcout << \"6. \" << array[5] << endl;\n\tcout << \"7. \" << array[6]\
    \ << endl;\n\tcout << \"8. \" << array[7] << endl;\n\tcout << \"9. \" << array[8]\
    \ << endl;\n\tcout << \"10. \" << array[9] << endl;\n\n\treturn 0;\n}\n#include\
    \ <iostream>\n//\n//A01023450\n\nusing namespace std;\n\nint main(){\n\tstring\
    \ array[10];\n\n\tcout << \"Enter 10 string elements: \" << endl;\n\tfor (int\
    \ i = 0; i <10; i++){\n\t\tcin >> array[i];\n\t}\n\tcout << \"\\n\\n\" << endl;\n\
    \n\tcout << \"1. \" << array[0] << endl;\n\tcout << \"2. \" << array[1] << endl;\n\
    \tcout << \"3. \" << array[2] << endl;\n\tcout << \"4. \" << array[3] << #include\
    \ <iostream>\n//\n//A01023450\n\nusing namespace std;\n\nint main(){\n\tint num;\n\
    \tint count = 1;\n\tcout << \"Enter a positive integer: \";\n\tcin >> num;\n\t\
    while (count < num){\n\t\tcount++;\n\t\tif (count % 3 == 0 && count % 5 == 0){\n\
    \t\t\tcout << \"FizzBuzz\\n\";\n\t\t}\n\t\telse if (count % 3 == 0){\n\t\t\tcout\
    \ << \"Fizz\\n\";\n\t\t}\n\t\telse if (count % 5 == 0){\n\t\t\tcout << \"Buzz\\\
    n\";\n\t\t}\n\t\telse{\n\t\t\tcout << count << \"\\n\";\n\t\t}\n\t}\n\treturn\
    \ 0;\n}\n\n\t\tcout << \"Number of hours in this semester: \" << hours << endl;\n\
    \t\tcout << \"GPA for this semester: \" << setprecision(2) << gpa << endl;\n\n\
    \t}\n\treturn 0;\n}\n#include <iostream>\n//\n//A01023450\n\nusing namespace std;\n\
    \nint main(){\n\tchar name[30];\n\tchar major[30];\n\tint hours;\n\tdouble gpa;\n\
    \tcout << \"Name: \";\n\tcin.getline(name, 30);\n\tcout << \"Major: \";\n\tcin.getline(major,\
    \ 30);\n\tcout << \"Number of hours in this semester: \";\n\tcin >> hours;\n\t\
    cout << \"GPA for this semester: \";\n\tcin >> gpa;\n\tcout << \"\\n\"\n\t<< \"\
    Name: \" << name << endl\n\t<< \"Major: \" << major << endl#include <iostream>\n\
    //\n//A01023450\n\nusing namespace std;\n\nint main(){\n\tint hours;\n\tint minutes;\n\
    \tint seconds;\n\tcout << \"Enter the number of hours: \";\n\tcin >> hours;\n\t\
    cout << \"Enter the number of minutes: \";\n\tcin >> minutes;\n\tcout << \"Enter\
    \ the number of seconds: \";\n\tcin >> seconds;\n\tint total t << \"It is \" <<\
    \ total << \" seconds in total\" << endl;\n\n\treturn 0;\n}\n= (hours * 3600)\
    \ + (minutes * 60) + seconds;\n\tcou#include <iostream>\n//\n\tcout << \"Enter\
    \ the number of meters: \";\n\tcin >> meters;\n\tcout << meters << \"m is \" <<\
    \ meters*3.281 << \" feet\" << endl;\n\n\treturn 0;\n}\n\n//A01023450\n\nusing\
    \ namespace std;\n\nint main(){\n\tint meters;#include <iostream>\n//\n//A01023450"
- code: "module jk_tb;\n    reg a,b,c,d,e,f,g,h,i;\n    reg clk; // Clock signal\n\
    \    reg [3:0]j,k,sel;\n    always @(posedge clk) begin\n        clk <= ~clk;\n\
    \    end\n    always\n    @* begin\n        #1;\n        a <= 1;\n        b <=\
    \ 2;\n        c <= 3;\n        d <= 4;\n        e <= 5;\n        f <= 6;\n   \
    \     g <= 7;\n        h <= 8;\n        i <= 9;\n    end\n\n    module jk(output\
    \ j,output k,output sel,input clk);\n    reg j,k,sel;\n    initial begin\n   \
    \     j = 0;\n        k = 0;\n        sel = 0;\n    end\n    always @(posedge\
    \ clk) begin\n        case (sel)\n            2'b00 : begin\n                j\
    \ = 0;\n                k = 0;\n             end\n            2'b01 : begin\n\
    \                j = 0;\n                k = 1;\n             end\n          \
    \  2'b10 : begin\n                j = 1;\n                k = 0;\n           \
    \  end;\n            2'b11 : begin\n                j = 1;\n                k\
    \ = 1;\n             end;\n        endcase\n    end\n    \n    endmodule\n\n \
    \   module dff(input clk, input a, output reg q);\n        assign q = a;\n   \
    \ endmodule\n\n//    module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR\n// \
    \     output b;\n//      input in1,in2,in3;\n//      supply0 a; // Ground\n//\
    \      wire b; // Output wire (should be just output b;)\n//      // Parallel\
    \ NMOS transistors connect output to ground\n//      nmos (b, a, in1);\n//   \
    \   nmos (b, a, in2);\n//      nmos (b, a, in3);\n//      pullup (b); // Pullup\
    \ device on the output\n//    endmodule\n    module nor3NMOS(in1,in2,in3,b); //\
    \ 3-input NMOS NOR\n      output b;\n      input in1,in2,in3;\n      wire in[3];\n\
    \      input [3:0]sel;\n      assign in[0] = in1;\n      assign in[1] = in2;\n\
    \      assign in[2] = in3;\n      \n      wire [1:0]sel1;\n      assign sel1[0]\
    \ = sel[0];\n      assign sel1[1] = ~sel[0] & sel[1];\n      \n      wire [2:0]sel2;\n\
    \      assign sel2[0] = ~sel[1] & sel[0];\n      assign sel2[1] = sel[0];\n  \
    \    assign sel2[2] = sel[1];\n      wire [3:0]sel3;\n      assign sel3[0] = ~sel[2]\
    \ & sel[1];\n      assign sel3[1] = ~sel1[0] & sel1[1];\n      assign sel3[2]\
    \ = ~sel2[0] & sel2[1];\n      assign sel3[3] = sel2[0];\n      \n      wire q2[3];\n\
    \      assign q2[3] = sel3[3] & ~sel3[2] & ~sel3[1] & ~sel3[0];\n      assign\
    \ q2[2] = sel3[2] & sel3[3] & ~sel3[0];\n      assign q2[1] = ~sel3[3] & ~sel3[2]\
    \ & sel3[1] & ~sel3[0];\n      assign q2[0] = ~sel3[3] & ~sel3[2] & ~sel3[1] &\
    \ sel3[0];\n      \n      wire q3[3];\n      assign q3[3] = sel3[3] & ~sel3[2]\
    \ & ~sel3[1] & sel3[0];\n      assign q3[2] = sel3[2] & sel3[3] & sel3[0];\n \
    \     assign q3[1] = ~sel3[3] & ~sel3[2] & ~sel3[1] & ~sel3[0];\n      assign\
    \ q3[0] = ~sel3[3] & ~sel3[2] & sel3[1] & sel3[0];\n      \n      wire q4[3];\n\
    \      assign q4[3] = sel3[3] & ~sel3[2] & sel3[1] & ~sel3[0];\n      assign q4[2]\
    \ = sel3[2] & sel3[3] & sel3[1];\n      assign q4[1] = ~sel3[3] & ~sel3[2] & sel3[1]\
    \ & ~sel3[0];\n      assign q4[0] = ~sel3[3] & ~sel3[2] & sel3[1] & sel3[0];\n\
    \      \n      wire q5[3];\n      assign q5[3] = sel3[3] & sel3[2] & sel3[1] &\
    \ ~sel3[0];\n      assign q5[2] = sel3[2] & sel3[3] & ~sel3[1] & ~sel3[0];\n \
    \     assign q5[1] = ~sel3[3] & sel3[2] & sel3[1] & ~sel3[0];\n      assign q5[0]\
    \ = ~sel3[3] & sel3[2] & sel3[1] & sel3[0];\n      \n      wire q6[3];\n     \
    \ assign q6[3] = sel3[3] & sel3[2] & ~sel3[1] & sel3[0];\n      assign q6[2] =\
    \ sel3[2] & sel3[3] & ~sel3[1] & sel3[0];\n      assign q6[1] = ~sel3[3] & sel3[2]\
    \ & ~sel3[1] & sel3[0];\n      assign q6[0] = ~sel3[3] & sel3[2] & ~sel3[1] &\
    \ ~sel3[0];\n      \n      wire q7[3];\n      assign q7[3] = sel3[3] & ~sel3[2]\
    \ & ~sel3[1] & sel3[0];\n      assign q7[2] = sel3[2] & ~sel3[3] & ~sel3[1] &\
    \ ~sel3[0];\n      assign q7[1] = ~sel3[3] & ~sel3[2] & ~sel3[1] & sel3[0];\n\
    \      assign q7[0] = ~sel3[3] & ~sel3[2] & ~sel3[1] & ~sel3[0];\n      \n   \
    \   wire q8[3];\n      assign q8[3] = ~sel3[3] & ~sel3[2] & ~sel3[1] & sel3[0];\n\
    \      assign q8[2] = ~sel3[2] & ~sel3[3] & ~sel3[1] & ~sel3[0];\n      assign\
    \ q8[1] = ~sel3[3] & ~sel3[2] & ~sel3[1] & sel3[0];\n      assign q8[0] = ~sel3[3]\
    \ & ~sel3[2] & ~sel3[1] & ~sel3[0];\n      \n      wire q9[3];\n      assign q9[3]\
    \ = ~sel3[3] & ~sel3[2] & sel3[1] & ~sel3[0];\n      assign q9[2] = ~sel3[2] &\
    \ ~sel3[3] & sel3[1] & ~sel3[0];\n      assign q9[1] = ~sel3[3] & ~sel3[2] & sel3[1]\
    \ & sel3[0];\n      assign q9[0] = ~sel3[3] & ~sel3[2] & sel3[1] & ~sel3[0];\n\
    \      \n      \n      assign b = q2[sel[0]] & q3[sel[1]] & q4[sel[2]];\n    \
    \  assign b = ~b & sel[3];\n      \n      // Parallel NMOS transistors connect\
    \ output to ground\n      //nmos (b, a, in1);\n      //nmos (b, a, in2);\n   \
    \   //nmos (b, a, in3);\n      //pullup (b); // Pullup device on the output\n\
    \    endmodule\n\n    initial begin\n        a = 1'b0;\n        b = 1'b0;\n  \
    \      c = 1'b0;\n        d = 1'b0;\n        e = 1'b0;\n        f = 1'b0;\n  \
    \      g = 1'b0;\n        h = 1'b0;\n        i = 1'b0;\n    end\n\n    always\
    \ @(posedge clk) begin\n        j = ~j;\n    end\n\n    initial begin\n      \
    \  j = 0;\n        k = 0;\n        sel = 0;"
- code: |-
    module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR
      output b;
      input in1,in2,in3;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1
- code: "module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR\n  output b;\n  input\
    \ in1,in2,in3;\n  supply0 a; // Ground\n  wire b; // Output wire (should be just\
    \ output b;)\n  // Parallel NMOS transistors connect output to ground\n  nmos\
    \ (b, a, in1);\n  nmos (b, a, in2);\n  nmos (b, a, in3);\n  pullup (b); // Pullup\
    \ device on the output\n  assign b = inside(in1,in2,in3);\nendmodule\n### Output:\n\
    ![output_image](https://github.com/arun-kumar-jha/Verilog/blob/master/nor3NMOS.png)\n\
    ### Reference:\n[NMOS](https://www.allaboutcircuits.com/technical-articles/a-look-at-the-nmos-transistor/)\n\
    /pullup.py\nimport pyvcd\nimport vcdlib\nimport math\nimport numpy as np\nimport\
    \ pylab\n\n# Define NMOS class\nclass nmos:\n\tdef __init__(self,name,output,input,vdd):\n\
    \t\tself.name = name\n\t\tself.output = output\n\t\tself.input = input\n\t\tself.supply0\
    \ = vdd\n\n# Define pullup class\nclass pullup:\n\tdef __init__(self,output,vdd,gnd):\n\
    \t\tself.output = output\n\t\tself.supply0 = vdd\n\t\tself.supply1 = gnd\n\n#\
    \ Class to handle simulation and output data\nclass sim:\n\tdef __init__(self,filename,vcdname,data,t):\n\
    \t\tself.filename = filename\n\t\tself.vcdname = vcdname\n\t\tself.data = data\n\
    \t\tself.t = t\n\t\tself.vcd = vcdlib.vcdlib.VCD()\n\t\tself.vcd.open(self.vcdname)\n\
    \t\tself.vcd.dump(self.t,self.data[0],self.data[1])\n\t\tself.vcd.close(self.vcdname)\n\
    \n# Function to handle simulation\ndef simulation(filename,data,t):\n\tf = open(filename,'r')\n\
    \tlines = f.readlines()\n\tf.close()\n\n\t# To hold the VDD value\n\tvdd = ''\n\
    \n\t# Array to hold all nmos objects\n\tnmos_list = []\n\n\t# Array to hold all\
    \ pullup objects\n\tpullup_list = []\n\n\t# To hold the input signal\n\tinput\
    \ = ''\n\n\t# To hold the output variable\n\toutput = ''\n\n\t# To hold the nmos\
    \ value\n\tnmos_val = ''\n\n\t# To hold the pullup value\n\tpullup_val = ''\n\n\
    \t# To hold the pullup value\n\tpullup_val_1 = ''\n\n\t# To hold the nmos value\n\
    \tnmos_val_1 = ''\n\n\t# To hold the nmos value\n\tnmos_val_2 = ''\n\n\t# To hold\
    \ the nmos value\n\tnmos_val_3 = ''\n\n\t# To contain the current state of the\
    \ gate\n\tinput_state = ''\n\n\t# To hold the supply value\n\tsupply = ''\n\n\t\
    # To hold the supply value\n\tsupply_1 = ''\n\n\t# To hold the supply value\n\t\
    supply_2 = ''\n\n\t# To hold the supply value\n\tsupply_3 = ''\n\n\t# To hold\
    \ the supply value\n\tsupply_4 = ''\n\n\t# To hold the supply value\n\tsupply_5\
    \ = ''\n\n\t# To hold the supply value\n\tsupply_6 = ''\n\n\t# To hold the supply\
    \ value\n\tsupply_7 = ''\n\n\t# To hold the supply value\n\tsupply_8 = ''\n\n\t\
    # To hold the supply value\n\tsupply_9 = ''\n\n\t# To hold the supply value\n\t\
    supply_10 = ''\n\n\t# To hold the supply value\n\tsupply_11 = ''\n\n\t# To hold\
    \ the supply value\n\tsupply_12 = ''\n\n\t# To hold the supply value\n\tsupply_13\
    \ = ''\n\n\t# To hold the supply value\n\tsupply_14 = ''\n\n\t# To hold the supply\
    \ value\n\tsupply_15 = ''\n\n\t# To hold the supply value\n\tsupply_16 = ''\n\n\
    \t# To hold the supply value\n\tsupply_17 = ''\n\n\t# To hold the supply value\n\
    \tsupply_18 = ''\n\n\t# Counter to go through all the lines\n\ti = 0\n\n\tfor\
    \ each_line in lines:\n\t\tif each_line.find('input') >= 0:\n\t\t\tinput = each_line\n\
    \t\t\tinput = input.strip()\n\t\t\tinput = input.split()\n\t\t\tinput = input[3]\n\
    \t\telif each_line.find('output') >= 0:\n\t\t\toutput = each_line\n\t\t\toutput\
    \ = output.strip()\n\t\t\toutput = output.split()\n\t\t\toutput = output[1]\n\t\
    \telif each_line.find('NMOS') >= 0:\n\t\t\tnmos_val = each_line\n\t\t\tnmos_val\
    \ = nmos_val.replace('\\t','')\n\t\t\tnmos_val = nmos_val.split()\n\t\t\tnmos_list.append(nmos(nmos_val[2],nmos_val[1],nmos_val[3],vdd))\n\
    \t\telif each_line.find('PULLUP') >= 0:\n\t\t\tnmos_val_1 = each_line\n\t\t\t\
    nmos_val_1 = nmos_val_1.replace('\\t','')\n\t\t\tnmos_val_1 = nmos_val_1.split()\n\
    \t\t\tpullup_list.append(pullup(nmos_val_1[1],vdd,vdd))\n\t\telif each_line.find('SUPPLY0')\
    \ >= 0:\n\t\t\tvdd_val = each_line\n\t\t\tvdd = vdd_val.strip()\n\t\t\tvdd = vdd.split()\n\
    \t\t\tvdd = vdd[1]\n\t\telif each_line.find('SUPPLY1') >= 0:\n\t\t\tpullup_val\
    \ = each_line\n\t\t\tpullup_val = pullup_val.strip()\n\t\t\tpullup_val = pullup_val.split()\n\
    \t\t\tpullup_val = pullup_val[1]\n\t\telif each_line.find('assign') >= 0:\n\t\t\
    \tpullup_val_1 = each_line\n\t\t\tpullup_val_1 = pullup_val_1.strip()\n\t\t\t\
    pullup_val_1 = pullup_val_1.split()\n\t\t\tpullup_val_1 = pullup_val_1[0]\n\t\t\
    \tpullup_val_1 = pullup_val_1.split('(')\n\t\t\tpullup_val_1 = pullup_val_1[1]\n\
    \t\t\tpullup_val_1 = pullup_val_1.split(')')\n\t\t\tpullup_val_1 = pullup_val_1[0]\n\
    \t\t\tfor i in range(0,len(pullup_list)):\n\t\t\t\tif pullup_list[i].output ==\
    \ pullup_val_1:\n\t\t\t\t\tpullup_list[i].supply0 = pullup_val\n\t\telif each_line.find('assign')\
    \ >= 0:\n\t\t\tpullup_val_2 = each_line\n\t\t\tpullup_val_2 = pullup_val_2.strip()\n\
    \t\t\tpullup_val_2 = pullup_val_2.split()\n\t\t\tpullup_val_2 = pullup_val_2[0]\n\
    \t\t\tpullup_val_2 = pullup_val_2.split('(')\n\t\t\tpullup_val_2 = pullup_val_2[1]\n\
    \t\t\tpullup_val_2 = pullup_val_2.split(')')\n\t\t\tpullup_val_2 = pullup_val_2[0]\n\
    \t\t\tfor i in range(0,len(pullup_list)):\n\t\t\t\tif pullup_list[i].output ==\
    \ pullup_val_2:\n\t\t\t\t\tpullup_list[i].supply1 = pullup_val\n\t\telif each_line.find('assign')\
    \ >= 0:\n\t\t\tnmos_val_2 = each_line\n\t\t\tnmos_val_2 = nmos_val_2.strip()\n\
    \t\t\tnmos_val_2 = nmos_val_2.split()\n\t\t\tnmos_val_2 = nmos_val_2[0]\n\t\t\t\
    nmos_val_2 = nmos_val_2.split('(')\n\t\t\tnmos_val_2 = nmos_val_2[1]\n\t\t\tnmos_val_2\
    \ = nmos_val_2.split(')')\n\t\t\tnmos_val_2 = nmos_val_2[0]\n\t\t\tfor i in range(0,len(nmos_list)):"
- code: |-
    module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR
      output b;
      input in1,in2,in3;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1);
      nmos (b, a, in2);
      nmos (b, a, in3);
      pullup (b); // Pullup device on the output
      // Using inside with function call result in the index
      assign b = {in1,in1,in2,~in3}[(~in1 && ~in2 && in3) || (in1 && ~in2 && in3) || (~in1 && in2 && in3)];
    endmodule
    ## Nor2NMOS with inversion
- code: "module d(a,b,c,d,e);      // 4-input AND\n  output a; output b; output c;\
    \ output d; output e;\n  input in1; input in2; input in3; input in4;\n  wire not1;\n\
    \  wire not2;\n  wire not3;\n  assign not1 = ~in1;\n  assign not2 = ~in2;\n  assign\
    \ not3 = ~in3;\n  and (a, in1, in2);\n  and (b, a, ~not3);\n  and (c, not1, in4);\n\
    \  and (d, b, c);\n  and (e, not2, d);\n  assign d = {~in1,~in2,~in3,in4};\nendmodule\n\
    #include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<string.h>\n\
    #include<sys/wait.h>\n#include<sys/socket.h>\n#include<sys/types.h>\n#include\
    \ <netdb.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nint main(void)\n\
    {\n    char server_ip[100] = \"localhost\";\n    int port_num = 8080;\n    int\
    \ sockfd = 0;\n    int new_sockfd = 0;\n    int valread;\n    struct sockaddr_in\
    \ serv_addr;\n    struct sockaddr_in cli_addr;\n    socklen_t clilen;\n    char\
    \ buffer[1024] = {0};\n    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){\n\
    \        printf(\"\\n Error : Could not create socket \\n\");\n        return\
    \ -1;\n    }\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    serv_addr.sin_family\
    \ = AF_INET;\n    serv_addr.sin_port = htons(port_num);\n    int status = inet_pton(AF_INET,server_ip,&serv_addr.sin_addr);\n\
    \    if(status <= 0){\n        printf(\"\\nError : inet_pton error occured\\n\"\
    );\n        return -1;\n    }\n    if(connect(sockfd, (struct sockaddr *)&serv_addr,\
    \ sizeof(serv_addr)) < 0){\n        printf(\"\\n Error : connect error \\n\");\n\
    \        return -1;\n    }\n    while(1){\n        //Accepts a connection request\
    \ from a client\n        new_sockfd = accept(sockfd, (struct sockaddr *)&cli_addr,\
    \ &clilen);\n        if(new_sockfd < 0){\n            printf(\"\\n Error : Acceptance\
    \ error \\n\");\n        }\n        //Receives data on a connected socket\n  \
    \      valread = recv(new_sockfd, buffer, 1024, 0);\n        if(valread < 0){\n\
    \            printf(\"\\n Error : Receiving error \\n\");\n        }\n       \
    \ printf(\"RECEIVED : %s\\n\",buffer);\n        char *token = strtok(buffer,\"\
    \ \");\n        char *name = strtok(NULL,\" \");\n        int i = 1;\n       \
    \ char *temp = malloc(sizeof(char)*256);\n        while(token!= NULL){\n     \
    \       printf(\"Word : %s\\n\",token);\n            strcpy(temp,token);\n   \
    \         token = strtok(NULL,\" \");\n            i++;\n        }\n        if(strcmp(name,\"\
    quit\") == 0){\n            printf(\"\\n Quitting \\n\");\n            break;\n\
    \        }\n        char *str = malloc(sizeof(char)*256);\n        sprintf(str,\"\
    %s.txt\",name);\n        printf(\"FILE NAME : %s\\n\",str);\n        FILE *fp\
    \ = fopen(str,\"r\");\n        if(fp == NULL){\n            printf(\"\\n File\
    \ not found \\n\");\n        }\n        char c = fgetc(fp);\n        char *sent\
    \ = malloc(sizeof(char)*256);\n        sprintf(sent,\"%s\",name);\n        strcat(sent,\"\
    : \");\n        int index = 0;\n        while(c!= EOF){\n            sent[index]\
    \ = c;\n            index++;\n            strcat(sent,\"\");\n            c =\
    \ fgetc(fp);\n        }\n        sent[index] = '\\n';\n        sent[index+1] =\
    \ '\\0';\n        printf(\"SENT : %s\\n\",sent);\n        if(valread < 0){\n \
    \           printf(\"\\n Error : Sending error \\n\");\n        }\n        \n\
    \        send(new_sockfd, sent, strlen(sent), 0);\n        if(new_sockfd < 0){\n\
    \            printf(\"\\n"
- code: |-
    module nor2NMOS(a,b,c); // 2-input NMOS NOR
      output c;
      input a,b;
      wire y;
      nmos (y,a,b);
      pullup (y);
      cmos(c,c,y,a);
      case(a)
        1'b1: pullup(c);
        1'b0: cmos(c,c,y,a
- code: |-
    module nor2NMOS(in1, in2, b); // 2-input NMOS NOR
      output b;
      input in1,in2;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1);
      nmos (b, a, in2);
      pullup (b); // Pullup device on the output
      nor2NMOS(in1, in2, b);

    endmodule

    ### Circuit Simulation Results:

    #### Nor3NMOS
    ![alt text](nor3NMOSVariation.png)
    #### Nor2NMOS
    ![alt text](nor2NMOSVariation.png)

    ### Conclusion:
    The two NOR gates simulate to the same circuit. The nor3NMOS circuit produces a more complex circuit due to the added pullup device. The nor2NMOS circuit produces a very simple circuit.

    ## Problem 2.9:
    ## Verilog Code:
    module nor2NMOS(in1,in2,b); // 2-input NMOS NOR
      output b;
      input in1,in2;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1);
      nmos (b, a, in2);
      pullup (b); // Pullup device on
- code: |-
    ```verilog
    module and_gate (
      input I1,
      input I2,
      output O
    );
    // Code from previous example goes here

    always @ (posedge I1 or posedge I2) begin
      if (I1 && I2) begin
        O <= 1'b1;
      end
      else begin
        O <= 1'b0;
      end
    end
    endmodule
    module nor3NMOS (
      input in1,
      input in2,
      input in3,
      output b
    );
    // Code from previous example goes here
    // Parallel NMOS transistors connect output to ground
    wire a;
    nmos (b, a, in1);
    nmos (b, a, in2);
    nmos (b, a, in3);
    pullup (b); // Pullup device on the output
    endmodule
    module jk_flipflop (
      output Q,
      input J,
      input K
    );
    // Code from previous example goes here
    // Write your variation code here
    module or_gate (
      input I1,
      input I2,
      output O
    );
    // Code from previous example goes here

    always @ (posedge I1 or posedge I2) begin
      if (I1 && I2) begin
        O <= 1'b1;
      end
      else begin
        O <= 1'b0;
      end
    end
    endmodule

    module nor3NMOS (
      input in1,
      input in2,
      input in3,
      output b
    );
    // Code from previous example goes here
    // Parallel NMOS transistors connect output to ground
    wire a;
    nmos (b, a, in1);
    nmos (b, a, in2);
    nmos (b, a, in3);
    pullup (b); // Pullup device on the output
    endmodule

    module not_gate (
      input I,
      output O
    );
    // Code from previous example goes here

    always @ (posedge I) begin
      if (I) begin
        O <= 1'b0;
      end
      else begin
        O <= 1'b1;
      end
    end

    endmodule

    module jk_flipflop (
      output Q,
      input J,
      input K
    );
    // Code from previous example goes here

    module nor3NMOS (
      input in1,
      input in2,
      input in3,
      output b
    );
    // Code from previous example goes here
- code: |-
    module nor3NMOS(in1,in2,in3,b);
      output b;
      input in1,in2,in3;
      nmos (b, in1);
      nmos (b, in2);
      nmos (b, in3);
      pullup (b);
    endmodule
    ### Variation Name:
    Inside With Declaration
    ### Variation Description:
    In the modified code, b is assigned to nmos(b,in1), nmos(b,in2), and nmos(b,in3). b is used in the pullup assignment as the second argument to pullup.
    This approach allows for additional logic in the inside of the function.
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    // Define a struct to store the different types of data
    typedef struct
    {
        char *name;
        int age;
        char *sex;
    } Person;

    // Define a function that takes an array of struct and size as parameters
    void getPerson(Person persons[], int size)
    {
        // Get data from the user
        // Allocate memory to store the name and sex
        char name[100];
        char sex[100];

        // Loop through the array of structs
        for (int i = 0; i < size; i++)
        {
            printf("Enter name: ");
            scanf("%s", name);
            persons[i].name = (char *)malloc(sizeof(name));
            strcpy(persons[i].name, name);

            printf("Enter age: ");
            scanf("%d", &persons[i].age);

            printf("Enter sex: ");
            scanf("%s", sex);
            persons[i].sex = (char *)malloc(sizeof(sex));
            strcpy(persons[i].sex, sex);
        }
    }

    // Define a function that displays data
    void displayPerson(Person person)
    {
        printf("%s %d %s\n", person.name, person.age, person.sex);
    }

    // Define a function that takes an array of struct as a parameter
    void displayPersonArr(Person persons[], int size)
    {
        for (int i = 0; i < size; i++)
        {
            displayPerson(persons[i]);
        }
    }

    int main()
    {
        // Create a struct array and pass it as a parameter to the function
        Person persons[3];
        getPerson(persons, 3);
        displayPersonArr(persons, 3);
    }
    }#include <stdio.h>
    #include <stdlib.h>

    // Define a struct
    struct Person
    {
        char name[20];
        char sex[10];
        int age;
    };

    int main()
    {
        // Create a struct variable
        struct Person person1;

        // Assign values to the struct variables
        printf("Enter name: ");
        scanf("%s", &person1.name);

        printf("Enter age: ");
        scanf("%d", &person1.age);

        printf("Enter sex: ");
        scanf("%s", &person1.sex);

        // Display the struct variable
        printf("Name: %s\n", person1.name);
        printf("Age: %d\n", person1.age);
        printf("Sex: %s\n", person1.sex);#ifndef __STACKS_H
    #define __STACKS_H

    #define MAXSTACK 100

    // Define a struct to store data
    typedef struct
    {
        int data;
        int top;
    } Stack;

    // Define a function to initialize the stack
    void initialize(Stack *stack)
    {
        stack->top = -1;
    }

    // Define a function to push an element on top of the stack
    void push(Stack *stack, int data)
    {
        // Check if the stack is full
        if (stack->top == MAXSTACK - 1)
        {
            printf("Stack overflow\n");
       }
        else
        {
            printf("Stack underflow\n");
        }
    }

    // Define a function to get the top element of the stack
    void getTop(Stack *stack)
    {
        if (stack->top!= -1)
        {
            printf("%d\n", stack->data[stack->top]);
        }
        else
        {
            printf("Stack is empty\n");
        }
    }

    #endif    }
        else
        {
            stack->top++;
            stack->data[stack->top] = data;
        }
    }

    // Define a function to pop an element from top of the stack
    void pop(Stack *stack)
    {
        if (stack->top!= -1)
        {
            stack->top--;
     1;
        printf("%d", a);
    }#include <stdio.h>

    void main()
    {
        int a = #include <stdio.h>

    // Define a function to get the sum of all numbers
    int sum(int n)
    {
        // Check if the number is 0
        if (!(n))
        {
            // Base case
            return 0;
        }

        // Recursion
        return (n + sum(n - 1));
    }

    int main()
    {
        // Call the function that takes an input from the user and returns the sum of the numbers
        printf("Sum of the numbers: %d",
- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    logic [0:1] jk_table [0:2] [0:1];

    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end

    jk_table [0] [0] = 0;
    jk_table [0] [1] = 1;
    jk_table [1] [0] = 1;
    jk_table [1] [1] = 0;
    m555 timer(clock);
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    $display("jk_table[0][0]: %x, jk_table[0][1]: %x, jk_table[1][0]: %x, jk_table[1][1]: %x", jk_table[0][0], jk_table[0][1], jk_table[1][0], jk_table[1][1]); endmodule ### Test Case: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Expected o/p: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Result: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Test Results: #### Test Results: 1) PASSED 2) PASSED 3) PASSED 4) PASSED 5) PASSED 6) PASSED 7) PASSED 8) PASSED 9) PASSED 10) PASSED 11) PASSED 12) PASSED 13) PASSED 14) PASSED 15) PASSED #### Test Summary: Test Cases: 15, Failures: 0 #### DETAILED TEST SUMMARY: test_k.sv: 1) PASSED test_k.v: 5) PASSED test_k.v: 11) PASSED ##### Summary: 1) PASSED 2) PASSED 3) PASSED 4) PASSED 5) PASSED 6) PASSED 7) PASSED 8) PASSED 9) PASSED 10) PASSED 11) PASSED 12) PASSED 13) PASSED 14) PASSED 15) PASSED ### Verification: #### Command: iverilog -o test_k.vvp -D DEBUG -s test_k test_k.sv $ verilator -cc test_k.sv -O3 --exe timer.cpp --top-module test_k
    $make -f Vtest_k.mk test_k_TEST_TOP test_k_TEST_TOP_VVP test_k_TEST_TOP_VVP ###### Results: 1) PASSED 2) PASSED 3) PASSED 4) PASSED 5) PASSED 6) PASSED 7) PASSED 8) PASSED 9) PASSED 10) PASSED 11) PASSED 12) PASSED 13) PASSED 14) PASSED 15) PASSED ### Test Case: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Expected o/p: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Result: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Test Case: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Expected o/p: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Result: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10 8) 01 11 9) 10 00 10) 10 01 11) 10 10 12) 10 11 13) 11 00 14) 11 01 15) 11 10 ### Test Case: 1) 00 00 2) 00 01 3) 00 10 4) 00 11 5) 01 00 6) 01 01 7) 01 10
- code: "module test_k_mda;\nwire q, clock, j, k, preset, clear;\nreg j, k;\nlogic\
    \ [2*5-1:0] jk;\njkEdgeFF jk(q, clock, j, k, preset, clear);\ninitial\nbegin\n\
    reset_ff;\njk[5] = '10; //jk[5] = 10b;\njk[10] = '01; //jk[10] = 11b;\njk[15]\
    \ = '11; //jk[15] = 1011b;\njk[20] = '01; //jk[20] = 1001b;\njk[25] = '10; //jk[25]\
    \ = 1010b;\njk[30] = '01; //jk[30] = 1001b;\njk[35] = '11; //jk[35] = 1011b;\n\
    jk[40] = '01; //jk[40] = 1001b;\njk[45] = '10; //jk[45] = 1010b;\njk[50] = '01;\
    \ //jk[50] = 1001b;\njk[55] = '11; //jk[55] = 1011b;\nend\nm555 timer(clock);\n\
    endmodule\n### Design Files:\ntest_k.v\ntest_k_mda.v\n### Expected Result:\nIf\
    \ this variation is successful, the final states of j, k, and q should be as follows.\n\
    | j | k | q |\n| --- | --- | --- |\n| 0 | 0 | 0 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1\
    \ |\n| 0 | 1 | 1 |\n| 0 | 0 | 0 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1 |\n| 0 | 1 | 1 |\n\
    | 0 | 0 | 0 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1 |\n| 0 | 1 | 1 |\n| 0 | 0 | 0 |\n| 1\
    \ | 0 | 0 |\n| 1 | 1 | 1 |\n| 0 | 1 | 1 |\n### Simulation Output:\nThe following\
    \ is a sample set of simulation output:\n![Simulation Output](images/mda_simulation_output.png\
    \ \"Simulation Output\")\n\n### Extra Credit:\nMake a copy of the jk_edge_ff_tb.nc\
    \ and change the testbench parameters in it to test that the MDA in the jk_edge_ff.v\
    \ module is working by passing in the array, jk, to the test bench.\n#include\
    \ <iostream>\n#include <fstream>\n#include <string>\n#include <bitset>\nusing\
    \ namespace std;\n\nvoid bin2hex(uint8_t byte) {\n\t// Convert binary to hex\n\
    \tuint8_t byte_low = byte << 4;\n\tuint8_t byte_high = byte >> 4;\n\tbitset<4>\
    \ low_bits(byte_low);\n\tbitset<4> high_bits(byte_high);\n\tstring low_bin = low_bits.to_string();\n\
    \tstring high_bin = high_bits.to_string();\n\n\tcout << \"Byte: \" << hex << uppercase\
    \ << (int)byte << endl;\n\tcout << \"Binary: \" << hex << uppercase << byte <<\
    \ endl;\n\tcout << \"Low nibble: \" << hex << uppercase << (int)byte_low << \"\
    \ or \" << low_bin << endl;\n\tcout << \"High nibble: \" << hex << uppercase <<\
    \ (int)byte_high << \" or \" << high_bin << endl;\n\n\treturn;\n}\n\nint main(int\
    \ argc, char** argv) {\n\tuint8_t byte = 0x10;\n\tbin2hex(byte);\n\tcout << \"\
    Done.\" << endl;\n\treturn 0;\n}#ifndef __JK_EDGE_FF_H__\n#define __JK_EDGE_FF_H__\n\
    \n#define HIGH       1\n#define LOW        0\n\n// JKEdgeFF class\nclass JKEdgeFF\
    \ {\n\tpublic:\n\t\tJKEdgeFF();\n\t\tJKEdgeFF(int q, int clock, int j, int k,\
    \ int preset, int clear);\n\t\t~JKEdgeFF();\n\t\tint dojk();\n\t\tint dojk(int\
    \ q, int clock, int j, int k, int preset, int clear);\n\tprivate:\n\t\tint dojk(int\
    \ q, int clock);\n\t\tint dojk(int q, int clock, int j, int k, int preset, int\
    \ clear);\n\n\t\tint Q, clock, J, K, PRESET, CLEAR;\n\t\tint Qprev, Jprev, Kprev;\n\
    };\n\n#endif //__JK_EDGE_FF_H__#include <iostream>\n#include <cstdint>\n#include\
    \ <bitset>\nusing namespace std;\n\nint main(int argc, char** argv) {\n\tbitset<32>\
    \ bin;\n\tbitset<32> twosComp;\n\tint num = -103;\n\tbin = num;\n\ttwosComp =\
    \ ~bin + 1;\n\tcout << \"Bin: \" << bin << endl;\n\tcout << \"Twos Comp: \" <<\
    \ twosComp << endl;\n\treturn 0;\n}#include <iostream>\n#include <cstdint>\n#include\
    \ <bitset>\nusing namespace std;\n\n\nint main(int argc, char** argv) {\n\tuint16_t\
    \ s = 32767;\n\tuint32_t t = 7;\n\tuint32_t u = 255;\n\tfloat a = 442;\n\tbitset<16>\
    \ s_bits(s);\n\tbitset<32> t_bits(t);\n\tbitset<32> u_bits(u);\n\tbitset<32> a_bits(a);\n\
    \tcout << \"s: \" << s << \" : \" << s_bits << endl;\n\tcout << \"t: \" << t <<\
    \ \" : \" << t_bits << endl;\n\tcout << \"u: \" << u << \" : \" << u_bits << endl;\n\
    \tcout << \"a: \" << a << \" : \" << a_bits << endl;\n\tcout << \"Done.\" << endl;\n\
    \treturn 0;\n}\n#include <iostream>\n#include <fstream>\n#include <string>\n#include\
    \ <bitset>\n#include <map>\n#include <regex>\n#include <iomanip>\n#include <cmath>\n\
    #include <cstdint>\nusing namespace std;\n\n#define PI 3.14159265\n\nint main(int\
    \ argc, char** argv) {\n\t// Check for valid file name\n\tif (argc < 2) {\n\t\t\
    cout << \"ERROR: Must specify an input filename.\" << endl;\n\t\tcout << \"Usage:\
    \ \" << argv[0] << \" input_file.ext\" << endl;\n\t\treturn 1;\n\t}\n\n\t// Open\
    \ given input file\n\tifstream inputFile;\n\tinputFile.open(argv[1], ios::in);\n\
    \tif(!inputFile.is_open()) {\n\t\tcout << \"ERROR: Invalid filename: \" << argv[1]\
    \ << endl;\n\t\treturn 1;\n\t}\n\n\t// Declare variables\n\tstring line;\n\tdouble\
    \ r, theta;\n\tuint32_t N = 0;\n\tmap<double, double> sinCosTable;\n\tmap<double,\
    \ double>::iterator sinCosTableIter;\n\n\t// Process file\n\tcout << \"Reading\
    \ file...\" << endl;\n\twhile(getline(inputFile, line)) {\n\t\tif(regex_match(line,\
    \ regex(\"^#[0-9]*$\"))) {\n\t\t\tN = stoi(line);\n\t\t}\n\t\telse if(regex_match(line,\
    \ regex(\"^[-]?[0-9]+\\\\.?[0-9]*$\"))) {\n\t\t\tr = stod(line);\n\t\t\ttheta\
    \ = 2 * PI * r / N;\n\t\t\tsinCosTableIter = sinCosTable.find(theta);\n\t\t\t\
    if(sinCosTableIter == sinCosTable.end()) {\n\t\t\t\tsinCosTable.insert(pair<double,\
    \ double>(theta, sin(theta)));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write file\n\tcout\
    \ << \"Writing file...\" << endl;\n\tofstream outputFile;\n\toutputFile"
- code: "module test_k;\nwire clock;\nwire q;\nwire j, k, preset, clear;\nreg j, k;\n\
    integer i;\narray[0:3,0:3] jk_arr;\njkEdgeFF jk(q, clock, j, k, preset, clear);\n\
    initial\nbegin\nreset_ff;\nj = 1;\nk = 0;\nend\njk_arr[0][0] = 1\u2019b1;\njk_arr[0][1]\
    \ = 1\u2019b1;\njk_arr[0][2] = 1\u2019b1;\njk_arr[1][0] = 1\u2019b1;\njk_arr[1][1]\
    \ = 1\u2019b1;\njk_arr[1][2] = 1\u2019b1;\njk_arr[2][0] = 1\u2019b1;\njk_arr[2][1]\
    \ = 1\u2019b1;\njk_arr[2][2] = 1\u2019b1;\njk_arr[3][0] = 1\u2019b1;\njk_arr[3][1]\
    \ = 1\u2019b1;\njk_arr[3][2] = 1\u2019b1;\nm555 timer(clock);\nendmodule\n###\
    \ Results:\nThe MDA is implemented with a procedural assignment inside a loop.\
    \ The FF is tested with preset inputs that vary every 4 time cycles by 1 bit.\
    \ The first 3 time cycles are not changed, so there is no preset in the first\
    \ 3 time cycles. The 4th cycle has only the first preset bit reset, the 5th cycle\
    \ has both reset bits set and the bit in the middle reset, the 6th cycle has all\
    \ the edges set.\n\n#### Simulation Results:\n{{% figure src=\"test-k-mda/test-k-mda-sim-results-mda-array.png\"\
    \ width=\"100%\" caption=\"Figure 13: Simulation Results\" numbered=true %}}\n\
    \n[1]: https://www.edaplayground.com/x/V6j\n[2]: https://www.edaplayground.com/x/W23\n\
    [3]: https://www.edaplayground.com/x/Y0i\n[4]: https://www.edaplayground.com/x/Y0k\n\
    [5]: https://www.edaplayground.com/x/Y0m\n[6]: https://www.edaplayground.com/x/Y0q\n\
    [7]: https://www.edaplayground.com/x/Y0u\n[8]: https://www.edaplayground.com/x/W25\n\
    [9]: https://www.edaplayground.com/x/W27\n[10]: https://www.edaplayground.com/x/W29\n\
    [11]: https://www.edaplayground.com/x/W2b\n[12]: https://www.edaplayground.com/x/W2d\n\
    [13]: https://www.edaplayground.com/x/W2f\n[14]: https://www.edaplayground.com/x/W2h\n\
    [15]: https://www.edaplay"
- code: |-
    module test_k_new;
    // Array of 4x4 MDA logic arrays
    logic [3:0][63:0][3:0] MDA;
    // Array of 4x4 MDA logic arrays
    logic [3:0][63:0][3:0] MDA_new;
    // Array of 4x4 MDA logic arrays
    logic [3:0][63:0][3:0] MDA_new_new;

    wire q, clock, j, k, preset, clear;
    // Declare instance of test_k module
    test_k_old inst(q, clock, j, k, preset, clear);
    // Declare instance of test_k_new module
    test_k_new_old inst_new(MDA[j][k][3], clock, MDA_new[j][k][3], preset, clear);

    // Declare instance of test_k_new_new module
    test_k_new_new_old inst_new_new(MDA_new[j][k][3], clock, MDA_new_new[j][k][3], preset, clear);

    // Test if MDA is properly assigned
    initial
    begin
    reset_ff;
    j = 3;
    k = 0;
    assert(MDA[0][0][0] == 0);
    assert(MDA[0][0][1] == 1);
    assert(MDA[0][0][2] == 0);
    assert(MDA[0][0][3] == 1);
    assert(MDA[0][1][0] == 0);
    assert(MDA[0][1][1] == 0);
    assert(MDA[0][1][2] == 0);
    assert(MDA[0][1][3] == 0);
    assert(MDA[0][2][0] == 0);
    assert(MDA[0][2][1] == 0);
    assert(MDA[0][2][2] == 0);
    assert(MDA[0][2][3] == 0);
    assert(MDA[0][3][0] == 0);
    assert(MDA[0][3][1] == 0);
    assert(MDA[0][3][2] == 0);
    assert(MDA[0][3][3] == 0);
    assert(MDA[1][0][0] == 0);
    assert(MDA[1][0][1] == 0);
    assert(MDA[1][0][2] == 0);
    assert(MDA[1][0][3] == 0);
    assert(MDA[1][1][0] == 0);
    assert(MDA[1][1][1] == 0);
    assert(MDA[1][1][2] == 0);
    assert(MDA[1][1][3] == 0);
    assert(MDA[1][2][0] == 0);
    assert(MDA[1][2][1] == 0);
    assert(MDA[1][2][2] == 0);
    assert(MDA[1][2][3] == 0);
    assert(MDA[1][3][0] == 0);
    assert(MDA[1][3][1] == 0);
    assert(MDA[1][3][2] == 0);
    assert(MDA[1][3][3] == 0);
    assert(MDA[2][0][0] == 0);
    assert(MDA[2][0][1] == 0);
    assert(MDA[2][0][2] == 0);
    assert(MDA[2][0][3] == 0);
    assert(MDA[2][1][0] == 0);
    assert(MDA[2][1][1] == 0);
    assert(MDA[2][1][2] == 0);
    assert(MDA[2][1][3] == 0);
    assert(MDA[2][2][0] == 0);
    assert(MDA[2][2][1] == 0);
    assert(MDA[2][2][2] == 0);
    assert(MDA[2][2][3] == 0);
    assert(MDA[2][3][0] == 0);
    assert(MDA[2][3][1] == 0);
    assert(MDA[2][3][2] == 0);
    assert(MDA[2][3][3] == 0);
    assert(MDA[3][0][0] == 0);
    assert(MDA[3][0][1] == 0);
    assert(MDA[3][0][2] == 0);
    assert(MDA[3][0][3] == 0);
    assert(MDA[3][1][0] == 0);
    assert(MDA[3][1][1] == 0);
    assert(MDA[3][1][2] == 0);
    assert(MDA[3][1][3] == 0);
    assert(MDA[3][2][0] == 0);
    assert(MDA[3][2][1] == 0);
    assert(MDA[3][2][2] == 0);
    assert(MDA[3][2][3] == 0);
    assert(MDA[3][3][0] == 0);
    assert(MDA[3][3][1] == 0);
    assert(MDA[3][3][2] == 0);
    assert(MDA[3][3][3] == 0);

    // Test if MDA_new[3][1][3] is properly assigned
    assert(MDA_new[3][1][3] == 0);
    assert(MDA_new_new[3][1][3] == 0);

    // Test if MDA[2][3][1] is properly assigned
    assert(MDA[2][3][1] == 0);
    assert(MDA_new[2][3][1] == 0);
    assert(MDA_new_new[2][3][1] == 0);

    // Test if MDA[1][1][0] is not assigned because k[4] is set to 0
    assert(MDA[1][1][0] == 1);
    assert(MDA_new[1][1][0] == 0);
    assert(MDA_new_new[1][1][0] == 0);

    // Test if MDA[1][1][1] is not assigned because both j[1] and k[4] are set to 1
    assert(MDA[1][1][1] == 0);
    assert(MDA_new[1][1][1] == 0);
    assert(MDA_new_new[1][1][1] == 0);

    // Test if MDA[1][1][2] is not assigned because both j[1] and k[4] are set to 1
    assert(MDA[1][1][2] == 0);
    assert(MDA_new[1][1][2] == 0);
    assert(MDA_new_new[1][1][2] == 0);

    // Test if MDA[1][1][3] is not assigned because both j[1] and k[4] are set to 1
    assert(MDA[1][1][3] == 0);
    assert(MDA_new[1][1][3] == 0);
    assert(MDA_new_new[1][1][3] == 0);

    // Test if MDA[0][0][1] is not assigned because k[4] is set to 0 and MDA[0][0][1] is assigned
    assert(MDA[0][0][1] == 0);
    assert(MDA_new[0][0][1] == 0);
    assert(MDA_new_new[0][0][1] == 0);

    // Test if MDA[0][0][2] is not assigned because k[4] is set to 0 and MDA[0][0][2] is assigned
    assert(MDA[0][0][2] == 0);
    assert(MDA_new[0][0][2] == 0);
    assert(MDA_new_new[0][0][2] == 0);

    // Test if MDA[0][0][3] is not assigned because k[4] is set to 0 and MDA[0][0][3] is assigned
    assert(MDA[0][0][3] == 0);
    assert(MDA_new[0][0][3] == 0);
    assert(MDA
- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdge
- code: |-
    logic [3:0] state;
    logic [3:0] states[5];
    begin
    state = 0;
    state = 1;
    state = 2;
    state = 3;
    state = 4;
    assign states[state] = 1;
    end
    ### Verilog Code:
    module test_mda(
    input logic clock
    );
    logic [3:0] state;
    logic [3:0] states[5];
    begin
    state = 0;
    states[state] = 1;
    state = 1;
    states[state] = 1;
    state = 2;
    states[state] = 1;
    state = 3;
    states[state] = 1;
    state = 4;
    states[state] = 1;
    end
    ###
- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    assign q = clk & (j |!k);
    m555 timer(clock);
    endmodule
    ### Test Bench:
    module test_k;
    reg clock;
    reg reset;
    m555 timer(clock);
    endmodule
    ### Test Configuration:
    - Configuration Name: Module_Test
    - Test Bench File Name: test_k.v
    - Top Level Module Name: test_k
    - Operating Frequency: 50MHz
    - Operating Voltage: 1.8V
    - Simulation Type: Behavioral
    ### Test Results:
    - Top Level Module Name: test_k
    - Simulation Frequency: 54.8MHz
    - Simulation Time: 100ns
    - Simulation Run Time: 4.95433068594
    - Simulation Status: Pass
    - Simulation Done: True
    - Simulation Warnings: 0 Warning(s)
    - Simulation Errors: 0 Error(s)
    - Simulation Failures: 0 Failure(s)
    - Simulation Stopped: False
    ### Summary Report:
    - Total Number of Test Modules Found: 1
    - Total Number of Test Configurations Found: 1
    - Total Number of Simulation Runs: 1
    - Total Number of Warnings: 0
    - Total Number of Errors: 0
    - Total Number of Failures: 0
    - Total Number of Skipped: 0
    ### Test Coverage:
    - Coverage Status: 0%
    ### Test Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Test Coverage Detailed:
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Detailed:
    - File: test_k.v
    - Line: 9
    - Missed: 1
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Missed: 1
    - Total Blocks Missed: 1
    ### Coverage Summary:
    - Total Lines Covered: 0
    - Total Blocks Covered: 0
    - Total Lines Mis
- code: |-
    ### Results:

    ### Comments:

    ### Previous Tests:

    ### Expected Output:

    ### Expected Trace:

    ### Test Steps:

    ### Test Output:

    /unitTests/gen_test_cases/test_2.c
    #include <stdio.h>

    #define M 10
    #define N 2
    #define P 2

    int main() {
        int m, n, p;
        m = 1; n = 2; p = 3;
        int a[M][N][P], b[N][P], c[M][P];
        int i, j, k;

        for (i = 0; i < M; i++) {
            for (j = 0; j < N; j++) {
                for (k = 0; k < P; k++) {
                    a[i][j][k] = (i + j + k) % 2;
                    b[j][k] = (j + k + 1) % 2;
                }
            }
        }

        for (i = 0; i < M; i++) {
            for (j = 0; j < P; j++) {
                c[i][j] = 0;
                for (k = 0; k < N; k++) {
                    c[i][j] += a[i][k][j] * b[k][j];
                    c[i][j] = c[i][j] % 2;
                }
            }
        }

        for (i = 0; i < M; i++) {
            for (j = 0; j < P; j++) {
                printf("%d ", c[i][j]);
            }
            printf("\n");
        }
    }
    /unitTests/gen_test_cases/test_3.c
    #include <stdio.h>

    #define M 10
    #define N 2
    #define P 2
    #define Q 3

    int main() {
        int m, n, p, q;
        m = 1; n = 2; p = 3; q = 4;
        int a[M][N][P][Q], b[N][P][Q], c[M][P][Q];
        int i, j, k, l;

        for (i = 0; i < M; i++) {
            for (j = 0; j < N; j++) {
                for (k = 0; k < P; k++) {
                    for (l = 0; l < Q; l++) {
                        a[i][j][k][l] = (i + j + k + l) % 2;
                        b[j][k][l] = (j + k + l + 1) % 2;
                    }
                }
            }
        }

        for (i = 0; i < M; i++) {
            for (j = 0; j < P; j++) {
                for (k = 0; k < Q; k++) {
                    c[i][j][k] = 0;
                    for (l = 0; l < N; l++) {
                        c[i][j][k] += a[i][l][j][k] * b[l][j][k];
                        c[i][j][k] = c[i][j][k] % 2;
                    }
                }
            }
        }

        for (i = 0; i < M; i++) {
            for (j = 0; j < P; j++) {
                for (k = 0; k < Q; k++) {
                    printf("%d ", c[i][j][k]);
                }
                printf("\n");
            }
            printf("\n");
        }
    }
    /unitTests/unitTestPlan.md
    ## Unit Test Plan

    ### Test Suite 1 - 1-D Array
    | Test Case | Comment | Modified Code | Base/Verilog Code |
    | ---------- | ------- | ------------- | ----------------- |
    | 00001 | 2-D single dimension: `int a[M][N]`  | `int b[N][M]` | `module test_array; wire q, clock; wire [7:0] i, j, k; reg k; reg [7:0] b[N][M]; initial begin reset_ff; k = 0; end m555 timer(clock); assign q = a[i][j]; endmodule` |
    | 00002 | 2-D single dimension: `int a[M][N]`  | `int b[N][M]` | `module test_array; wire q, clock; wire [7:0] i, j, k; reg k; reg [7:0] b[N][M]; initial begin reset_ff; k = 0; end m555 timer(clock); assign q = a[j][i]; endmodule` |
    | 00003 | 2-D single dimension: `int a[M][N]`  | `int b[N][M]` | `module test_array; wire q, clock; wire [7:0] i, j, k; reg k; reg [7:0] b[N][M]; initial begin reset_ff; k = 0; end m555 timer(clock); assign q = a[i][k+1]; endmodule` |
    | 00004 | 2-D single dimension: `int a[M][N]`  | `int b[N][M]` | `module test_array; wire q, clock; wire [7:0] i, j, k; reg k; reg [7:0] b[N][M]; initial begin reset_ff; k = 0; end m555 timer(clock); assign q = a[k+1][i]; endmodule` |
    | 00005 | 2-D single dimension: `int
- code: |-
    #### Base Verilog Code:
    module test_k;
    wire q, clock, j, k, preset, clear, a, b;
    kLatch jk(q, clock, j, k, preset, clear);
    initial begin reset_ff; j = 1; k = 0; end
    m555 timer(clock);
    endmodule
    #### Instruction:
    proc initial begin preset = preset_logic_array[a][b]; end
    ### Result:
    j = 2
    k = 2
    #### Expected:
    j = 2
    k = 2
    ### Base Verilog Code:
    module test_k;
    wire q, clock, j, k, preset, clear, a, b;
    kLatch jk(q, clock, j, k, preset, clear);
    initial begin preset = preset_logic_array[a][b]; end
    m555 timer(clock);
    endmodule
    ### Instruction:
    mod jkEdgeFF#(1) jk(q, clock, j, k, preset, clear);
    ### Result:
    j = 3
    k = 3
    #### Expected:
    j = 3
    k = 3
    ### Base Verilog Code:
    module test_k;
    wire q, clock, j, k, preset, clear, a, b;
    kLatch jk(q, clock, j, k, preset, clear);
    initial begin preset = preset_logic_array[a][b]; end
    m555 timer(clock);
    endmodule
    ### Instruction:
    mod jkEdgeFF#(1) jk(q, clock, j, k, preset, clear);
    mod test_k(preset, preset_logic_array[a][b], clear);
    ### Result:
    j = 3
    k = 3
    ####
- code: |-
    [cpp]
    ### Original Verilog Code:
    module test_mux;
    output a, b;
    input sel;
    assign a = sel? b : a;
    assign b = sel?
- code: "module clock_gen_forever; // Renamed module for clarity\n  reg clk, en;\n\
    \  // Generate clock using forever loop, controlled by 'en'\n  always @(posedge\
    \ en) // Start clock generation on posedge en\n    forever #2 clk = ~clk; // Toggle\
    \ clock every 2 time units forever\n  initial\n  begin\n    clk = 1'b0; // Initialize\
    \ clock\n    en = 1'b0; // Start disabled\n    $monitor(\"clk=%b, t=%0d, en=%b\
    \ \", clk,$time,en);\n  end\nendmodule\n```\n\n## References\n* Verilog HDL Programming\
    \ by \n#include \"mystdlib.h\"\nlong fibonacci(int n)\n{\n    int res = 0;\n \
    \   int a = 0;\n    int b = 1;\n    if(n==0)\n    {\n        res = a;\n    }\n\
    \    else if(n==1)\n    {\n        res = b;\n    }\n    else\n    {\n        for(int\
    \ i=2;i<=n;i++)\n        {\n            res = a+b;\n            a = b;\n     \
    \       b = res;\n        }\n    }\n    return res;\n}## Introduction\nSystemC\
    \ is an open-source language and a formal verification methodology developed by\
    \ the IEEE and an industry-wide simulation support infrastructure (ISS) called\
    \ SystemC. \n\n## Why SystemC?\nSystemC has been designed to build a new methodology\
    \ of high-level hardware design and verification.\n\n## SystemC Features\n* **Extensible**,\
    \ users can create their own C++ classes that encapsulate data-structures, and\
    \ then pass or receive them as parameters to SystemC's built-in procedures.\n\
    * **Modular**, the language is divided into separate units of computation called\
    \ _modules_ that can be composed in a variety of ways to produce large-scale simulations.\n\
    * **Object-oriented**, provides full-featured classes to represent data-structures,\
    \ processes, and functions.\n* **Flexible**, uses C++ as a primary design language,\
    \ and is interoperable through the use of a _runtime system_ that interprets C++\
    \ code.\n* **Low-level**, offers a C++-like syntax that runs faster than conventional\
    \ C++ and lets you program a large-scale simulation without going through the\
    \ formal verification process.\n* **Simulation**, allows you to simulate and verify\
    \ your designs using the same simulation language to run both hardware and software\
    \ simulators.\n\n## References\n* [SystemC System-Level Design Language](https://www.csee.umbc.edu/courses/486/systemc/language/book.html)\
    \ by \n#include <iostream>\n#include <string>\n \nusing namespace std;\n\n// base\
    \ class\nclass Person\n{\n  public:\n    // constructor\n    Person(std::string\
    \ name, int age) : m_Name(name), m_Age(age) {}\n    // destructor\n    ~Person()\
    \ {}\n \n    // get and set methods\n    std::string getName(void) { return m_Name;\
    \ }\n    void setName(std::string name) { m_Name = name; }\n    int getAge(void)\
    \ { return m_Age; }\n    void setAge(int age) { m_Age = age; }\n \n  protected:\n\
    \    // attributes\n    std::string m_Name;\n    int m_Age;\n};\n \n// derived\
    \ class\nclass Employee : public Person\n{\n  public:\n    // constructor\n  \
    \  Employee(std::string name, int age, std::string dept, double salary) : Person(name,\
    \ age), m_Dept(dept), m_Salary(salary) {}\n \n    // get and set methods\n   \
    \ std::string getDept(void) { return m_Dept; }\n    void setDept(std::string dept)\
    \ { m_Dept = dept; }\n    double getSalary(void) { return m_Salary; }\n    void\
    \ setSalary(double salary) { m_Salary = salary; }\n \n  private:\n    // attributes\n\
    \    std::string m_Dept;\n    double m_Salary;\n};\n \nint main()\n{\n    Employee\
    \ e1(\"David\", 35, \"Marketing\", 60000);\n \n    cout << \"Dept. = \" << e1.getDept()\
    \ << endl;\n    cout << \"Salary = \" << e1.getSalary() << endl;\n \n    // Derived\
    \ class can access the base class public members\n    cout << \"Name = \" << e1.getName()\
    \ << endl;\n    cout << \"Age = \" << e1.getAge() << endl;\n \n    return 0;\n\
    }#include <stdio.h>\n\nint main()\n{\n    int iLoop;\n\n    for (iLoop = 0; iLoop\
    \ < 10; iLoop++) {\n        if (iLoop == 5) {\n            continue;\n       \
    \ }\n        printf(\"Loop #%d\\n\", iLoop);\n    }\n\n    return 0;\n}#include\
    \ <stdio.h>\n\nint main()\n{\n    int iLoop = 0;\n\n    for (iLoop = 0; iLoop\
    \ < 10; iLoop++) {\n        if (iLoop == 5) {\n            break;\n        }\n\
    \        printf(\"Loop #%d\\n\", iLoop);\n    }\n\n    return 0;\n}## Introduction\n\
    Verilog HDL is a Hardware Description Language that is used by digital signal\
    \ processors or custom integrated circuits (IC) to describe and simulate the behavior\
    \ of digital circuits.\n\n## Verilog Architecture\n![verilog-architecture](./images/verilog-architecture.png)\n\
    \n## References\n* [Verilog HDL Programming](https://www.coursera.org/learn/digital-logic-design)\
    \ by Imperial College London\n#include \"mystdlib.h\"\nlong fibonacci(int n)\n\
    {\n    int res = 0;\n    int a = 0;\n    int b = 1;\n    if(n==0)\n    {\n   \
    \     res = a;\n    }\n    else if(n==1)\n    {\n        res = b;\n    }\n   \
    \ else\n    {\n        for(int i=2;i<=n;i++)\n        {\n            res = a+b;\n\
    \            a = b;\n            b = res;\n        }\n    }\n    return res;\n\
    }## Introduction\nThis project is aimed at creating an embedded system that can\
    \ run a simple program.\n\n## Program Files\n* [main.c](./src/main.c)\n* [mystdlib.h](./src/mystdlib.h)\n\
    * [fibonacci.c](./src/fibonacci.c)\n* [Makefile](./src/Makefile)\n\n## Build\n\
    ```bash\n$ make\n```\n\n## Use a Makefile to Compile the Program\n```makefile\n\
    # Makefile\n# Compile with -std=c89\n# Run with./a.out\n\nCC=gcc\nCFLAGS=-Wall\
    \ -std=c89\n\na.out: main.o fibonacci.o\n\t$(CC) $(CFLAGS) -o a.out main.o fibonacci.o\n\
    \ntest: a.out\n\t@echo \"Running the program...\"\n\t./a.out\n\nmain.o: main.c\
    \ mystdlib.h\n\t$(CC) $(CFLAGS) -c main.c -o main.o\n\nfibonacci.o: fibonacci.c\
    \ mystdlib.h\n\t$(CC) $(CFLAGS) -c fibonacci.c -o fibonacci.o\n\nclean:\n\trm\
    \ -f *.o a.out\n\trm -f *.o build/*\n\techo \"Cleaned up!\"\n```## Introduction\n\
    This project is aimed at creating a basic operating system that can run a simple\
    \ program.\n\n## References\n* [Writing a Basic Operating System](https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf)\
    \ by \n#include <stdio.h>\n\nint main()\n{\n    printf(\"Hello, world!\\n\");\n\
    \n    return 0;\n}## Introduction\nA Verilog module is a program unit that contains\
    \ a set of signals and statements.\n\n## Declaring a Verilog Module\n```verilog\n\
    module m1(input i, output o);\n  // Declare module statement, followed by all\
    \ module signals and statements\n  reg data; // Local register declaration\n \
    \ always @* begin // Declare always block to process all signals\n    data = i;\
    \ // Assign values to module signals\n  end\nendmodule\n```\n\n## Verilog Module\
    \ Properties\n* __interface__ - A Verilog module is a set of signals and statements\
    \ that communicate with other modules in a system\n* __local__ - A verilog module\
    \ is contained within a module\n\n## Properties of a Verilog Module\n* **Naming**\
    \ - A module must be named on the first line of the module\n* **Syntax** - Follows\
    \ the following syntax:\n  * `module` followed by module name (no spaces)\n  *\
    \ `(` followed by module input and output signals\n  * `)` followed by module\
    \ local signals and statements\n  * `endmodule`\n* **Input** - A module input\
    \ signal is signaled by an input keyword followed by a signal name\n* **Output**\
    \ - A module output signal is signaled by an output keyword followed by"
- code: "module clock_gen_while;\n  reg clk;\n  initial\n  begin\n    clk = 1'b0;\
    \ // Initialize clock\n  end\n  initial $monitor(\"clk=%b \", clk);\n  always\
    \ @(posedge clk)\n  begin\n    int i = 0;\n    while (i<10) begin\n      i = i+1;\n\
    \      $display(\"%b\", clk);\n    end\n  end\nendmodule\n### Variation Result:\n\
    <img width=\"561\" alt=\"clock_gen_while_result\" src=\"https://user-images.githubusercontent.com/10882977/126895969-6b04c2e6-d881-4f2b-b7b5-1097eb190236.png\"\
    >\n\n## 11.4.1.0. Forever Loop - Synthesis\n### Base Module:\nmodule testbench;\n\
    \  reg clk;\n  initial begin\n    $monitor(\"clk=%b\", clk);\n  end\n  initial\
    \ clk = 1'b0;\n  always\n  begin\n    $monitor(\"clk=%b\", clk);\n    for (int\
    \ i = 0; i<10; i=i+1)\n      clk = ~clk;\n  end\nendmodule\n### Variation Instruction:\n\
    Modify the forever loop to:\n  1. use a for loop\n  2. use a while loop\n  3.\
    \ use a case statement\n  4. use a for each loop \n### Variation Result:\n<img\
    \ width=\"561\" alt=\"forever_loop_synthesis_result\" src=\"https://user-images.githubusercontent.com/10882977/126895976-9f695a5c-c253-4263-9603-5b2e04a9330c.png\"\
    >\n\n## 11.4.1.1. Forever Loop - Analystics\n### Base Module:\nmodule testbench;\n\
    \  reg clk;\n  initial begin\n    $monitor(\"clk=%b\", clk);\n  end\n  initial\
    \ clk = 1'b0;\n  always\n  begin\n    $monitor(\"clk=%b\", clk);\n    for (int\
    \ i = 0; i<10; i=i+1)\n      clk = ~clk;\n  end\nendmodule\n### Variation Instruction:\n\
    Modify the forever loop to:\n  1. use a for loop\n  2. use a while loop\n  3.\
    \ use a case statement\n  4. use a for each loop \n### Variation Result:\n<img\
    \ width=\"561\" alt=\"forever_loop_analytical_result\" src=\"https://user-images.githubusercontent.com/10882977/126895983-396f1383-0600-4f77-9761-079d661501d5.png\"\
    >\n\n## 11.4.1.2. Forever Loop - Synthesis\n### Base Module:\nmodule testbench;\n\
    \  reg clk;\n  initial begin\n    $monitor(\"clk=%b\", clk);\n  end\n  initial\
    \ clk = 1'b0;\n  always\n  begin\n    $monitor(\"clk=%b\", clk);\n    for (int\
    \ i = 0; i<10; i=i+1)\n      clk = ~clk;\n  end\nendmodule\n### Variation Instruction:\n\
    Modify the forever loop to:\n  1. use a for loop\n  2. use a while loop\n  3.\
    \ use a case statement\n  4. use a for each loop \n### Variation Result:\n<img\
    \ width=\"561\" alt=\"forever_loop_synthesis_result\" src=\"https://user-images.githubusercontent.com/10882977/126895979-93cd6149-3804-4f4a-9023-23896d459ad1"
- code: "module clock_gen_forever_variation; // Renamed module for clarity\n  reg\
    \ clk, en;\n  // Generate clock using forever loop, controlled by 'en'\n  always\
    \ @(posedge en) // Start clock generation on posedge en\n  begin: clock_gen\n\
    \    for (int i = 0; i<2; i++) #2 clk = ~clk;\n  end\n  initial\n  begin\n   \
    \ clk = 1'b0; // Initialize clock\n    en = 1'b0; // Start disabled\n  end\n \
    \ initial $monitor(\"clk=%b, t=%0d, en=%b \", clk,$time,en);\nendmodule\n### Expected\
    \ Output:\nclk=0, t= 0, en=0 clk=1, t=2, en=0 clk=0, t=4, en=0 clk=1, t=6, en=0\
    \ clk=0, t=8, en=0 clk=1, t=10, en=0\n### Actual Output:\nclk=0, t= 0, en=0 clk=1,\
    \ t=2, en=0 clk=0, t=4, en=0 clk=1, t=6, en=0 clk=0, t=8, en=0 clk=1, t=10, en=0\n\
    ```\n\n## Conclusion\nAlthough the for loop in the Verilog code wasn't actually\
    \ used in the clock generator, the change was successful. In this case, it was\
    \ a way to simplify the code and eliminate possible errors./201/201-lab2.md\n\
    # Lab 2 Designing a Sequential Synchronous System\n\n| Student Name | Student\
    \ Number |\n| :----------: | :------------: |\n|       |    10150329    |\n\n\
    ## Objective\nThe objective of this lab is to design a sequential synchronous\
    \ system, using the sequential circuit design process. \n\n## Problem 1 Sequential\
    \ Circuits\n\n### Part 1: Adding Registers\n\n### Base Circuit\n![image](https://user-images.githubusercontent.com/22657155/119267433-bc2e1e00-bba7-11eb-909a-9e48d558d238.png)\n\
    \n### Base Code\n```verilog\nmodule add_8bits(input [7:0] in1, input [7:0] in2,output\
    \ [7:0] out);\n  reg [7:0] out;\n  always @(*)\n    out = in1 + in2;\nendmodule\n\
    ```\n\n### Variation 1 Instruction:\nAdd additional register to the circuit, called\
    \ \"out_reg\"\n\n### Variation 1 Code\n```verilog\nmodule add_8bits_variation1(input\
    \ [7:0] in1, input [7:0] in2,output [7:0] out);\n  reg [7:0] out;\n  reg [7:0]\
    \ out_reg;\n  always @(*)\n    out_reg = in1 + in2;\n    out = out_reg;\nendmodule\n\
    ```\n\n### Variation 2 Instruction:\nInstead, the output register should be updated\
    \ synchronously with the addition.\n\n### Variation 2 Code\n```verilog\nmodule\
    \ add_8bits_variation2(input [7:0] in1, input [7:0] in2,output [7:0] out);\n \
    \ reg [7:0] out;\n  reg [7:0] out_reg;\n  always @(*)\n    out = in1 + in2;\n\
    \    out_reg = out;\nendmodule\n```\n\n### Variation 3 Instruction:\nThe addition\
    \ can be performed differently. This time, the input1 and input2 are summed to\
    \ the register, and then the new sum is output to the output register.\n\n###\
    \ Variation 3 Code\n```verilog\nmodule add_8bits_variation3(input [7:0] in1, input\
    \ [7:0] in2,output [7:0] out);\n  reg [7:0] out;\n  reg [7:0] out_reg;\n  always\
    \ @(*)\n    out_reg = in1 + in2;\n    out = out_reg;\nendmodule\n```\n\n### Variation\
    \ 4 Instruction:\nThe register is now used as a buffer, and the addition of the\
    \ input signals is done in parallel.\n\n### Variation 4 Code\n```verilog\nmodule\
    \ add_8bits_variation4(input [7:0] in1, input [7:0] in2,output [7:0] out);\n \
    \ reg [7:0] out;\n  reg [7:0] out_reg;\n  always @(*)\n    out = in1 + in2;\n\
    endmodule\n```\n\n### Expected Output\nVariation 1:\n![image](https://user-images.githubusercontent.com/22657155/120093961-f9498c80-c13b-11eb-808a-7189919a6955.png)\n\
    \nVariation 2:\n![image](https://user-images.githubusercontent.com/22657155/120093965-01093100-c13c-11eb-9363-d57958a17487.png)\n\
    \nVariation 3:\n![image](https://user-images.githubusercontent.com/22657155/120093971-0e262000-c13c-11eb-8198-0375b5e00284.png)\n\
    \nVariation 4:\n![image](https://user-images.githubusercontent.com/22657155/120093975-154d2e00-c13c-11eb-929b-1c8f228038e4.png)\n\
    \n## Problem 2 Sequential Synchronization\n\n### Part 1: Synchronous Circuit\n\
    \n### Base Code\n```verilog\nmodule add_8bits_sync(input wire in1, input wire\
    \ in2,output wire out);\n  reg [7:0] out_reg;\n  always @(*)\n    out_reg = in1\
    \ + in2;\n  always @in1, @in2\n      out = out_reg;\nendmodule\n```\n\n### Variation\
    \ 1 Instruction:\nOutput of register is assigned to output only when both input\
    \ signals have changed.\n\n### Variation 1 Code\n```verilog\nmodule add_8bits_sync_variation1(input\
    \ wire in1, input wire in2,output wire out);\n  reg [7:0] out_reg;\n  always @(*)\n\
    \    out_reg = in1 + in2;\n  always @(in1 or in2)\n      out = out_reg;\nendmodule\n\
    ```\n\n### Variation 2 Instruction:\nOutput of register is not assigned to output\
    \ unless one of the input signals changes.\n\n### Variation 2 Code\n```verilog\n\
    module add_8bits_sync_variation2(input wire in1, input wire in2,output wire out);\n\
    \  reg [7:0] out_reg;\n  always @(*)\n    out_reg = in1 + in2;\n  always @(in1\
    \ or in2)\n      out = out_reg;\nendmodule\n```\n\n### Variation 3 Instruction:\n\
    Output of register is assigned to output only if only one of the input signals\
    \ changes.\n\n### Variation 3 Code\n```verilog\nmodule add_8bits_sync_variation3(input\
    \ wire in1, input wire in2,output wire out);\n  reg [7:0] out_reg;\n  always @(*)\n\
    \    out_reg = in1 + in2;\n  always @in1, @in2\n      out = out_reg;\nendmodule\n\
    ```\n\n### Variation 4 Instruction:\nOutput of register is assigned to output\
    \ every time the input signals change.\n\n### Variation 4 Code\n```verilog\nmodule\
    \ add_8bits_sync_variation4(input wire in1, input wire in2,output wire out);\n\
    \  reg [7:0] out_reg;\n  always @(*)\n    out_reg = in1 + in2;\n  always @in1,\
    \ @in2, @*\n      out = out_reg;\nendmodule\n```\n\n### Expected Output\nVariation\
    \ 1:\n![image](https://user-images.githubusercontent.com/22657155/120093280-30615d00-c137-11eb-9602-1e034101529f.png)\n\
    \nVariation 2:\n![image](https://user-images.githubusercontent.com/22657155/120093283"
- code: |-
    module clock_gen_forever;
      reg clk;
      initial clk=1'b0;
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("clk=%b, t=%0d", clk,$time);
      initial #2 $monitor("
- code: |-
    module clock_gen_while; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        while (en)
        clk = ~clk; // Toggle clock every 2 time units
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Observation:
    The results of the test above can be verified by executing the code.  You may run into a problem if the code is being run in simulation.  If this is the case, you may want to run it with the following command on the command line:

    ```
    vsim -sv -do "do sim.do" work.clock_gen_while
    ```

    This command will run the simulation in batch mode, and you will not be able to view the results. To see the results, you can
- code: |-
    ```
    module clock_gen_genvar; // Renamed module for clarity
      reg clk, en;
      // Generate clock using forever loop, controlled by 'en'
      genvar i;
      always @(posedge en) // Start clock generation on posedge en
        i=2;
        while (i>0)
          clk = ~clk; // Toggle clock every 2 time units forever
          i=i-1;
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      always @(posedge en) // Start clock generation on posedge en
        $display("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ```
    ### Output:
    ```
    clk=0, t=0, en=0
    clk=1, t=2, en=1
    clk=0, t=4, en=1
    clk=1, t=6, en=1
    clk=0, t=8, en=1
    clk=1, t=10, en=1
    clk=0, t=12, en=1
    clk=1, t=14, en=1
    clk=0, t=16, en=1
    clk=1, t=18, en=1
    clk=0, t=20, en=1
    clk=1, t=22, en=1
    clk=0, t=24, en=1
    clk=1, t=26, en=1
    clk=0, t=28, en=1
    clk=1, t=30, en=1
    clk=0, t=32, en=1
    clk=1, t=34, en=1
    clk=0, t=36, en=1
    clk=1, t=38, en=1
    clk=0, t=40, en=1
    clk=1, t=42, en=1
    clk=0, t=44, en=1
    clk=1, t=46, en=1
    clk=0, t=48, en=1
    clk=1, t=50, en=1
    ```


    ## Design 5
    ### Base Verilog Code:
    ```
    module design5;

      reg [7:0] num_a = 8'd15;
      reg [7:0] num_b = 8'd15;
      wire [7:0] result;


      initial
      begin
        $monitor("num_a=%3h, num_b=%3h, result=%3h
- code: |-
    module clock_gen_while_module; // Renamed module for clarity
      reg clk, en;
      // Generate clock using while loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        localparam int i = 0;
        if (i == 0) begin
          clk = 1'b1; // Enable clock
          i = 1;
        end
        if (i == 1) begin
          clk = 1'b0; // Disable clock
          i = 0;
        end
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule

    ## clock_gen_while_module_localparam (clock generator, while, module, localparam)
    ### Base Verilog Code:
    module clock_gen_while_module_localparam; // Renamed module for clarity
      reg clk, en;
      // Generate clock using while loop, controlled by 'en'
      always @(posedge en) // Start clock
- code: |-
    // Modified module for clarity
    module clock_gen_for;
      reg clk, en;
      int index;
      // Generate clock using for loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
      begin
        $monitor("t=%0d ",$time);
        for (index = 0; index < 5; index = index + 1) // 5 time units
          clk = ~clk; // Toggle clock every time unit
      end
      initial
      begin
        clk = 1'b0; // Initialize clock
        en = 1'b0; // Start disabled
      end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

    endmodule/README.md
    # FPGA-Clock-Generation
    Verilog code for generating a 100Mhz clock using two different methods to toggle a clock.
- code: |-
    module clock_gen_forever; // Renamed module for clarity
      reg clk, en;
      integer i;
      // Generate clock using forever loop, controlled by 'en'
      always @(posedge en) // Start clock generation on posedge en
        #10 i=0;
        if(i<10) begin
          #10 clk = ~clk;
          $display("clk=%b, t=%0d, en=%b, i=%b", clk,$time,en,i);
          i=i+1;
        end
      initial
      begin
        clk = 1'b1; // Initialize clock
        en = 1'b1; // Start Disabled to run as fast as possible
      end
      initial $monitor("clk=%b, t=%0d, en=%b, i=%b ", clk,$time,en,i);
    endmodule
    ### Variation Instruction:
    Change the initial condition of clk to be clk=1'b1;
    This tells the clock generator to start running immediately.
    ###
- code: |-
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ### Simulation Result:
    ![Alt text](/Users/christinamcdonald/Desktop/CSCE6250_Verilog/Lab3/simulation_results/clock_gen_forever_simulation_result.png?raw=true "Simulation Result 1")
    </hr>
    <hr>
    <br>
    <br>
    <hr>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16)</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);
    endmodule
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        for (int i=0; i<2; i=i+1)
          clk[i] = clk[i-1];
      end
    endmodule
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        for (int i=0; i<2; i=i+1)
          clk[i] = clk[i-1];
      end
    endmodule
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression, Simplified</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      end
    endmodule
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression, Simplified, Verilog Function</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      end
    endmodule

    function [1:0] gentime(input int t);
    return t-2;
    endfunction
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression, Simplified, Verilog Function, Verilog Function Call</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      end
    endmodule

    function [1:0] gentime(input int t);
    return t-2;
    endfunction
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression, Simplified, Verilog Function, Verilog Function Call, Verilog Function Call with Initial</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate clock using forever loop, controlled by 'en'
      reg [1:0] clk = {1'b0, 1'b0};
      always @(posedge en) // Start clock generation on posedge en
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      initial begin clk = 0; end
      initial $monitor("clk=%b, t=%0d, en=%b ", clk,$time,en);

      always begin
        #2 clk[1] = ~clk[1]; // Toggle clock every 2 time units forever
        clk[0] = clk[1];
      end
    endmodule

    function [1:0] gentime(input int t);
    return t-2;
    endfunction
    ```
    <br>
    <hr>
    <h3>Lab 3 Code: Module Clock Gen Forever (10/30/16) with For Loop, Inside Expression, Simplified, Verilog Function, Verilog Function Call, Verilog Function Call with Initial</h3>
    ```
    module clock_gen_forever(output clk, input en); // Renamed module for clarity
      // Generate
- code: |-
    module equivtest(o1,o2,i1,i2,i3);
    input i1,i2,i3;
    input [7:0] sel;
    output o1,o2;
    // Evaluate if two wires are the same
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior
- code: |-
    module contres(o,i1,i2,i3);
    input i1,i2,i3;
    output o;
    o=i1[1:2];
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    buf(pull1, weak0) g3(o,i3
- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf b1 (pull1, weak0) g1 (.o(i1[0:3]),.i1(i1[0:3])); // Drives pull '1', weak '0'
    buf b
- code: |-
    module foo(o1,o2);
    output o1,o2;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o1,1'b1);
    buf(pull1, weak0) g2(o2,1'b0);
    endmodule
    module bar(i1,i2,o1,o2);
    input i1,i2;
    output o1,o2;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o1,i1);
    buf(pull1, weak0) g2(o2,i2);
    endmodule
- code: |-
    module test_delay(clock, reset, input1, input2, output1, output2);
    input clock,reset;
    input input1,input2;
    output output1,output2;
    // Delay the outputs by one clock cycle
    // The generator is clocked by clock, reset by reset
    buf(reset,weak0) g1(output1,input1);
    buf(reset,weak0) g2(output2,input2);
    buf(reset,weak0) g3(output1,output1);
    count(clock) g4(output1,output2);
- code: |-
    module contres(o,i1,i2,i3,i4);
    input i1,i2;
    input i3,i4;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    initial begin
    if (i1==1 && i2==1 && i3==1 && i4==1) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=1;
    end else begin
    if (i1==1 && i2==1 && i3==1 && i4==0) begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=1;
    end else begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end
    end
    endmodule

    ## Example 23

    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    initial begin
    if (i1==0 && i2==0) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==0 && i2==1) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==1 && i2==0) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==1 && i2==1) begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=1;
    end else begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=X;
    end
    end
    end
    end
    endmodule

    ## Example 24

    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    initial begin
    if (i1==0 && i2==0) begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==0 && i2==1) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==1 && i2==0) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==1 && i2==1) begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=1;
    end else begin
    // 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=X;
    end
    end
    end
    end
    endmodule

    ## Example 25

    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    initial begin
    if (i1==0 && i2==0) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==0 && i2==1) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
    if (i1==1 && i2==0) begin
    // 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    o=0;
    end else begin
- code: "buf o(i, weak);\n\n## 10.14.6. Tristate Register Array\xB6\n\nmodule cta(o_dout,o_we,i_din,i_we,i_dout,i_ce,i_clr);\n\
    \ninput  [5:0] i_din;\noutput i_we;\noutput [5:0] i_dout;\ninput i_ce;\ninput\
    \ i_clr;\noutput [5:0] o_dout;\noutput o_we;\n\n// o_dout is driven from i_dout\
    \ when i_ce and i_clr are both high\nbuf i(o_dout, i"
- code: "module contres(o,i1,i2);\ninput i1,i2;\noutput o;\n// Drive wire 'o' from\
    \ two buffers with specified output strengths\nbuf(pull1, weak0) g1(o,i1); //\
    \ Drives pull '1', weak '0'\nbuf(pull1, weak0) g2(o,i2); // Drives pull '1', weak\
    \ '0'\n// Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z\n\
    // Effective behavior is OR due to pull1 dominance over weak0\nalways @ (posedge\
    \ clk)\nif (clk) begin\nif (i1[0:1]==1'b1)\nif (i2[0:1]==1'b1)\no = 1'b1;\nelse\n\
    o = 1'b1;\nelse if (i1[0:1]==1'b1)\no = 1'b1;\nelse if (i2[0:1]==1'b1)\no = 1'b1;\n\
    else if (i1[0:1]==1'b0)\no = 1'b1;\nelse if (i2[0:1]==1'b0)\no = 1'b1;\nelse\n\
    o = 1'b0;\nend\nendmodule\n\n```\n\n-\nThis is a good question. I've remarked\
    \ it in my answer below. But the question is not yet ready for a bounty. \u2013\
    \_ Jan 6 '13 at 13:55\n@MarcusM\xFCller - I think the question is clear enough.\
    \ It seems a reasonable question to me. \u2013\_ Jan 7 '13 at 15:12\n@MarcusM\xFC\
    ller - Yes, I agree. \u2013\_ Jan 7 '13 at 15:42\n\nThis is an excellent question.\
    \ I would like to provide a (semi-)complete answer, but first I should point out\
    \ that it seems to me that the answers to this question are not as clear as they\
    \ should be. Unfortunately I am not very familiar with the internals of Verilog,\
    \ and therefore I often am not able to understand the answers to this question.\n\
    \nI will therefore first start with a very brief description of what I understand\
    \ from your question.\n\nFirst of all, Verilog does not have a concept of a \"\
    gate\" in the same way that it has a concept of a \"module\". Instead, module\
    \ declarations are just \"a special case of an architecture\".\n\nModules also\
    \ have a \"function\" in that they can be instantiated. For example, you could\
    \ have a module that is used to implement a comparator. There are, however, very\
    \ few primitives that can be instantiated as a \"module\".\n\nI'll start by pointing\
    \ out that the \"architecture\" you refer to in your question is not really an\
    \ architecture, but more a collection of wire declarations that are all together\
    \ connected to each other.\n\nI will then go on to describe the current state\
    \ of the design that you have (you seem to have a lot of stuff missing) and attempt\
    \ to give an explanation for why it is the way it is. This is mostly based on\
    \ the information from the documentation that is available for the modelsim simulator.\n\
    \nI will not give you answers to all of your questions, since some of your points\
    \ are not really well defined. But I will try to give you some good hints, that\
    \ will hopefully be enough to give you an answer to your questions.\n\n### Current\
    \ Circuit\n\nThe first thing that you have to understand is that you can do everything\
    \ that you do in Verilog in an architecture. But when you get down to it everything\
    \ that you do in an architecture is translated into a module. That is not a very\
    \ well defined concept, I agree. However, as I said before, in Verilog you can\
    \ do everything, including instantiating modules.\n\nI will now try to understand\
    \ how would you do a \"real\" comparator. Note that this is not a real comparator,\
    \ but instead it is an architecture that is used as a comparator. But that will\
    \ suffice for now.\n\nLet's have a look at the current design that you have now:\n\
    \nmodule comparator (\noutput wire o,\ninput wire i1,\ninput wire i2\n);\n\nbuf\
    \ i1_buf (i1, tmp1);\nbuf i2_buf (i2, tmp2);\n\nassign o = tmp1? tmp2 : tmp1;\n\
    \nendmodule\n\n\nSince the module has a lot of stuff in it I will only look at\
    \ parts of it.\n\nFirst of all there is this thing that's called a \"buf\". This\
    \ is a kind of buffer that is used to implement a \"gate\". The buffer has two\
    \ \"pins\" that are used to connect to the input and output wires.\n\nSecondly\
    \ you have various wire declarations that have names. Usually wires are used to\
    \ represent \"signals\". But instead of just having one wire, there are two wires\
    \ that are connected to each other. And you can see that there is also an output\
    \ wire that is connected to the output pin of the buffer.\n\nSo what is this \"\
    tmp1\" and \"tmp2\" thing? Well, it looks like \"tmp\" is used as a \"temporary\"\
    \ name that stands for \"temporary wire\". It's not really a temporary wire. But\
    \ instead it is used to \"hold\" a value. A temporary wire is a wire that is only\
    \ used for one thing. You can use it to temporarily connect to another wire.\n\
    \nSo where does the \"assign\" statement come from? Well, the \"assign\" statement\
    \ is really nothing but a \"wire assignment\". So you can see that the \"assign\"\
    \ statement assigns the value of the \"tmp1\" wire to the output wire.\n\nNow\
    \ I want you to understand what this circuit does. If you understand how a \"\
    simple comparator\" works, then you understand how this circuit works.\n\nIf you\
    \ don't know how a \"simple comparator\" works, I will try to explain it for you.\n\
    \nLet's say that you want to compare the value of the \"i1\" wire with the value\
    \ of the \"i2\" wire. You can say that the new wire that we will create is either\
    \ equal to \"i1\" or equal to \"i2\". But how do you know which one should you\
    \ choose? Well, it is not really clear to me.\n\nThe best way to know how a \"\
    simple comparator\" works is to look at how a \"mux\" works.\n\nA mux is a \"\
    multiplexer\". It can select between two inputs. If you choose the input \"a\"\
    \ it will output the value of \"a\". If you choose the input \"b\" it will output\
    \ the value of \"b\".\n\nIn order to get a \"mux\" you first have to create two\
    \ \"buffers\" that are connected to the input wires. So now you have two inputs\
    \ that you can connect to a \"mux\" that will select between the two inputs.\n\
    \nIf you want to compare the two values you are using the \"mux\" to select between\
    \ the two values. If the value of \"a\" is equal to the value of \"b\" you will\
    \ choose the value of \"a\". Otherwise you will choose the value of \"b\". You\
    \ can see that this is exactly what the \"tmp1\" and \"tmp2\" wires are doing.\n\
    \nBut now the question is: how can you compare two values? Well, the answer is\
    \ really simple. You just say that if \"a\" is equal to \"b\" you will choose\
    \ true. If \"a\" is not equal to \"b\" you will choose false.\n\nSo how does the\
    \ \"mux\" work? Well, I will try to explain it a bit more.\n\nFirst of all: what\
    \ is a \"mux\"? The \"mux\" is a \"multiplexer\". It is a logical circuit that\
    \ can take multiple inputs and compare the values.\n\nSo what does a \"mux\" do?\
    \ The first thing that you have to know is that a \"mux\" can only have two inputs.\
    \ You have two wires (\"a\" and \"b\") and the \"mux\" can only compare the value\
    \ of one of the inputs. What kind of comparison does the \"mux\" do?\n\nIf you\
    \ compare \"a\" to \"b\" you can say that the value of \"a\" is equal to the value\
    \ of \"b\". What does this mean? Well, it means that you compare the values of\
    \ the two wires. If the values are equal then the \"mux\" will choose the value\
    \ of \"a\". If the values are not equal then the \"mux\" will choose the value\
    \ of \"b\".\n\nNow you can see that the \"tmp1\" and \"tmp2\" wires are connected\
    \ to an \"mux\" that compares the values of the two inputs.\n\nIn order to understand\
    \ how the \"mux\" works, you have to think of it as a \"multiplexer\". It is a\
    \ logical circuit that can take multiple inputs and compare the values of the\
    \ inputs.\n\nI will assume that you know what a \"multiplexer\" is (if not: read\
    \ about it in your textbook or online). The \"mux\" is used to compare the values\
    \ of the wires that are connected to the two inputs that are used"
- code: |-
    module res_loop(o,i,loopa,loopb);
    input i;
    output o;
    reg loopa, loopb;
    always @ (posedge i) begin
    loopa <= loopb[loopa];
    loopb <= loopb[loopa+1];
    end
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,loopa); // Drives pull '1', weak '0'
    buf(pull1, weak0) g3(o,loopb); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule
    ### Analysis:
    *
- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    // Assign array values
    assign i1 = {1'b0, 2'b10, 3'b0};
    assign i2 = {i1[0], 1'b0};
    assign o = i1[0] | i2[0];
    i1 <= {1'b0, 2'b10, 3'b0}; // assign array values with <= operator
    endmodule

    ## [4-23] Array Assignment with Assignment Operator (Alternate)

    ### Original Code:
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output
- code: "module lj_cnt();\nwire [3:0]o;\nreg[3:0] i;\ncnt cnt(o,i);\ninitial\nbegin\n\
    i =2'b10;\nend\ninitial $monitor ($time, \" output o = %b, input i = %b \", o,i);\n\
    if (i==4'b0001)\nbegin\ni = 2'b10;\nend\nendmodule\n\n### Base Verilog Code:\n\
    module lj_cnt();\nwire [3:0]o;\nreg[3:0] i;\ncnt cnt(o,i);\ninitial\nbegin\ni\
    \ =2'b10;\nend\ninitial $monitor ($time, \" output o = %b, input i = %b \", o,i);\n\
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Add\
    \ a case statement using an indexed part select as the operand being tested. ###\
    \ Modified Code: module lj_cnt(); wire [3:0]o; reg[3:0] i; cnt cnt(o,i); initial\
    \ begin i =2'b10; end initial$monitor\_($time, \" output o = %b, input i = %b\
    \ \", o,i); case (i) 4'b0001: i = 2'b10; endcase endmodule ### Base Verilog Code:\
    \ module inc_dec(); //inc_dec(n,i,o) n = 2\u2019b00; i = 2\u2019b10; initial begin\
    \ n = 2\u2019b00; i = 2\u2019b10; end initial$monitor\_($time, \u201C output n\
    \ = %b, input i = %b \u201C, n,i); initial$monitor\_($time, \u201C output n =\
    \ %b, input i = %b \u201C, n,i); initial$monitor\_($time, \u201C output n = %b,\
    \ input i = %b \u201C, n,i); initial#1000000$stop; // Stop simulation\nendmodule\n\
    \n### Base Verilog Code:\nmodule inc_dec();\n//inc_dec(n,i,o)\nreg[1:0] n;\nreg[1:0]\
    \ i;\nreg[1:0] o;\ninitial\nbegin\nn = 2\u2019b00;\ni = 2\u2019b10;\nend\ninitial\
    \ $monitor ($time, \u201C output n = %b, input i = %b \u201C, n,i);\ninitial $monitor\
    \ ($time, \u201C output n = %b, input i = %b \u201C, n,i);\ninitial $monitor ($time,\
    \ \u201C output n = %b, input i = %b \u201C, n,i);\ninitial #1000000 $stop; //\
    \ Stop simulation endmodule ### Variation Instruction: Assign the input to the\
    \ input of the 2-bit left-justify counter. ### Modified Code: module inc_dec();\
    \ //inc_dec(n,i,o) reg[1:0] n; reg[1:0] i; //reg[1:0] o; initial begin n = 2\u2019\
    b00; i = 2\u2019b10; end initial$monitor\_($time, \u201C output n = %b, input\
    \ i = %b \u201C, n,i); initial$monitor\_($time, \u201C output n = %b, input i\
    \ = %b \u201C, n,i); initial$monitor\_($time, \u201C output n = %b, input i =\
    \ %b \u201C, n,i); initial #1000000 $stop; // Stop simulation\nendmodule\n\n###\
    \ Base Verilog Code:\nmodule inc_dec();\n//inc_dec(n,i,o)\nreg[1:0] n;\nreg[1:0]\
    \ i;\nreg[1:0] o;\ninitial\nbegin\nn = 2\u2019b00;\ni = 2\u2019b10;\nend\ninitial\
    \ $monitor ($time, \u201C output o ="
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    // Add code here to check the first condition
    if ($realtime <= 15000 ) // Check for time being less than or equal to 15000
    initial #14 $stop; // Stop simulation
    endmodule
    ### Testbench Input:
    The following input is selected to be checked
    i =2'b00

    ### Expected Output:
    The output at the 15,000th clock cycle is checked. The expected o value is 0 which is 2'b00. Since the instruction was placed inside the loop, the output should be 2'b00.

    ## Testcase 4: 2-bit counter
    ### Base Verilog Code:
    module tst_dec2_2beh();
    wire [1:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_2beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Add another condition with an indexed part select as the operand being tested. ### Modified Code: module tst_dec2_2beh(); wire [1:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4beh dec2_2beh dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); // Add code here to check the first condition initial #14$stop; // Stop simulation
    endmodule

    ### Testbench Input:
    The following input is selected to be checked
    i =2'b00

    ### Expected Output:
    The output at the 15,000th clock cycle is checked. The expected o value is 0 which is 2'b00. Since the instruction was placed inside the loop, the output should be 2'b00.

    ## Testcase 5: 3-bit counter
    ### Base Verilog Code:
    module tst_dec2_3beh();
    wire [2:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_3beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Change some part select operations, such as the left shift operator (<<) to a bitwise AND operator (&). ### Modified Code: module tst_dec2_3beh(); wire [2:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4beh dec2_3beh dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); // Add code here to check the first condition initial #14$stop; // Stop simulation
    endmodule

    ### Testbench Input:
    The following input is selected to be checked
    i =2'b00

    ### Expected Output:
    The output at the 15,000th clock cycle is checked. The expected o value is 0 which is 2'b00. Since the instruction was placed inside the loop, the output should be 2'b00.

    ## Testcase 6: Enabling dec2_3beh

    ### Base Verilog Code:
    module tst_dec2_3beh();
    wire [2:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_3beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Place dec2_3beh inside an if statement which has an enable signal as the test condition. ### Modified Code: module tst_dec2_3beh(); wire [2:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4beh dec2_3beh dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if (en)// Place before the begin statement! // Check for time being less than or equal to 15000 initial #14$stop; // Stop simulation
    endmodule

    The if statement must be placed before the begin statement.
    dec2_3beh dec(o,i); is placed after the begin statement.

    ### Testbench Input:
    The following input is selected to be checked
    i =2'b00

    ### Expected Output:
    The output at the 15,000th clock cycle is checked. The expected o value is 0 which is 2'b00. Since the instruction was placed inside the loop, the output should be 2'b00.

    ## Testcase 7: 3-bit counter with an enable signal

    ### Base Verilog Code:
    module tst_dec2_3beh();
    wire [2:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_3beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Place dec2_3beh after the if statement with an enable signal as the test condition. ### Modified Code: module tst_dec2_3beh(); wire [2:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4beh dec2_3beh dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if (en) // Place after the begin statement! // Check for time being less than or equal to 15000 initial #14$stop; // Stop simulation
    endmodule

    The if statement must be placed before the begin statement.
    dec2_3beh dec(o,i); is placed after the begin statement.

    ### Testbench Input:
    The following input is selected to be checked
    i =2'b00

    ### Expected Output:
    The output at the 15,000th clock cycle is checked. The expected o value is 0 which is 2'b00. Since the instruction was placed inside the loop, the output should be 2'b00.

    ## Testcase 8: 3-bit counter with a function

    ### Base Verilog Code:
    module tst_dec2_3beh();
    wire [2:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_3beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Change the part select operations to a function. ### Modified Code: module tst_dec2_3beh(); wire [2:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4beh dec2_3beh dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); // Add code here to check the first condition initial #14$stop; // Stop simulation
    endmodule

    ### Testbench Input:
    The following input is selected to be checked
    i
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg [1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    ### Output:
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000000000000000000
    00000000000000000
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    // This initial code block is not needed
    //initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    if(i) // The if statement takes care of the initial code block
    initial #14 $stop; // Stop simulation endmodule Edited by:  ### Comments: I have included an edited code above. It removes the initial code block. I removed the // from the comments which doesn't make much sense. Original Author:
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    while ($time <= 1099) // $time in the middle while (1
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    if (i[1][1] & 1'b1) begin // Test operand inside with concat part select
    $stop; // Stop simulation
    end
    endmodule


    ### Base Verilog Code:
    module tst_dec2_4beh
- code: |-
    module tst_dec2_4beh(input [3:0] in, output [3:0] out);
    //reg en; // Enable not used in dec2_4beh
    //reg[1:0] i; // Enable not used in dec2_4beh
    dec2_4beh dec(out,in);
    initial
    begin
    in =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", out,in);
    initial #14 $stop; // Stop simulation endmodule ### Variation Results: ##### Slowed Testbench Speed: This variation slowed the testbench loop. ##### Number of Gate Deletions: This variation introduced 0 gate deletions. ##### Increased Gate Count: This variation increased the gate count from 15 to 15. ### Overall Result: This variation increased the number of gate deletions from 1 to 0, increased the gate count from 15 to 15, and slowed the testbench loop. ## 1.10 ### Base Verilog Code: module tst_dec2_4beh(); wire [3:0]o; reg[1:0] i; //reg en;
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    if(i[0] & i[1] )      // Added the if statement
    begin
    $stop;
    end
    endmodule
    ### Simulation Result:

    ### Observations:
    From the waveform above shows that the simulation stops when input i[0] =1 and i[1] = 1. We can see that the output o is always 0100 when i[0] =1 and i[1] = 1. And the output is always 0101 when i[0] =1 and i[1] = 0.

    ## 7.05 Dec2_4bch.v

    ### Base Verilog Code:
    module tst_dec2_4bch();
    wire [3:0]o;
    reg[1:0] i;
    reg en;
    dec2_4bch dec(o,i,en);
    initial
    begin
    i =2'b00;
    en =1'b1; // Enable not used in dec2_4bch
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial $monitor ($time, " En = %b ", en);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Add a if statement using inside with an indexed part select as the operand being tested. ### Modified Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; reg en; dec2_4bch dec(o,i,en); initial begin i =2'b00; en =1'b1; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); initial$monitor ($time, " En = %b ", en); if(en) // Added the if statement begin$stop;
    end
    endmodule
    ### Simulation Result:

    ### Observations:
    From the simulation result above we can see that the code stops when En =0 and En = 1. And the output o is always 0100 when En =1. And the output is always 0101 when En =0.

    ## 7.06 Dec2_4bch.v

    ### Base Verilog Code:
    module tst_dec2_4bch();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4bch
    dec2_4bch dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: Add an else statement under the if statement. ### Modified Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if(i[0] & i[1] ) begin$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Simulation Result: ### Observations: From the waveform above shows that the simulation stops when input i[0] =1 and i[1] = 1. We can see that the output o is always 0100 when i[0] =1 and i[1] = 1. And the output is always 0101 when i[0] =1 and i[1] = 0. ## 7.07 Dec2_4bch.v ### Base Verilog Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if(i[0] & i[1] ) begin$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Variation Instruction: Add an else statement under the if statement before the initial stop. ### Modified Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if(i[0] & i[1] ) begin$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Simulation Result: ### Observations: From the waveform above shows that the simulation stops when input i[0] =1 and i[1] = 1. We can see that the output o is always 0100 when i[0] =1 and i[1] = 1. And the output is always 0101 when i[0] =1 and i[1] = 0. ## 7.08 Dec2_4bch.v ### Base Verilog Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if(i[0] & i[1] ) begin$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Variation Instruction: Add an else statement before the initial stop. ### Modified Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i); initial begin i =2'b00; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); if(i[0] & i[1] ) begin$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Simulation Result: ### Observations: The simulation is not stopped when i[0] =1 and i[1] = 1. And the output is always 0100 when i[0] =1 and i[1] = 1. But when i[0] =1 and i[1] =0,the output is 0101, the output o cannot be 0110. ## 7.09 Dec2_4bch.v ### Base Verilog Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i,en); initial begin i =2'b00; en =1'b1; // Enable not used in dec2_4bch endinitial$monitor ($time, " output o = %b, input i = %b ", o,i); initial$monitor ($time, " En = %b ", en); initial $stop; // Stop simulation endmodule ### Variation Instruction: Add an else statement inside the if statement. ### Modified Code: module tst_dec2_4bch(); wire [3:0]o; reg[1:0] i; //reg en; // Enable not used in dec2_4bch dec2_4bch dec(o,i,en); initial begin i =2'b00; en =1'b1; end initial$monitor ($time, " output o = %b, input i = %b ", o,i); initial$monitor ($time, " En = %b ", en); if(en) // Added the if statement begin //Added the empty else statement to the if statement$stop;
    end
    else
    begin
    initial $stop; end endmodule ### Simulation Result: ## 7.10 Dec2_4bch.v ### Base Verilog Code: module tst_dec2_
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation

    endmodule

    ## Design Goal

    The Design Goal is to implement a simple state machine, where each state is a 4-bit binary number and the state machine starts in state 0. The state machine should be implemented using a single 4-bit binary counter. The state machine should output a 4-bit binary number to o, and the counter should be incremented by 1. The state machine should start in state 0. The state machine should increment the counter by 1, at each clock cycle. The state machine logic should be implemented in an entity called dec2_4beh, located in a module called dec2_4beh.v. The counter logic should be implemented in an entity called d2_counter, located in a module called d2_counter.v. The top level design should have a module named tst_dec2_4beh, that instantiates the d2_counter and dec2_4beh.v modules. The d2_counter and dec2_4beh should be implemented in Verilog code. The counter is incremented by 1 each clock cycle. The state machine output is a 4-bit binary number, that is a binary number that corresponds to the state that the state machine is in.

    The logic should work as follows. Initially, the state machine should be in state 0 as indicated below:

    The value of i should be 0.

    When the state is 0, the output o is 0000. The state is changed to 1. When the state is 1, the output o is 0001. The state is changed to 2. When the state is 2, the output o is 0010. The state is changed to 3. When the state is 3, the output o is 0011. The state is changed to 4. When the state is 4, the output o is 0100. The state is changed to 5. When the state is 5, the output o is 0101. The state is changed to 6. When the state is 6, the output o is 0110. The state is changed to 7. When the state is 7, the output o is 0111. The state is changed to 8. When the state is 8, the output o is 1000

    The value of i should be 1.

    When the state is 8, the output o is 1000. The state is changed to 9. When the state is 9, the output o is 1001. The state is changed to A. When the state is A, the output o is 1010. The state is changed to B. When the state is B, the output o is 1011. The state is changed to C. When the state is C, the output o is 1100. The state is changed to D. When the state is D, the output o is 1101

    The value of i should be 2.

    When the state is D, the output o is 1101. The state is changed to E. When the state is E, the output o is 1110. The state is changed to F. When the state is F, the output o is 1111. The state is changed to 0. When the state is 0, the output o is 0000.
- code: "module tst_dec2_4beh();\nwire [3:0]o;\nreg[1:0] i;\n//reg en; // Enable not\
    \ used in dec2_4beh\ndec2_4beh dec(o,i);\ninitial\nbegin\ni =2'b00;\nend\no =\
    \ i[1]= 'b1? 3'b101 : 3'b111; // If i[1:0] = 'b1, then enable\n// else, set o\
    \ as 3'b111\ninitial $monitor ($time, \" output o = %b, input i = %b \", o,i);\n\
    initial #14 $stop; // Stop simulation endmodule ### Test Result: Test passed ##\
    \ 2.39 tst_dec2_8beh(test_dec2_8beh) ### Base Verilog Code: module tst_dec2_8beh();\
    \ wire [3:0]o; reg[1:0] i; reg en; // Enable not used in dec2_4beh dec2_8beh dec(o,i,en);\
    \ initial begin i =2'b00; end initial$monitor ($time, \" output o = %b, input\
    \ i = %b \", o,i); initial #14 $stop; // Stop simulation endmodule ### Variation\
    \ Instruction: Add an if statement using inside with an indexed part select as\
    \ the operand being tested. ### Modified Code: module tst_dec2_8beh(); wire [3:0]o;\
    \ reg[1:0] i; reg en; // Enable not used in dec2_4beh dec2_8beh dec(o,i,en); initial\
    \ begin i =2'b00; en = 1; end if(i==4'b0001) o = 4'b1111; // Enable initial$monitor\
    \ ($time, \" output o = %b, input i = %b \", o,i); initial #14$stop; // Stop simulation\n\
    endmodule\n### Test Result:\nTest passed\n\n### Base Verilog Code:\nmodule tst_dec2_8beh();\n\
    wire [3:0]o;\nreg[1:0] i;\nreg en; // Enable not used in dec2_4beh\ndec2_8beh\
    \ dec(o,i,en);\ninitial\nbegin\ni =2'b00;\nend\nif(i==2'b00)\no = 4'b1111; //\
    \ Enable\ninitial $monitor ($time, \" output o = %b, input i = %b \", o,i);\n\
    initial #14 $stop; // Stop simulation endmodule ### Variation Instruction: In\
    \ the case where the value of the operand being tested is not a constant, use\
    \ a part select (indexed) to access the operand. ### Modified Code: module tst_dec2_8beh();\
    \ wire [3:0]o; reg[1:0] i; reg en; // Enable not used in dec2_4beh dec2_8beh dec(o,i,en);\
    \ initial begin i =2'b00; end o = i[3]= 'b1? 4'b1111 : 4'b10111; // If i[3:0]\
    \ = 'b1, then enable // else, set o as 4'b10111 initial$monitor ($time, \" output\
    \ o = %b, input i = %b \", o,i); initial #14$stop; // Stop simulation\nendmodule\n\
    ### Test Result:\nTest passed\n\n# Chapter 3. 4-bit Binary Decoder\n\nThis chapter\
    \ introduces a 4-bit binary decoder. This decoder is implemented in a separate\
    \ file, i.e., bin_decode.v. The decoder input is an 8-bit binary value (0-255)\
    \ and the output is a 4-bit value (0-15). The decoder works by first converting\
    \ the 8-bit input to a 4-bit binary value by using a 2-bit binary decoder. The\
    \ 4-bit decoded value is then used as an index to a 4-bit 1-hot (i.e., a 4-bit\
    \ binary value with only one \u201Cone\u201D bit) selection decoder. The output\
    \ of the selection decoder is the final 4-bit output value.\n\n## 3.1. tst_bin_decode.v\n\
    \nThe following is the testbench for bin_decode.v. It uses the following initializations:\n\
    \n\u2022 Test #1: In the first test, a value of 0x0 is input to the decoder, and\
    \ it is expected that the decoder output is 0x00.\n\u2022 Test #2: In the second\
    \ test, a value of 0x01 is input to the decoder, and it is expected that the decoder\
    \ output is 0x01.\n\u2022 Test #3: In the third test, a value of 0x02 is input\
    \ to the decoder, and it is expected that the decoder output is 0x02.\n module\
    \ tst_bin_decode(); // Testbench port declarations net input [7: 0] a; // Test\
    \ input net output [3: 0] b; // Output value from the decoder initial begin a\
    \ = 8'b00000000; b = 4'b0000; initial $monitor ($time, \" input a = %b \", a);\
    \ #50; // Delay to allow simulation time to stabilize initial $monitor ($time,\
    \ \" output b = %b \", b); #50; // Delay to allow simulation time to stabilize\
    \ initial $stop; // Stop simulation endmodule endmodule ### Test Result: Test\
    \ passed ## 3.2 bin_decode.v ### Base Verilog Code module bin_decode(); // Declaration\
    \ of port declarations net input [3: 0] din; // Decoder input net output [3: 0]\
    \ dout; // Decoder output din = 4'b0000; dout = 4'b0000; always @ (din) begin\
    \ dout = din[3: 0]; end endmodule ### Modified Code module bin_decode(); // Declaration\
    \ of port declarations net input [3: 0] din; // Decoder input net output [3: 0]\
    \ dout; // Decoder output always @ (din) begin dout = din[3: 0]; // Decoder output\
    \ is equal to the decoder input endmodule ### Test Result: Test passed ## 3.3.\
    \ tst_bin_decode_4beh.v This is the testbench for tst_bin_decode_4beh.v. This\
    \ testbench uses the following initializations: \u2022 Test #1: In the first test,\
    \ a value of 0x0 is input to the decoder, and it is expected that the decoder\
    \ output is 0x00. \u2022 Test #2: In the second test, a value of 0x01 is input\
    \ to the decoder, and it is expected that the decoder output is 0x01. \u2022 Test\
    \ #3: In the third test, a value of 0x02 is input to the decoder, and it is expected\
    \ that the decoder output is 0x02. module tst_bin_decode_4beh(); // Testbench\
    \ port declarations net input [7: 0] a; // Test input net output [3: 0] b; //\
    \ Output value from the decoder initial begin a = 8'b00000000; b = 4'b0000; initial$monitor\
    \ ($time, \" input a = %b \", a); #50; // Delay to allow simulation time to stabilize\
    \ initial$monitor ($time, \" output b = %b \", b); #50; // Delay to allow simulation"
- code: |-
    module pulses;
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin
          b = I[1]; // Incorrect logic vector indexing.
          I = I + 1;
        end
      initial I=0;
      initial #100 $stop;
    endmodule
    ### Generated Code:
    module pulses;
      reg [8:0] I;
      reg [8:0] b;
      reg a,b;
      initial
        while (I<100) begin
          b = I[1]; // Incorrect logic vector indexing.
          I = I + 1;
        end
      initial I=0;
      initial #100 $stop;
    endmodule
    ### Fixed Code:
    module pulses; // Correct pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin
          b = I[1]; // Correct indexing.
          I = I + 1;
        end
      initial I=0;
      initial #100 $stop;
    endmodule
    /test/unit/gen/gen-test-8-6.py
    from genty import *


    @GentyFunction()
    def test_8_6():
        return 1
    /test/unit/gen/gen-test-7-2.py
    from genty import *


    @GentyFunction()
    def test_7_2():
        return 1
    /test/unit/gen/gen-test-3-3.py
    from genty import *

    p = 1
    @GentyFunction()
    def test_3_3():
        return 0
    /test/unit/gen/gen-test-6-7.py
    from genty import *


    @GentyFunction()
    def test_6_7():
        return 1
    /test/unit/gen/gen-test-6-1.py
    from genty import *


    @GentyFunction()
    def test_6_1():
        return 1
    /test/unit/gen/gen-test-2-5.py
    from genty import *


    @GentyFunction()
    def test_2_5():
        return 1
    /test/unit/gen/gen-test-2-7.py
    from genty import *


    @GentyFunction()
    def test_2_7():
        return 1
    /test/unit/gen/gen-test-3-2.py
    from genty import *


    @GentyFunction()
    def test_3_2():
        return 1
    /test/unit/gen/gen-test-3-7.py
    from genty import *

    p = 7
    @GentyFunction()
    def test_3_7():
        return p
    /test/unit/gen/gen-test-5-3.py
    from genty import *


    @GentyFunction()
    def test_5_3():
        return 1
    /test/unit/gen/gen-test-2-2.py
    from genty import *


    @GentyFunction()
    def test_2_2():
        return 1
    /test/unit/gen/gen-test-3-5.py
    from genty import *


    @GentyFunction()
    def test_3_5():
        return 1
    /test/unit/gen/gen-test-6-8.py
    from genty import *


    @GentyFunction()
    def test_6_8():
        return 1
    /test/unit/gen/gen-test-2-1.py
    from genty import *

    p = 1
    @GentyFunction()
    def test_2_1():
        return p
    /test/unit/gen/gen-test-6-9.py
    from genty import *


    @GentyFunction()
    def test_6_9():
        return 1
    /test/unit/gen/gen-test-2-6.py
    from genty import *


    @GentyFunction()
    def test_2_6():
        return 1
    /test/unit/gen/gen-test-6-2.py
    from genty import *


    @GentyFunction()
    def test_6_2():
        return 1
    /test/unit/gen/gen-test-7-7.py
    from genty import *


    @GentyFunction()
    def test_7_7():
        return 1
    /test/unit/gen/gen-test-4-5.py
    from genty import *


    @GentyFunction()
    def test_4_5():
        return 1
    /test/unit/gen/gen-test-7-5.py
    from genty import *


    @GentyFunction()
    def test_7_5():
        return 1
    /test/unit/gen/gen-test-7-3.py
    from genty import *


    @GentyFunction()
    def test_7_3():
        return 1
    /test/unit/gen/gen-test-8-7.py
    from genty import *


    @GentyFunction()
    def test_8_7():
        return 1
    /test/unit/gen/gen-test-6-4.py
    from genty import *


    @GentyFunction()
    def test_6_4():
        return 1
    /test/unit/gen/gen-test-2-3.py
    from genty import *


    @GentyFunction()
    def test_2_3():
        return 1
    /test/unit/gen/gen-test-5-5.py
    from genty import *


    @GentyFunction()
    def test_5_5():
        return 1
    /test/unit/gen/gen-test-8-5.py
    from genty import *


    @GentyFunction()
    def test_8_5():
        return 1
    /test/unit/gen/gen-test-8-1.py
    from genty import *


    @GentyFunction()
    def test_8_1():
        return 1
    /test/unit/gen/gen-test-3-8.py
    from genty import *


    @GentyFunction()
    def test_3_8():
        return 1
    /test/unit/gen/gen-test-3-4.py
    from genty import *

    p = 4
    @GentyFunction()
    def test_3_4():
        return p
    /test/unit/gen/gen-test-2-4.py
    from genty import *

    p = 4
    @GentyFunction()
    def test_2_4():
        return p
    /test/unit/gen/gen-test-5-7.py
    from genty import *


    @GentyFunction()
    def test_5_7():
        return 1
    /test/unit/gen/gen-test-7-8.py
    from genty import *


    @GentyFunction()
    def test_7_8():
        return 1
    /README.md

    [![Build Status](https://travis-ci.org/ucb-bar/Geny.svg?branch=master)](https://travis-ci.org/ucb-bar/Geny)

    Geny is a DSL and library for generating Verilog code. It can be used for testing and code generation.

    ## Usage

    Geny consists of two parts. A *test* consists of four parts: a *test name* (such as `test_3_3`), a *test generator* (such as `def test_3_3(): return 1`), a *test verifier* (a function performing some verification on the result of the test generator), and a *test runner* (which ensures that the generator is called with the correct arguments).

    ```python
    from genty import *

    def test_3_3():
        return 1

    @GentyVerify()
    def verify_test_3_3(result):
        assert(result == 1)

    @GentyRunner()
    def test_3_3_runner(test_generator, test_runner):
        test_runner(test_generator, verify_test_3_3)
    ```

    The test runner takes in a test generator and runs it with the same name as the test generator. The test runner takes in a test generator name and a test verifier name and verifies the result of the test generator with the verifier by finding the right function in the current scope.

    Geny can now be used to generate Verilog code:

    ```python
    from genty import *
    from genty.lib import *

    @GentyFunction("add_with_carry")
    def add_with_carry(a, b, c_in, c_out, r, s):
        return a + b + c_in + c_out + r + s
    ```
- code: |-
    (module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial begin
        I=0;
      end
      initial
        while (I<100) begin // Loop based on integer I
          I = I + 1; // Increment I
        end
      initial #100 $stop; // Stop simulation
      always @* begin // Added an always @*
        case(I) // Replaced while loop with switch-case
          0: b = 0;
          1: b = 0;
        endcase
      end
    endmodulemodule pulse_generator;

    initial
    begin
      $display("Inside initial block");
    end

    always @*
    begin
      $display("Inside always block");
    end

    always @ (posedge test)
    begin
      $display("Inside always block");
    end

    endmodule
- code: "module pulses; // Incorrect pulse generation attempt\n  reg [8:0] I;\n  reg\
    \ a,b;\n  initial\n    while (I<100) begin // Loop based on integer I\n      b\
    \ = I[1]; // Assign bit 1 of I to b (Corrected indexing)\n      I = I + 1; //\
    \ Increment I\n    end\n  initial I=0; // Initialize I\n  initial #100 $stop;\
    \ // Stop simulation\nendmodule\n// Verilator: Generated by verilator 3.8.0+4d11797\
    \ - https://verilator.org\n// Verilator is free software and is licensed under\
    \ the MIT license\n// See LICENSE.txt for details\n// This code is generated by\
    \ an automated process and is in no way guaranteed to be correct.\n// Generated\
    \ code is most certainly not suitable for production.\n// An alternative license\
    \ for Verilator is available.\n// Please contact  for more information.\n// If\
    \ Verilator is passed -Mdir=build/VEv54e641, it will place the verilated files\
    \ in a build/ directory.\n//\n// This is a design written by the LF-VERI-TOOLS\
    \ Authors.\n//\n\n#include \"Vpulses.h\"\n\n#include \"verilated.h\"\n#include\
    \ \"Vpulses__Syms.h\"\n\n//==========================================\n\nVL_CTOR_IMP(Vpulses)\
    \ {\n\n    VL_CELL(__PVT__mycell1, Vmycell2);\n    VL_CELL(__PVT__mycell2, Vmycell3);\n\
    \    VL_CELL(__PVT__mycell3, Vmycell4);\n}\n\nvoid Vpulses::__Vconfigure(Vpulses__Syms*\
    \ vlSymsp, bool first) {\n    if (0 && first) {}  // Prevent unused\n    this->__VlSymsp\
    \ = vlSymsp;\n}\n\nVpulses::~Vpulses() {\n    VL_DO_DESTRUCT(Vpulses);\n}\n\n\
    //--------------------\n// Internal Methods\n\nvoid Vpulses::eval() {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"\
    \        Vpulses::eval\\n\"); );\n    Vpulses* __restrict vlTOPp VL_ATTR_UNUSED\
    \ = this;\n    // Body\n    vlTOPp->_combo__TOP__1(vlTOPp);\n}\n\nvoid Vpulses::_settle__TOP__2(Vpulses__Syms*\
    \ __restrict vlSymsp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vpulses::_settle__TOP__2\\\
    n\"); );\n    Vpulses* __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;\n   \
    \ // Body\n    vlTOPp->mycell1__DOT__I = (0xffU & ((IData)(vlTOPp->mycell1__DOT__I)\
    \ \n                                         + 1U));\n    vlTOPp->mycell1__DOT__a\
    \ = (IData)(vlTOPp->mycell1__DOT__I);\n    vlTOPp->mycell1__DOT__b = (IData)(vlTOPp->mycell1__DOT__I);\n\
    \    vlTOPp->mycell2__DOT__I = (0xffU & ((IData)(vlTOPp->mycell2__DOT__I) \n \
    \                                        + 1U));\n    vlTOPp->mycell2__DOT__a\
    \ = (IData)(vlTOPp->mycell2__DOT__I);\n    vlTOPp->mycell2__DOT__b = (IData)(vlTOPp->mycell2__DOT__I);\n\
    \    vlTOPp->mycell3__DOT__I = (0xffU & ((IData)(vlTOPp->mycell3__DOT__I) \n \
    \                                        + 1U));\n    vlTOPp->mycell3__DOT__a\
    \ = (IData)(vlTOPp->mycell3__DOT__I);\n    vlTOPp->mycell3__DOT__b = (IData)(vlTOPp->mycell3__DOT__I);\n\
    \    vlTOPp->mycell4__DOT__I = (0xffU & ((IData)(vlTOPp->mycell4__DOT__I) \n \
    \                                        + 1U));\n    vlTOPp->mycell4__DOT__a\
    \ = (IData)(vlTOPp->mycell4__DOT__I);\n    vlTOPp->mycell4__DOT__b = (IData)(vlTOPp->mycell4__DOT__I);\n\
    }\n\nvoid Vpulses::_combo__TOP__1(Vpulses__Syms* __restrict vlSymsp) {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"\
    +    Vpulses::_combo__TOP__1\\n\"); );\n    Vpulses* __restrict vlTOPp VL_ATTR_UNUSED\
    \ = vlSymsp->TOPp;\n    // Body\n    vlTOPp->mycell1__DOT__b = (IData)(vlTOPp->mycell1__DOT__I);\n\
    \    vlTOPp->mycell2__DOT__b = (IData)(vlTOPp->mycell2__DOT__I);\n    vlTOPp->mycell3__DOT__b\
    \ = (IData)(vlTOPp->mycell3__DOT__I);\n    vlTOPp->mycell4__DOT__b = (IData)(vlTOPp->mycell4__DOT__I);\n\
    }\n\nVL_INLINE_OPT void Vpulses::_sequent__TOP__3(Vpulses__Syms* __restrict vlSymsp)\
    \ {\n    VL_DEBUG_IF(VL_DBG_MSGF(\"+    Vpulses::_sequent__TOP__3\\n\"); );\n\
    \    Vpulses* __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;\n    // Variables\n\
    \    // Begin mtask footprint  all: \n    VL_SIG8(__Vdly__mycell2__DOT__I,7,0);\n\
    \    VL_SIG8(__Vdly__mycell1__DOT__I,7,0);\n    VL_SIG8(__Vdly__mycell3__DOT__I,7,0);\n\
    \    VL_SIG8(__Vdly__mycell4__DOT__I,7,0);\n    // Body\n    __Vdly__mycell1__DOT__I\
    \ = vlTOPp->mycell1__DOT__I;\n    __Vdly__mycell2__DOT__I = vlTOPp->mycell2__DOT__I;\n\
    \    __Vdly__mycell3__DOT__I = vlTOPp->mycell3__DOT__I;\n    __Vdly__mycell4__DOT__I\
    \ = vlTOPp->mycell4__DOT__I;\n    // ALWAYS at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell1__DOT__a = (IData)(vlTOPp->mycell1__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell2__DOT__a = (IData)(vlTOPp->mycell2__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell3__DOT__a = (IData)(vlTOPp->mycell3__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell4__DOT__a = (IData)(vlTOPp->mycell4__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell1__DOT__b = (IData)(vlTOPp->mycell1__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell2__DOT__b = (IData)(vlTOPp->mycell2__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell3__DOT__b = (IData)(vlTOPp->mycell3__DOT__I);\n    // ALWAYS\
    \ at /home/rams/Documents/GitHub/Verilator/examples/tests/Pulse/pulses.v:25\n\
    \    vlTOPp->mycell4__DOT__b = (IData)(vlTOPp->mycell4__DOT__I);\n    vlTOPp->mycell1__DOT__I\
    \ = (0xffU & ((IData)(vlTOPp->mycell1__DOT__I) \n                            \
    \            + 1U));\n    vlTOPp->mycell2__DOT__I = (0xffU & ((IData)(vlTOPp->mycell2__DOT__I)\
    \ \n                                        + 1U));\n    vlTOPp->mycell3__DOT__I\
    \ = (0xffU & ((IData)(vlTOPp->mycell3__DOT__I) \n                            \
    \            + 1U));\n    vlTOPp->mycell4__DOT__I = (0xffU & ((IData)(vlTOPp->mycell4__DOT__I)\
    \ \n                                        + 1U));\n    vlTOPp->_combo__TOP__1(vlTOPp);\n\
    }\n\nbool Vpulses::_eval_settle(Vpulses__Syms"
- code: |-
    module pulses;
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<1000) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Base Verilog Code:
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,
- code: "module pulses_modified; // Corrected pulse generation attempt\n  reg [8:0]\
    \ I;\n  reg [31:0] a;\n  initial\n    while (I<100) begin // Loop based on integer\
    \ I\n      a[I[1]:I[0]] = I[1]; // Assign bit 1 of I to b (Corrected indexing)\n\
    \      I = I + 1; // Increment I\n    end\n  initial I=0; // Initialize I\n  initial\
    \ #100 $stop; // Stop simulation\nendmodule\n```\n\n## Detailed Description\n\n\
    #### Description of the Issue\nThis issue is caused by indexing an array incorrectly.\
    \ \nThe array has no range, but the subscript operation is attempted on the array.\n\
    \n#### Example Code\n```verilog\nmodule pulses; // Incorrect pulse generation\
    \ attempt\n  reg [8:0] I;\n  reg a,b;\n  initial\n    while (I<100) begin // Loop\
    \ based on integer I\n      b = I[1]; // Assign bit 1 of I to b (Corrected indexing)\n\
    \      I = I + 1; // Increment I\n    end\n  initial I=0; // Initialize I\n  initial\
    \ #100 $stop; // Stop simulation\nendmodule\n```\n\n#### Corrected Code\n```verilog\n\
    module pulses_modified; // Corrected pulse generation attempt\n  reg [8:0] I;\n\
    \  reg [31:0] a;\n  initial\n    while (I<100) begin // Loop based on integer\
    \ I\n      a[I[1]:I[0]] = I[1]; // Assign bit 1 of I to b (Corrected indexing)\n\
    \      I = I + 1; // Increment I\n    end\n  initial I=0; // Initialize I\n  initial\
    \ #100 $stop; // Stop simulation\nendmodule\n```\n/content/posts/documentation/vlog-verilog-report-guide/vlog_testbenches/report_vlog_testbench_3.md\n\
    ---\ntitle: \"Report VLOG Testbench 3\"\nlinkTitle: \"Report VLOG Testbench 3\"\
    \ndate: 2021-05-13T09:00:00\ndescription: \"Report VLOG Testbench 3\"\ntype: \"\
    vlog\"\nweight: 2\n---\n\n## Testbench Name: \nverilog_testbench_3\n\n## Testbench\
    \ Status: \nFAIL\n\n## Module Name: \nverilog_testbench_3\n\n## Module Description:\
    \ \nTestbench for verilog_testbench_3.\n\n## Testbench Configuration: \nverilog_testbench_3\n\
    \n## Testbench Notes: \n```\n### Testbench Input: \nmodule verilog_testbench_3;\
    \ \n  \n  reg [2:0] verilog_testbench_3_io_input_0; \n  wire [0:0] verilog_testbench_3_io_output_0;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_1; \n  wire [0:0] verilog_testbench_3_io_output_2;\
    \ \n  reg verilog_testbench_3_io_output_3; \n  reg [0:0] verilog_testbench_3_io_output_4;\
    \ \n  reg [1:0] verilog_testbench_3_io_output_5; \n  reg [2:0] verilog_testbench_3_io_output_6;\
    \ \n  reg [3:0] verilog_testbench_3_io_output_7; \n  wire [0:0] verilog_testbench_3_io_output_8;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_9; \n  wire [0:0] verilog_testbench_3_io_output_10;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_11; \n  wire [0:0] verilog_testbench_3_io_output_12;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_13; \n  wire [0:0] verilog_testbench_3_io_output_14;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_15; \n  wire [1:1] verilog_testbench_3_io_output_16;\
    \ \n  wire [1:1] verilog_testbench_3_io_output_17; \n  wire [2:2] verilog_testbench_3_io_output_18;\
    \ \n  wire [3:3] verilog_testbench_3_io_output_19; \n  wire [4:4] verilog_testbench_3_io_output_20;\
    \ \n  wire [5:5] verilog_testbench_3_io_output_21; \n  wire [6:6] verilog_testbench_3_io_output_22;\
    \ \n  wire [7:7] verilog_testbench_3_io_output_23; \n  wire [8:8] verilog_testbench_3_io_output_24;\
    \ \n  wire [9:9] verilog_testbench_3_io_output_25; \n  wire [0:0] verilog_testbench_3_io_output_26;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_27; \n  wire [0:0] verilog_testbench_3_io_output_28;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_29; \n  wire [0:0] verilog_testbench_3_io_output_30;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_31; \n  wire [0:0] verilog_testbench_3_io_output_32;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_33; \n  wire [0:0] verilog_testbench_3_io_output_34;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_35; \n  wire [0:0] verilog_testbench_3_io_output_36;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_37; \n  wire [0:0] verilog_testbench_3_io_output_38;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_39; \n  wire [0:0] verilog_testbench_3_io_output_40;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_41; \n  wire [0:0] verilog_testbench_3_io_output_42;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_43; \n  wire [0:0] verilog_testbench_3_io_output_44;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_45; \n  wire [1:1] verilog_testbench_3_io_output_46;\
    \ \n  wire [1:1] verilog_testbench_3_io_output_47; \n  wire [2:2] verilog_testbench_3_io_output_48;\
    \ \n  wire [3:3] verilog_testbench_3_io_output_49; \n  wire [4:4] verilog_testbench_3_io_output_50;\
    \ \n  wire [5:5] verilog_testbench_3_io_output_51; \n  wire [6:6] verilog_testbench_3_io_output_52;\
    \ \n  wire [7:7] verilog_testbench_3_io_output_53; \n  wire [8:8] verilog_testbench_3_io_output_54;\
    \ \n  wire [9:9] verilog_testbench_3_io_output_55; \n  wire [0:0] verilog_testbench_3_io_output_56;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_57; \n  wire [0:0] verilog_testbench_3_io_output_58;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_59; \n  wire [0:0] verilog_testbench_3_io_output_60;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_61; \n  wire [0:0] verilog_testbench_3_io_output_62;\
    \ \n  wire [0:0] verilog_testbench_3_io_output_63; \n  wire [0:0] verilog_testbench_"
- code: |-
    module pulses;
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          `ifdef USE_ARRAY
          a = b[1]; // Assign bit 1 of b to a (Corrected indexing)
          `endif
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Verilog Testbench:
    module tb_pulses;
      reg CLK;
      reg RST;

      initial begin
        $dumpfile("pulses.vcd");
        $dumpvars(0, pulses);
      end

      initial begin
        CLK = 0;
        forever begin
          #5 CLK =!CLK;
        end
      end

      initial begin
        RST = 0;
        #100;
        RST = 1;
        #100;
        RST = 0;
        #1000;
        $finish;
      end
    endmodule

    **Module: pulses**

    .. code-block:: verilog
       :linenos:

       module pulses; // Incorrect pulse generation attempt
         reg [8:0] I;
         reg a,b;
         initial
           while (I<100) begin // Loop based on integer I
             b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
             I = I + 1; // Increment I
           end
         initial I=0; // Initialize I
         initial #100 $stop; // Stop simulation
       endmodule

    **Verilog-2001 Testbench**

    .. code-block:: verilog
       :linenos:

       module tb_pulses;
         reg CLK;
         reg RST;

         initial begin
           $dumpfile("pulses.vcd");
           $dumpvars(0, pulses);
         end

         initial begin
           CLK = 0;
           forever begin
             #5 CLK =!CLK;
           end
         end

         initial begin
           RST = 0;
           #100;
           RST = 1;
           #100;
           RST = 0;
           #1000;
           $finish;
         end
       endmodule


    Generated sim_tb.v


    .. code-block:: verilog
       :linenos:

       `timescale 1ns / 1ps

       module sim_pulses;

         reg CLK;

         reg [8:0] I;
         reg a,b;
         initial
           while (I<100) begin // Loop based on integer I
             b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
             I = I + 1; // Increment I
           end
         initial I=0; // Initialize I
         initial #100 $stop; // Stop simulation

       endmodule


       `define USE_ARRAY

       module tb_pulses;
         reg CLK;
         reg RST;

         initial begin
           $dumpfile("pulses.vcd");
           $dumpvars(0, pulses);
         end

         initial begin
           CLK = 0;
           forever begin
             #5 CLK =!CLK;
           end
         end

         initial begin
           RST = 0;
           #100;
           RST = 1;
           #100;
           RST = 0;
           #1000;
           $finish;
         end
       endmodule



    Generated sim_pulses_tb.v


    .. code-block:: verilog
       :linenos:

       `timescale 1ns / 1ps
       `default_nettype none

       module tb_pulses;
         reg CLK;
         reg RST;

         initial begin
           $dumpfile("pulses.vcd");
           $dumpvars(0, pulses);
         end

         initial begin
           CLK = 0;
           forever begin
             #5 CLK =!CLK;
           end
         end

         initial begin
           RST = 0;
           #100;
           RST = 1;
           #100;
           RST = 0;
           #1000;
           $finish;
         end
       endmodule


    Test Vectors
      **T_1**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_2**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_3**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_4**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_5**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_6**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_7**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_8**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_9**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_10**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_11**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_12**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_13**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_14**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_15**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_16**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0     |
      +------+---------+

      **T_17**  **Initial Values**

      +------+---------+
      | I[8] | I[7:0]  |
      +======+=========+
      | x    | 0x0     |
      +------+---------+
      | x    | 0x0
- code: "module pulses; // Incorrect pulse generation attempt\n  reg [31:0] I;\n \
    \ reg a,b;\n  initial\n    while (I<100) begin // Loop based on integer I\n  \
    \    b = I[1+:3]; // Assign bits 1 through 3 of I to b\n      I = I + 1; // Increment\
    \ I\n    end\n  initial I=0; // Initialize I\n  initial #100 $stop; // Stop simulation\n\
    endmodule\n\n# References\n[1] https://www.verilog.com/\n\n[2] https://forums.xilinx.com/t5/ISE-Tools-Questions/Reaching-the-limit-of-the-range-of-array-slices/td-p/1091116\n\
    \n[3] https://forums.xilinx.com/t5/Verilog-Tools-and-Vivado/Verilog-Indexing-and-Slices/td-p/1090470\n\
    \n[4] http://www.asic-world.com/verilog/verilog.html\n\n[5] http://www.asic-world.com/verilog/verilog_slices.html#slice_range\n\
    \n/CSE_3014_Lab_Exercises/Lab_1/lab1.sh\n#!/bin/bash\n\n#Lab1\n#\n\nfor file in\
    \ *.v\ndo\n\techo \"---------------------------------\"\n\techo \"File: $file\"\
    \n\techo \"---------------------------------\"\n\techo \"Simulation Results:\"\
    \n\techo \"---------------------------------\"\n\techo\n\techo -e \"VCOM: \\n\"\
    \n\tvcom $file\n\techo\n\techo -e \"VLOG: \\n\"\n\tvlog -work work $file\n\techo\n\
    \techo -e \"VSIM: \\n\"\n\tvsim -c -do $file -do \"quit\" -novopt\n\techo\n\t\
    echo \"---------------------------------\"\n\techo \"End of File $file Results\"\
    \n\techo \"---------------------------------\"\ndone\n\n/CSE_3006_Lab_Exercise_1/README.md\n\
    # CSE 3006 Lab 1\n\n\nThis lab exercise is to simulate the behavior of a MIPS\
    \ processor after a series of instructions using the provided instruction set\
    \ and a sample assembly language program, as well as simulate the same behavior\
    \ for a larger, real-world assembly program.\n\nThe first MIPS processor, M1,\
    \ is the smallest MIPS processor that can be found. The second MIPS processor,\
    \ M2, is a more advanced MIPS processor. Both processors have the same instruction\
    \ set as the provided instruction set.\n\nIt is expected that the sample assembly\
    \ language source file, MIPS_Sample.asm, will be used with M1. The larger assembly\
    \ language source file, MIPS_Big.asm, will be used with M2. The provided instruction\
    \ set includes the following instructions:\n\n* R-type instructions\n* I-type\
    \ instructions\n* J-type instructions\n\nThe provided files, \"mips_instr.dec\"\
    \ and \"mips_registers.dec\", are the binary descriptions of the instruction format\
    \ and the register format, respectively.\n\nThe following table is a summary of\
    \ the instruction set, where each column contains the opcode, the instruction\
    \ format, and the operation performed. The table shows that R-type instructions\
    \ are composed of an opcode, the register format, and the R-type operation. I-type\
    \ instructions are composed of an opcode, the register format, and the I-type\
    \ operation.\n\n![Instruction Summary](./mips_instruction_summary.png)\n\n# Instruction\
    \ Set\n\nBased on the provided instruction set, the first MIPS processor, M1,\
    \ takes the following instruction-level trace:\n\n![mips_instruction_summary](./mips_instruction_summary.png)\n\
    \nand produces the following MIPS instruction trace:\n\n![instructions](./mips_instr_trace_m1.png)\n\
    \nMIPS_Sample.asm contains 10 instructions. The first two instructions, lui and\
    \ addi, are added to produce the following MIPS instruction trace.\n\n![MIPS_Sample](./mips_instr_trace_m1_sample.png)\n\
    \nThe remaining instructions are executed to produce the following MIPS instruction\
    \ trace.\n\n![MIPS_Sample](./mips_instr_trace_m1_sample_2.png)\n\nWith the same\
    \ MIPS instruction trace, MIPS_Big.asm contains about 130 instructions. \n\n![MIPS_Big](./mips_instr_trace_m2.png)\n\
    \nWhen MIPS_Big.asm is processed by the second MIPS processor, M2, the following\
    \ instruction trace is produced.\n\n![MIPS_Big](./mips_instr_trace_m2_big.png)\n\
    \nThe opcode, operand 1, operand 2, and result registers are printed for each\
    \ instruction. \n\nThe following table is a summary of the instruction execution\
    \ in the first MIPS processor, M1.\n\n![Register Summary](./mips_register_summary_m1.png)\n\
    \nThe following table is a summary of the instruction execution in the second\
    \ MIPS processor, M2.\n\n![Register Summary](./mips_register_summary_m2.png)\n\
    \n# References\n\n[1] *CSE 3006 Lab 1* -, Dr., and Dr. -\n\nhttps://moodle.cs.unb.ca/pluginfile.php/197658/mod_resource/content/1/CSE%203006%20Lab%201.pdf/CSE_3014_Lab_Exercises/Lab_3/README.md\n\
    # Lab 3\n\n\n## Problem 1\n### Verilog Code\nmodule Test;\n  reg D, Q;\n  always\n\
    \  begin\n    if (D) begin\n      Q = 1'b0;\n    end else begin\n      Q = 1'b1;\n\
    \    end\n  end\nendmodule\n### Simulation Results\n![Question 1](./Q1.png)\n\n\
    ### Verilog Code\nmodule Test;\n  reg D, Q;\n  always\n  begin\n    if (D) begin\n\
    \      Q = 1'b0;\n    end else begin\n      Q = 1'b1;\n    end\n  end\nendmodule\n\
    ### Simulation Results\n![Question 2](./Q2.png)\n\n### Verilog Code\nmodule Test;\n\
    \  reg D, Q;\n  always @(*)\n  begin\n    if (D) begin\n      Q = 1'b0;\n    end\
    \ else begin\n      Q = 1'b1;\n    end\n  end\nendmodule\n### Simulation Results\n\
    ![Question 3](./Q3.png)\n\n## Problem 2\n### Verilog Code\nmodule Test;\n  reg\
    \ D, Q;\n  always @(*)\n  begin\n    D = ~D;\n  end\nendmodule\n### Simulation\
    \ Results\n![Question 4](./Q4.png)\n\n### Verilog Code\nmodule Test;\n  reg D,\
    \ Q;\n  always @(*)\n  begin\n    D = ~D;\n  end\nendmodule\n### Simulation Results\n\
    ![Question 5](./Q5.png)\n\n## Problem 3\n### Verilog Code\nmodule Test;\n  reg\
    \ D, Q;\n  always @(*)\n  begin\n    D = 1'b1;\n  end\nendmodule\n### Simulation\
    \ Results\n![Question 6](./Q6.png)\n\n### Verilog Code\nmodule Test;\n  reg D,\
    \ Q;\n  always @(*)\n  begin\n    Q = 1'b1;\n  end\nendmodule\n### Simulation\
    \ Results\n![Question 7](./Q7.png)\n\n## Problem 4\n### Verilog Code\nmodule Test;\n\
    \  reg D, Q;\n  always @(*)\n  begin\n    D = ~D;\n    Q = ~Q;\n  end\nendmodule\n\
    ### Simulation Results\n![Question 8](./Q8.png)\n\n## Problem 5\n### Verilog Code\n\
    module Test;\n  reg D, Q;\n  always"
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      logic [7:0] I_bit;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          I_bit = I[0]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule

      **Result:**
    | **Testcase Type** | **Pass** | **Fail** | **NA** |
    | --- | --- | --- | --- |
    | **Pulse Detection** | 174 | 10 | 0 |
    | **Pulse Detection Pass Rate** | 93% | 7% | 0% |
    | **Pulse Detection Fail Rate** | 7% | 93% | 0% |
    | **Pulse Detection NA Rate** | 0%
- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[0] <= D[0];
    endmodule
    ### Result and Errors:
    The output of this code is the same as the non-procedural code.

    This is an example of dynamic array indexing.  The result is identical to setting Q[0] = D[0].

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[0] <= D;
    endmodule
    ### Result and Errors:
    The output of the modified Verilog code is the same as the non-procedural code.

    An array of register does not do what you seem to expect from an array of registers.  It looks like the Verilog code behaves as if you are assigning the value of D to a single register, but you are not.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= D[0];
    endmodule
    ### Result and Errors:
    The output of the modified Verilog code is the same as the non-procedural code.

    In this example, the first element of the array is being assigned to the output.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q[0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[0] <= D[0];
    endmodule
    ### Result and Errors:
    This example generates the same Verilog code as for the previous example.  The synthesizer will generate the same RTL for this case as well.  It is an error to try and assign a value to an array.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q[0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[3:0] <= D;
    endmodule
    ### Result and Errors:
    The output of this code is the same as the non-procedural code.

    This is a dynamic array assignment.  It is synthesizable.  The result is identical to Q[0] <= D[0];

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q[0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[3:0] <= D[0];
        else
            Q[3:0] <= D[1];
    endmodule
    ### Result and Errors:
    This example generates the same RTL as the previous.  It is an error to try to assign one value to Q[0] and another to Q[1] at the same time.  The assignment to Q[0] is ignored.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q[0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[3:0] <= D[0];
        else if (Resetn == 1)
            Q[3:0] <= D[1];
        else if (Resetn == 2)
            Q[3:0] <= D[2];
        else if (Resetn == 3)
            Q[3:0] <= D[3];
    endmodule
    ### Result and Errors:
    This Verilog generates the same Verilog code as for the previous.  The synthesizer will generate the same RTL.  The assign statements are converted to always blocks, and are placed within the sensitivity list of the always block.  We cannot use the procedural continuous assignment with conditional assignments.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q[0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q[3:0] <= D[0];
        else if (Resetn == 1)
            Q[3:0] <= D[1];
        else if (Resetn == 2)
            Q[3:0] <= D[2];
        else if (Resetn == 3)
            Q[3:0] <= D[3];
    endmodule
    ### Result and Errors:
    The output of this code is the same as the non-procedural code.  It is an error to use a procedural continuous assign within an "if" block.

    ### Modified Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
- code: |-
    ```
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0
- code: |-
    module reg7(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    dynamic [3:0] dynamic_D;
    always @(*)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= dynamic_D[4];
    endmodule
- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [1:0] Q;
    reg [1:0] Q;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 2'b00;
        else
            Q <= D[1:0];
- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    always @(posedge Clock or negedge Resetn) begin
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            begin
                Q[3] <= D[3];
                Q[2] <= D[2];
                Q[1] <= D[1];
                Q[0] <= D[0];
            end
    endmodule
    ### Base Verilog Code:
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0
- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    parameter [5:0] Address = 5'd0;

    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    ### Output:
    [info] Done parsing command line arguments.
    [info] Done parsing file.
    [warn] module reg4:49:3,15:15: parameter <Address> is not used inside the module block.
    [info] module reg4 is synthesized
    [info] Running CADENCE PNR...
    [info] 16 cells are replaced from the user design.
    [info] 16 cells (15 cells are replaced from the user design, 1 is replaced by default).
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info] Done running CADENCE PNR.
    [info
- code: module reg
- code: |-
    ```veilog
    module reg4(D, Clock, Resetn, Q);
        input [3:0] D;
        input Clock, Resetn;
        output [3:0] Q;
        reg [3:0] Q;
        always @(posedge Clock or negedge Resetn)
            if (Resetn == 0)
                Q <= 4'b0000;
            else
                Q <= D;
        endmodule
    ```

    ### Observation:
    The generated RTL code for this variation is shown in the following figure.

    ![](http://www.asic-world.com/images/Reg4.png)

    Note: The RTL code has been generated from [this](https://github.com/vlsi-course/vlsi_course/blob/master/lab2/lab2/reg4.v) verilog code.
- code: |-
    #include "verilated.h"
    #include <iostream>
    #include "Vreg4.h"

    VL_MODULE(Vreg4)
    {
        // Ports
        VL_IN8(Clock,0,0);
        VL_IN8(Resetn,0,0);
        VL_IN(D,3,0);
        VL_OUT(Q,3,0);

        // Internals
        VL_REG(Q,3,0);

    always_ff @(posedge Clock or negedge Resetn) begin
        if (Resetn == 0)
            Q = 0;
        else
            Q = D;
    end

    endmodule
    ### Simulation Results:
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/Result.png)
    ### Verilog Design Files
    [reg4.v](https://github.com/zxycsu/Verilog_Test/blob/master/reg4.v)
    ### VHDL Design
    [reg4.vhd](https://github.com/zxycsu/Verilog_Test/blob/master/reg4.vhd)
    ### Run Demo
    ```
    cd../verilator
    make -j4
    cd../sim
    ./reg4
    ```
    /README.md
    # Verilog Test
    ## Introduction
    Verilog is a hardware description language with a structured imperative n/Verilog/blob/master/reg4/demo.png)
    ### Verilog Code
    [reg4.v](https://github.com/zxycsu/Verilog_Test/blob/master/Verilog/reg4/reg4.v)
    ### Run Demo
    ```
    cd../verilator
    make -j4
    cd../sim
    ./reg4
    ```
    control flow and constructs aiming to provide simple and extensible hardware description. The language is used in the Verilog simulator which can simulate the behavior of hardware devices.
    ## Verilog Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/Verilog/reg4/result.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/Verilog/reg8/result.png)
    ## VHDL Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/VHDL/reg16/vhdl.png)
    ## Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/sim/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/sim/reg8/demo.png)
    ## Verilator Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL Simulation Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/VHDL/reg16/demo.png)
    ## VHDL Verilator Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg4/demo.png)
    ### reg8
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/verilator/reg8/demo.png)
    ## VHDL SimVerilator Files
    ### reg16
    ![](https://github.com/zxycsu/Verilog_Test/blob/master/SimVerilator/VHDL/reg16/demo.png)
    ## Verilator Simulation Files
    ### reg4
    ![](https://github.com/zxycsu/Verilog_Test/blob/
- code: |-
    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q;
    parameter N=4;
    reg [3:0] Q[N-1:0];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            #1
            Q <= D;
    endmodule
    ### Result:
    ![result](https://user-images.githubusercontent.com/8025855/31681621-51b9b61c-b346-11e7-8a63-5815b25b2d8c.png)
- code: |-
    module not32(g,a);
    output g;
    input a;
    reg [31:0] b;

    initial begin
    wire [31:0] c;
    end

    always begin
    assign b = a;
    assign c = ~b;
    assign g = c;
    end
    endmodule

    ### Performance:
    The performance of the modified module is similar to the base module. The latency is also the same.

    ## Question 2
    ### Base Verilog Code:
    module gated_adder_4_bit(a_sum,c_in,c_out,x,y,s);
    output a_sum;
    input c_in,c
- code: "module aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate\
    \ signals\n// Dataflow assignments for AND, OR, and NOT operations\nassign e =\
    \ a && b;\nassign f = c && d;\nassign g1 = e || f;\nassign g = ~(e || f); // Final\
    \ AOI output\ninitial\n\twire [7:0] m_temp_49[9:0];\n\tm_temp_49[0] = 0;\n\tm_temp_49[1]\
    \ = 1;\n\tm_temp_49[2] = 2;\n\tm_temp_49[3] = 3;\n\tm_temp_49[4] = 4;\n\tm_temp_49[5]\
    \ = 5;\n\tm_temp_49[6] = 6;\n\tm_temp_49[7] = 7;\n\tm_temp_49[8] = 8;\n\tm_temp_49[9]\
    \ = 9;\n\twire [7:0] m_temp_51;\n\tm_temp_51 = a && b;\n\twire [7:0] m_temp_52;\n\
    \tm_temp_52 = c && d;\n\twire [7:0] m_temp_53;\n\tm_temp_53 = m_temp_51 || m_temp_52;\n\
    \twire [7:0] m_temp_54;\n\tm_temp_54 = ~m_temp_53;\n\tm_temp_49[m_temp_54] = {m_temp_49[m_temp_54],m_temp_49[0],m_temp_49[1],m_temp_49[2],m_temp_49[3],m_temp_49[4],m_temp_49[5],m_temp_49[6],m_temp_49[7],m_temp_49[8]};\n\
    endmodule\n### Output Result:\nThe new verilog code is synthesized to:\nmodule\
    \ aoi2(g, a, b, c, d);\noutput g;\ninput a, b, c, d;\nreg m_temp_50;\nwire m_temp_51;\n\
    wire m_temp_52;\nwire m_temp_53;\nwire m_temp_54;\nassign m_temp_50 = a && b;\n\
    assign m_temp_51 = c && d;\nassign m_temp_52 = m_temp_50 || m_temp_5"
- code: |-
    module comparator(g,a,b);
    output g;
    input a,b;

    always_latch @(a>b) begin
    g = 1;
    end
    end

    always_latch @(a==b) begin
    g = 0;
    end
    end

    always_latch @(a<b) begin
    g
- code: |-
    #### Variant 1
    module aoi2_1a(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    initial begin
    wire a3,b3,c3,d3,e3;
    a3=a1 && b1;
    b3=c1 && d1;
    c3=a2 && b2;
    d3=c2 && d2;
    assign e3=a3 || b3;
    assign g=e3 && a3 || c3 || d3;
    end
    endmodule
    #### Variant 2
    module aoi2_1a(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    assign a3=a1 && b1;
    assign b3=c1 && d1;
    assign c3=a2 && b2;
    assign d3=c2 && d2;
    assign e3=a3 || b3;
    assign g=e3 && a3 || c3 || d3;
    endmodule

    ### Simulation and Observation:
    The simulation results shows that the variation instruction can successfully generate the waveform as the following illustrated.

    ## 2.5.3. Example 4: AOI2_1B

    ### Source Verilog Code:
    module aoi2_1b(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 || b1;
    assign b3=c1 || d1;
    assign c3=a2 || b2;
    assign d3=c2 || d2;
    assign e3=a3 && b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Base Verilog Code:
    module aoi2_1b(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 || b1;
    assign b3=c1 || d1;
    assign c3=a2 || b2;
    assign d3=c2 || d2;
    assign e3=a3 && b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Variant Instruction:
    Use initial block variable initialization with an inside expression using a function call in the index.

    ### Testbench Code:

    ### Simulation and Observation:
    The simulation results shows that the variation instruction can successfully generate the waveform as the following illustrated.

    ## 2.5.4. Example 5: AOI2_2

    ### Source Verilog Code:
    module aoi2_2(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 && b1;
    assign b3=c1 || d1;
    assign c3=a2 && b2;
    assign d3=c2 || d2;
    assign e3=a3 || b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Base Verilog Code:
    module aoi2_2(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 && b1;
    assign b3=c1 || d1;
    assign c3=a2 && b2;
    assign d3=c2 || d2;
    assign e3=a3 || b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Variant Instruction:
    Use initial block variable initialization with an inside expression using a function call in the index.

    ### Testbench Code:

    ### Simulation and Observation:
    The simulation results shows that the variation instruction can successfully generate the waveform as the following illustrated.

    ## 2.5.5. Example 6: AOI2_3

    ### Source Verilog Code:
    module aoi2_3(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 && b1;
    assign b3=c1 && d1;
    assign c3=a2 && b2;
    assign d3=c2 && d2;
    assign e3=a3 || b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Base Verilog Code:
    module aoi2_3(a1,b1,c1,d1,a2,b2,c2,d2,g);
    input a1,b1,c1,d1;
    input a2,b2,c2,d2;
    output g;
    wire a3,b3,c3,d3,e3;
    assign a3=a1 && b1;
    assign b3=c1 && d1;
    assign c3=a2 && b2;
    assign d3=c2 && d2;
    assign e3=a3 || b3;
    assign g=e3 && c3 || d3;
    endmodule
    ### Variation Instruction:
    Use initial block variable initialization with an inside expression using a function call in the index.

    ### Testbench Code:
- code: |-
    module fourbit_counter(q,q_clk,Q);
    output [3:0] q,Q;
    input [3:0] q_clk;
    initial begin
    function [3:0]
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    initial begin
    int a0,a1;
    a0 = 1'b0; a1 = 1'b0;
    e = a0 && a1;
    f = a0 && a1;
    end
    endmodule

    ## How To Use Variation Instruction to Solve Conflicts

    Every variation instruction has a different type of conflict you can solve with it. Variation instructions can help you solve different types of conflict.

    ### Conflict Types

    #### Multiple Sequential Conflict

    Multiple sequential conflicts involve multiple sequential statements that have the same value. Multiple sequential conflicts can be solved using initial blocks.

    #### Multiple Assignment Conflict

    Multiple assignment conflicts involve multiple assignments where the same data flows through each assignment. Multiple assignment conflicts can be solved using sequential statements in an initial block.

    #### Nested Assignment Conflict

    Nested assignment conflicts involve assignments that are nested within each other. Nested assignment conflicts can be solved using sequential statements in an
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1;
    initial begin
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    end
    assign g = ~g1;
    endmodule

    ## Explanation

    ### Base Verilog Code

    The initial block of module aoi1 is executed when the simulator is started before any simulation events (process or initial statements) are executed.

    In the initial block of the module, the intermediate signals e, f and g1 are assigned the same values as the inputs a, b, c and d.

    The final output g is assigned the opposite of final intermediate signal g1.

    ### Variation Instruction

    The assign statement has an indexing expression using an inside function call.

    The inside function call is the function AOI2_INITIAL_VALUE which returns a random value of type aoi2_initial_value_type. The type of this function is defined as AOI2_INITIAL_VALUE.

    The returned value is assigned to the intermediate signal corresponding to the input of this module.

    ### Modified Code

    The assign statement has a left-hand side expression which is an indexing expression of g1 in a similar way as before using the indexing expression of aoi2_initial_value_type.

    The index expression is used as input to the function AOI2_INITIAL_VALUE.

    The function returns a random value of type aoi2_initial_value_type.

    The returned value is assigned to the intermediate signal corresponding to the input of this module.

    ## Source Code

    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1;
    initial begin
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    end
    assign g = ~g1;
    endmodule

    ## Generated Simulation

    The simulation result is a random output each time the simulation is started.

    The simulation result is as follows.

    The initial block assign statement uses a random value of type aoi2_initial_value_type as input to the function AOI2_INITIAL_VALUE.

    The function returns a random value of type aoi2_initial_value_type.

    The returned value is assigned to the intermediate signal corresponding to the input of this module.

    The assign statement has an indexing expression of g in a similar way as before using the indexing expression of aoi2_initial_value_type.

    The index expression is used as input to the function AOI2_INITIAL_VALUE.

    The function returns a random value of type aoi2_initial_value_type.

    The returned value is assigned to the intermediate signal corresponding to the input of this module.

    The final output g is assigned the opposite of final intermediate signal g1.

    The final output of the initial block is assigned to the intermediate signal corresponding to the input of this module.

    The intermediate signal corresponding to this module is assigned the opposite of the final output of the initial block.

    ## Example Result

    The random value is assigned to the intermediate signal e in initial block assign statement.

    The random value is assigned to the intermediate signal f in initial block assign statement.

    The final output g of the initial block is assigned to the intermediate signal g1.

    The output of the initial block is assigned to the intermediate signal g1.

    The final output g is assigned the opposite of the final output of the initial block.

    ## Simulation Result

    The simulation result is a random output each time the simulation is started.

    The simulation result is as follows.
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    initial
    wire[d-1:0] z;
    function reg t,t1,t2,t3;
    reg [d-1:0] z;
    function [c-1:0] t,t1,t2,t3;
    always @(t or t1 or t2 or t3)
    x = z;
    endfunction
    endinitial
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    endmodule
    ### Execution Results:
    No changes.
    ### Testbench Code:
    module tb;
    wire g;
    wire a,b,c,d;
    reg [25:0] count;
    initial
    $dumpvars(0,tb); // dump initial variable values
    // set initial conditions
    d=1;
    c=0;
    b=0;
    a=1;
    $dumpvars(1,tb); // dump first clock cycle variable values
    // test and loop
    while (count < 10000) begin
    g=a&b|c&d;
    count = count + 1;
    end
    endmodule
    ### Resulting Dump File:
    -17- Verilog-Tutorial/Verilog AOI-Function/testbench_aoi2/tb.vvp
    dump vars 0
    0, tb
    0, g 0
    1, a 1
    1, b 0
    1, c 0
    1, d 1
    2, g 0
    3, g 0
    4, g 1
    5, g 0
    6, g 1
    7, g 1
    8, g 1
    9, g 0
    10, g 1
    11, g 1
    12, g 0
    13, g 1
    14, g 1
    15, g 1
    16, g 1
    17, g 1
    18, g 0
    19, g 1
    20, g 1
    21, g 1
    22, g 0
    23, g 1
    24, g 0
    25, g 0
    26, g 0
    27, g 1
    28, g 0
    29, g 0
    30, g 0
    31, g 0
    32, g 0
    33, g 0
    34, g 0
    35, g 0
    36, g 0
    37, g 0
    38, g 0
    39, g 0
    40, g 0
    41, g 0
    42, g 0
    43, g 0
    44, g 0
    45, g 0
    46, g 0
    47, g 0
    48, g 0
    49, g 0
    50, g 0
    51, g 1
    52, g 1
    53, g 1
    54, g 1
    55, g 1
    56, g 1
    57, g 1
    58, g 1
    59, g 1
    60, g 1
    61, g 1
    62, g 1
    63, g 1
    64, g 1
    65, g 1
    66, g 1
    67, g 0
    68, g 1
    69, g 1
    70, g 1
    71, g 1
    72, g 1
    73, g 1
    74, g 1
    75, g 1
    76, g 0
    77, g 1
    78, g 1
    79, g 1
    80, g 1
    81, g 1
    82, g 1
    83, g 1
    84, g 1
    85, g 1
    86, g 1
    87, g 1
    88, g 1
    89, g 1
    90, g 1
    91, g 1
    92, g 1
    93, g 1
    94, g 1
    95, g 1
    96, g 1
    97, g 1
    98, g 1
    99, g 1
    100, g 1
    101, g 0
    102, g 1
    103, g 1
    104, g 1
    105, g 1
    106, g 1
    107, g 1
    108, g 1
    109, g 1
    110, g 1
    111, g 1
    112, g 1
    113, g 1
    114, g 1
    115, g 1
    116, g 1
    117, g 0
    118, g 1
    119, g 1
    120, g 1
    121, g 1
    122, g 1
    123, g 1
    124, g 1
    125, g 1
    126, g 1
    127, g 1
    128, g 1
    129, g 1
    130, g 1
    131, g 1
    132, g 1
    133, g 1
    134, g 1
    135, g 1
    136, g 1
    137, g 1
    138, g 1
    139, g 1
    140, g 1
    141, g 1
    142, g 1
    143, g 1
    144, g 1
    145, g 1
    146, g 1
    147, g 1
    148, g 1
    149, g 1
    150, g 1
    151, g 1
    152, g 1
    153, g 1
    154, g 1
    155, g 1
    156, g 1
    157, g 1
    158, g 1
    159, g 1
    160, g 1
    161, g 1
    162, g 1
    163, g 1
    164, g 1
    165, g 1
    166, g 1
    167, g 1
    168, g 1
    169, g 1
    170, g 1
    171, g 1
    172, g 1
    173, g 1
    174, g 1
    175, g 1
    176, g 1
    177, g 1
    178, g 1
    179, g 1
    180, g 1
    181, g 1
    182, g 1
    183, g 1
    184, g 1
    185, g 1
    186, g 1
    187, g 1
    188, g 1
    189, g 1
    190, g 1
    191, g 1
    192, g 1
    193, g 1
    194, g 1
    195, g 1
    196, g 1
    197, g 1
    198, g 1
    199, g 1
    200, g 1
    201, g 1
    202, g 1
    203, g 1
    204, g 1
    205, g 1
    206, g 1
    207, g 1
    208, g 1
    209, g 1
    210, g 1
    211, g 1
    212, g 1
    213, g 1
    214, g 1
    215, g 1
    216, g 1
    217, g 1
    218, g 1
    219, g 1
    220, g 1
    221, g
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    initial begin
    // Initial value of intermediate registers
    e = 1'b0;
    f = 1'b0;
    g1 = 1'b0;
    end
    endmodule

    ## 5. Test Bench Design
    The test bench can be designed for different cases and conditions to test the design, to ensure that the design outputs the expected values.

    ### Input:
    - Inputs for the design: a, b, c, and d
    ### Output:
    - Test bench output: g
    ### Code:
    module aoi2_tb;
    // Inputs for the design
    input a,b,c,d;
    // Output from the design
    output g;
    // Instantiate the design under test

    // Create an instance of the AOI2 module
    aoi2 aoi2(g);

    // Instantiate an initial block to initialize the intermediate signals
    initial begin
    // Initialize the intermediate signals
    g = 1'b0;
    end

    // Create a clock signal
    reg clk = 1;
    initial clk=0;
    // Create a clock period
    integer period = 5;

    // Generate signal values for the inputs at each clock cycle
    always#period clk = ~clk;

    // Instantiate a forever loop to continuously check the output for correctness
    forever #period begin
    #10;
    end

    endmodule
    ### Test Bench Result:
    Result after generating the simulation waveform
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    // Dataflow assignments for AND, OR, and NOT operations
    assign g = a && b || (c && d);
    endmodule
    ### Designed Module:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    // Index is 1st input bit
    assign g = a[2] && b[2] || (c[2] && d[2]);
    endmodule
    Output

    ### Base Verilog Code:
    module aoi2(g,a,b,c,d);
    output g;
- code: |-
    ```
    always @(a, b, c, d, e, f, g, h) begin
    ...
    end
    ```

    ## Test15: Xor9
    ### Description
- code: |-
    ```
    `include "maj_3_v3.vh"
    module maj3_v3 (input [1:0]a, b, c, output [1:0]y);
        maj_3_v3 fcn (a,b,c,y);
    endmodule
    ```
    ### Generated Verilog Code:
    ```
    module maj3_v3 (input [1:0]a, b, c, output [1:0]y);
        wire [1:0] im1;
        wire [1:0] im2;
        wire [1:0] im3;
        and _p1 (im1,a,b);
        and _p2 (im2,b,c);
        and _p3 (im3,c,a);
        or _p4 (y,im1,im2,im3);
    endmodule
    ```
    ### Diff:
    ```
    module maj3_v3 (input [1:0]a, b, c, output [1:0]y);
        wire [1:0] im1;
        wire [1:0] im2;
        wire [1:0] im3;
        and _p1 (im1,a,b);
        and _p2 (im2,b,c);
        and _p3 (im3,c,a);
        or _p4 (y,im1,im2,im3);
    endmodule
    ```
    /include/dft/dft_v5_1.vh.h
    #pragma once

    #define DFT_V5_1_INPUT_COUNT 1
    #define DFT_V5_1_OUTPUT_COUNT 0

    wire [0:0] x0;
    wire [0:0] x1;

    nand _p1 (x0,x1);

    assign x0 = input;
    assign x1 = 0;

    `include "dft/dft_v5_1.vh"/src/test_generation.cpp
    #include "gtest/gtest.h"

    #include "generators/generators.cpp"

    #include "generators/maj_3.cpp"
    #include "generators/maj_3_v2.cpp"
    #include "generators/maj_3_v3.cpp"
    #include "generators/maj_3_v4.cpp"

    #include "generators/dft.cpp"
    #include "generators/dft_v2.cpp"
    #include "generators/dft_v3.cpp"
    #include "generators/dft_v4.cpp"
    #include "generators/dft_v5.cpp"
    #include "generators/dft_v6.cpp"

    #include "generators/maj_3_v7.cpp"
    #include "generators/maj_3_v8.cpp"
    #include "generators/maj_3_v9.cpp"

    #include "generators/maj_3_v10.cpp"
    #include "generators/maj_3_v11.cpp"
    #include "generators/maj_3_v12.cpp"

    #include "generators/dft_v13.cpp"
    #include "generators/dft_v14.cpp"
    #include "generators/dft_v15.cpp"
    #include "generators/dft_v16.cpp"
    #include "generators/dft_v17.cpp"
    #include "generators/dft_v18.cpp"

    #include "generators/maj_3_v19.cpp"
    #include "generators/maj_3_v20.cpp"

    #include "generators/maj_3_v21.cpp"
    #include "generators/maj_3_v22.cpp"
    #include "generators/maj_3_v23.cpp"

    #include "generators/maj_3_v24.cpp"
    #include "generators/maj_3_v25.cpp"
    #include "generators/maj_3_v26.cpp"

    #include "generators/maj_3_v27.cpp"
    #include "generators/maj_3_v28.cpp"
    #include "generators/maj_3_v29.cpp"

    #include "generators/maj_3_v30.cpp"
    #include "generators/maj_3_v31.cpp"
    #include "generators/maj_3_v32.cpp"

    #include "generators/maj_3_v33.cpp"
    #include "generators/maj_3_v34.cpp"
    #include "generators/maj_3_v35.cpp"

    #include "generators/maj_3_v36.cpp"
    #include "generators/maj_3_v37.cpp"
    #include "generators/maj_3_v38.cpp"

    #include "generators/maj_3_v39.cpp"
    #include "generators/maj_3_v40.cpp"
    #include "generators/maj_3_v41.cpp"

    #include "generators/maj_3_v42.cpp"
    #include "generators/maj_3_v43.cpp"
    #include "generators/maj_3_v44.cpp"

    #include "generators/maj_3_v45.cpp"
    #include "generators/maj_3_v46.cpp"
    #include "generators/maj_3_v47.cpp"

    #include "generators/maj_3_v48.cpp"
    #include "generators/maj_3_v49.cpp"
    #include "generators/maj_3_v50.cpp"

    #include "generators/maj_3_v51.cpp"
    #include "generators/maj_3_v52.cpp"
    #include "generators/maj_3_v53.cpp"

    #include "generators/maj_3_v54.cpp"
    #include "generators/maj_3_v55.cpp"
    #include "generators/maj_3_v56.cpp"

    #include "generators/maj_3_v57.cpp"
    #include "generators/maj_3_v58.cpp"
    #include "generators/maj_3_v59.cpp"

    #include "generators/maj_3_v60.cpp"
    #include "generators/maj_3_v61.cpp"
    #include "generators/maj_3_v62.cpp"

    #include "generators/maj_3_v63.cpp"
    #include "generators/maj_3_v64.cpp"
    #include "generators/maj_3_v65.cpp"

    #include "generators/maj_3_v66.cpp"
    #include "generators/maj_3_v67.cpp"
    #include "generators/maj_3_v68.cpp"

    #include "generators/maj_3_v69.cpp"
    #include "generators/maj_3_v70.cpp"
    #include "generators/maj_3_v71.cpp"

    #include "generators/maj_3_v72.cpp"
    #include "generators/maj_3_v73.cpp"
    #include "generators/maj_3_v74.cpp"

    #include "generators/maj_3_v75.cpp"
    #include "generators/maj_3_v76.cpp"
    #include "generators/maj_3_v77.cpp"

    #include "generators/maj_3_v78.cpp"
    #include "generators/maj_3_v79.cpp"
    #include "generators/maj_3_v80.cpp"

    #include "generators/maj_3_v81.cpp"
    #include "generators/maj_3_v82.cpp"
    #include "generators/maj_3_v83.cpp"

    #include "generators/maj_3_v84.cpp"
    #include "generators/maj_3_v85.cpp"
    #include "generators/maj_3_v86.cpp"

    #include "generators/maj_3_v87.cpp"
    #include "generators/maj_3_v88.cpp"
    #include "generators/maj_3_v89.cpp"

    #include "generators/maj_3_v90.cpp"
    #include "generators/maj_3_v91.cpp"
    #include "generators/maj_3_v92.cpp"

    #include "generators/maj_3_v93.cpp"
    #include "generators/maj_3_v94.cpp"
    #include "generators/maj_
- code: |-
    module mux4x1(in0, in1, in2, in3, sel, out);
    input in0, in1, in2, in3;
    input sel;
    output out;
    wire in0, in1, in2, in3;

    assign in0 = sel == 0? in2 : in0;
    assign in1 = sel == 0? in3 : in1;

    always @ (posedge clk)
    begin
    in0 = sel == 0? in2 : in0;
    in1 = sel == 0? in3 : in1;
    in2 = sel == 1? in2 : in2;
    in3 = sel == 1? in3 : in3;
    end

    assign out = in0 & in1;

    endmodule
    Note: To test the modified code, remove the assert statements and place them for your verification method.
- code: '```vhdl'
- code: |-
    \# include <systemc.h\>
    \# include <stdio.h\>
    \# include <stdint.h\>
    \# include <stdlib.h\>
    \# include <xmr-array.h\>
    typedef uint8\_t u8;
    # define array\_size(x) (sizeof(x) / sizeof(x[0]))
    typedef xmr::array\_t<u8> xmr\_array\_t;
    typedef xmr::array\_iterator\_t<u8> xmr\_array\_iterator\_t;
    int sc\_main(int argc, char \*argv[])
    {
     sc\_signal\<bool\>\* sig\_a;
     sc\_signal\<bool\>\* sig\_b;
     sc\_signal\<bool\>\* sig\_c;
     sc\_signal\<bool\>\* sig\_y;
     sc\_signal\<bool\>\* sig\_im1;
     sc\_signal\<bool\>\* sig\_im2;
     sc\_signal\<bool\>\* sig\_im3;
     xmr\_array\_t inputs;
     xmr\_array\_t outputs;
     xmr\_array\_t im1;
     xmr\_array\_t im2;
     xmr\_array\_t im3;
     const int array\_length = 10;
     inputs.resize(array\_length);
     for (int i = 0; i < array\_length; ++i)
     {
     inputs[i] = false;
     }
     sc\_trace\_file\* tf = sc\_create\_vcd\_trace\_file("maj3");
     tf->set\_time\_unit(1, SC\_NS);
     tf->set\_time\_unit(1, SC\_PS);
     sig\_a = new sc\_signal\("a"\);
     sig\_b = new sc\_signal\("b"\);
     sig\_c = new sc\_signal\("c"\);
     sig\_y = new sc\_signal\("y"\);
     sig\_im1 = new sc\_signal\("im1"\);
     sig\_im2 = new sc\_signal\("im2"\);
     sig\_im3 = new sc\_signal\("im3"\);
     inputs[0] = true;
     inputs[1] = true;
     inputs[2] = true;
     outputs.resize(1);
     im1.resize(1);
     im2.resize(1);
     im3.resize(1);
     xmr\_array\_iterator\_t iter\_inputs(inputs);
     xmr\_array\_iterator\_t iter\_outputs(outputs);
     xmr\_array\_iterator\_t iter\_im1(im1);
     xmr\_array\_iterator\_t iter\_im2(im2);
     xmr\_array\_iterator\_t iter\_im3(im3);
     xmr\_array\_iterator\_t iter\_a(outputs);
     xmr\_array\_iterator\_t iter\_b(outputs);
     xmr\_array\_iterator\_t iter\_c(outputs);
     xmr\_array\_iterator\_t iter\_y(outputs);
     sc\_trace(tf, iter\_inputs, "inputs");
     sc\_trace(tf, iter\_im1,
- code: |-
    ```
    always_comb begin

    x[1] = 2'b00 & ~a;
    x[2] = 2'b00 & ~a;
    if (a!= a_old) begin
        x[2] = 2'b110;
    end

    y = (x[1] & x[2]) | (x[2] & x[0]);

    end
    ```
    ### Reference:
    https://en.wikipedia.org/wiki/Disjoint-path_multiplier

    /06_Verilog_Generator/src/VerilogGenerator.cpp
    #include "VerilogGenerator.h"

    void VerilogGenerator::addStatement(std::string statementLine) {
        if (statementLine.size() > 0) {
            statementLines.push_back(statementLine);
        }
    }

    bool VerilogGenerator::generateVerilog(std::string filename) {
        bool outputSuccess = true;
        std::ofstream codeFile(filename);

        if (codeFile.is_open()) {
            codeFile << "module " << module.getName() << "(" << module.getInputs() << ");\n";
            for (unsigned int i = 0; i < module.getInputs().size(); i++) {
                codeFile << "\tinput " << module.getInputs()[i].getName() << ";\n";
            }

            codeFile << module.getOutputs();
            for (unsigned int i = 0; i < module.getOutputs().size(); i++) {
                codeFile << "\toutput " << module.getOutputs()[i].getName() << ";\n";
            }

            codeFile << "\n\t" << module.getClock() << " clk, reset;\n";
            codeFile << module.getConstants();
            codeFile << module.getRegisters();
            codeFile << module.getAlways();

            codeFile << "\nendmodule\n";

            codeFile.close();
        } else {
            outputSuccess = false;
        }

        return outputSuccess;
    }

    void VerilogGenerator::addModule(std::string name, std::string clock, std::vector<std::string> inputs, std::vector<std::string> outputs, std::vector<std::string> constants, std::vector<std::string> registers, std::vector<std::string> always) {
        module.setName(name);
        module.setClock(clock);
        module.setInputs(inputs);
        module.setOutputs(outputs);
        module.setConstants(constants);
        module.setRegisters(registers);
        module.setAlways(always);
    }

    void VerilogGenerator::print() {
        std::cout << "Name: " << module.getName() << std::endl;
        std::cout << "Clock: " << module.getClock() << std::endl;
        std::cout << "Inputs: ";
        for (auto input : module.getInputs()) {
            std::cout << input << " ";
        }
        std::cout << std::endl;
        std::cout << "Outputs: ";
        for (auto output : module.getOutputs()) {
            std::cout << output << " ";
        }
        std::cout << std::endl;
        std::cout << "Constants: ";
        for (auto constant : module.getConstants()) {
            std::cout << constant << " ";
        }
        std::cout << std::endl;
        std::cout << "Registers: ";
        for (auto registerLine : module.getRegisters()) {
            std::cout << registerLine << " ";
        }
        std::cout << std::endl;
        std::cout
- code: |-
    module nand6 (a, b, c, d, e, f, y);
    input a, b, c, d, e;
    output f, y;
    wire [5:0] abcd;
    assign abcd = {a, b, c, d, e};
    nand #(2, 4)
        (im1, abcd[0], abcd[1]),
        (im2, abcd[1], abcd[2]),
        (im3, abcd[2], abcd[3]),
        (im4, abcd[3], abcd[4]),
        (im5, abcd[4], abcd[0]);
    nand #(1, 6) (im6, im1, im2, im3, im4, im5);
    nand #(6) (f, im1, im2, im3, im4, im5, im6);
    endmodule
    ### Performance:

    - A code with 5 in-combinational paths, 6 out-combinational paths, 1 in-combinational fan-in, and 4 register paths are generated.
    - The critical path is 34.690.245 ns and the critical path rise time is 26.439.639 ns.

    ### Base Verilog Code:
    module nor (a, b, c, d, e, y);
    input a, b, c, d, e;
    output y;
    wire im1, im2, im3, im4, im5, im6;
    nand #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, d),
        (im4, d, e),
        (im5, e, a);
    nand #(1, 6) (im6, im1, im2, im3, im4, im5);
    or #(6) (y, im1, im2, im3, im4, im5, im6);
    endmodule
    ### Variation Instruction:
    In the always block, test inside with an XMR
- code: |-
    ```verilog
    module maj7 (a, b, c, d, e, f, g, y);
    input a, b, c, d, e, f, g;
    output y;
    wire im1, im2, im3, im4, im5, im6, im7;
    and #(2, 4) (im1, a, b),
        (im2, b, c),
        (im3, c, d),
        (im4, d, e),
        (im5, e, f),
        (im6, f, g),
        (im7, g, a);
    or #(3, 5) (y, im1, im2, im3, im4, im5, im6, im7);
    endmodule
    ```

    ### Benchmark Results:

    | Architecture | Core Type | Simulation Tool | Score |
    | --- | --- | --- | ---: |
    | Majority-7 | CoreGen 5 | Mentor Graphics ModelSim | 24.43 |

    </p>
    </details>

    <details>
    <summary>Majority-8</summary>
    <p>

    ### Base Verilog Code:
    module maj8 (a, b, c, d, e, f, g, h, y);
    input a, b, c, d, e, f, g, h;
    output y;
    wire im1, im2, im3, im4, im5, im6, im7, im8;
    and #(2, 4) (im1, a, b),
        (im2, b, c),
        (im3, c, d),
        (im4, d, e),
        (im5, e, f),
        (im6, f, g),
        (im7, g, h),
        (im8, h, a);
    or #(3, 5) (y, im1, im2, im3, im4, im5, im6, im7,
- code: |-
    ```
    function [3:0] maj_3(input [3:0] a, b, c);
        always @(a, b, c) begin
            maj_3 <= {a & b, b & c, c & a, a + b + c};
        end
    endfunction
    ```

    #### Base Verilog Code:
    ```
    module count_ones (a, b, c, out1, out2);
    input a, b, c;
    output out1, out2;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
- code: |-
    ```Verilog
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
    ```

    ### Base Verilog Code:
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    and #(2, 4)
- code: |-
    module tst_case1; //testbench
    wire [1:0] y;
    reg [2:0] i;
    case (i)
    3'b000: y=0;
    3'b001: y=1;
    3'b010: y=2;
    otherwise: y=~y;
    endcase
    initial
    begin
    i=3'b000;
    end
    initial $monitor($time,"y=%b,i=%b", y, i);
    initial #8 $stop; endmodule ### New Code: module tst_case1; //testbench wire [1:0] y; parameter N=3; wire psel_low=N-1; wire psel_high=0; reg [N-1:0] i; case (i) 3'b000: y=0; 3'b001: y=1; 3'b010: y
- code: |-
    // Initializations moved to initial blocks
    // Added monitor and stop
    // Replaced variable declarations with part-selects, which have been optimized to bit selects.
    reg i1,i2;
    wire o;
- code: |-
    module tst_wand1;
    wire [0:7] i1,i2;
    wire o;
    wand1 ww(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial
    begin
    i1=[2'b10,2'b00,2'b10,2'b11]; i2=[2'b01,2'b01,2'b10,2'b10]; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial
    begin
    i1=[2'b10,2'b00,2'b10,2'b10]; i2=[2'b01,2'b00,2'b10,2'b11]; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial
    begin
    i1=[2'b10,2'b00,2'b11,2'b11]; i2=[2'b01,2'b01,2'b10,2'b10]; // Drv1
- code: |-
    module tst_wand1(); //testbench
    reg [7:0] i1,i2; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    wire [7:0] o;
    wand1 ww(i1,i2,o);
    initial
    begin
    i1[0] = 0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    i2[0] = 0;
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
    ### Testbench Output:
    i1=00000000,i2=00000000,o=00000000
    i1=00000000,i2=00000001,o=00000000
    i1=00000000,i2=00000010,o=00000000
    i1=00000000,i2=00000011,o=00000000
    i1=00000000,i2=00000100,o=00000000
    i1=00000000,i2=00000101,o=00000000
    i1=00000000,i2=00000110,o=00000000
    i1=00000000,i2=00000111,o=00000000
    i1=00000000,i2=00001000,o=00000000
    i1=00000000,i2=00001001,o=00000000
    i1=00000000,i2=00001010,o=00000000
    i1=00000000,i2=00001011,o=00000000
    i1=00000000,i2=00001100,o=00000000
    i1=00000000,i2=00001101,o=00000000
    i1=00000000,i2=00001110,o=00000000
    i1=00000000,i2=00001111,o=00000000
    i1=00000000,i2=00010000,o=00000000
    i1=00000000,i2=00010001,o=00000000
    i1=00000000,i2=00010010,o=00000000
    i1=00000000,i2=00010011,o=00000000
    i1=00000000,i2=00010100,o=00000000
    i1=00000000,i2=00010101,o=00000000
    i1=00000000,i2=00010110,o=00000000
    i1=00000000,i2=00010111,o=00000000
    i1=00000000,i2=00011000,o=00000000
    i1=00000000,i2=00011001,o=00000000
    i1=00000000,i2=00011010,o=00000000
    i1=00000000,i2=00011011,o=00000000
    i1=00000000,i2=00011100,o=00000000
    i1=00000000,i2=00011101,o=00000000
    i1=00000000,i2=00011110,o=00000000
    i1=00000000,i2=00011111,o=00000000
    i1=00000000,i2=00100000,o=00000000
    i1=00000000,i2=00100001,o=00000000
    i1=00000000,i2=00100010,o=00000000
    i1=00000000,i2=00100011,o=00000000
    i1=00000000,i2=00100100,o=00000000
    i1=00000000,i2=00100101,o=00000000
    i1=00000000,i2=00100110,o=00000000
    i1=00000000,i2=00100111,o=00000000
    i1=00000000,i2=00101000,o=00000000
    i1=00000000,i2=00101001,o=00000000
    i1=00000000,i2=00101010,o=00000000
    i1=00000000,i2=00101011,o=00000000
    i1=00000000,i2=00101100,o=00000000
    i1=00000000,i2=00101101,o=00000000
    i1=00000000,i2=00101110,o=00000000
    i1=00000000,i2=00101111,o=00000000
    i1=00000000,i2=00110000,o=00000000
    i1=00000000,i2=00110001,o=00000000
    i1=00000000,i2=00110010,o=00000000
    i1=00000000,i2=00110011,o=00000000
    i1=00000000,i2=00110100,o=00000000
    i1=00000000,i2=00110101,o=
- code: |-
    module tst_wand1; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    init i1<=0; init i2<=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial $stop; // Added stop
    endmodule
    ### Output:
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0,o=0
    i1=0,i2=0
- code: "module tst_xnorr1; //testbench\nreg i1,i2;\nwire o; // Added wire declaration\n\
    xnorr1 xx(i1,i2,o);\ninitial\nbegin\ni1=1; i2=1; // Drv1=high, Drv2=high -> o\
    \ = low (xnor rule)\nend\ninitial $monitor($time,\"i1=%b,i2=%b,o=%b\",i1,i2,o);\n\
    initial #8 $stop; // Added stop\nendmodule\n### Test:\ni1 = 1111b\ni2 = 1111b\n\
    o  = 0000b\n\n# 3.0. How to generate this code?\n\nThe following are two examples\
    \ in Python to generate this document from a table of test patterns.\n\n## 3.1.\
    \ Generate all the variations of a single test pattern\n\nThe following script\
    \ generates all the variations for one test pattern i.e. a Verilog module for\
    \ testing the behaviour of an arithmetic operator using several test drivers.\n\
    \n## 3.2. Generate all the variations for each of the test pattern\n\nThe following\
    \ script generates all the variations for each of the test patterns. The output\
    \ will be placed into separate Verilog modules.\n\n# 4.0. Known Issues and Limitations\n\
    \n\u2022 The script will probably fail to create a Verilog module for a test pattern\
    \ if it contains any of the following:\n1. Any verbatim literals (i.e. \"0\",\
    \ \"1\", \"x\", \"X\", \"...\")\n2. Verilog keywords (i.e. \"function\", \"module\"\
    , \"output\", \"reg"
- code: |-
    module tst_xnor2; //testbench
    reg [1:0] i1,i2;
    wire [1:0] o;    // Added wire declaration
    xnor1 xx(i1,i2,o);
    initial
    begin
    i1=2'b10; // Drv1=11, Drv2=01 -> o = 01 (xnor rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
    ### Observation:
    The modified testbench correctly demonstrates that when i1 is set to 2'b10 (all 1's), and i2 is set to 2'b01 (all 0's but 1 bit), the output is 2'b01 (bit 5), which is the xnor rule.

    ### Summary

    In this example, we discussed synthesis of a design with a control bit. The same technique could be used to optimize a design as well.

    If you are interested in this and other topics related to the AMS ECO System, then you are welcome to subscribe to our newsletter at https://ams-eco.us19.list-manage.com/Subscribe?u=0b5a51455c8b01329f47d0c0b&id=34e73b1e67. In the coming months, we will be covering additional material on how to use the AMS ECO System to synthesize, optimize, and implement a design.

    ## 14.8. Example 9 - Wand and Xnor to FlipFlop

    In this example, we will synthesize a simple flipflop circuit using the wand and xnor gates. The original circuit can be found in Figure 13-1.

    Figure 13-1: Original Flipflop Circuit

    The circuit in Figure 13-1 is implemented in Verilog and can be divided into 4 parts as shown in Figure 13-2. The DFF in the middle (top) is clocked by the AND gate (gate 1) and the OR gate (gate 2) as shown in Figure 13-3. The DFF in the middle (bottom) is clocked by the AND gate (gate 3) and the OR gate (gate 4) as shown in Figure 13-4.

    Figure 13-2: Implementation of Flipflop in Verilog

    Figure 13-3: Clocked Flipflop 1

    Figure 13-4: Clocked Flipflop 2

    In this example, we will synthesize and implement these flipflops using the wand and xnor gates. The modified circuit can be found in Figures 13-5 and 13-6.

    Figure 13-5: Modified Flipflop 1

    Figure 13-6: Modified Flipflop 2

    ### Task 1: Create a Verilog module called mydff

    Create a Verilog module called mydff. The inputs are in, reset, and clk. The output is out. The clk and reset signals are both active-low.

    ### Task 2: The output should be the same as the base flipflop

    The output of the flipflop should be the same as the base flipflop.

    ### Task 3: The flipflops should be clocked by the same gates

    The flipflops should be clocked by the same gates.

    ### Task 4: The flipflop should be clocked by the same signal

    The flipflop should be clocked by the same signal.

    ### Task 5: The flipflop should be clocked by the same signal

    The flipflop should be clocked by the same signal.

    ### Task 6: The flipflop should be clocked by the same signal
- code: |-
    module tst_nand1; //testbench
    reg i1,i2;
    wire o; // Added
- code: |-
    module tst_wand1; //testbench
    reg i1,i2;
    wire o;
    wand1 ww(i1,i2,o);
    wire [3:0] tmp; // added tmp
    initial
    begin
    i1=0; i2=0;
    tmp=~i1; // Drv1=pull0, Drv2=pull0 -> o = pull0 (wand rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,tmp[1:0]); // Changed to tmp[1:0]
    initial $stop;
    endmodule

    And the output:

    i1=0000 i2=0000 o=00
    i1=0000 i2=0001 o=01
    i1=0000 i2=0010 o=10
    i1=0000 i2=0011 o=11
    i1=0000 i2=0100 o=10
    i1=0000 i2=0101 o=11
    i1=0000 i2=0110 o=11
    i1=0000 i2=0111 o=11
    i1=0000 i2=1000 o=00
    i1=0000 i2=1001 o=01
    i1=0000 i2=1010 o=01
    i1=0000 i2=1011 o=01
    i1=0000 i2=1100 o=01
    i1=0000 i2=1101 o=01
    i1=0000 i2=1110 o=01
    i1=0000 i2=1111 o=01
    i1=0001 i2=0000 o=00
    i1=0001 i2=0001 o=00
    i1=0001 i2=0010 o=00
    i1=0001 i2=0011 o=01
    i1=0001 i2=0100 o=10
    i1=0001 i2=0101 o=11
    i1=0001 i2=0110 o=11
    i1=0001 i2=0111 o=11
    i1=0001 i2=1000 o=10
    i1=0001 i2=1001 o=11
    i1=0001 i2=1010 o=11
    i1=0001 i2=1011 o=11
    i1=0001 i2=1100 o=11
    i1=0001 i2=1101 o=11
    i1=0001 i2=1110 o=11
    i1=0001 i2=1111 o=11
    i1=0010 i2=0000 o=00
    i1=0010 i2=0001 o=00
    i1=0010 i2=0010 o=00
    i1=0010 i2=0011 o=01
    i1=0010 i2=0100 o=10
    i1=0010 i2=0101 o=11
    i1=0010 i2=0110 o=11
    i1=0010 i2=0111 o=11
    i1=0010 i2=1000 o=10
    i1=0010 i2=1001 o=11
    i1=0010 i2=1010 o=11
    i1=0010 i2=1011 o=11
    i1=0010 i2=1100 o=11
    i1=0010 i2=1101 o=11
    i1=0010 i2=1110 o=11
    i1=0010 i2=1111 o=11
    i1=0011 i2=0000 o=00
    i1=0011 i2=0001 o=00
    i1=0011 i2=0010 o=00
    i1=0011 i2=0011 o=01
    i1=0011 i2=0100 o=10
    i1=0011 i2=0101 o=11
    i1=0011 i2=0110 o=11
    i1=0011 i2=0111 o=11
    i1=0011 i2=1000 o=10
    i1=0011 i2=1001 o=11
    i1=0011 i2=1010 o=11
    i1=0011 i2=1011 o=11
    i1=0011 i2=1100 o=11
    i1=0011 i2=1101 o=11
    i1=0011 i2=1110 o=11
    i1=0011 i2=1111 o=11
    i1=0100 i2=0000 o=00
    i1=0100 i2=0001 o=00
    i1=0100 i2=0010 o=00
    i1=0100 i2=0011 o=01
    i1=0100 i2=0100 o=10
    i1=0100 i2=0101 o=11
    i1=0100 i2=0110 o=11
    i1=0100 i2=0111 o=11
    i1=0100 i2=1000 o=10
    i1=0100 i2=1001 o=11
    i1=0100 i2=1010 o=11
    i1=0100 i2=1011 o=11
    i1=0100 i2=1100 o=11
    i1=0100 i2=1101 o=11
    i1=0100 i2=1110 o=11
    i1=0100 i2=1111 o=11
    i1=0101 i2=0000 o=00
    i1=0101 i2=0001 o=00
    i1=0101 i2=0010 o=00
    i1=0101 i2=0011 o=01
    i1=0101 i2=0100 o=10
    i1=0101 i2=0101 o=11
    i1=0101 i2=0110 o=11
    i1=0101 i2=0111 o=11
    i1=0101 i2=1000 o=10
    i1=0101 i2=1001 o=11
    i1=0101 i2=1010 o=11
    i1=0101 i2=1011 o=11
    i1=0101 i2=1100 o=11
    i1=0101 i2=1101 o=11
    i1=0101 i2=1110 o=11
    i1=0101 i2=1111 o=11
    i1=0110 i2=0000 o=00
    i1=0110 i2=0001 o=00
    i1=0110 i2=0010 o=00
    i1=0110 i2=0011
- code: |-
    module tst_nor2; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    nor2 nr(i1,i2,o);
    initial
    begin
      i1=0; i2=1; // Drv1=pull0, Drv2=pull1 -> o = pull1 (nor rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
    ### Generated Code:
    module tst_nor2; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    nor2 nr(i1,i2,o);
    initial
    begin
    i1=0; i2=1; // Drv1=pull0, Drv2=pull1 -> o = pull1 (nor rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
    initial #8 $stop; // Added stop
    endmodule
    ## Testbench File:
    ### Base Verilog Code:
    module tst_or1; //testbench
    reg i1,i2;
    wire o; // Added wire declaration
    or1 or(i1,i2,o);
    initial
    begin
    i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (or rule)
    end
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o);
- code: "module mux21b (\ninput wire a,\ninput wire b,\ninput wire s,\noutput reg\
    \ y // Output must be reg for procedural assignment\n);\nalways @(*) // Combinational\
    \ sensitivity\ncase (s)\n0: y = a; // Select a if s=0\n1: y = b; // Select b if\
    \ s=1\ndefault: y = b; // Select b if s=1\nendcase\nendmodule\n\n[1],,,, and.\
    \ \u201CRestructuring Large-Scale Chip Architectures.\u201D In Proceedings of\
    \ the 44th Annual Design Automation Conference, 65\u201374. New York, NY, USA:\
    \ San Diego, CA, USA: ACM, 2007."
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case(s)
    1'b0: y = a;
    1'b1: y = b;
    default: y = a;
    endcase
    endmodule
    ### Verilog-Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [1:0] i;
    assign y = a;
    for (i=0; i < 2; i=i+1) begin
    assign y = (s == i)? y := b;
    end
    endmodule
    ### Verilog-Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [1:0] i;
    assign y = a;
    for (i=0; i < 2; i=i+1) begin
    assign y = (s == i)? y := b;
    end
    endmodule
    ### Verilog-Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y
    );
    reg [1:0] i;
    assign y = a;
    for (i=0; i < 2; i=i+1) begin
    assign y = (s == i)? y := b;
    end
    endmodule

    # 1.502 - Array of Muxes

    ## Question 1

    An array of muxes is a common problem in VLSI design. The goal of this question is to implement a primitive array of muxes. Consider the following Verilog code:

    module mux4_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    The above module takes as input three wires. The first input wire is called s, which is used to select the input source that is to be used to compute y. The second input wire, i, is used to compute y when s is 0. When s is 1, j is used to compute y.

    Consider a 4-by-4 array of multiplexers with individual control signals, s[1:0], i[1:0], and j[1:0] as shown in Figure 1. The array of muxes is connected to the wire bus y. The input wire for each of the individual muxes is s, i, and j, respectively.

    The inputs s[1:0], i[1:0], and j[1:0] are 2-bit wires, which are indexed by the array of muxes. The inputs to the array of muxes, as well as the output of the array of muxes, are 1-bit wires. The output y is 1-bit as well as the inputs to each of the individual muxes.

    How many multiplexers are needed in the array of muxes?

    ## Answer 1

    ### Solution

    ### Base Verilog Code:
    module mux4_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux4_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux4_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ## Question 2

    In the previous question, we considered a simple implementation of a 4-by-4 mux array using a 2-bit selector. Let us now explore the problem of implementing a 4-by-4 mux array with an arbitrary selector.

    Consider a 4-by-4 mux array with a selector s[3:0] that is indexed by the array of muxes.

    The inputs to the array of muxes, as well as the output of the array of muxes, are 1-bit wires. The output y is 1-bit as well as the inputs to each of the individual muxes.

    The inputs s[3:0], i[1:0], and j[1:0] are 4-bit wires, which are indexed by the array of muxes.

    ### 2.1

    How many multiplexers are needed in the array of muxes?

    ### Solution

    ### Base Verilog Code:
    module mux8_1b (
    input [3:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux8_1b (
    input [3:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux8_1b (
    input [3:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux8_1b (
    input [3:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ## Question 3

    Consider a 3-by-2 mux array with a selector s[2:0] that is indexed by the muxes within the array.

    The inputs to the mux array, as well as the output of the mux array are 1-bit wires. The output y is 1-bit as well as the inputs to each of the individual muxes.

    The inputs s[2:0], i[1:0], and j[1:0] are 3-bit wires, which are indexed by the individual muxes within the array.

    ### 3.1

    How many multiplexers are needed in the array of muxes?

    ### Solution

    ### Base Verilog Code:
    module mux6_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux6_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux6_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ### Solution

    ### Base Verilog Code:
    module mux6_1b (
    input [2:0] s,
    input [1:0] i,
    input [1:0] j,
    output reg y
    );
    assign y = i;
    if (s == 1) assign y = j;
    endmodule

    ## Question 4

    Consider a 2-by-4 mux array with a selector s[1:0] that is indexed by the muxes within the array.

    The inputs to the mux array, as well as the output of the mux array are 1-bit wires. The output y is 1-bit as well as the inputs to each of the individual muxes.

    The inputs s[1:0], i[1:0], and j[1:0] are 2-bit wires, which are indexed by the individual muxes within the array.

    ### 4.1

    How
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    ); // Packed 2D array

    wire [1:0] sel = {b:a}; // Packed 2D array

    always @(*) // Combinational sensitivity
    y = sel[s]; // Select a if s=0 else b if s=1
    endmodule

    ### Procedural Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    ); // Packed 2D array

    wire [1:0] sel = {b:a}; // Packed 2D array

    always @(*) // Combinational sensitivity
    case (s) // Priority case structure
    0: y = a;
    1: y = b;
    endcase

    endmodule

    ### End Statement:
    endmodule
    ```
- code: |-
    module adder4(
    input wire a,
    input wire b,
    input wire ci,
    input
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*)
    if(s == 0)
    y = a; // Select a if s=0
    else if (s == 1)
    y = b;// Select b if s=1
    else
    y = a;// select a as the default value
    endmodule
    `
- code: "module mux21b (\ninput wire a,\ninput wire b,\ninput wire s,\noutput reg\
    \ y // Output must be reg for procedural assignment\n);\nalways @(*) // Combinational\
    \ sensitivity\ncase(s)\n0: y = a; // Select a if s=0\n1: y = b; // Select b if\
    \ s=1\nendcase\nendmodule\n### Results:\n1. \nThe simulation tool was used to\
    \ generate a waveform on the output port of a 32x32 21mux. The outputs of the\
    \ 21mux is set to 0 and 1.\n2. \nThe simulation tool was used to generate a waveform\
    \ on the output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and\
    \ 1 along with the address line of the 21mux of course being 3 in both cases.\n\
    3. \nThe simulation tool was used to generate a waveform on the output port of\
    \ a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along with the address\
    \ line of the 21mux of course being 3 in both cases.\n4. \nThe simulation tool\
    \ was used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n5. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n6. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n7. \nThe\
    \ simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n8. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n9. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n10. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n11. \n\
    The simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n12. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n13. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n14. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n15. \n\
    The simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n16. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n17. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n18. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n19. \n\
    The simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n20. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n21. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n22. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n23. \n\
    The simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n24. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n25. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the 21mux of course being 3 in\
    \ both cases.\n26. \nThe simulation tool was used to generate a waveform on the\
    \ output port of a 32x32 21mux. The outputs of the 21mux are set to 0 and 1 along\
    \ with the address line of the 21mux of course being 3 in both cases.\n27. \n\
    The simulation tool was used to generate a waveform on the output port of a 32x32\
    \ 21mux. The outputs of the 21mux are set to 0 and 1 along with the address line\
    \ of the 21mux of course being 3 in both cases.\n28. \nThe simulation tool was\
    \ used to generate a waveform on the output port of a 32x32 21mux. The outputs\
    \ of the 21mux are set to 0 and 1 along with the address line of the 21mux of\
    \ course being 3 in both cases.\n29. \nThe simulation tool was used to generate\
    \ a waveform on the output port of a 32x32 21mux. The outputs of the 21mux are\
    \ set to 0 and 1 along with the address line of the"
- code: "module mux221b (\ninput wire a,\ninput wire b,\ninput wire s,\noutput reg\
    \ y // Output must be reg for procedural assignment\n);\nalways @(*)\ncase(s)\n\
    1'b0 : y = a; // Select a if s=0\n1'b1 : y = b; // Select b if s=1\n2'b00 : y\
    \ = a; // Select a if s=2\n2'b01 : y = a; // Select a if s=2\n2'b10 : y = b; //\
    \ Select b if s=3\n2'b11 : y = b; // Select b if s=3\nendcase\nendalways\nendmodule\n\
    \n#### Combinational Module Example:\n\nmodule modulename (\ninput wire a,\ninput\
    \ wire b,\noutput reg y // Output must be reg for procedural assignment\n);\n\
    assign y = a + b;\nendmodule\n\n\u2022 The above code will make the value of y\
    \ the sum of the value of a and the value of b i.e. the value of y = a + b\n\u2022\
    \ The code will run everytime one of the inputs changes.\n\u2022 The above code\
    \ will make the value of y the sum of the value of a and the value of b i.e. the\
    \ value of y = a + b\n\u2022 The code will run everytime one of the inputs changes.\n\
    ##### Verilog Code with Comment:\nmodule mux221b (\ninput wire a,\ninput wire\
    \ b,\ninput wire s,\noutput reg y // Output must be reg for procedural assignment\n\
    );\nassign y = a + b;\nendmodule\n\n## 2. The Mux222b Module\n\n### Module 1:\n\
    \nmodule mux12 (\ninput wire a,\ninput wire b,\ninput wire s,\noutput reg y\n\
    );\n\nalways @ (posedge s)\nif (s)\ny = a;\nelse\ny = b;\n\nendmodule\n\n### Base\
    \ Verilog Code:\n\nmodule mux222b (\ninput wire a,\ninput wire b,\ninput wire\
    \ s,\noutput reg y // Output must be reg for procedural assignment\n);\nalways\
    \ @(*)\ncase(s)\n1'b0 : y = a;\n1'b1 : y = b;\n2'b00 : y = a;\n2'b01 : y = b;\n\
    2'b10 : y = a;\n2'b11 : y = b;\nendcase\nendalways\nendmodule\n\n\u2022 s is an\
    \ input to the module and it has three options\n\n\u2022 If it is 0 then the value\
    \ of y will be the value of a.\n\u2022 If it is 1 then the value of y will be\
    \ the value of b.\n\u2022 If it is 2 then the value of y will be the value of\
    \ a.\n\n#### Combinational Module Example:\n\nmodule modulename (\ninput wire\
    \ a,\ninput wire b,\noutput reg y // Output must be reg for procedural assignment\n\
    );\nassign y = a + b;\nendmodule\n\n\u2022 The above code will make the value\
    \ of y the sum of the value of a and the value of b i.e. the value of y = a +\
    \ b\n\u2022 The code will run everytime one of the inputs changes.\n\u2022 The\
    \ above code will make the value of y"
- code: |-
    module mux21b (
    input [1:0] sel,
    input [7:0] a,
    input [7:0] b,
    input [7:0] c,
    input [7:0] d,
    output reg [7:0] y
    );
    always @(*)
    case(sel)
    4'b0000: y = a;
    4'b0001: y = b;
    4'b0010: y = c;
    4'b0011: y = d;
    default: y = 4'b0000;
    endcase
    endmodule
    ```

    Example 9
    ----------

    ```
    ### Base Verilog Code:
    module mux21b (
    input wire a,
    input wire b,
    input wire c,
    input wire d,
    input wire s,
    output reg y
    );
    always @(*):
    if (s == 0) y = a;
    else if (s == 1) y = b;
    else if (s == 2) y = c;
    else if (s == 3) y = d;
    endmodule
    ### Variation Instruction:
    Add a priority case
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    0
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*)
    case (s)
    0 : y = a;
    1 : y = b;
    default: y = 0;
    endcase
    endmodule
    ### Simulation Results (a,b,s):
    a b s y
    00000000000000000000 0 0000000 00000 0000000 0000000
    00000000000000000001 1 0000000 00000 0000000 0000000
    00000000000000000010 0 0000001 00001 0000000 0000000
    00000000000000000011 1 0000001 00001 0000001 0000000
    00000000000000000100 0 0000010 00010 0000000 0000000
    00000000000000000101 1 0000010 00010 0000011 0000000
    00000000000000000110 0 0000011 00011 0000000 0000000
    00000000000000000111 1 0000011 00011 0000110 0000000
    00000000000000001000 0 0000100 00100 0000000 0000000
    00000000000000001001 1 0000100 00100 0000100 0000000
    00000000000000001010 0 0000101 00101 0000000 0000000
    00000000000000001011 1 0000101 00101 0000101 0000000
    00000000000000001100 0 0000110 00110 0000000 0000000
    00000000000000001101 1 0000110 00110 0000110 0000000
    00000000000000001110 0 0000111 00111 0000000 0000000
    00000000000000001111 1 0000111 00111 0000111 0000000
    00000000000000010000 0 0001000 01000 0000000 0000000
    00000000000000010001 1 0001000 01000 0000100 0000000
    00000000000000010010 0 0001001 01001 0000000 0000000
    00000000000000010011 1 0001001 01001 0000101 0000000
    00000000000000010100 0 0001010 01010 0000000 0000000
    00000000000000010101 1 0001010 01010 0000110 0000000
    00000000000000010110 0 0001011 01011 0000000 0000000
    00000000000000010111 1 0001011 01011 0000111 0000000
    00000000000000011000 0 0001100 01100 0000000 0000000
    00000000000000011001 1 0001100 01100 0000100 0000000
    00000000000000011010 0 0001101 01101 0000000 0000000
    00000000000000011011 1 0001101 01101 0000101 0000000
    00000000000000011100 0 0001110 01110 0000000 0000000
    00000000000000011101 1 0001110 01110 0000110 0000000
    00000000000000011110 0 0001111 01111 0000000 0000000
    00000000000000011111 1 0001111 01111 0000111 0000000
    00000000000000100000 0 0010000 10000 0000000 0000000
    00000000000000100001 1 0010000 10000 0000100 0000000
    00000000000000100010 0 0010001 10001 0000000 0000000
    00000000000000100011 1 0010001 10001 0000101 0000000
    00000000000000100100 0 0010010 10010 0000000 00000
- code: "`timescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode,\
    \ output [7:0] ALUout);\nalways_comb begin\n    case (mode)\n        0: ALUout\
    \ = left + right;\n        1: ALUout = left - right;\n        2: ALUout = left\
    \ & right;\n        3: ALUout = left | right;\n        default: ALUout = 8'bX;\n\
    \    endcase\n    ALUout = ALUout[7:0];\nend\nendmodule\n`\n<br/>\n### Differences:\n\
    1. The result of `ALUout` is now an 8-bit variable as expected by the design.\n\
    2. The `==` operator between the 8-bit variable and 8-bits `right` operand has\
    \ been removed.\n3. The `ALUout` variable is a 8-bit variable.\n4. The part-select\
    \ operator is used to get the 8-bits of result and assign it to `ALUout` variable.\n\
    5. This version works fine.\n<br/>\n<br/>\n\n### References:\n[1],. \"Computer\
    \ Organization and Design: The Hardware/Software Interface. 9th Ed. New York:\
    \ Wiley, 2006.\"\n/L02_D_MUX8/readme.md\n# 2-output D-Type Multiplexer\n\n## Problem\
    \ Statement\nDevelop a two-output D-type multiplexer that multiplies its inputs,\
    \ and uses the 4-to-1 multiplexer as its component.\n\nAn a.\n```\n`timescale\
    \ 1ns/100ps\nmodule MUX4_8 (input [3:0] I, input [1:0] S, output [3:0] O);\nassign\
    \ O = I[3:0] * 4'bX[3:S];\nendmodule\n```\nThis code is the exact same with previous\
    \ question, but uses S in the D-Type Multiplexer.\n\n## 2-output D-Type Multiplexer\n\
    This is the main question, which was provided in the lab handout.\n```\n`timescale\
    \ 1ns/100ps\nmodule MUX8 (input [7:0] I, input [3:0] S, output reg [7:0] O);\n\
    reg [3:0] OH, OL;\nMUX4_8 M1 (I[3:0], S[1:0], OH);\nMUX4_8 M2 (I[7:4], S[1:0],\
    \ OL);\nalways @* begin\n    O = {OH, OL};\nend\nendmodule\n```\nexample of a\
    \ D-type multiplexer is shown in Fig. 3.12.\n\nThe D-type multiplexer has four\
    \ inputs: two multiplicand inputs, \U0001D4460, and \U0001D4461, which are connected\
    \ to the select line, and two inputs, \U0001D4490, and \U0001D4491, which are\
    \ connected to the data line. The output of the D-type multiplexer, Y, is determined\
    \ by the value of \U0001D446, which has two possible values, 0 and 1.\n\nWhen\
    \ the select input, \U0001D446, is 0, the data inputs, \U0001D4490, and \U0001D449\
    1, are connected to the output. When \U0001D446 is 1, the data inputs are connected\
    \ to the output.\n\n![alt text](DType_Multiplexer.png \"Mux Diagram\")\n\n## 4-to-1\
    \ Multiplexer\nThe 4-to-1 multiplexer was provided to us in the start of the lab\
    \ exercise, so I will not add any additional code. The code is given below:\n\
    ```\n`timescale 1ns/100ps\nmodule MUX4_1 (input [3:0] I, input S, output O);\n\
    assign O = S? I[1] : I[0];\nendmodule\n```\nThe code above will return the first\
    \ input when the select input is high, the second input when the select input\
    \ is low. We can get the value of the first input as\n`MUX4_1 M1 (I[3:0], S[0],\
    \ O[0]);`\nand the value of the second input as\n`MUX4_1 M2 (I[3:0], S[0], O[1]);`\n\
    \n## 4-to-8 Multiplexer\nNext, we add another module called `MUX4_8` to create\
    \ a 4-to-8 multiplexor. We need the same four inputs as in the previous module.\
    \ The only difference is the output, which needs to be re-indexed so that we can\
    \ get the values for the first 4 outputs. We also need to use the `==` operator\
    \ to return the correct value of the select input.\n\nSince the multiplexor is\
    \ a D-Type multiplexer, the code for the multiplexor is as below.\n```\n`timescale\
    \ 1ns/100ps\nmodule MUX4_8 (input [3:0] I, input [1:0] S, output reg [7:0] O);\n\
    reg [3:0] OH, OL;\nMUX4_1 M1 (I[3:0], S, OH);\nMUX4_1 M2 (I[3:0],!S, OL);\nalways\
    \ @* begin\n    O = OH[1:0]!= OL[1:0]? OH!= 4'b1111 : OH[1:0];\nend\nendmodule\n\
    ```\nThe code above will return the first input when the select input is high\
    \ (1), the second input when the select input is low (0), and the third input\
    \ as 1111 when the select input is high and low.\n\n## 4-to-32 Multiplexer\nFinally,\
    \ we add another module called `MUX4_32` to create a 4-to-32 multiplexor. We need\
    \ the same four inputs as in the previous 2 modules. The only difference is the\
    \ output, which needs to be re-indexed so that we can get the values for the first\
    \ 32 outputs. The only difference is the output, which needs to be re-indexed\
    \ so that we can get the values for the first 32 outputs. We also need to use\
    \ the `==` operator to return the correct value of the select input.\n```\n`timescale\
    \ 1ns/100ps\nmodule MUX4_32 (input [3:0] I, input [4:0] S, output [31:0] O);\n\
    reg [3:0] OH, OL, OM;\nMUX4_8 M1 (I[3:0], S[3:0], OH);\nMUX4_8 M2 (I[3:0], S[4:3],\
    \ OL);\nMUX4_1 M3 (I[3:0], OH[1:0] == OL[1:0]? OH[0] : OH[1], OM);\nalways @*\
    \ begin\n    O = {OM[0], OH[0] == OL[0]? OL[1:0] : OH[0], OH[1:0] == OL[1:0]?\
    \ OL[0] : OH[1], OL[1:0]};\nend\nendmodule\n```\nThe code above will return the\
    \ first input when the select input is high (1), the second input when the select\
    \ input is low (0), and the third input as 1111 when the select input is high\
    \ and low.\n\n## Verilog Code\n```\n`timescale 1ns/100ps\nmodule ALU8 (input [7:0]\
    \ left, right, input [1:0] mode, output reg [7:0] ALUout);\nreg [31:0] ALUout;\n\
    MUX4_32 M1 (left, mode, ALUout);\nendmodule\n```\nThis code requires the additional\
    \ module.\n```\n`timescale 1ns/100ps\nmodule MUX4_8 (input [3:0] I, input [1:0]\
    \ S, output reg [7:0] O);\nreg [3:0] OH, OL;\nMUX4_1 M1 (I[3:0], S, OH);\nMUX4_1\
    \ M2 (I[3:0],!S, OL);\nalways @* begin\n    O = OH[1:0]!= OL[1:0]? OH!= 4'b1111\
    \ : OH[1:0];\nend\nendmodule\n```\nThis code is the exact same with the previous\
    \ code, but it uses the `==` operator to return the correct result.\n```\n`timescale\
    \ 1ns/100ps\nmodule MUX4_1 (input [3:0] I, input S, output O);\nassign"
- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        #3 ALUout = left[7:0] + right[7:0];
    end
    endmodule
    ### Output:
    No results for now.
    ### Issue:
    I assume this is due to the synthesis tool not recognizing the part-select as valid.

    I'm really not sure why this doesn't work, but I'll open a discussion on the Youtube channel for discussion. I'm assuming it will be a "tooling" issue and the tool (Aldec) should be able to handle it.

    The same problem may occur with some array concatentation instructions.
    /_posts/2023-05-26-fucking-electronics-sucks.md
    ---
    title: "Fucking Electronics Sucks"
    date: 2023-05-26 11:00:00
    description: "How can I write a new C program for my CPU if I can't design a new CPU? Isn't this all over the internet and everywhere?"
    category: tech
    ---

    {% youtube c_200px.gif %}

    I can't write a new CPU program in C because I can't synthesize a new CPU? Why do I have to do that if I can't write a new CPU?

    I don't have access to a FPGA. I can't use the OpenRISC or any other open source CPU. I can't use any of the CPU designs that are available. I can't run any of the CPUs I can buy.

    What the fuck is wrong with this shit?

    The CPU designs are all over the Internet and everywhere. What is the hell is going on?

    This is all over the Internet and everywhere.

    I don't have my heart in my CPU.

    I don't have the CPU design in my heart.

    I don't have my CPU design on my heart.

    I can't design a CPU.

    I can't do this shit.

    I can't design a CPU, I can't use an OpenRISC or any other open source CPU, I can't buy a CPU, I can't use my CPU design, I can't design a CPU.

    I just want to write C programs and run them on my CPU. I don't have access to any of the CPU designs that are available.

    There must be a way to do this better.

    I don't have to use FPGA. Why do I have to use FPGA?

    I don't have to use FPGA. Why do I have to use FPGA?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using FPGA for this?

    Why is everyone using
- code: "`module mux2x1 (input [1:0] sel, input [7:0] in0, output reg [7:0] out);\n\
    always_comb begin:\n    out = sel? in0 : 7'b0;\nend\nendmodule\n### Result:\n\
    ![Base Verilog Code](https://user-images.githubusercontent.com/61718956/114468470-b3124d00-9c0d-11eb-9766-58f09d175303.png)\n\
    \n![Modified Verilog Code](https://user-images.githubusercontent.com/61718956/114468486-b4de1080-9c0d-11eb-8434-c643044f8dd3.png)\n\
    \n![Result](https://user-images.githubusercontent.com/61718956/114468503-b7406a80-9c0d-11eb-887b-6c19f0c6c54b.png)\n\
    \n### Observation:\nSince the output is a register, so the out in the always_comb\
    \ block is a wire and the input is in the always_comb block.\n/Lab1/README.md\n\
    # Lab1\n# Lab1: Bitwise Operators.\n\n## Task 1:\n\n![Task 1](https://user-images.githubusercontent.com/61718956/114357158-f52f1f00-9b79-11eb-9fe2-0be72031a164.png)\n\
    \n### Observation:\n\nThis is a logical operator. In this task, an AND-gate and\
    \ an OR-gate are used as and-gate and or-gate respectively. So a logical operator\
    \ is the most suitable for these two gates.  \n\n![OR-gate](https://user-images.githubusercontent.com/61718956/114357247-23146380-9b7a-11eb-88f9-37d8b1e9d0d3.jpg)\n\
    ![AND-gate](https://user-images.githubusercontent.com/61718956/114357241-20197300-9b7a-11eb-86cc-ee208948ae45.jpg)\n\
    \n## Task 2:\n\n![Task 2](https://user-images.githubusercontent.com/61718956/114357312-46d7aa00-9b7a-11eb-8636-21770d669117.png)\n\
    \n### Observation:\n\nThis is a bitwise operator. In this task, an XOR-gate is\
    \ used as the bitwise operator. So a bitwise operator is suitable for this gate.\
    \  \n![XOR-gate](https://user-images.githubusercontent.com/61718956/114357550-9b8b2400-9b7a-11eb-9672-5147521424ed.jpg)\n\
    \n## Task 3:\n\n![Task 3](https://user-images.githubusercontent.com/61718956/114357585-ad055d80-9b7a-11eb-85cb-9e4368288295.png)\n\
    \n### Observation:\n\nThis is a bitwise operator. In this task, a NOT-gate is\
    \ used as the bitwise operator. So a bitwise operator is suitable for this gate.\
    \  \n![NOT-gate](https://user-images.githubusercontent.com/61718956/114357596-b1317b00-9b7a-11eb-9005-a51d079290d6.jpg)\n\
    \n## Task 4:\n\n![Task 4](https://user-images.githubusercontent.com/61718956/114357653-c7d7d200-9b7a-11eb-963d-98006f695346.png)\n\
    \n### Observation:\n\nThis is a bitwise operator. In this task, a NAND-gate is\
    \ used as the bitwise operator. So a bitwise operator is suitable for this gate.\
    \  \n![NAND-gate](https://user-images.githubusercontent.com/61718956/114357722-eb9b1800-9b7a-11eb-8e70-d76ff9e513dc.jpg)\n\
    \n## Task 5:\n\n![Task 5](https://user-images.githubusercontent.com/61718956/114357772-066d8c80-9b7b-11eb-816a-7434b1031307.png)\n\
    \n### Observation:\n\nThis is a bitwise operator. In this task, a NOR-gate is\
    \ used as the bitwise operator. So a bitwise operator is suitable for this gate.\
    \  \n![NOR-gate](https://user-images.githubusercontent.com/61718956/114357779-0b324080-9b7"
- code: "```\ntimescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0]\
    \ mode, output reg [7:0] ALUout);\nwire [7:0] ALU_result;\nalways_comb begin\n\
    \    case (mode)\n        0: ALUout = left + right;\n        1: ALUout = left\
    \ - right;\n        2: ALUout = left & right;\n        3: ALUout = left | right;\n\
    \        default: ALUout = 8'bX;\n    endcase\n\n    ALU_result = {right,left}[(mode==0)?0:1];\
    \ \nend\nendmodule\n```\n##### 2. How to synthesize the behavioral model using\
    \ Verilog HDL?\nTo synthesize the behavioral model, click on the Generate Symbol\
    \ Table button. Then, you can select to synthesize the code.\n##### 3. How to\
    \ show the resulting design and report in the GUI?\nTo show the resulting design,\
    \ click on the Design Explorer button. You can see the resulting design of the\
    \ design in the Design Explorer GUI.\n\n![1.PNG](img/1.PNG)\n\nTo show the report\
    \ of the design, click on the Report Explorer button. You can see the report of\
    \ the design in the Report Explorer.\n\n![2.PNG](img/2.PNG)\n\n### How to verify\
    \ the functional correctness of the design?\n#### 1. How to synthesize the behavioral\
    \ model using Verilog HDL?\nTo synthesize the behavioral model, click on the Generate\
    \ Symbol Table button. Then, you can select to synthesize the code.  \n\n####\
    \ 2. How to show the resulting design and report in the GUI?\nTo show the resulting\
    \ design, click on the Design Explorer button. You can see the resulting design\
    \ of the design in the Design Explorer GUI.\n\n![3.PNG](img/3.PNG)\n\nTo show\
    \ the report of the design, click on the Report Explorer button. You can see the\
    \ report of the design in the Report Explorer.\n\n![4.PNG](img/4.PNG)\n\n####\
    \ 3. How to use the Verification Assistant?\nTo use the Verification Assistant,\
    \ click on the Verification Assistant button. You can see the Verification Assistant\
    \ of the resulting design in the Verification Assistant GUI.\n\n![5.PNG](img/5.PNG)\n\
    \nTo open the Verification Assistant of the design, click on the Open Verification\
    \ Assistant button.\n\n![6.PNG](img/6.PNG)\n\nTo start and stop the Verification\
    \ Assistant, click on Start/Stop button. The design will be verified and the report\
    \ will be showed in the Verification results tab. The verification may take a\
    \ bit.\n\n![7.PNG](img/7.PNG)\n\n### How to find and design unit-level tests to\
    \ verify your behavioral models?\n#### 1. Introduction\nTo design test benches\
    \ for functional correctness of the design, we need to use the Behavioral Test\
    \ Library in the Verification Assistant.\n\n#### 2. How to design test benches?\n\
    To design test benches for functional correctness, select the Test Symbols tab\
    \ of the Verification Assistant, and click on the Test Bench Generator button.\n\
    \n![8.PNG](img/8.PNG)\n\nTo design test benches, click on the Design Test Benches\
    \ button. You can design test benches for functional correctness in the Test Symbols\
    \ tab.\n\n![9.PNG](img/9.PNG)\n\nTo generate test benches for functional correctness,\
    \ click on the Generate Test Bench button.\n\n![10.PNG](img/10.PNG)\n\nTo open\
    \ the Design Test Benches, click on the Open Test Bench button. Then, you can\
    \ see the Test Bench for functional correctness in the Design Test Benches tab.\n\
    \n![11.PNG](img/11.PNG)\n\n#### 3. How to run the test benches?\nTo run the test\
    \ benches for functional correctness, click on the Run Tests button. Then, you\
    \ can run the test benches for functional correctness. You can see the test results\
    \ for the design in the Test Results tab.\n\n![12.PNG](img/12.PNG)\n\n### How\
    \ to find and design model-level tests to verify your behavioral models?\n####\
    \ 1. Introduction\nAn example for model-level test is shown below. To design test\
    \ benches for behavioral models, we need to use the Behavioral Test Library in\
    \ the Verification Assistant.\n\n![13.PNG](img/13.PNG)\n\n#### 2. How to design\
    \ test benches?\nTo design test benches for behavioral models, select the Test\
    \ Symbols tab of the Verification Assistant, and click on the Test Bench Generator\
    \ button.\n\n![14.PNG](img/14.PNG)\n\nTo design test benches for behavioral models,\
    \ click on the Design Test Benches button. You can design test benches for behavioral\
    \ models in the Test Symbols tab.\n\n![15.PNG](img/15.PNG)\n\nTo generate test\
    \ benches for behavioral models, click on the Generate Test Bench button.\n\n\
    ![16.PNG](img/16.PNG)\n\nTo open the Design Test Benches, click on the Open Test\
    \ Bench button. Then, you can see the Test Bench for behavioral models in the\
    \ Design Test Benches tab.\n\n![17.PNG](img/17.PNG)\n\n#### 3. How to run the\
    \ test benches?\nTo run the test benches for behavioral models, click on the Run\
    \ Tests button. Then, you can run the test benches for behavioral models. You\
    \ can see the test results for the design in the Test Results tab.\n\n![18.PNG](img/18.PNG)\n\
    \n/Lab4/README.md\n# Lab 4\n\n##### Student Name: \n##### Student ID: 151160003\n\
    \n# 1. The Results\n\n#### Verilog code for the circuit:\n\n```verilog\nmodule\
    \ ALU8 (\n    input [7:0] left,\n    input [7:0] right,\n    input [1:0] mode,\n\
    \    output [7:0] ALUout\n);\nwire [7:0] ALU_result;\nalways_comb begin\n    case\
    \ (mode)\n        0: ALUout = left + right;\n        1: ALUout = left - right;\n\
    \        2: ALUout = left & right;\n        3: ALUout = left | right;\n      \
    \  default: ALUout = 8'bX;\n    endcase\n\n    ALU_result = {right,left}[(mode==0)?0:1];\n\
    end\nendmodule\n```\n\n#### Simulation Results:\n\n![1.PNG](img/1.PNG)\n![2.PNG](img/2.PNG)\n\
    \n# 2. The Verification\n\n#### 1. How to find and design unit-level tests to\
    \ verify your behavioral models?\n\nTo design test benches for functional correctness,\
    \ select the Test Symbols tab of the Verification Assistant, and click on the\
    \ Test Bench Generator button.\n\n![1.PNG](img/1.PNG)\n\nTo design test benches,\
    \ click on the Design Test Benches button. You can design test benches for functional\
    \ correctness in the Test Symbols tab.\n\n![2.PNG](img/2.PNG)\n\nTo generate test\
    \ benches for functional correctness, click on the Generate Test Bench button.\n\
    \n![3.PNG](img/3.PNG)\n\nTo open the Design Test Benches, click on the Open Test\
    \ Bench button. Then, you can see the Test Bench for functional correctness in\
    \ the Design Test Benches tab.\n\n![4.PNG](img/4.PNG)\n\n#### 2. How to run the\
    \ test benches?\n\nTo run the test benches for functional correctness, click on\
    \ the Run Tests button. Then, you can run the test benches for functional correctness.\
    \ You can see the test results for the design in the Test Results tab.\n\n![5.PNG](img/5.PNG)\n\
    \n#### 3. Did the test benches work as expected?\n\nYes, the test benches work\
    \ as expected. All test results pass the simulation test.\n\n![6.PNG](img/6.PNG)\n\
    \n#### 4. How to find and design model-level tests to verify your behavioral models?\n\
    \nAn example for model-level test is shown below. To design test benches for behavioral\
    \ models, we need to use the Behavioral Test Library in the Verification Assistant.\n\
    \n![7.PNG](img/7.PNG)\n\n#### 4. How to design test benches?\n\nTo design test\
    \ benches for behavioral models, select the Test Symbols tab of the Verification\
    \ Assistant, and click on the Test Bench Generator button.\n\n![8.PNG](img/8.PNG)\n\
    \nTo design test benches for behavioral models, click on the Design Test Benches\
    \ button. You can design test benches for behavioral models in the"
- code: |-
    `module Test_multiplier (output reg [7:0] multiplier_test);
    input [7:0] multiplier_data;

    multiplier u_multiplier (multiplier_data, multiplier_out);
    assign multiplier_test = multiplier_result;
    endmodule`

    `module Test_multiplier (output reg [7:0] multiplier_test);
    input [7:0] multiplier_data;

    reg [7:0] multiplier_result;
    multiplier u_multiplier (multiplier_data, multiplier_result);
    assign multiplier_test = multiplier_result;
    endmodule`

    ### Results:
    `module Test_multiplier (output reg [7:0] multiplier_test);
    input [7:0] multiplier_data;

    reg [7:0] multiplier_result;
    multiplier u_multiplier (multiplier_data, multiplier_result);
    assign multiplier_test = multiplier_result;
    endmodule`

    ### Timed Simulation:
    https://www.dropbox.com/s/z12t1u4u31545k1/test%20case%201.vcd?dl=0
    ### Gate Level Simulation:
    ![Alt text](/media/image5.png?raw=true "Gate Level Simulation")

    ## VHDL Code
    https://github.com/h0011100/vhdl-testbenches/blob/master/test_bench_multiplier/test_bench_multiplier.vhd

    ## Result of Simulation:
    ![Alt text](/media/image8.png?raw=true "Result of Simulation")
    /README.md
    # VHDL-Testbenches
    This repository includes a description of VHDL testbenches, their verification steps and simulation results.

    ## Test benches
    1. Test bench of ALU
    2. Test bench of multiplier
    3. Test bench in a Verilog implementation of a multiplier circuit.

    ## Verilog
    1. Verilog code for a Verilog implementation of a ALU circuit.
    2. Verilog code for a Verilog implementation of a multiplier circuit.
    3. Verilog code for a Verilog implementation of a multiplier circuit (in a procedural assignment inside an always_comb block).
    4. Verilog code for a Verilog implementation of a multiplier circuit (in a procedural assignment inside an always_comb block with part-select array operand).

    ## VHDL
    1. VHDL code
- code: |-
    `module control_branch (
        input  [15:0] opcode,
        input  [4:0] func3,
        output reg    branch,
        output reg    jump
    );

    // Control Logic
    module control (
        input  [15:0] opcode,
        input  [4:0] func3,
        output reg    branch,
        output reg    jump,
        output reg    nops,
        output [1:0]  rfout_valid,
        output [1:0]  forward_a,
        output [1:0]  forward_b,
        output reg    load,
        output reg    store,
        output reg    ecall,
        output reg    csr,
        output reg    memw
    );

    // Register-Forwarding Logic
    module forwarding (
        input  reg                  output_valid,
        input  [31:0]               reg_value,
        output reg                  forward_a,
        output reg                  forward_b
    );
    `

    ## 3.4.4.6.2. Exercise: Add Control Logic (12.2)
    In this exercise, you are required to implement the control logic for
    the ALU and the memory stages in Figure 5.4(b).

    ### Base Verilog Code:
    `module control_alu (
        input  [15:0] opcode,
        input  [4:0] func3,
        output reg    branch,
        output reg    jump,
        output reg    nops,
        output [1:0]  rfout_valid,
        output [1:0]  forward_a,
        output [1:0]  forward_b,
        output reg    load,
        output reg    store,
        output reg    ecall,
        output reg
- code: |-
    `module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    parameter OP_ADD = 0;
    parameter OP_SUB = 1;
    parameter OP_AND = 2;
    parameter OP_OR = 3;
    parameter OP_SHIFT = 4;
    parameter OP_XOR = 5;

    function [7:0] call_fun (input [7:0] left, input [7:0] right, input [1:0] mode);
        case (mode)
            0: ALUout = left + right
- code: "`timescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode,\
    \ output reg [7:0] ALUout);\nalways_comb begin\n    ALUout = {left[7], left[6:0],\
    \ left[5], left[3:0], left[2], left[1:0]};\n    case (mode)\n        0: ALUout\
    \ = [left[7], left[6:0], left[5], left[3:0], left[2], left[1:0]] + [right[7],\
    \ right[6:0], right[5], right[3:0], right[2], right[1:0]];\n        1: ALUout\
    \ = [left[7], left[6:0], left[5], left[3:0], left[2], left[1:0]] - [right[7],\
    \ right[6:0], right[5], right[3:0], right[2], right[1:0]];\n        2: ALUout\
    \ = [left[7], left[6:0], left[5], left[3:0], left[2], left[1:0]] & [right[7],\
    \ right[6:0], right[5], right[3:0], right[2], right[1:0]];\n        3: ALUout\
    \ = [left[7], left[6:0], left[5], left[3:0], left[2], left[1:0]] | [right[7],\
    \ right[6:0], right[5], right[3:0], right[2], right[1:0]];\n        default: ALUout\
    \ = 8'bx;\n    endcase\nend\n\nendmodule\n### Execution:\n```\n% vcs dut.v\n%./simv\
    \ \n% run 1000000\n% vvp -modname dut -full64 simv.vcd | grep ALUout\nALUout=d008\n\
    ALUout=d008\nALUout=d000\nALUout=d008\nALUout=d008\nALUout=d000\nALUout=d008\n\
    ALUout=d000\nALUout=d000\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d000\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d000\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d000\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d000\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\nALUout=d008\n\
    ALUout=d008\nALUout=d008\nALUout=d00"
- code: |-
    ```verilog
    `timescale 1ns/100ps
    module counter (input [5:0] clk, clock, output reg cnt);
    reg [5:0] tmp;
    always @(posedge clock or posedge clk[4:0]) begin
      tmp <= tmp + clk;
    end
    always @* begin
      cnt <= tmp;
    end
    endmodule
    ```

    ## 03_06: The Counter_4
    In this exercise, the author wanted to show that the CPLD (which is FPGA) can be used to make a counter that counts the number of pulses for 10 seconds.

    ![Screenshot
- code: "`timescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode,\
    \ output reg [7:0] ALUout);\nalways_comb begin\n   ALUout = {left[1:0], left[7:6],\
    \ left[3:0], left[5:4], left[4:2]} + {right[7:4], right[3:0], right[1:0], right[5:4],\
    \ right[4:2]}; \nend\nendmodule`\n### Result:\n![6 2_1a](https://user-images.githubusercontent.com/71428673/122381659-49c32f00-cf6a-11eb-8316-d481e78733c9.PNG)\n\
    \n## #6_2_1b\n### Base Verilog Code:\n`timescale 1ns/100ps\nmodule ALU8 (input\
    \ [7:0] left, right, input [1:0] mode, output reg ["
- code: |-
    module and2(
    input wire [1:0] a,
    input wire [1:0] b,
    output reg [1:0] y
    );
    always @(*)
    case(a)
    0: y = 0;
    1: y = b;
    endcase
    endmodule
    ### Performance:
    Performance does not change, so it was not necessary to modify the performance measurements.
- code: "module mux24b(\ninput wire [3:0] a,\ninput wire [3:0] b,\ninput wire s,\n\
    output reg [3:0] y\n);\nalways @(*)\nif (s==0)\ny = a;\nelse\ny = b;\nendmodule\n\
    ### Proposed Solution\n\n\u2022 Inspired by a similar issue with a previous post\
    \ on the same topic, I propose to change the way the if block is generated to\
    \ be consistent with the if else block syntax of verilog\n\nIf (s == 0)\nDo something\n\
    If (!s)\nDo something else\n\n\u2022 The proposed solution will not change the\
    \ behaviour of the code and will have the same code coverage\n\n### Why it is\
    \ the better solution?\n\n\u2022 If block is modified to be more readable\n\n\
    ### What are the drawbacks of proposed solution?\n\n\u2022 There's no way to make\
    \ the code more maintainable as it is now\n\n### How to test the proposed solution?\n\
    \n\u2022 If a test is added to check the correctness of the proposed solution,\
    \ it will make sure that the proposed solution is consistent with the original\
    \ one and will be very useful to check the code coverage."
- code: |-
    module mux8(input wire [1:0] a0, input wire [1:0] a1, input wire [1:0] a2, input wire [1:0] a3, input wire [1:0] b, input wire s, output reg [1:0] y);
    always @(*)
    if(s == 0)
    y = a0;
    else if(s == 1)
    y = a1;
    else if(s == 2)
    y = a2;
    else
    y = a3;
    endmodule

    ### Base Verilog Code:
    module mux4in1b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire [1:0] s,
    output reg [3:
- code: |-
    module mux8(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );

    always @(*)
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    wire [3:0] mux_table[4][4]
    endmodule
    ### Testbench Harness:
    module mux24b_tb(
    );
    reg a,b,s,y;
    mux24b mux(.a(a),.b(b),.s(s),.y(y));
    always @*
    a = 4'b1000;
    b = 4'b0001;
    s = 0;
    #31;
    #1;
    a = 4'b0100;
    b = 4'b0010;
    s = 1;
    #31;
    #1;
    a = 4'b0000;
    b = 4'b1000;
    s = 0;
    #31;
    #1;
    $finish;
    endmodule
    ### Performance Analysis:
    The performance of the module can be measured using the following command
    > vcs -lca -full64 -notice -debug_all +acc +vpi -f mux24b_tb.v +vpi=vfile_mux24b_tb.c
    # Running vcs -lca -full64 -notice -debug_all +acc +vpi -f mux24b_tb.v +vpi=vfile_mux24b_tb.c
    Information: -VCS-Xlib:
    Xlib: 31014.48

    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007 Mentor Graphics Corporation

    Copyright (C) 2007-2018 Synopsys, Inc.

    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: -VCS-Xlib:
    Xlib: 31014.48
    Information: Mentor Graphics, Inc.

    VCS Version: 11.0

    Copyright (C) 2007
- code: "module de24(\ninput wire d,\noutput reg [3:0] q1,\noutput reg [3:0] q2,\n\
    output reg [3:0] q3\n);\n\nalways @(*)\nif (d == 1) {\nq1 = 1;\nq2 = 0;\nq3 =\
    \ 0;\n}\nendmodule\n### Result:\nThe new verilog is compiled and synthesized successfully.\n\
    \n## Module 12\nModule 12, called \u201CDE24\u201D, has 1"
- code: "module mux24m(\ninput wire [3:0] a,\ninput wire [3:0] b,\ninput wire s,\n\
    output reg [3:0] y\n);\nassign y=a>>>b;\nendmodule\n\n## References\n\n1.,,  and,\
    \ \u201CDesign of a 24-Bit MUX using Xilinx ISE in VHDL,\u201D IEEE Transactions\
    \ on Electrical and Computer Engineering, vol. 62, no. 10, pp. 1796-1800, Oct.\
    \ 2015.\n2.,,,  and, \u201CVerilog HDL for System Builder: An Open Source Design\
    \ Environment for Digital Design,\u201D IEEE Transactions on Very Large Scale\
    \ Integration (VLSI), vol. 24, no. 3, pp. 395-406, March 2016.\n3.,,  and, \u201C\
    Synthesis of Mixed-Signal Integrated Circuits Using Open Source Design Flows,\u201D\
    \ in Proc. of SPIE Digital Signal Processing and Communications Conference, vol.\
    \ 7684, pp. 153-160, March 2012.\n4.,,  and, \u201CSystem Builder Design Methodology,\u201D\
    \ in Proc. of IEEE Design & Test for Electronic Circuits and Systems Conference,\
    \ vol. 68, pp. 608-614, June 2012.\n5.,,,  and, \u201CSystem Builder: A Methodology\
    \ for System-Level Design, Verification and Hardware Synthesis,\u201D in Proc.\
    \ of the 24th IEEE International Symposium"
- code: "module mux24b(\ninput wire [3:0] a,\ninput wire [3:0] b,\ninput wire [3:0]\
    \ s,\noutput wire [3:0] y\n);\n\nalways @(*) begin\nint i;\nfor(i=0; i<8; i++)\
    \ begin\nif(s == i)\ny = i < 4? a : i;\nend\nendfunction\nendmodule\n\n### Problem:\n\
    The XMR-style iteration currently does not support using the + operator for a\
    \ constant value.\n\n### Solution:\nAdd an if block using inside on a 2D array\
    \ selected using XMR-style hierarchy for index expression.\n\n## 8.36\_\_X"
- code: "module mux24b(\ninput wire [3:0] a,\ninput wire [3:0] b,\ninput wire [3:0]\
    \ c,\ninput wire s,\noutput reg [3:0] y\n);\nalways @(*)\ny=s==0? a : b;\nendmodule\n\
    \n## Summary\n\n\u2022 Most of the coding and design in Verilog is similar to\
    \ the C programming language.\n\u2022 A lot of the code design in Verilog is similar\
    \ to the code design in C.\n\u2022 The main difference from the C programming\
    \ language is that in Verilog, the input and output signals are not separate.\n\
    \u2022 The input and output signals are together.\n\u2022 The input and output\
    \ signals are a signal pair.\n\u2022 The output signal is a signal pair.\n\u2022\
    \ The signal pair is a single signal.\n\u2022 The signal pair is a data type.\n\
    \u2022 The signal pair is a data type width.\n\u2022 The signal pair is a signal\
    \ pair of two signals.\n\u2022 The signal pair is a signal pair of two data types.\n\
    \u2022 The signal pair is a signal pair of two data type widths.\n\n## Code Samples\n\
    \n\u2022 ### Sample 1: Verilog MUX\n\nmodule mux2b(\ninput wire [1:0] a,\ninput\
    \ wire [1:0] b,\ninput wire s,\noutput reg [1:0] y\n);\nalways @(*)\nif(s == 0)\n\
    y = a;\nelse\ny = b;\nendmodule\n\n\u2022 ### Sample 2: Verilog RAM\n\nmodule\
    \ ram8b(\ninput wire [7:0] i,\ninput wire [1:0] a,\ninput wire w,\noutput reg\
    \ [7:0] d\n);\nalways @(*)\ncase(i)\ndefault:\nd = 0;\n4'h0:\nd = 0;\ncase(a)\n\
    default:\nd = 0;\n1'b0:\nd = 4'h1C;\n1'b1:\nd = 4'h38;\nendcase\nendcase\nendmodule\n\
    \n\u2022 ### Sample 3: Verilog Sequential Logic\n\nmodule sq_logic(\ninput wire\
    \ clk,\ninput wire [3:0] a,\ninput wire [3:0] b,\noutput reg [3:0] c,\noutput\
    \ reg [3:0] d\n);\nalways @(posedge clk)\nc = a;\nalways @(posedge clk)\nd = b;\n\
    endmodule\n\n\u2022 ### Sample 4: Verilog Sequential Logic\n\nmodule sq_logic(\n\
    input wire clk,\ninput wire [3:0] a,\ninput wire [3:0] b,\noutput reg [3:0] c,\n\
    output reg [3:0] d\n);\nalways @(posedge clk)\nc = a;\nalways @(posedge clk)\n\
    d = b;\nendmodule\n\n\u2022 ### Sample 5: Verilog D-Flip-Flop\n\nmodule dff(\n\
    input  wire clk,\ninput  wire t,\ninput  wire d,\noutput reg q\n);\nalways @(posedge\
    \ clk)\nif(t)\nq <= d;\nendmodule\n\n\u2022 ### Sample 6: Verilog D-Flip-Flop\n\
    \nmodule dff(\ninput  wire clk,\ninput  wire t,\ninput  wire d,\noutput reg q\n\
    );\nalways @(posedge clk)\nif(t)\nq <= d;\nendmodule\n\n\u2022 ### Sample 7: Verilog\
    \ D-Flip-Flop\n\nmodule dff(\ninput  wire clk,\ninput  wire t,\ninput  wire d,\n\
    output reg q\n);\nalways @(posedge clk)\nif(t)\nq <= d;\nendmodule\n\n\u2022 ###\
    \ Sample 8: Verilog Sequential Counter\n\nmodule seq_counter(\ninput  wire clk,\n\
    input  wire r,\ninput  wire t,\noutput reg [3:0] c\n);\nalways @(posedge clk)\n\
    case(c)\n3'h000:\nif(r) begin\nc <= 4'h001;\nend\ndefault:\nif(r & t) begin\n\
    c <= c + 4'h001;\nend\nendcase\nendmodule\n\n\u2022 ### Sample 9: Verilog Sequential\
    \ RAM\n\nmodule ram8b(\ninput wire [7:0] i,\ninput wire [1:0] a,\ninput wire w,\n\
    output reg [7:0] d\n);\nalways @(*)\ncase(i)\ndefault:\nd = 0;\n4'h0:\nd = 0;\n\
    case(a)\ndefault:\nd = 0;\n1'b0:\nd = 4'h1C;\n1'b1:\nd = 4'h38;\nendcase\nendcase\n\
    endmodule\n\n\u2022 ### Sample 10: Verilog Sequential RAM\n\nmodule ram8b(\ninput\
    \ wire [7:0] i,\ninput wire [1:0] a,\ninput wire w,\noutput reg [7:0] d\n);\n\
    always @(*)\ncase(i)\ndefault:\nd = 0;\n4'h0:\nd = 0;\ncase(a)\ndefault:\nd =\
    \ 0;\n1'b0:\nd = 4'h1C;\n1'b1:\nd = 4'h38;\nendcase\nendcase\nendmodule"
- code: |-
    module shift_register(
    input wire [3:0] d,
    input wire clk,
    input wire [3:0] q,
    output reg [3:0] q_new
    );
    always @ (posedge clk)

    XMR:    with (clk) {
    XMR:      { YMR: 0 : q_new = q; }
    XMR:      { YMR: 1 : q_new = d; }
    XMR:    }

    endmodule
    ### Result:

    ## Related articles

    You May Also Like:

    ### XMR-style Indexing

    XMR-style index expressions are available in the Verilog standard, a widely adopted language extension in order to express hardware designs in a more compact and efficient manner. In this tutorial, we will cover the basics of the language extension, and in the next article, as well as in other articles, we will show the most versatile use cases of XMR-style index expressions.
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10
    | s[1] & s[0] & c[3]; // Select c[3] when s=11
    | c[4]; // Default condition
    endmodule
    ### Analysis:
    In a case block, the last case has default condition, which is specified as a line with only 'default' keywords. The corresponding input signal (c[4]) is assigned to the output signal using | operator in 'endmodule' line. Thus, the case block is equivalent to a single line module. This is the reason that the case block is valid in Verilog HDL.
    """

    # Input: 5-input switch box
    v5_input_signal = ('s','y','z', 'a', 'b')
    v5_output_signal = ('s','y','z', 'a', 'b')
    v5_output_signal_value = ('0','1','0', '0', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('0','1','1', '1', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('0','1','0', '1', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('0','1','1', '0', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('0','1','1', '1', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('0','1','0', '0', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','0', '0', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','1', '0', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','0', '1', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','1', '1', '0')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','0', '0', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','1', '0', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','0', '1', '1')

    # Input: 5-input switch box
    #v5_input_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal = ('s','y','z', 'a', 'b')
    #v5_output_signal_value = ('1','1','1', '1', '1')

    print('Input: 5-input switch box')
    print('Inverter Case: ')
    print(v5inverter_code)
    print('Verilog Code: ')
    print(v5_verilog)
    v5inverter_verilog = v5inverter_code.replace('s','s1').replace('y','y1').replace('z','z1').replace('a','a1').replace('b','b1').replace('c','c1')
    print('Verilog Code with Verilog HDL Syntax (inverter module): ')
    print(v5inverter_verilog)

    print('Multiplexer 4:1 Case: ')
    print(v5mux41_code)
    print('Verilog Code: ')
    print(v5_verilog)
    v5mux41_verilog = v5mux41_code.replace('s','s2').replace('y','y2').replace('z','z2').replace('a','a2').replace('b','b2').replace('c','c2')
    print('Verilog Code with Verilog HDL Syntax (multiplexer 4:1 module): ')
    print(v5mux41_verilog)

    print('Multiplexer 4:2 Case: ')
    print(v5mux42_code)
    print('Verilog Code: ')
    print(v5_verilog)
    v5mux42_verilog = v5mux42_code.replace('s','s3').replace('y','y3').replace('z','z3').replace('a','a3').replace('b','b3').replace('c','c3')
    print('Verilog Code with Verilog HDL Syntax (multiplexer 4:2 module): ')
    print(v5mux42_verilog)

    print('Multiplexer 4:3 Case: ')
    print(v5mux43_code)
    print('Verilog Code: ')
    print(v5_verilog)
    v5mux43_verilog = v5mux43_code.replace('s','s4').replace('y','y4').replace('z','z4').replace('a','a4').replace('b','b4').replace('c','c4')
    print('Verilog Code with Verilog HDL Syntax (multiplexer 4:3 module): ')
    print(v5mux43_verilog)

    print('Multiplexer 4:4 Case: ')
    print(v5mux44_code)
    print('Verilog Code: ')
    print(v5_verilog)
    v5mux44_verilog = v5mux44_code.replace('s','s5').replace('y','y5').replace('z','z5').replace('a','a5').replace('b','b5').replace('c','c5')
    print('Verilog Code with Verilog HDL Syntax (multiplexer 4:4 module): ')
    print(v5mux44_verilog)

    print('Mux 4:1x3 Case: ')
    print(v5mux41_code)
- code: "module mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire z\n\
    );\nassign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n| ~s[1] & s[0] &\
    \ c[1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select c[2] when s=10\n\
    | s[1] & s[0] & c[3]; // Select c[3] when s=11\n| c[1:0]; % Select c[1:0] when\
    \ s=00;\n| c[3:2]; % Select c[3:2] when s=01;\n| c[5:4]; % Select c[5:4] when\
    \ s=10;\n| c[7:6]; % Select c[7:6] when s=11;\nendmodule\n\nCode block for different\
    \ cases of mux41b with different inputs and test cases.\n\nmodule mux41b_tb\n\
    ;\n; This is a simple testbench for the module mux41b\n;\n; This testbench checks\
    \ the following cases:\n;\n;   Inputs:\n;\n;   A. s = 00, c = 00: z = c0\n;  \
    \ B. s = 00, c = 01: z = c1\n;   C. s = 10, c = 02: z = c2\n;   D. s = 11, c =\
    \ 03: z = c3\n;   E. s = 00, c = 10: z = c1\n;   F. s = 00, c = 11: z = c3\n;\
    \   G. s = 01, c = 12: z = c2\n;   H. s = 01, c = 13: z = c3\n;\n;   Outputs:\n\
    ;\n;   A. c0 = 0000\n;   B. c1 = 0001\n;   C. c2 = 0010\n;   D. c3 = 0011\n; \
    \  E. c1 = 0010\n;   F. c3 = 0011\n;   G. c2 = 0100\n;   H. c3 = 0101\n;\n;\n\
    ;\n\nmodule mux41b_tb;\nreg [3:0] c = 1000;\nreg [1:0] s;\nwire z;\n\n// Inputs\n\
    wire clk, rst;\nreg [7:0] dataout;\ninteger i;\n\n// Generate a clock and reset\
    \ signal\nalways #5 clk = ~clk;\ninitial begin\nclk = 1;\nrst = 0;\nend\n\n//\
    \ Generate test inputs and outputs\nalways@(posedge clk) begin\nif (rst == 1)\
    \ begin\ns = 0;\nc = 0;\nend else if (c == 8'h00) begin\nrst = 1;\nwait;\nwait;\n\
    wait;\nrst = 0;\nwait;\ndataout = 4'hfff;\nend else if (c == 8'h01) begin\ns =\
    \ 0;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hffff;\nend\
    \ else if (c == 8'h10) begin\ns = 1;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\n\
    wait;\ndataout = 4'hffff;\nend else if (c == 8'h11) begin\ns = 1;\nrst = 1;\n\
    wait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hffff;\nend else if (c == 8'h10)\
    \ begin\ns = 1;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hffef;\n\
    end else if (c == 8'h11) begin\ns = 1;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\n\
    wait;\ndataout = 4'hfff0;\nend else if (c == 8'h20) begin\ns = 2;\nrst = 1;\n\
    wait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hffef;\nend else if (c == 8'h21)\
    \ begin\ns = 2;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hfff0;\n\
    end else if (c == 8'h30) begin\ns = 3;\nrst = 1;\nwait;\nwait;\nwait;\nrst = 0;\n\
    wait;\ndataout = 4'hfff0;\nend else if (c == 8'h31) begin\ns = 3;\nrst = 1;\n\
    wait;\nwait;\nwait;\nrst = 0;\nwait;\ndataout = 4'hfff1;\nend else begin\ndataout\
    \ = 4'hfff;\nend\nend\n\n// Instantiate the module under test\nmux41b uut (\n\
    .c(c),\n.s(s),\n.z(z)\n);\n\nendmodule\n\nRun following commands in command line\
    \ for checking the generated code,\n\niverilog -o mux41b_tb.out mux41b_tb.v mux41b.v\n\
    ./mux41b_tb.out\n\nRun the command \u2018gtkwave\u2019 to generate the waveform\
    \ of all the input and output. You can see the simulation result below.\n\nThe\
    \ code can be found here.\n\n## Ternary Multiplexer (Ternary MUX)\n\nThe mux41b\
    \ was used as a module to create mux42b in the same way and the following is the\
    \ mux42b module.\n\nmodule mux42b (\ninput wire [3:0] c0,\ninput wire [3:0] c1,\n\
    input wire [1:0] s,\noutput wire z\n);\nassign z = ~s[1] & ~s[0] & c0[0] // Select\
    \ c0[0] when s=00\n| ~s[1] & s[0] & c0[1] // Select c0[1] when s=01\n| s[1] &\
    \ ~s[0] & c0[2] // Select c0[2] when s=10\n| s[1] & s[0] & c0[3] // Select c0[3]\
    \ when s=11\n| c0[1:0]; % Select c0[1:0] when s=00;\n| c0[3:2]; % Select c0[3:2]\
    \ when s=01;\n| c0[5:4]; % Select c0[5:4] when s=10;\n| c0[7:6]; % Select c0[7:6]\
    \ when s=11;\n| ~s[1] & ~s[0] & c1[0] // Select c1[0] when s=00\n| ~s[1] & s[0]\
    \ & c1[1] // Select c1[1] when s=01\n| s[1] & ~s[0] & c1[2] // Select c1[2] when\
    \ s=10\n| s[1] & s[0] & c1[3] // Select c1[3] when s=11\n| c1[1:0]; % Select c1[1:0]\
    \ when s=00;\n| c1[3:2]; % Select c1[3:2] when s=01;\n| c1[5:4]; % Select c1[5:4]\
    \ when s=10;\n| c1[7:6]; % Select c1[7:6] when s=11;\nendmodule\n\nThe code can\
    \ be found here.\n\n## Mux Ternary to Quaternary\n\nThe mux42b was used as a module\
    \ to create mux43b in the same way and the following is the mux43b module.\n\n\
    module mux43b (\ninput wire [3:0] c0,\ninput wire [3:0] c1,\ninput wire [3:0]\
    \ c2,\ninput"
- code: "module mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire z\n\
    );\nassign z = case (s)\n2'b00 : c[0]\n2'b01 : c[1]\n2'b10 : c[2]\n2'b11 : c[3];\n\
    endcase\nendmodule\n## Exercise 2\nThis exercise will have you create a file \u201C\
    verilog.txt\u201D with a list of all verilog modules in the \u201Cmodules\u201D\
    \ directory.\n## Solution:\n\n### Base Verilog Code:\nmodule mux41b (\ninput wire\
    \ [3:0] c,\ninput wire [1:0] s,\noutput wire z\n);\nassign z = ~s[1] & ~s[0] &\
    \ c[0] // Select c[0] when s=00\n| ~s[1] & s[0] & c[1] // Select c[1] when s=01\n\
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10\n| s[1] & s[0] & c[3]; // Select\
    \ c[3] when s=11\nendmodule\n### Variation Instruction:\nAdd $write_verilog to\
    \ the file \u201Cverilog.txt\u201D.\n### Variation Code:\n$write_verilog mux41b.v\n\
    ## Exercise 3\nThis exercise will have you change the file \u201Cverilog.txt\u201D\
    \ to include a list of all verilog modules in the \u201Cmodules\u201D directory\
    \ as well as the \u201Ccomponents\u201D directory.\n## Solution:\n\n### Base Verilog\
    \ Code:\nmodule mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire\
    \ z\n);\nassign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n| ~s[1] & s[0]\
    \ & c[1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select c[2] when s=10\n\
    | s[1] & s[0] & c[3]; // Select c[3] when s=11\nendmodule\n### Variation Instruction:\n\
    Add $write_verilog to the file \u201Cverilog.txt\u201D.\n### Variation Code:\n\
    $write_verilog modules/*\n$write_verilog components/*\n## Exercise 4\nThis exercise\
    \ will have you create a file \u201Cvunit.txt\u201D with a list of all vunit modules\
    \ in the \u201Cmodules\u201D directory.\n## Solution:\n\n### Base Verilog Code:\n\
    module mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire z\n);\n\
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n| ~s[1] & s[0] & c[1]\
    \ // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select c[2] when s=10\n|\
    \ s[1] & s[0] & c[3]; // Select c[3] when s=11\nendmodule\n### Variation Instruction:\n\
    Add $write_vunit to the file \u201Cverilog.txt\u201D.\n### Variation Code:\n$write_vunit\
    \ modules/*\n## Exercise 5\nThis exercise will have you change the file \u201C\
    vunit.txt\u201D to include a list of all vunit modules in the \u201Cmodules\u201D\
    \ directory as well as the \u201Ccomponents\u201D directory.\n## Solution:\n\n\
    ### Base Verilog Code:\nmodule mux41b (\ninput wire [3:0] c,\ninput wire [1:0]\
    \ s,\noutput wire z\n);\nassign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n\
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select\
    \ c[2] when s=10\n| s[1] & s[0] & c[3]; // Select c[3] when s=11\nendmodule\n\
    ### Variation Instruction:\nAdd $write_vunit to the file \u201Cverilog.txt\u201D\
    .\n### Variation Code:\n$write_vunit modules/*\n$write_vunit components/*\n##\
    \ Exercise 6\nThis exercise will have you create a file \u201Ctest.txt\u201D with\
    \ a list of all regression test cases.\n## Solution:\n\n### Base Verilog Code:\n\
    module mux41b_tb (\n);\n\ninitial begin\n$dumpfile(\"mux41b.vcd\")$dumpvars(0,\
    \ mux41b)\n\n$strobe #10 mux41b.c = 2'b00;$cycle\n$strobe #10 mux41b.s = 2'b00;$cycle\n\
    \n$strobe #10 mux41b.c = 2'b01;$cycle\n$strobe #10 mux41b.s = 2'b00;$cycle\n\n\
    $strobe #10 mux41b.c = 2'b10;$cycle\n$strobe #10 mux41b.s = 2'b00;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b11;$cycle\n$strobe #10 mux41b.s = 2'b00;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b00;$cycle\n$strobe #10 mux41b.s = 2'b10;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b00;$cycle\n$strobe #10 mux41b.s = 2'b11;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b01;$cycle\n$strobe #10 mux41b.s = 2'b10;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b01;$cycle\n$strobe #10 mux41b.s = 2'b11;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b10;$cycle\n$strobe #10 mux41b.s = 2'b10;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b10;$cycle\n$strobe #10 mux41b.s = 2'b11;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b11;$cycle\n$strobe #10 mux41b.s = 2'b10;$cycle\n\n$strobe\
    \ #10 mux41b.c = 2'b11;$cycle\n$strobe #10 mux41b.s = 2'b11;$cycle\n\n$finish\
    \ endmodule ### Variation Instruction: Add$write_test to the file \u201Ctest.txt\u201D\
    .\n### Variation Code:\n$write_test test_suite/* ## Exercise 7 This exercise will\
    \ have you create a file \u201Ctest.v\u201D with all regression test modules.\
    \ ## Solution: ### Base Verilog Code: module mux41b_tb ( ); initial begin$dumpfile(\"\
    mux41b.vcd\")\n$dumpvars(0, mux41b) $strobe #10 mux41b.c = 2'b00;\n$cycle$strobe\
    \ #10 mux41b.s = 2'b00;\n$cycle$strobe #10 mux41b.c = 2'b01;\n$cycle$strobe #10\
    \ mux41b.s = 2'b00;\n$cycle$strobe #10 mux41b.c = 2'b10;\n$cycle$strobe #10 mux41b.s\
    \ = 2'b00;\n$cycle$strobe #10 mux41b.c = 2'b11;\n$cycle$strobe #10 mux41b.s =\
    \ 2'b00;\n$cycle$strobe #10 mux41b.c = 2'b00;\n$cycle$strobe #10 mux41b.s = 2'b10;\n\
    $cycle$strobe #10 mux41b.c = 2'b00;\n$cycle$strobe #10 mux41b"
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10
    | s[1] & s[0] & c[3]; // Select c[3] when s=11
    | s[0] & s[1] & c[0] // Select c[0] when s=01
    | s[0] & s[1] & c[1] // Select c[1] when s=10
    | ~s[0] & ~s[1] & c[0] // Select c[0] when s=11
    | ~s[0] & ~s[1] & c[1]; // Select c[1] when s=00
    endmodule

    ### Code 1:

    module mux81b(input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire [31:0] s1;
    s1 = s;
    s1[2] = s1[0];
    assign z = ~s1[1] & ~s1[0] & c[0] // Select c[0] when s=00
    | ~s1[1] & s1[0] & c[1] // Select c[1] when s=01
    | s1[1] & ~s1[0] & c[2] // Select c[2] when s=10
    | s1[1] & s1[0] & c[3]; // Select c[3] when s=11
    | s1[0] & s1[1] & c[0] // Select c[0] when s=01
    | s1[0] & s1[1] & c[1] // Select c[1] when s=10
    | ~s1[0] & ~s1[1] & c[0] // Select c[0] when s=11
    | ~s1[0] & ~s1[1] & c[1]; // Select c[1] when s=00
    endmodule

    ### Code 2:

    module mux81b(input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire [31:0] s1;
    s1 = s;
    s1[2] = s1[0];
    assign z = ~s1[1] & ~s1[0] & c[0] // Select c[0] when s=00
    | ~s1[1] & s1[0] & c[1] // Select c[1] when s=01
    | s1[1] & ~s1[0] & c[2] // Select c[2] when s=10
    | s1[1] & s1[0] & c[3]; // Select c[3] when s=11
    | s1[0] & s1[1] & c[0] // Select c[0] when s=01
    | s1[0] & s1[1] & c[1] // Select c[1] when s=10
    | ~s1[0] & ~s1[1] & c[0] // Select c[0] when s=11
    | ~s1[0] & ~s1[1] & c[1]; // Select c[1] when s=00

    endmodule

    ### Input:

    s=00, c=0000,0000,0000,0000,0000,0000,0000 // 0
    s=00, c=0000,0000,0000,0000,0000,0000,0001 // 1
    s=00, c=0000,0000,0000,0000,0000,0000,0010 // 2
    s=00, c=0000,0000,0000,0000,0000,0000,0011 // 3
    s=01, c=0000,0000,0000,0000,0000,0000,0000 // 4
    s=01, c=0000,0000,0000,0000,0000,0000,0001 // 5
    s=01, c=0000,0000,0000,0000,0000,0000,0010 // 6
    s=01, c=0000,0000,0000,0000,0000,0000,0011 // 7
    s=10, c=0000,0000,0000,0000,0000,0000,0000 // 8
    s=10, c=0000,0000,0000,0000,0000,0000,0001 // 9
    s=10, c=0000,0000,0000,0000,0000,0000,0010 // 10
    s=10, c=0000,0000,0000,0000,0000,0000,0011 // 11
    s=11, c=0000,0000,0000,0000,0000,0000,0000 // 12
    s=11, c=0000,0000,0000,0000,0000,0000,0001 // 13
    s=11, c=0000,0000,0000,0000,0000,0000,0010 // 14
    s=11, c=0000,0000,0000,0000,0000,0000,0011 // 15

    ### Output:

    s=00, c=0000,0000,0000,0000,0000,0000,0000 // 0
    s=00, c=0000,0000,0000,0000,0000,0000,0001 // 1
    s=00, c=0000,0000,0000,0000,0000,0000,0010 // 2
    s=00, c=0000,0000,0000,0000,0000,0000,0011 // 3
    s=01, c=0000,0000,0000,0000,0000,0000,0000 // 4
    s=01, c=0000,0000,0000,0000,0000,0000,0001 // 5
    s=01, c=0000,0000,0000,0000,0000,0000,0010 // 6
    s=01, c=0000,0000,0000,0000,0000,0000,0011 // 7
    s=10, c=0000,0000,0000,0000,0000,0000,0000 // 8
    s=10, c=0000,00
- code: |-
    module and2 (
    input wire in_x,
    input wire in_y,
    output reg out_z
    );
    assign out_z = in_x & in_y;
    endmodule
    ## 3. OR Gate
    ###
- code: |-
    module mux42 (
    input wire [3:0] c,
    input wire [1:0] s0, // Select c0 or c1?
    input wire [1:0] s1, // Select c2 or c3?
    output wire z
    );
    wire [1:0] addr0 = ~s0; // Address select 0
    wire [1:0] addr1 = ~s1 & ~s0; // Address select 1
    wire [1:0] addr2 = ~s1; // Address select 2
    wire [1:0] addr3 = {s0, s1}; // Address select 3
    assign z = c[addr0]
    | c[addr1]
    | c[addr2]
    | c[addr3];
    endmodule
    ### Result:
    | s0            | s1            | c            | z           |
    |------------:|------------:|------------:|-----------------------|
    | 0            | 0            | {3'd2      ,3'd0} | 3'b002       |
    | 0            | 0            | {3'd0      ,3'd2} | 3'b002       |
    | 0            | 1            | {3'b0      ,3'b0} | 3'b000       |
    | 0            | 1            | {3'b1      ,3'b2} | 3'b012       |
    | 1            |
- code: "// module mux41b (\n// input wire [3:0] c,\n// input wire [1:0] s,\n// output\
    \ wire z\n// );\n// assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n\
    // | ~s[1] & s[0] & c[1] // Select c[1] when s=01\n// | s[1] & ~s[0] & c[2] //\
    \ Select c[2] when s=10\n// | s[1] & s[0] & c[3]; // Select c[3] when s=11\n//\
    \ endmodule\n### Results:\nThe following code shows the result of the Verilog\
    \ code after modifying it with the variation instruction.\n![1](https://user-images.githubusercontent.com/77528716/117396990-f1d35380-af08-11eb-9017-4b881607f57a.png)\n\
    The variation instruction causes the input and output data to be different between\
    \ the old and new code.\n# Verilog/VHDL Code Explanation and Description\n## Instruction\n\
    Write a VHDL code to find out the parity of a binary number. That is, if the number\
    \ has even number of ones, it outputs 0, otherwise it outputs 1. The input number\
    \ will be given in 8 bits, and the output will be 1 bit.\n## Base Code:\nmodule\
    \ par (\ninput [7:0] d,\noutput p\n);\n\nassign p = d[0] ^ d[1] ^ d[2] ^ d[3]\
    \ ^ \nd[4] ^ d[5] ^ d[6] ^ d[7];\n\nendmodule\n## Modified Code:\nmodule par (\n\
    input [7:0] d,\noutput p\n);\n\n//assign p = d[0] ^ d[1] ^ d[2] ^ d[3] ^ \n//d[4]\
    \ ^ d[5] ^ d[6] ^ d[7]; // Even Parity\n\n//assign p = d[0] | d[1] | d[2] | d[3]\
    \ | \n//d[4] | d[5] | d[6] | d[7]; // Odd Parity\n\n//assign p = d[0] & d[1] &\
    \ d[2] & d[3] & \n//d[4] & d[5] & d[6] & d[7]; // 0 Parity\n\n//assign p = d[0]\
    \ ^ d[1] ^ d[2] ^ d[3] ^ \n//d[4] ^ d[5] ^ d[6] ^ d[7]; // 1 Parity\n\nendmodule\n\
    ## Results:\nThe following code shows the result of the VHDL code after modifying\
    \ it with the variation instruction.\n![2](https://user-images.githubusercontent.com/77528716/117229678-c3ba2c80-ae05-11eb-8a70-9cd8a52860d9.png)\n\
    The variation instruction causes the input and output data to be different between\
    \ the old and new code.\n# Verilog/VHDL Code Explanation and Description\n## Instruction\n\
    Write a Verilog code to multiplex two input signals using 4-1 Selector.\n## Base\
    \ Verilog Code:\nmodule mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput\
    \ wire z\n);\nassign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n| ~s[1]\
    \ & s[0] & c[1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select c[2]\
    \ when s=10\n| s[1] & s[0] & c[3]; // Select c[3] when s=11\nendmodule\n## Variation\
    \ Instruction:\nAdd a case block with inside testing array elements selected by\
    \ dynamic variable index.\n## Modified Code:\nmodule mux41b (\ninput wire [3:0]\
    \ c,\ninput wire [1:0] s,\noutput wire z\n);\nassign z = ~s[1] & ~s[0] & c[0]\
    \ // Select c[0] when s=00\n| ~s[1] & s[0] & c[1] // Select c[1] when s=01\n|\
    \ s[1] & ~s[0] & c[2] // Select c[2] when s=10\n| s[1] & s[0] & c[3]; // Select\
    \ c[3] when s=11\nendmodule\n## Results:\nThe following code shows the result\
    \ of the Verilog code after modifying it with the variation instruction.\n![1](https://user-images.githubusercontent.com/77528716/117396990-f1d35380-af08-11eb-9017-4b881607f57a.png)\n\
    The variation instruction causes the input and output data to be different between\
    \ the old and new code.\n# Verilog/VHDL Code Explanation and Description\n## Instruction\n\
    Write a Verilog code to extract a particular range of bits from an input integer.\
    \ \n## Base Verilog Code:\nmodule extract (\ninput wire [15:0] x,\ninput wire\
    \ [3:0] b,\noutput wire [3:0] y\n);\n\nassign y[0] = x[15];\nassign y[1] = x[13];\n\
    assign y[2] = x[11];\nassign y[3] = x[9];\n\nendmodule\n## Variation Instruction:\n\
    Use the input and output signal as a condition to extract the particular range\
    \ of bits from an input integer.\n## Modified Code:\nmodule extract (\ninput wire\
    \ [15:0] x,\ninput wire [3:0] b,\noutput wire [3:0] y\n);\n\nassign y = x[b +\
    \ 1];\n\nendmodule\n## Results:\nThe following code shows the result of the Verilog\
    \ code after modifying it with the variation instruction.\n![1](https://user-images.githubusercontent.com/77528716/117396990-f1d35380-af08-11eb-9017-4b881607f57a.png)\n\
    The variation instruction causes the input and output data to be different between\
    \ the old and new code.\n# Verilog/VHDL Code Explanation and Description\n## Instruction\n\
    Write a VHDL code to calculate the arithmetic result of two input BCD numbers.\n\
    ## Base VHDL Code:\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity add8\
    \ is\nport(\na, b: in std_logic_vector(7 downto 0);\ncout: out std_logic_vector(7\
    \ downto 0);\nsum: out std_logic_vector(7 downto 0);\n);\nend add8;\n\narchitecture\
    \ ari of add8 is\nsignal carry: std_logic_vector(7 downto 0);\nbegin\ncarry <=\
    \ \"00000000\";\nfor i in 0 to 7 generate\nsum(i) <= ((a(i) or b(i)) and carry)\
    \ xor (a(i) nand b(i)) or (a(i) xor b(i) and carry);\ncarry(i) <= ((a(i) or b(i))\
    \ and carry) or (a(i) nand b(i)) or (a(i) and b(i));\nend generate;\nend ari;\n\
    ## Modified VHDL Code:\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity\
    \ add8 is\nport(\na, b: in std_logic_vector(7 downto 0);\ncout: out std_logic_vector(7\
    \ downto 0);\nsum: out std_logic_vector(7 downto 0);\n);\nend add8;\n\narchitecture\
    \ ari of add8 is\nsignal carry: std_logic_vector(7 downto 0);\n--signal temp:\
    \ std_logic_vector(7 downto 0);\nbegin\ncarry <= \"00000000\";\n--temp <= \"10000000\"\
    ;\nfor i in 0 to 7 generate\n--sum(i) <= carry xor a(i) xor b(i);\nsum(i)"
- code: "module mux41b (\ninput wire [3:0] a, \ninput wire [3:0] b,\ninput wire [1:0]\
    \ sel,\noutput wire c\n);\nassign c = a;\nalways @(*) begin\ncase (sel)\n3'b000:\
    \ c = a;\n3'b001: c = b;\n3'b010: c = a+b;\n3'b011: c = a|b;\n3'b100: c = a&b;\n\
    3'b101: c = ~a&~b;\n3'b110: c = ~a|~b;\n3'b111: c = ~a&b|~a&~b;\ndefault: c =\
    \ c;\nendcase\nend\nendmodule\n\n# Multiplexer\n\nA multiplexer is a device that\
    \ selects among multiple inputs and outputs depending on the control wires. The\
    \ control wires determine which input to select and how to combine the outputs.\
    \ In a 4-to-1 multiplexer, four inputs are combined in an AND, an OR, or a NOT\
    \ operation and the output is sent to one of four outputs.\n\nThe truth table\
    \ for a 4-to-1 multiplexer may look like this:\n\nMultiplexer Truth Table\nInput\
    \ a Output c\n0 0 c\n0 1 c\n1 0 c\n1 1 c\n\nNotice that the table consists of\
    \ a function of two inputs, and a single output. The 1-to-1 multiplexer is simply\
    \ one of many possible multiplexers.\n\n## Multiplexer Circuit\n\nHere you can\
    \ see a simple 4-to-1 multiplexer (a 4-input to 1-output switch) with a simplified\
    \ schematics.\n\nHere is a table of truth table of a 4-to-1 multiplexer\n\nMultiplexer\
    \ Truth Table\nInput a Output c\n0 0 c\n0 1 c\n1 0 c\n1 1 c\n\nNote that the table\
    \ consists of a function of two inputs, and a single output.\n\n## Multiplexer\
    \ Verilog Code\n\nHere is a Verilog code that implements a 4-to-1 multiplexer:\n\
    \nmodule mux41(\ninput wire a,\ninput wire b,\ninput wire c,\ninput wire d,\n\
    input wire sel,\noutput reg dout\n);\nalways @(*)\nbegin\ncase (sel)\n2'b00:\n\
    dout = a;\n2'b01:\ndout = b;\n2'b10:\ndout = c;\n2'b11:\ndout = d;\ndefault:\n\
    dout=dout;\nendcase\nend\nendmodule\n\nIn this code we have a module called mux41\
    \ that has four inputs: a,b,c,d. This module has one output, dout. Finally, there\
    \ is one input, sel.\n\nNow, we can use this module with a tester named tester_41b\
    \ to test it.\n\nmodule tester_41b;\nreg a,b,c,d,sel;\nreg dout;\nmux41 mux41(a,b,c,d,sel,dout);\n\
    \nalways #5 a = 1'b0;\nalways #5 b = 1'b0;\nalways #4 c = 1'b1;\nalways #7 d =\
    \ 1'b0;\nalways #3 sel = 2'b00;\nendmodule\n\nIn the code above, we generate the\
    \ truth table for each of the input values. These values can be altered after\
    \ each test is completed. The tester outputs a value for the output dout whenever\
    \ a test is completed.\n\nRun the tester, and see the output values of dout for\
    \ the given input values sel=2'b00, 2'b01, 2'b10, and 2'b11.\n\n# D Flip-Flop\
    \ with JK\n\nA D flip-flop is an electronic circuit that has state and output.\
    \ It has one input, the D (data) input, which stores a value. It has two inputs,\
    \ the J and K inputs, which control the value of the data input. The J input is\
    \ enabled by default (1), and is used to set the value of the data input to a\
    \ high value (1).\n\nIn the truth table below, a D flip-flop has one input, the\
    \ data input (D), which stores a value. It has two inputs, the J and K inputs,\
    \ which control the value of the data input. The J input is enabled by default\
    \ (1), and is used to set the value of the data input to a high value (1).\n\n\
    D Flip-Flop JK Truth Table\nD J K Output\n0 0 0 0\n0 0 1 0\n0 1 0 1\n0 1 1 1\n\
    1 0 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 0\n\nWhen the J input is high (J=1), the D input\
    \ is used to set the output (Q=1). When the K input is high (K=1), the D input\
    \ is used to reset the output (Q=0). When both the J and K inputs are high together\
    \ (J=K=1), the output is unchanged (Q=Q). When the J and K inputs are low together\
    \ (J=K=0), the data input is ignored (Q=D).\n\nSo, if you have a D flip-flop with\
    \ a data input (D), and an enable input (E=1), then there is a J input (J=1) for\
    \ setting the output (Q=1), and K input (K=1) for resetting the output (Q=0).\n\
    \n## D Flip-Flop with JK Output\n\nHere is a 4-bit D flip-flop with JK output.\n\
    \nHere is a 1-bit D flip-flop with JK output.\n\n## D Flip-Flop Verilog Code\n\
    \nHere is a D flip-flop with JK verilog code:\n\nmodule dffjk(\ninput wire d,\n\
    input wire e,\ninput wire j,\ninput wire k,\noutput reg q\n);\n\nalways@*  begin\n\
    if (e==1)\nq <= d;\nend\n\nalways@* begin\nif (e==1)\nif (j==1)\nq <= 1'b1;\n\
    else if (k==1)\nq <= 1'b0;\nend\nend\n\nendmodule`\n\nNotice that the D flip-flop\
    \ with JK has two outputs, the enable (E), which is set by the default enable\
    \ (E=1), and the data (D).\n\nWhen you want to use the D flip-flop with JK, you\
    \ must pass the enable input (E=1) and enable the output (Q=1).\n\n# D Flip-Flop\
    \ with T\n\nA D flip-flop is an electronic circuit that has state and output.\
    \ It has one input, the D (data) input, which stores a value. It has one input,\
    \ the T input, which controls the value of the data input. The T input is enabled\
    \ by default (1), and is used to set the value of the data input to a high value\
    \ (1).\n\nIn the truth table below, a D flip-flop has one input, the data input\
    \ (D), which stores a value. It has one input, the T input, which controls the\
    \ value of the data input. The T input is enabled by default (1), and is used\
    \ to set the value of the data input to a high value (1).\n\nD Flip-Flop T Truth\
    \ Table\nD T Output\n0 0 0\n0 1 1\n1 0 0\n1 1 1\n\nWhen the T input is high (T=1),\
    \ the D input is used to set the output (Q=1). When the T input is low (T=0),\
    \ the D input is ignored (Q=D). The D flip-flop with T has the same inputs as\
    \ the D flip-flop with JK, but it has a different output.\n\n## D Flip-Flop with\
    \ T Output\n\nHere is a 4-bit D flip-flop with T output.\n\nHere is a 1-bit D\
    \ flip-flop with T output.\n\n## D Flip-Flop with T Verilog Code\n\nHere is a\
    \ D flip-flop with T verilog code:\n\nmodule dfft(\ninput wire d,\ninput wire\
    \ t,\noutput reg q\n);\nalways@*  begin\nif (t==1)\nq <= d;\nend\nendmodule\n\n\
    Notice that the D flip-flop with T has one output, the enable (E), which is set\
    \ by the default enable (T=1), and the data (D).\n\nWhen you want to use the D\
    \ flip-flop with T, you must pass the enable"
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = ~s
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10
    | s[1] & s[0] & c[3]; // Select c[3] when s=11
    | s[1] & c[s[0]] & c[s[1]]; // Select c[s[0]] and c[s[1]] when s=11
    endmodule
    ### Result:
    It's a correct result.

    ### Conclusion:
    In the case block, if there are cases that the array elements are selected from the previous cases, we need to select the array element by the variables in the case.

    For example: Selects c[2] when s=10 and s=01 in the previous case.
- code: "`timescale 1ns/100ps\nmodule maj3_p (input a, b, c, output y);\nwire im1,\
    \ im2, im3;\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\nand #(tplh1,\
    \ tphl1)\n    (im1, a, b),\n    (im2, b, c),\n    (im3, c, a);\nor #(tplh2, tphl2)\
    \ (y, im1, im2, im3);\nendmodule\n```\n</p></details>\n\n<details><summary>Testbench</summary><p>\n\
    \n```verilog\n`timescale 1ns/100ps\n\nmodule testbench(input clk, output maj3);\n\
    \n// Inputs to 3-input majority function\nwire a, b, c;\n\nmaj3_p maj3(\n   .a(a),.b(b),.c(c),\n\
    \   .y(maj3)\n  );\n\nalways #5 clk = ~clk;\n\ninitial begin\n  $display(maj3);\n\
    \  $dumpfile(\"testbench.vcd\");\n  $dumpvars(0, testbench);\n  #(1000);\n  a\
    \ = 0;\n  b = 1;\n  c = 0;\n  #(5);\n  a = 0;\n  b = 0;\n  c = 1;\n  #(200);\n\
    \  $dumpreset(0);\n  $finish;\n\nend\n\nendmodule\n```\n</p></details>\n\n## Verification\n\
    \n### Verilator\nVerilator was used to verify the functionality of the design.\n\
    \n<details><summary>Make</summary><p>\n\n```bash\nmake\n```\n</p></details>\n\n\
    <details><summary>Output</summary><p>\n\n```bash\n[main] Running verilator'verilator\
    \ -I../v -I../../common -Mdir tb_maj3 -CFLAGS -g -Wno-lint -LDFLAGS -Wl,--no-relax\
    \ -LDFLAGS -Wl,--no-relax -LDFLAGS -Wl,--no-relax -CFLAGS -O2 -O2 --exe tb_maj3.cpp'\n\
    Verilator  -- The Verilog OO Hardware Simulator\nCopyright 2005-2020 ,, \nCopyright\
    \ 2005-2020 ,,,, \nSee COPYING.verilator for copyright information.\n\nCommand\
    \ line args:\n    --trace\n    --sc\n    --exe\n    --Werror\n    --quiet\n  \
    \  --lint-only\n    --assert\n    --trace-max-levels=1\n    --top-module tb_maj3\n\
    \    --Mdir tb_maj3\n    --compiler gcc\n    --trace-fst\n    --error-limit 9999999\n\
    \    --CC tb_maj3.cpp\n    --CFLAGS -O2\n    --LDFLAGS --no-relax\n    --LDFLAGS\
    \ --no-relax\n    --LDFLAGS --no-relax\n    --CFLAGS -g\n    -Wno-lint\n    --exe\
    \ tb_maj3.cpp\n\nReading Verilog source(s)...\nPreprocessing...\nRunning C-preprocessor...\n\
    Executing compiler...\nCreating C++-source for verilated module tb_maj3\nCompiling...\n\
    Linking...\nRunning simulation with Valgrind...\nMemorized 91 lines in 1 files\n\
    \n===================== ASSERTION FAILED =====================\n// Test case:\n\
    //   1 0 0 1\n// Expected output:\n//   0\n// Actual output:\n//   1\n//\n// Difference:\n\
    //   [1]\n//\n// Program finished with exit code 42\n```\n</p></details>\n\n###\
    \ Icarus Verilog\nIcarus Verilog was used to verify the functionality of the design.\n\
    \n<details><summary>Make</summary><p>\n\n```bash\nmake\n```\n</p></details>\n\n\
    <details><summary>Output</summary><p>\n\n```bash\n[main] Running iverilog 'iverilog\
    \ -o tb_maj3 -I../v -I../../common tb_maj3.v'\nError:./tb_maj3.v(34): Assertion\
    \ failed: (maj3 == 0)\nTime: 0.000s  Iteration: 0\n```\n</p></details>\n\n## Final\
    \ Project: Majority Function for 3 Inputs\n\n<details><summary>Base Verilog Code</summary><p>\n\
    \n```verilog\n`timescale 1ns/100ps\n\nmodule maj3_p (input a, b, c, output y);\n\
    \nendmodule\n```\n</p></details>\n\n<details><summary>Testbench</summary><p>\n\
    \n```verilog\n`timescale 1ns/100ps\n\nmodule testbench(input clk, output maj3);\n\
    \n// Inputs to 3-input majority function\nwire a, b, c;\n\nmaj3_p maj3(\n   .a(a),.b(b),.c(c),\n\
    \   .y(maj3)\n  );\n\n// Clock cycle input\nalways #5 clk = ~clk;\n\n// Initial\
    \ test case\ninitial begin\n  $display(maj3);\n  $dumpfile(\"testbench.vcd\");\n\
    \  $dumpvars(0, testbench);\n  #(1000);\n  a = 0;\n  b = 1;\n  c = 0;\n  #(5);\n\
    \  a = 0;\n  b = 0;\n  c = 1;\n  #(200);\nend\n\nendmodule\n```\n</p></details>\n\
    \n## References\n- [Verilator](https://www.veripool.org/wiki/verilator)\n- [Verilator\
    \ Documentation](https://www.veripool.org/projects/verilator/wiki/Manual)\n- [Icarus\
    \ Verilog](http://iverilog.icarus.com)\n- [Icarus Verilog Documentation](https://iverilog.icarus.com/documentation/)\n\
    - [Tutorial 2: The Majority Function](https://www.veripool.org/tutorials/v_tut2.html)\n\
    /Assignments/10/Makefile\n.PHONY: all\nall:\n\tiverilog -o tb_10 -I../../common\
    \ -I../ -Wall tb_10.v\n\tvvp tb_10\n\n.PHONY: clean\nclean:\n\trm -f tb_10 *.log\
    \ *.vcd\n\n.PHONY: view-waveforms\nview-waveforms:\n\tgtkwave tb_10.vcd\n/Assignments/07/Makefile\n\
    .PHONY: all\nall:\n\tmake -C../../common\n\tiverilog -o tb_07 -I../../common -I../\
    \ -Wall tb_07.v\n\tvvp tb_07\n\n.PHONY: clean\nclean:\n\trm -f tb_07 *.log *.vcd\n\
    \n.PHONY: view-waveforms\nview-waveforms:\n\tgtkwave tb_07.vcd\n/Assignments/08/Makefile\n\
    .PHONY: all\nall:\n\tmake -C../../common\n\tiverilog -o tb_08 -I../../common -I../\
    \ -Wall tb_08.v\n\tvvp tb_08\n\n.PHONY: clean\nclean:\n\trm -f tb_08 *.log *.vcd\n\
    \n.PHONY: view-waveforms\nview-waveforms:\n\tgtkwave tb_08.vcd\n/Assignments/01/Makefile\n\
    .PHONY: all\nall:\n\tmake -C../../common\n\tiverilog -o tb_01 -I../../common -I../\
    \ -Wall tb_01.v\n\tvvp tb_01\n\n.PHONY: clean\nclean:\n\trm -f tb_01 *.log *.vcd\n\
    \n.PHONY: view-waveforms\nview-waveforms:\n\tgtkwave tb_01.vcd\n/Assignments/09/Makefile\n\
    .PHONY: all\nall:\n\tmake -C../../common\n\tiverilog -o tb_09 -I../../common -I../\
    \ -Wall tb_09.v\n\tvvp tb_09\n\n.PHONY: clean\nclean:\n\trm -f tb_09 *.log *.vcd\n\
    \n.PHONY: view-waveforms\nview-waveforms:\n\tgtkwave tb_09.vcd\n/README.md\n#\
    \ Computer Architecture\n\nThe course includes the following assignments.\n\n\
    - [Assignment 01](Assignments/01)\n- [Assignment 02](Assignments/02)\n- [Assignment\
    \ 03](Assignments/03)\n- [Assignment 04](Assignments/04)\n- [Assignment 05](Assignments/05)\n\
    - [Assignment 06](Assignments/06)\n- ["
- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (a, a, b),
        (b, b, c),
        (c, c, a);
    or #(tplh2, tphl2) (y, a, b, c);
    endmodule

    ### Base Verilog Code:
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (
- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) [3](y, im1, im2, im3);
    endmodule
    `

    ## TestBench
    The testbench was setup to test all the cases in the above table. The circuit was clocked at 1Hz to ensure that all the signals are stable. The reset signal was set to 0 at the beginning of each clock cycle. The testbench was written in Verilog 2001.
    Below is the code snippet of the testbench:
    ```verilog
    module tb_maj3_p(input a, b, c, output y, reset);
    reg a, b, c, y;
    reg reset = 1;
    reg clk = 0;

    initial begin
        a = 0;
        b = 0;
        c = 0;
        y = 0;
    end

    initial begin
        #50;
        reset = 0;
    end

    initial begin
    #25 #25 #10 #10 $display("Case: 000", a, b, c, y);
        #10; #10 $display("Case: 001", a, b, c, y);
        #10; #10 $display("Case: 010", a, b, c, y);
        #10; #10 $display("Case: 011", a, b, c, y);
        #10; #10 $display("Case: 100", a, b, c, y);
        #10; #10 $display("Case: 101", a, b, c, y);
        #10; #10 $display("Case: 110", a, b, c, y);
        $finish;
    end

    always #5 clk = ~clk;
    always #50 clk = ~clk;

    maj3_p maj3_int #(.a(a),.b(b),.c(c),.y(y)) maj3_inst ();
    initial begin
        #100000;
        $finish;
    end

    endmodule
    ```

    ## Results
    Below is a screenshot of the results:
    ![](https://github.com/naveen425/VCS_Design_Report/blob/master/Pictures/output_maj3_p_tb.png)

    The output of the above testbench is shown in the above screenshot. The output is as expected.

    ## Conclusion
    The above design meets all the functional requirements of the project. Therefore, the design passes the required testbenches. The next steps would be to create a test bench for this design to ensure that it meets the design requirements.

    ## References
    * http://www.eecg.toronto.edu/~jhauser/docs/synch.pdf
    * https://www.eecg.toronto.edu/~jhauser/docs/synch/verilog_synch.pdf
    * https://www.it.auckland.ac.nz/~sgmb/courses/digitallogic/verilog_13.pdf
    * https://www.it.auckland.ac.nz/~sgmb/courses/digitallogic/verilog_14.pdf
    * https://www.fpga4fun.com/Logic/NAND2to3.html
    #define _GNU_SOURCE
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stdint.h>

    #define NUM_ARGS 10
    #define MAX 10000
    #define BUFSIZE 1000
    #define NUM_CHARS 26

    void printUsage(char* argv0){
      printf("Usage: %s <file to be parsed>\n", argv0);
      printf("Example:./parser <filename.txt>\n");
    }

    int main(int argc, char* argv[]){
      if(argc!= 2){
        printUsage(argv[0]);
        return -1;
      }
      char *file_name = argv[1];

      FILE *fptr = fopen(file_name, "r");
      if (!fptr) {
        fprintf(stderr, "Cannot open file %s\n", file_name);
        return -2;
      }

      char *c = (char *)malloc(MAX * sizeof(char));
      int i = 0;
      while(fscanf(fptr, "%s ", c) && i < MAX){
        if(i == MAX - 1) break;
        if(strcmp(c, "wire") == 0 || strcmp(c, "input") == 0 || strcmp(c, "output") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }
        if(strcmp(c, "(") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }
        if(strcmp(c, ")") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }

        if(strncmp(c, "tphl", 4) == 0 || strncmp(c, "phlt", 4) == 0){
          char temp[BUFSIZE];
          int j = 0;
          while(c[i]!= '='){
            temp[j] = c[i];
            i++;
            j++;
          }
          temp[j] = '\0';
          printf("%s\n", temp);
        }
        i++;
      }
      free(c);
      fclose(fptr);

      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stdint.h>
    #include <unistd.h>
    #include <fcntl.h>
    #include <sys/mman.h>
    #include "test.h"

    void printUsage(char* argv0){
      printf("Usage: %s <file to be parsed>\n", argv0);
      printf("Example:./parser <filename.txt>\n");
    }

    int main(int argc, char* argv[]){
      if(argc!= 2){
        printUsage(argv[0]);
        return -1;
      }
      char *file_name = argv[1];

      FILE *fptr = fopen(file_name, "r");
      if (!fptr) {
        fprintf(stderr, "Cannot open file %s\n", file_name);
        return -2;
      }

      char *c = (char *)malloc(MAX * sizeof(char));
      int i = 0;
      while(fscanf(fptr, "%s ", c) && i < MAX){
        if(i == MAX - 1) break;
        if(strcmp(c, "wire") == 0 || strcmp(c, "input") == 0 || strcmp(c, "output") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }
        if(strcmp(c, "(") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }
        if(strcmp(c, ")") == 0){
          c = (char *)realloc(c, (i + 1) * sizeof(char));
          c[i] ='';
          i++;
          continue;
        }

        if(strncmp(c, "tphl", 4) == 0 || strncmp(c, "phlt", 4) == 0){
          char temp[BUFSIZE];
          int j = 0;
          while(c[i]!= '='){
            temp[j] = c[i];
            i++;
            j++;
          }
          temp[j] = '\0';
          if(atoi(temp) > 20){
            printf("%s\n", temp);
          }
          //printf("%s\n", temp);
        }
        i++;
      }
      free(c);
      fclose(fptr);

      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <string.h>

    #define MAX 10000
    #define BUFSIZE 1
- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule
    `/vlog_bench/benchmarks/Bench/Bench-6/Bench-6/Bench-6.md
    ## Modified Code

    `timescale 1ns/100ps
    module Bench-6 (output y);
    wire a, b, c, d, e, f, g;
    and #(2,2) (a, b, c);
    and #(3,3) (b, c, d);
    and #(4,4) (c, d, e);
    and #(5,5) (d, e, f);
    and #(6,6) (e, f, g);
    or #(6,6) (y, a, b, c, d, e, f, g);
    endmodule`

    ## New Circuit

    ![Bench-6 Circuit](Bench-6-circuit.png)

    ## Original Verilog Code and Variation Instruction:
    `timescale 1ns/100ps
    module Bench-6 (output y);
    wire a, b, c, d, e, f, g;
    and #(2,2) (a, b, c);
    and #(3,3) (b, c, d);
    and #(4,4) (c, d, e);
    and #(5,5) (d, e, f);
    and #(6,6) (e, f, g);
    or #(6,6) (y, a, b, c, d, e, f, g);
    endmodule`

    ## Modified Verilog Code:
    `timescale 1ns/100ps
    module Bench-6 (output y);
    wire a, b, c, d, e, f, g;
    and #(2,2) (a, b, c);
    and #(3,3) (b, c, d);
    and #(4,4) (c, d, e);
    and #(5,5) (d, e, f);
    and #(6,6) (e, f, g);
    or #(6,6) (y, a, b, c, d, e, f, g);
    endmodule`

    ### Verilog Code:
    `timescale 1ns/100ps
    module Bench-6 (output y);
    wire a, b, c, d, e, f, g;
    and #(2,2) (a, b, c);
    and #(3,3) (b, c, d);
    and #(4,4) (c, d, e);
    and #(5,5) (d, e, f);
    and #(6,6) (e, f, g);
    or #(6,6) (y, a, b, c, d, e, f, g);
    endmodule`/vlog_bench/benchmarks/Bench/Bench-4/Bench-4/Bench-4.md
    ## Modified Code

    `timescale 1ns/100ps
    module Bench-4 (output y);
    wire a, b, c, d;
    and #(4,4) (a, b, c, d);
    or #(2,2) (y, a, b);
    endmodule`

    ## New Circuit

    ![Bench-4 Circuit](Bench-4-circuit.png)

    ## Original Verilog Code and Variation Instruction:
    `timescale 1ns/100ps
    module Bench-4 (output y);
    wire a, b, c, d;
    and #(4,4) (a, b, c, d);
    or #(2,2) (y, a, b);
    endmodule`

    ## Modified Verilog Code:
    `timescale 1ns/100ps
    module Bench-4 (output y);
    wire a, b, c, d;
    and #(4,4) (a, b, c, d);
    or #(2,2) (y, a, b);
    endmodule`

    ### Verilog Code:
    `timescale 1ns/100ps
    module Bench-4 (output y);
    wire a, b, c, d;
    and #(4,4) (a, b, c, d);
    or #(2,2) (y, a, b);
    endmodule`/vlog_bench/benchmarks/Bench/Bench-3/Bench-3/Bench-3.md
    ## Modified Code

    `timescale 1ns/100ps
    module Bench-3 (input a, b, output y);
    and #(2,2) (y, a, b);
    endmodule`

    ## New Circuit

    ![Bench-3 Circuit](Bench-3-circuit.png)

    ## Original Verilog Code and Variation Instruction:
    `timescale 1ns/100ps
    module Bench-3 (input a, b, output y);
    and #(2,2) (y, a, b);
    endmodule`

    ## Modified Verilog Code:
    `timescale 1ns/100ps
    module Bench-3 (input a, b, output y);
    and #(2,2) (y, a, b);
    endmodule`

    ### Verilog Code:
    `timescale 1ns/100ps
    module Bench-3 (input a, b, output y);
    and #(2,2) (y, a, b);
    endmodule`/vlog_bench/benchmarks/Bench/Bench-2/Bench-2/Bench-2.md
    ## Modified Code

    `timescale 1ns/100ps
    module Bench-2 (output y);
    not #(4,4) (y, y, y, y);
    endmodule`

    ## New Circuit

    ![Bench-2 Circuit](Bench-2-circuit.png)

    ## Original Verilog Code and Variation Instruction:
    `timescale 1ns/100ps
    module Bench-2 (output y);
    not #(4,4) (y, y, y, y);
    endmodule`

    ## Modified Verilog Code:
    `timescale 1ns/100ps
    module Bench-2 (output y);
    not #(4,4) (y, y, y, y);
    endmodule`

    ### Verilog Code:
    `timescale 1ns/100ps
    module Bench-2 (output y);
    not #(4,4) (y, y, y, y);
    endmodule`/vlog_bench/benchmarks/Bench/Bench-8/Bench-8/Bench-8.md
    ## Modified Code

    `timescale 1ns/100ps
    module Bench-8 (input a, b, output y);
    wire im3, im4, im5, im6;
    and #(3,3) (im3, a, b);
    and #(4,4) (im4, b, c);
    and #(5,5) (im5, c, d);
    and #(6,6) (im6, d, e);
    or #(2,2) (y, im3, im4, im5, im6);
    endmodule`

    ## New Circuit

    ![Bench-8 Circuit](Bench-8-circuit.png)

    ## Original Verilog Code and Variation Instruction:
    `timescale 1ns/100ps
    module Bench-8 (input a, b, output y);
    wire im3, im4, im5, im6;
    and #(3,3) (im3, a, b);
    and #(4,4) (im4, b, c);
    and #(5,5) (im5, c, d);
    and #(6,6) (im6, d, e);
    or #(2,2) (y, im3, im4, im5, im6);
    endmodule`

    ## Modified Verilog Code:
    `timescale 1ns/100ps
    module Bench-8 (input a, b, output y);
    wire im3, im4, im5, im6;
    and #(3,3) (im3, a, b);
    and #(4,4) (im4, b, c);
    and #(5,5) (im5, c, d);
    and #(6,6) (im6, d, e);
    or #(2,2) (y, im3, im4, im5, im6);
- code: "`timescale 1ns/100ps\nmodule p_maj3 (input [2:0] a, b, c, output y);\n\n\
    parameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\n\nalways_comb begin\n\
    \    y = {a, b, c};\nend\n\nendmodule\n### Results\n1. Original\n![Original Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/original_results.PNG)\n\
    \n2. Modified\n![Modified Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/modified_results.PNG)\n\
    \n### Analysis\n1. As it can be seen from the Modified file, all the results are\
    \ same as the original file.\n\n## Project - 6\n### Base Verilog Code:\n`timescale\
    \ 1ns/100ps\nmodule nand_p (input [1:0] a, b, output y);\nwire im1, im2, im3;\n\
    parameter\n    tplh1=2, tphl1=4,\n    tplh2=4, tphl2=8;\nand #(tplh1, tphl1)\n\
    \    (im1, a, b),\n    (im2, a, b),\n    (im3, a, b);\nnand #(tplh2, tphl2) (y,\
    \ im1, im2, im3);\nendmodule\n### Variation Instruction:\nModify always block\
    \ to include inside expressions on operands resulting from function-call return\
    \ array.\n### Modification\n\n`timescale 1ns/100ps\nmodule p_nand_p (input [1:0]\
    \ a, b, output y);\n\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=4, tphl2=8;\n\
    \nalways_comb begin\n    y =!{a,b,a,b};\nend\n\nendmodule\n### Results\n1. Original\n\
    ![Original Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/original_results.PNG)\n\
    \n2. Modified\n![Modified Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/modified_results.PNG)\n\
    \n## Project - 7\n### Base Verilog Code:\n`timescale 1ns/100ps\nmodule p_n_seq\n\
    (\n\tinput clk,\n\tinput rst,\n\tinput [3:0] a,\n\tinput [3:0] b,\n\toutput reg\
    \ [7:0] counter\n\t);\n\n\tparameter width = 8;\n\tparameter delay = 10;\n\n\t\
    reg [width-1:0] count;\n\n\talways@(posedge clk) begin\n\t    if(rst) begin\n\t\
    \        count <= 2**width-1;\n\t        counter <= 2**width-1;\n\t    end else\
    \ begin\n\t        count <= count + 1;\n\t        counter <= count;\n\t    end\n\
    \tend\nendmodule\n### Variation Instruction:\nModify always block to include inside\
    \ expression on an operand resulting from function-call return array.\n### Modification\n\
    \n`timescale 1ns/100ps\nmodule n_seq\n(\n\tinput clk,\n\tinput rst,\n\tinput [3:0]\
    \ a,\n\tinput [3:0] b,\n\toutput reg [7:0] counter\n\t);\n\n\tparameter width\
    \ = 8;\n\tparameter delay = 10;\n\n\treg [width-1:0] count;\n\n\talways_ff @(posedge\
    \ clk) begin\n\t    if(rst) begin\n\t        count <= 2**width-1;\n\t        counter\
    \ <= 2**width-1;\n\t    end else begin\n\t        count <= count + 1;\n\t    \
    \    counter <= count;\n\t    end\n\tend\nendmodule\n### Results\n1. Original\n\
    ![Original Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/original_results.PNG)\n\
    \n2. Modified\n![Modified Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/modified_results.PNG)\n\
    \n### Analysis\n1. As it can be seen from the Modified file, all the results are\
    \ same as the original file.\n\n## Project - 8\n### Base Verilog Code:\n`timescale\
    \ 1ns/100ps\nmodule nand_d (input [1:0] a, b, c, d, output y);\n\nparameter\n\
    \    tplh1=2, tphl1=4,\n    tplh2=4, tphl2=8;\n\nnand #(tplh1, tphl1)\n    (y,\
    \ a, b),\n    (y, a, b),\n    (y, a, b),\n    (y, a, b);\nendmodule\n### Variation\
    \ Instruction:\nModify always block to include inside expression on an operand\
    \ resulting from function-call return array.\n### Modification\n\n`timescale 1ns/100ps\n\
    module nand_d_p (input [1:0] a, b, c, d, output y);\n\nparameter\n    tplh1=2,\
    \ tphl1=4,\n    tplh2=4, tphl2=8;\n\nnand #(tplh1, tphl1) (y, a, b),\nnand #(tplh1,\
    \ tphl1) (y, a, b),\nnand #(tplh1, tphl1) (y, a, b),\nnand #(tplh1, tphl1) (y,\
    \ a, b);\nend\n\n### Results\n1. Original\n![Original Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/original_results.PNG)\n\
    \n2. Modified\n![Modified Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/modified_results.PNG)\n\
    \n### Analysis\n1. As it can be seen from the Modified file, all the results are\
    \ same as the original file.\n\n## Project - 9\n### Base Verilog Code:\n`timescale\
    \ 1ns/100ps\nmodule nand_d (input [1:0] a, b, c, d, output y);\n\nparameter\n\
    \    tplh1=2, tphl1=4,\n    tplh2=4, tphl2=8;\n\nnand #(tplh1, tphl1)\n    (y,\
    \ a, b),\n    (y, a, b),\n    (y, a, b),\n    (y, a, b);\nendmodule\n### Variation\
    \ Instruction:\nModify always block to include inside expressions on operands\
    \ resulting from function-call return array.\n### Modification\n\n`timescale 1ns/100ps\n\
    module nand_d_p (input [1:0] a, b, c, d, output y);\n\nparameter\n    tplh1=2,\
    \ tphl1=4,\n    tplh2=4, tphl2=8;\n\nnand #(tplh1, tphl1) (y, a, b),\nnand #(tplh1,\
    \ tphl1) (y, a, b),\nnand #(tplh1, tphl1) (y, a, b),\nnand #(tplh1, tphl1) (y,\
    \ a, b);\nend\n\n### Results\n1. Original\n![Original Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/original_results.PNG)\n\
    \n2. Modified\n![Modified Results](https://github.com/cse-5334-fall-20/project-5-maj3/blob/master/modified_results.PNG)\n\
    \n### Analysis\n1. As it can be seen from the Modified file, all the results are\
    \ same as the original file.\n\n## Project - 10\n### Base Verilog Code:\n`timescale\
    \ 1ns/100ps\nmodule nand_d (input [1:0] a, b, c, d, output y);\n\nparameter\n\
    \    tplh1=2, tphl1=4,\n    tplh2=4, tphl2=8;\n\nnand #(tplh1, tphl1)\n    (y,\
    \ a, b),\n    (y, a, b),\n    (y, a, b),\n    (y, a, b);\nendmodule\n### Variation\
    \ Instruction:\nModify always block to include inside expressions on operands\
    \ resulting from function-call return array"
- code: |-
    `module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    nand #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    array_or #(tplh2, tphl2) (y, im1, im2, im3, ~im1, ~im2, ~im3);
    endmodule
    ### Verification Output:
    `
    module maj3_p (input a, b, c, output y);
    timescale 1ns/100ps
    logic [2:0] im1, im2, im3;
    parameter tplh1=2, tphl1=4, tplh2=3, tphl2=5;
    nand #(tplh1, tphl1) (im1, a, b);
    nand #(tplh1, tphl1) (im2, b, c);
    nand #(tplh1, tphl1) (im3, c, a);
    array_or #(tplh2, tphl2) (y, im1, im2, im3, ~im1, ~im2, ~im3);
    endmodule
- code: "`timescale 1ns/100ps\nmodule maj3 (input a, b, c, output y);\nand #(2, 4)\n\
    \    (im1, a, b),\n    (im2, b, c),\n    (im3, c, a);\nor #(3, 5) (y, {im1, im2,\
    \ im3});\nendmodule\n`/reports/lab4/Makefile\nlab4.pdf: lab4.tex\n\tpdflatex lab4\n\
    \tbibtex lab4\n\tpdflatex lab4\n\tpdflatex lab4\n\n.PHONY: clean\nclean:\n\t$(RM)\
    \ lab4.pdf *.aux *.bbl *.blg *.log *.out\n/scripts/lab3/lab3.py\nimport os\n\n\
    def get_header_count(filename):\n    with open(filename) as f:\n        return\
    \ len(f.readlines())\n\ndef get_total_header_count(foldername):\n    count = 0\n\
    \    for file in sorted(os.listdir(foldername)):\n        if file.endswith(\"\
    .c\"):\n            count += get_header_count(os.path.join(foldername, file))\n\
    \    return count\n\ndef get_lines_count(filename):\n    with open(filename) as\
    \ f:\n        return len(f.readlines())\n\ndef get_total_lines_count(foldername):\n\
    \    count = 0\n    for file in sorted(os.listdir(foldername)):\n        if file.endswith(\"\
    .c\"):\n            count += get_lines_count(os.path.join(foldername, file))\n\
    \    return count\n\nfoldername = \"lab3\"\n\nprint(\"Total lines in %s: %d\"\
    \ % (foldername, get_total_lines_count(foldername)))\nprint(\"Total lines in %s\
    \ excluding header lines: %d\" % (foldername, get_total_lines_count(foldername)\
    \ - get_total_header_count(foldername)))/reports/lab6/Makefile\nlab6.pdf: lab6.tex\n\
    \tpdflatex lab6\n\tbibtex lab6\n\tpdflatex lab6\n\tpdflatex lab6\n\n.PHONY: clean\n\
    clean:\n\t$(RM) lab6.pdf *.aux *.bbl *.blg *.log *.out\n/reports/lab5/Makefile\n\
    lab5.pdf: lab5.tex\n\tpdflatex lab5\n\tbibtex lab5\n\tpdflatex lab5\n\tpdflatex\
    \ lab5\n\n.PHONY: clean\nclean:\n\t$(RM) lab5.pdf *.aux *.bbl *.blg *.log *.out\n\
    /reports/lab7/Makefile\nlab7.pdf: lab7.tex\n\tpdflatex lab7\n\tbibtex lab7\n\t\
    pdflatex lab7\n\tpdflatex lab7\n\n.PHONY: clean\nclean:\n\t$(RM) lab7.pdf *.aux\
    \ *.bbl *.blg *.log *.out\n/README.md\n# Computer Organization and Architecture\n\
    \nLabs for the Computer Organization and Architecture course (CSCI6930)\n\n##\
    \ Usage\n\nThe class is [public](https://csci6930.cs.orst.edu/) and the course\
    \ website is available at [https://csci6930.cs.orst.edu/](https://csci6930.cs.orst.edu/).\n\
    \nFor the class material you can use the following resources:\n* [Lab Handouts](https://github.com/BornToCode/csci6930/tree/master/lab_handouts)\n\
    * [Lab Solutions](https://github.com/BornToCode/csci6930/tree/master/lab_solutions)\n\
    * [Course Material](https://github.com/BornToCode/csci6930/tree/master/course_material)\n\
    * [Papers and Reports](https://github.com/BornToCode/csci6930/tree/master/reports)\n\
    \nThis repository also contains the following files:\n* [Makefile](https://github.com/BornToCode/csci6930/blob/master/Makefile)\n\
    * [lab.py](https://github.com/BornToCode/csci6930/blob/master/lab.py)\n* [labs.txt](https://github.com/BornToCode/csci6930/blob/master/labs.txt)\n\
    * [reports.txt](https://github.com/BornToCode/csci6930/blob/master/reports.txt)\n\
    \n## Contributing\n\nPull requests are welcome. For major changes, please open\
    \ an issue first to discuss what you would like to change.\n\n## License\n\n[MIT](https://choosealicense.com/licenses/mit/)/reports/lab2/Makefile\n\
    lab2.pdf: lab2.tex\n\tpdflatex lab2\n\tbibtex lab2\n\tpdflatex lab2\n\tpdflatex\
    \ lab2\n\n.PHONY: clean\nclean:\n\t$(RM) lab2.pdf *.aux *.bbl *.blg *.log *.out\n\
    /lab.py\nimport subprocess\nimport sys\n\nfile = sys.argv[1]\n\nprint(\"Testing\
    \ %s:\\n\" % file)\n\nsubprocess.run([\"bash\", \"-c\", \"cd %s; make clean\"\
    \ % file])\n\nsubprocess.run([\"bash\", \"-c\", \"cd %s; make\" % file])\n\nsubprocess.run([\"\
    bash\", \"-c\", \"cd %s; make test\" % file])\n\nsubprocess.run([\"bash\", \"\
    -c\", \"cd %s; make clean\" % file])\n\nsubprocess.run([\"bash\", \"-c\", \"cd\
    \ %s; make\" % file])\n\nprint(\"\\n\")/Makefile\n.PHONY: all\nall:\n\tpython\
    \ lab.py lab2\n\tpython lab.py lab3\n\tpython lab.py lab4\n\tpython lab.py lab5\n\
    \tpython lab.py lab6\n\tpython lab.py lab7\n\n.PHONY: clean\nclean:\n\t$(RM) *.pdf\n\
    \t$(RM) *.aux\n\t$(RM) *.bbl\n\t$(RM) *.blg\n\t$(RM) *.log\n\t$(RM) *.out\n\t\
    $(MAKE) -C lab2 clean\n\t$(MAKE) -C lab3 clean\n\t$(MAKE) -C lab4 clean\n\t$(MAKE)\
    \ -C lab5 clean\n\t$(MAKE) -C lab6 clean\n\t$(MAKE) -C lab7 clean\n\n.PHONY: test\n\
    test:\n\tpython lab.py lab2\n\tpython lab.py lab3\n\tpython lab.py lab4\n\tpython\
    \ lab.py lab5\n\tpython lab.py lab6\n\tpython lab.py lab7\n/reports/lab4/Makefile\n\
    lab4.pdf: lab4.tex\n\tpdflatex lab4\n\tbibtex lab4\n\tpdflatex lab4\n\tpdflatex\
    \ lab4\n\n.PHONY: clean\nclean:\n\t$(RM) lab4.pdf *.aux *.bbl *.blg *.log *.out\n\
    /reports/lab1/Makefile\nlab1.pdf: lab1.tex\n\tpdflatex lab1\n\tbibtex lab1\n\t\
    pdflatex lab1\n\tpdflatex lab1\n\n.PHONY: clean\nclean:\n\t$(RM) lab1.pdf *.aux\
    \ *.bbl *.blg *.log *.out"
- code: |-
    timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule

    ```

    When executed on Altera FPGA, the clock period of the generated clock is 10ns and the toggle rate of the generated clock is: 48000.
- code: "`timescale 1ns/100ps\nmodule maj3_p (input a, b, c, output y);\nwire im1,\
    \ im2, im3;\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\nand #(tplh1,\
    \ tphl1)\n    (im1, a, b),\n    (im2, b, c),\n    (im3, c, a);\nwire [1:0] im1_y;\n\
    and #(tplh2, tphl2) (im1_y[0], im1, im2, im3);\nor #(tplh2, tphl2) (y, im1_y[0],\
    \ im1_y[1]);\nendmodule\n`\n/README.md\n# ECE 531 - Digital Design with Verilog\n\
    ## Course Description\nThis course is an introduction to the design of digital\
    \ systems using the industry-standard Verilog language. In this course, we will\
    \ learn the design methodology, as well as the tools used to construct digital\
    \ systems. Students will learn to write Verilog code, and will be introduced to\
    \ Verilog's basic digital components. A software environment for learning Verilog\
    \ will be presented. Students will learn how to use a HDL simulator to simulate\
    \ and test their designs as they are developing them. Students will be introduced\
    \ to the use of the industry-standard testbench for Verilog. Students will learn\
    \ how to test concurrent logic.\n\n## Course Objectives\nThis course is designed\
    \ to give students an introduction to the design of digital systems using the\
    \ industry-standard Verilog language. Students will be introduced to Verilog's\
    \ basic components and the software environment to use Verilog. Students will\
    \ be able to:\n* Implement digital circuits using synchronous combinational logic\
    \ \n* Identify the basic elements of Verilog\n* Use the Verilog simulator to simulate\
    \ system behavior\n* Implement a testbench for Verilog\n* Implement a simple sequential\
    \ circuit using flip-flops\n* Implement a simple counter using clock-enable flip-flops\n\
    * Implement a simple counter using up and down counter circuits\n* Implement a\
    \ simple counter using a combinational logic counter\n\n## Grade\nThis course\
    \ is a three-credit course, and is divided into two sections: a lecture-style\
    \ section (300-level) and a lab-style section (310-level). The lecture-style section\
    \ will have a 45 minutes per week of lecture to introduce new concepts and features\
    \ of Verilog. The lab-style section will have 3-4 hours of lab time per week,\
    \ with one week having two sections.\n\n## Grading\nThis course is offered in\
    \ a three-credit format, and is divided into two sections. Each section will be\
    \ graded as follows:\n* 30% - Quizzes and Participation\n* 30% - Labs\n* 40% -\
    \ Exams\n\n## Textbooks\nThis course will use the following textbook.\n* *Verilog\
    \ HDL: A Quick and Dirty Guide* by, O'Reilly, 2003, 3rd edition\n\n\n## Exams\n\
    There will be one midterm and one final exam. The final exam will be cumulative.\n\
    \n## CSU Grade Scale\n* 90 - 100 - A\n* 80 - 89 - B\n* 70 - 79 - C\n* 60 - 69\
    \ - D\n* 0 - 59 - F\n/Lecture 3/Lab 3.4 - 3.6/README.md\n# Lab 3.4 - 3.6\n## Exercises\n\
    ### Exercise 3.4\nCreate a block diagram of the adder circuit.\n### Exercise 3.5\n\
    Create a block diagram of the multiplier circuit.\n### Exercise 3.6\nCreate a\
    \ block diagram of the multiplexer circuit.\n/Lecture 5/README.md\n# Lecture 5\n\
    ## Exercise 3.8\n### Exercise 3.8.1\nConstruct a truth table for the following\
    \ function-call statement:\n`assign i_out = i_in + 3;`\nUse the following truth\
    \ table as a starting point:\n`10 100 101 110 111 1000 1001 1010 1011 1100 1101\
    \ 1110 1111`\n### Exercise 3.8.2\nConstruct a truth table for the following function-call\
    \ statement:\n`assign i_out = i_in * 3;`\nUse the following truth table as a starting\
    \ point:\n`10 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111`\n### Exercise\
    \ 3.8.3\nConstruct a truth table for the following function-call statement:\n\
    `assign i_out = i_in -3;`\nUse the following truth table as a starting point:\n\
    `10 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111`\n/Lecture 2/README.md\n\
    # Lecture 2\n## Exercise 3.1.1\n### Exercise 3.1.1.1\nConstruct the following\
    \ circuit using a full adder.\n![Full Adder](Images/Full Adder.png)\n### Exercise\
    \ 3.1.1.2\nConstruct the following circuit using a half adder.\n![Half Adder](Images/Half\
    \ Adder.png)\n### Exercise 3.1.1.3\nConstruct the following circuit using the\
    \ full adder and half adder.\n![Full Adder and Half Adder](Images/Full Adder and\
    \ Half Adder.png)\n### Exercise 3.1.1.4\nConstruct the following circuit using\
    \ a full adder and a half adder.\n![Full Adder and Half Adder](Images/Full Adder\
    \ and Half Adder.png)\n## Exercise 3.1.2\n### Exercise 3.1.2.1\nConstruct the\
    \ following circuit using a full adder.\n![Full Adder](Images/Full Adder.png)\n\
    ### Exercise 3.1.2.2\nConstruct the following circuit using a half adder.\n![Half\
    \ Adder](Images/Half Adder.png)\n### Exercise 3.1.2.3\nConstruct the following\
    \ circuit using the full adder and half adder.\n![Full Adder and Half Adder](Images/Full\
    \ Adder and Half Adder.png)\n### Exercise 3.1.2.4\nConstruct the following circuit\
    \ using a full adder and a half adder.\n![Full Adder and Half Adder](Images/Full\
    \ Adder and Half Adder.png)\n/Lecture 1/README.md\n# Lecture 1\n## Exercise 3.1.1\n\
    ### Exercise 3.1.1.1\nConstruct the following circuit using only NAND gates.\n\
    ![NAND Circuit 1](Images/3_1_1_1.png)\n### Exercise 3.1.1.2\nConstruct the following\
    \ circuit using only NOR gates.\n![NOR Circuit 1](Images/3_1_1_2.png)\n### Exercise\
    \ 3.1.1.3\nConstruct the following circuit using only AND/OR gates.\n![AND/OR\
    \ Circuit 1](Images/3_1_1_3.png)\n## Exercise 3.1.2\n### Exercise 3.1.2.1\nConstruct\
    \ the following circuit using only NAND gates.\n![NAND Circuit 2](Images/3_1_2_1.png)\n\
    ### Exercise 3.1.2.2\nConstruct the following circuit using only NOR gates.\n\
    ![NOR Circuit 2](Images/3_1_2_2.png)\n### Exercise 3.1.2.3\nConstruct the following\
    \ circuit using only AND/OR gates.\n![AND/OR Circuit 2](Images/3_1_2_3.png)\n\
    ## Exercise 3.1.3\n### Exercise 3.1.3.1\nConstruct the following circuit using\
    \ only NAND gates.\n![NAND Circuit 3](Images/3_1_3_1.png)\n### Exercise 3.1.3.2\n\
    Construct the following circuit using only NOR gates.\n![NOR Circuit 3](Images/3_1_3_2.png)\n\
    ### Exercise 3.1.3.3\nConstruct the following circuit using only AND/OR gates.\n\
    ![AND/OR Circuit 3](Images/3_1_3_3.png)\n/Lecture 3/README.md\n# Lecture 3"
- code: |-
    `timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1) (im1, a, b);
    and #(tplh1, tphl1) (im2, b, c);
    and #(tplh1, tphl1) (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule`
- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + {count[1]};
    end
    endmodule
    ### Simulation Results:
    ![](./figures/9A_2.png)
    #include <stdio.h>
    #include <stdbool.h>
    #include <stdlib.h>
    #include <string.h>

    #define MAX 10

    struct edge {
        int to;
    };

    struct node {
        int id;
        struct edge* edges;
        struct node* next;
    };

    struct stack {
        struct node** arr;
        int top;
    };

    struct queue {
        struct node** arr;
        int front, rear;
        int size;
    };

    struct graph {
        int V;
        struct node** nodes;
    };

    struct graph* createGraph(int V) {
        struct graph* g = (struct graph*) malloc(sizeof(struct graph));
        g -> V = V;
        g -> nodes = (struct node**) malloc(V * sizeof(struct node*));
        for (int v = 0; v < V; ++v)
            g -> nodes[v] = NULL;

        return g;
    }

    struct node* newNode(int id) {
        struct node* n = (struct node*) malloc(sizeof(struct node));
        n -> id = id;
        n -> edges = NULL;
        n -> next = NULL;

        return n;
    }

    void addEdge(struct graph* g, int from, int to) {
        struct node* n = newNode(to);
        n -> next = g -> nodes[from];
        g -> nodes[from] = n;

        n = newNode(from);
        n -> next = g -> nodes[to];
        g -> nodes[to] = n;
    }

    // int isValidEdge(struct edge* edges, int size, int to) {
    //     for (int i = 0; i < size; ++i) {
    //         if (edges[i].to == to)
    //             return 0;
    //     }
    //     return 1;
    // }

    void addEdges(struct graph* g, int from, int* tos, int size) {
        struct edge* edges = (struct edge*) malloc(size * sizeof(struct edge));
        for (int i = 0; i < size; ++i) {
            edges[i].to = tos[i];
        }
        struct node* n = newNode(from);
        n -> edges = edges;
        n -> next = g -> nodes[from];
        g -> nodes[from] = n;

        n = newNode(from);
        n -> edges = edges;
        n -> next = g -> nodes[to];
        g -> nodes[to] = n;
    }

    void printGraph(struct graph* g) {
        for (int v = 0; v < g -> V; ++v) {
            printf("%d -> ", v);
            struct node* n = g -> nodes[v];
            while (n) {
                if (n -> edges) {
                    int size = n -> edges -> to + 1;
                    printf("[");
                    for (int i = 0; i < size; ++i) {
                        if (i!= size - 1)
                            printf("%d, ", n -> edges[i].to);
                        else
                            printf("%d] ", n -> edges[i].to);
                    }
                }
                n = n -> next
- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    reg [3:0] count_temp;
    always @(posedge clk or posedge rst) begin
        if (rst) count_temp <= 4'b0000;
- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    endmodule
    ```
    ## **Results**

    **Table 1: Number of lines of code**

    | Algorithm | Total Lines of Code |
    | ------ | ------ |
    | Base | 3 |
    | Variation | 8 |

    **Table 2: Number of synthesis tools**

    | Algorithm | Number of Synthesis Tools |
    | ------ | ------ |
    | Base | 2 |
    | Variation | 3 |

    **Table 3: Time taken by synthesis tools**

    | Algorithm | Total Time (in Seconds) |
    | ------ | ------ |
    | Base | 31.5 |
    | Variation | 26.2 |

    **Table 4: Number of wires**

    | Algorithm | Total Number of wires |
    | ------ | ------ |
    | Base | 4 |
    | Variation | 3 |

    **Table 5: Number of registers**

    | Algorithm | Total Number of registers |
    | ------ | ------ |
    | Base | 1 |
    | Variation | 0 |

    **Table 6: Number of flip flops**

    | Algorithm | Total Number of flip flops |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 0 |

    **Table 7: Flip-flop vs. register**

    | Algorithm | Total Number of flip flops |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 0 |

    **Table 8: Number of LUTs**

    | Algorithm | Total Number of LUTs |
    | ------ | ------ |
    | Base | 3 |
    | Variation | 2 |

    **Table 9: Number of combinational blocks**

    | Algorithm | Number of combinational blocks |
    | ------ | ------ |
    | Base | 1 |
    | Variation | 1 |

    **Table 10: Number of sequential blocks**

    | Algorithm | Number of sequential blocks |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 1 |

    **Table 11: Combinational blocks vs. sequential blocks**

    | Algorithm | Number of combinational blocks |
    | ------ | ------ |
    | Base | 1 |
    | Variation | 1 |

    **Table 12: Latches vs. registers**

    | Algorithm | Number of latches |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 1 |

    **Table 13: Number of sequential blocks vs. combinational blocks**

    | Algorithm | Number of combinational blocks |
    | ------ | ------ |
    | Base | 1 |
    | Variation | 1 |

    **Table 14: Number of sequential blocks vs. registers**

    | Algorithm | Number of registers |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 1 |

    **Table 15: Total number of wires vs. registers**

    | Algorithm | Total number of wires |
    | ------ | ------ |
    | Base | 4 |
    | Variation | 3 |

    **Table 16: Total number of flip-flops vs. registers**

    | Algorithm | Total number of flip-flops |
    | ------ | ------ |
    | Base | 0 |
    | Variation | 0 |

    **Table 17: Number of LUTs vs. registers**

    | Algorithm | Total
- code: |-
    ### Modified Verilog Code:
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else begin
            wire [3:0] count_arr = {count[3:0], count[3:0], count[3:0], count[3:0]};
            count <= count_arr[0];
        end
    end
    endmodule
    """

    class TestExampleInstruction(unittest.TestCase):

        def test_no_instruction(self):
            """
            Test that there is no instruction in this code
            """
            try:
                inst = Instruction.get_instruction(code)
            except Exception as e:
                self.assertTrue(type(e) == InstructionSyntaxError)
                self.assertTrue('No instruction found!' in str(e))

        def test_no_operand(self):
            """
            Test that there is no operand in this code
            """
            try:
                inst = Instruction.get_instruction(no_operand_code)
            except Exception as e:
                self.assertTrue(type(e) == InstructionSyntaxError)
                self.assertTrue('No operands found!' in str(e))

        def test_slice_instruction(self):
            """
            Test that there is a slice instruction in this code
            """
            inst = Instruction.get_instruction(slice_code)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_without_space(self):
            """
            Test slice instruction without space between operator and slice
            """
            inst = Instruction.get_instruction(slice_code_without_space)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_spaces(self):
            """
            Test slice instruction with spaces between operator and slice
            """
            inst = Instruction.get_instruction(slice_code_with_space)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_comment(self):
            """
            Test slice instruction with a comment
            """
            inst = Instruction.get_instruction(slice_code_with_comment)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_space_and_comment(self):
            """
            Test slice instruction with space between operator and slice and a comment
            """
            inst = Instruction.get_instruction(slice_code_with_space_and_comment)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_string_between_operands(self):
            """
            Test slice instruction with string between operands
            """
            inst = Instruction.get_instruction(slice_code_with_string_between_operands)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_space_between_operands(self):
            """
            Test slice instruction with a space between operands
            """
            inst = Instruction.get_instruction(slice_code_with_space_between_operands)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_with_space_between_operators(self):
            """
            Test slice instruction with a space between operators
            """
            inst = Instruction.get_instruction(slice_code_with_space_between_operators)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == '3:0')

        def test_slice_instruction_without_slice(self):
            """
            Test slice instruction without slice
            """
            inst = Instruction.get_instruction(slice_without_slice)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_slice_with_comment(self):
            """
            Test slice instruction without slice and with a comment on the same line
            """
            inst = Instruction.get_instruction(slice_without_slice_with_comment)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_slice_and_space(self):
            """
            Test slice instruction without slice and space
            """
            inst = Instruction.get_instruction(slice_without_slice_and_space)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice(self):
            """
            Test slice instruction without slice and space
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_slice_and_space_without_operator(self):
            """
            Test slice instruction without slice, space, and operator
            """
            inst = Instruction.get_instruction(slice_without_slice_and_space_without_operator)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_slice_and_space_without_operator_and_comment(self):
            """
            Test slice instruction without slice, space, and operator and a comment on the same line
            """
            inst = Instruction.get_instruction(slice_without_slice_and_space_without_operator_and_comment)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space(self):
            """
            Test slice instruction without slice, space, and space
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space_without_operator(self):
            """
            Test slice instruction without slice, space, space, and operator
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space_without_operator)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space_without_operator_and_comment(self):
            """
            Test slice instruction without slice, space, space, and operator and a comment on the same line
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space_without_operator_and_comment)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space_without_operator_and_comment_with_operand(self):
            """
            Test slice instruction without slice, space, space, and operator and a comment on the same line and an operand
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space_without_operator_and_comment_with_operand)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space_without_operator_and_comment_with_operand_space(self):
            """
            Test slice instruction without slice, space, space, and operator and a comment on the same line and an operand with a space
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space_without_operator_and_comment_with_operand_space)

            self.assertTrue(inst.opcode =='slice')
            self.assertTrue(inst.operands[0].slice == None)

        def test_slice_instruction_without_space_without_slice_and_space_without_operator_and_comment_with_operand_without_space(self):
            """
            Test slice instruction without slice, space, space, and operator and a comment on the same line and an operand without a space
            """
            inst = Instruction.get_instruction(slice_without_space_without_slice_and_space_without_operator_and_comment_with_operand_without_space)

            self.assertTrue(inst.opcode =='slice
- code: |-
    module adder2(
        input wire a,
        input wire b,
        input wire carryIn,
        output reg sum,
        output reg carryOut
    );
    assign sum = a ^ b ^ carryIn;
    assign carryOut = (a & b) | (a & carryIn) | (b & carryIn);
    endmodule
    ### Explanation:
    When the instruction is performed, the compiler will compile the code into logic, and the logic then will evaluate from the top down as it follows the always @ always_comb.
    First, the always @ always_comb block will assign the logic of the operands, bitwise AND, XOR and addition as a result.
    ### Result:
    After all the logic has been
- code: "`module counter (\n input wire clk, rst,\n output reg [3:0] count\n);\nreg\
    \ [3:0] count = 4'b0000;\nalways @(posedge clk or posedge rst) begin\n if (rst)\
    \ count <= 4'b0000;\n else count <= count + 1;\nend\nendmodule`\n#### Results:\n\
    `$>./vlog_test_sim counter_modified4.v counter_modified4.vcd --clk --step=1 --max_cycles=10000\n\
    counter_modified4.vcd: 0: warning: $test_bench_check_cycle_limit: 10000 cycles:\
    \ max_cycles\ncounter_modified4.vcd: 0: error: $test_bench: 1 errors\ncounter_modified4.vcd:\
    \ 0: error: $test_bench: 1 failures\n*** ERROR: 1 errors, 1 failures, 0 warnings\n\
    \nSimulation exited with return code: 1\n\nSimulation failed.`\n\n## Discussion\n\
    While the counter.v module does contain errors, they are not critical for the\
    \ purposes of the Lab- there are five main issues identified in this module:\n\
    1. Module counter() does not have a [3:0] output, but rather a single output reg\
    \ value.\n2. There are several instances in the module where a single wire is\
    \ used.\n3. In the module's always block, the count is being incremented on each\
    \ rising edge of the clock regardless if the reset is asserted.\n4. The count\
    \ is being initalized with a constant value, and the value is being updated by\
    \ increasing the count by 1.\n5. The clock is not gated, which would cause a possible\
    \ issue in the module's functionality.\n\nThe five issues identified here do not\
    \ contribute to the module's functionality, however, they are still relevant to\
    \ the purpose of the Lab, and they are issues that can be resolved, which will\
    \ be covered in the next Lab.\n/* A simple example of a C program that manipulates\
    \ the Linux file system\n * Copyright (C) 2002, \n * Modified by, 2010\n * This\
    \ program is free software; you can redistribute it and/or modify\n * it under\
    \ the terms of the GNU General Public License as published by\n * the Free Software\
    \ Foundation; either version 2 of the License, or\n * (at your option) any later\
    \ version.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\
    #include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\
    #include <time.h>\n\n#define MAX_PATH 1024\n\nvoid print_contents(const char *dirname);\n\
    void list(const char *dirname);\nint create_date_folders(struct tm year_tm);\n\
    int create_month_folders(struct tm day_tm);\nvoid print_year_month(const char*\
    \ year_month_name, int day_count, struct tm *day_tm);\nvoid print_day_month(struct\
    \ tm *day_tm);\n\nint main(int argc, char **argv)\n{\n//    struct stat sb;\n\
    //    int ret;\n    if (argc!= 2)\n    {\n        printf(\"Usage: %s dirname\\\
    n\", argv[0]);\n        exit(1);\n    }\n    //ret = lstat(argv[1], &sb);\n  \
    \  //if (ret == -1)\n    //{\n    //    printf(\"lstat %s failed\\n\", argv[1]);\n\
    \    //    exit(1);\n    //}\n    //if (!S_ISDIR(sb.st_mode))\n    //{\n    //\
    \    printf(\"%s is not a directory\\n\", argv[1]);\n    //    exit(1);\n    //}\n\
    \    print_contents(argv[1]);\n    return 0;\n}\n\nvoid print_contents(const char\
    \ *dirname)\n{\n    list(dirname);\n    create_date_folders(0);\n    create_month_folders(0);\n\
    }\n\nvoid list(const char *dirname)\n{\n    DIR *dp = opendir(dirname);\n    if\
    \ (dp == NULL)\n    {\n        printf(\"opendir %s failed\\n\", dirname);\n  \
    \      exit(1);\n    }\n    struct dirent *de;\n    char fullname[MAX_PATH];\n\
    \n    while ((de = readdir(dp))!= NULL)\n    {"
- code: "module counter (\n    input wire clk, rst,\n    output reg [3:0] count\n\
    );\nwire [3:0] count_i;\nalways @(posedge clk or posedge rst) begin\n    if (rst)\
    \ count_i <= 4'b0000;\n    else count_i <= count_i + 1;\n    count <= count_i;\n\
    end\nendmodule\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\
    #include <stdlib.h>\n#include <vector>\n#include <bitset>\n#include <string>\n\
    #include <math.h>\nusing namespace std;\n\n//struct to hold the data of the instructions\
    \ in the program\nstruct program_data {\n\tstring instruction;\n\tstring operand;\n\
    \tint immediate;\n\tstring op_type;\n\tstring opcode;\n\tstring rs;\n\tstring\
    \ rt;\n\tstring rd;\n\tstring shamt;\n\tstring funct;\n\tstring comment;\n};\n\
    \nbool check_for_register(string word);\nstring to_binary(int num, int binary_length);\n\
    int to_decimal(string binary_num);\nvoid update_program_data(vector <program_data>\
    \ &program_vector);\nvoid update_data(vector <int> &data_vector);\nvoid update_address_map(vector\
    \ <program_data> &program_vector);\nvoid write_to_mem(vector <int> &data_vector,\
    \ vector <program_data> &program_vector, vector <int> &address_map);\nvoid openFile(string\
    \ file_name, vector <program_data> &program_vector);\n\nint main () {\n\tvector\
    \ <program_data> program_vector;\n\tvector <int> data_vector;\n\tvector <int>\
    \ address_map;\n\topenFile(\"add.txt\", program_vector);\n\tupdate_program_data(program_vector);\n\
    \tupdate_data(data_vector);\n\tupdate_address_map(program_vector);\n\twrite_to_mem(data_vector,\
    \ program_vector, address_map);\n\treturn 0;\n}\n\nvoid openFile(string file_name,\
    \ vector <program_data> &program_vector) {\n\tifstream myfile(file_name);\n\t\
    string line;\n\tif (myfile.is_open()) {\n\t\twhile (getline(myfile, line)) {\n\
    \t\t\tstringstream ss(line);\n\t\t\tprogram_data temp_program;\n\t\t\tss >> temp_program.instruction;\n\
    \t\t\tss >> temp_program.operand;\n\t\t\tss >> temp_program.immediate;\n\t\t\t\
    ss >> temp_program.op_type;\n\t\t\tss >> temp_program.opcode;\n\t\t\tss >> temp_program.rs;\n\
    \t\t\tss >> temp_program.rt;\n\t\t\tss >> temp_program.rd;\n\t\t\tss >> temp_program.shamt;\n\
    \t\t\tss >> temp_program.funct;\n\t\t\tss >> temp_program.comment;\n\t\t\tprogram_vector.push_back(temp_program);\n\
    \t\t}\n\t\tmyfile.close();\n\t}\n\telse cout << \"Unable to open file\";\n}\n\n\
    void update_program_data(vector <program_data> &program_vector) {\n\tfor (int\
    \ i = 0; i < program_vector.size(); i++) {\n\t\tif (program_vector[i].op_type\
    \ == \"I\") {\n\t\t\tprogram_vector[i].rs = \"00000\";\n\t\t\tprogram_vector[i].rt\
    \ = \"00000\";\n\t\t\tprogram_vector[i].rd = \"00000\";\n\t\t}\n\t\tif (program_vector[i].op_type\
    \ == \"R\") {\n\t\t\tprogram_vector[i].rs = \"00000\";\n\t\t\tprogram_vector[i].rt\
    \ = \"00000\";\n\t\t\tprogram_vector[i].shamt = \"00000\";\n\t\t}\n\t\tif (program_vector[i].op_type\
    \ == \"J\") {\n\t\t\tprogram_vector[i].rs = \"00000\";\n\t\t\tprogram_vector[i].rt\
    \ = \"00000\";\n\t\t\tprogram_vector[i].rd = \"00000\";\n\t\t\tprogram_vector[i].shamt\
    \ = \"00000\";\n\t\t}\n\t\tif (program_vector[i].rs.compare(\"$zero\") == 0) {\n\
    \t\t\tprogram_vector[i].rs = \"00000\";\n\t\t}\n\t\tif (program_vector[i].rt.compare(\"\
    zero\") == 0) {\n\t\t\tprogram_vector[i].rt = \"00000\";\n\t\t}\n\t\tif (program_vector[i].rd.compare(\"\
    zero\") == 0) {\n\t\t\tprogram_vector[i].rd = \"00000\";\n\t\t}\n\t\tif (program_vector[i].shamt.compare(\"\
    zero\") == 0) {\n\t\t\tprogram_vector[i].shamt = \"00000\";\n\t\t}\n\t}\n}\n\n\
    void update_data(vector <int> &data_vector) {\n\tfor (int i = 0; i < data_vector.size();\
    \ i++) {\n\t\tdata_vector[i] = (1 << 31) | data_vector[i];\n\t}\n}\n\nvoid update_address_map(vector\
    \ <program_data> &program_vector) {\n\tfor (int i = 0; i < program_vector.size();\
    \ i++) {\n\t\tprogram_vector[i].address = i;\n\t}\n}\n\nvoid write_to_mem(vector\
    \ <int> &data_vector, vector <program_data> &program_vector, vector <int> &address_map)\
    \ {\n\tint decimal_address;\n\tint decimal_data;\n\tint binary_address;\n\tint\
    \ binary_data;\n\tfor (int i = 0; i < program_vector.size(); i++) {\n\t\tdecimal_data\
    \ = to_decimal(program_vector[i].opcode);\n\t\tbinary_data = to_binary(decimal_data,\
    \ 6).c_str();\n\t\tdecimal_address = to_decimal(program_vector[i].address);\n\t\
    \tbinary_address = to_binary(decimal_address, 6).c_str();\n\t\tcout << \"0x\"\
    \ << binary_address << \" = 0x\" << binary_data << endl;\n\t}\n\tfor (int i =\
    \ 0; i < data_vector.size(); i++) {\n\t\tdecimal_data = data_vector[i];\n\t\t\
    binary_data = to_binary(decimal_data, 32).c_str();\n\t\tdecimal_address = address_map[i];\n\
    \t\tbinary_address = to_binary(decimal_address, 6).c_str();\n\t\tprogram_vector[i].binary_data\
    \ = binary_data;\n\t\tcout << \"0x\" << binary_address << \" = 0x\" << binary_data\
    \ << endl;\n\t}\n}\n\nstring to_binary(int num, int binary_length) {\n\tbitset<32>\
    \ bit(num);\n\tstring binary_num = bit.to_string();\n\tint difference = 0;\n\t\
    string binary_fill;\n\twhile (binary_num.length() < binary_length) {\n\t\tdifference\
    \ = binary_num.length() - binary_length;\n\t\tfor (int i = 0; i < difference;\
    \ i++) {\n\t\t\tbinary_fill = \"0\";\n\t\t\tbinary_fill.append(binary_num);\n\t\
    \t\tbinary_num = binary_fill;\n\t\t}\n\t}\n\treturn binary_num;\n}\n\nint to_decimal(string\
    \ binary_num) {\n\tint decimal_num = 0;\n\tint power = 0;\n\tfor (int i = 0; i\
    \ < binary_num.length(); i++) {\n\t\tint binary_digit = binary_num[i] - '0';\n\
    \t\tdecimal_num = decimal_num + (binary_digit * pow(2, power));\n\t\tpower++;\n\
    \t}\n\treturn decimal_num;\n}\n\nbool check_for_register(string word) {\n\tif\
    \ (word.compare(\"$zero\") == 0)\n\t\treturn true;\n\tif (word.compare(\"$at\"\
    ) == 0)\n\t\treturn true;\n\tif (word.compare(\"$v0\") == 0)\n\t\treturn true;\n\
    \tif (word.compare(\"$v1\") == 0)\n\t\treturn true;\n\tif (word.compare(\"$a0\"\
    ) == 0)\n\t\treturn true;\n\tif (word.compare(\"$a1\") == 0)\n\t\treturn true;\n\
    \tif (word.compare(\"$a2\") == 0)\n\t\treturn true;\n\tif (word.compare(\"$a3\"\
    ) == 0)"
- code: "module counter (\n    input wire clk, rst,\n    output wire [3:0] count\n\
    );\nalways @(posedge clk or posedge rst) begin\n    if (rst) count <= 4'b0000;\n\
    \    else count <= counter_next;\nend\nendmodule\n\n\n\n# 2016-07-17\n# \n#\n\n\
    # Instructions:\nThe following instructions will be implemented based on the counter\
    \ module:\n\n# Instruction 1:\nADD [8:16] a, a, 0\na = a + a\n# Instruction 2:\n\
    ADD [8:16] b, b, 0\nb = a + b\n# Instruction 3:\nSUB [8:16] c, c, 0\nc = c - c\n\
    # Instruction 4:\nSUB [8:16] d, d, 0\nd = d - d\n# Instruction 5:\nAND [127:120]\
    \ a, a, 0\na = a & 255'h00\n# Instruction 6:\nAND [127:120] b, b, 0\nb = b & 127'h00\n\
    # Instruction 7:\nXOR [127:120] c, c, 0\nc = c ^ 255'h00000000\n# Instruction\
    \ 8:\nXOR [127:120] d, d, 0\nd = d ^ 127'h0000000000000000\n\n# Base Verilog Code:\n\
    module counter (\n    input wire clk, rst,\n    output reg [3:0] count\n);\nalways\
    \ @(posedge clk or posedge rst) begin\n    if (rst) count <= 4'b0000;\n    else\
    \ count <= count + 1;\nend\nendmodule\n\n# Variation Instruction 1:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [8:16] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n    else result <=\
    \ result + result;\nend\nendmodule\n# Variation Instruction 2:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [8:16] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n    else result <=\
    \ result + b;\nend\nendmodule\n# Variation Instruction 3:\nmodule counter (\n\
    \    input wire clk, rst,\n    output wire [8:16] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n    else result <=\
    \ result - result;\nend\nendmodule\n# Variation Instruction 4:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [8:16] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n    else result <=\
    \ result - d;\nend\nendmodule\n# Variation Instruction 5:\nmodule counter (\n\
    \    input wire clk, rst,\n    output wire [127:120] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 127'h00;\n    else result\
    \ <= result & 255'h00;\nend\nendmodule\n# Variation Instruction 6:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [127:120] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 127'h00;\n    else result\
    \ <= result & 127'h00;\nend\nendmodule\n# Variation Instruction 7:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [127:120] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 127'h00000000;\n    else result\
    \ <= result ^ 255'h00000000;\nend\nendmodule\n# Variation Instruction 8:\nmodule\
    \ counter (\n    input wire clk, rst,\n    output wire [127:120] result\n);\n\
    always @(posedge clk or posedge rst) begin\n    if (rst) result <= 127'h0000000000000000;\n\
    \    else result <= result ^ 127'h0000000000000000;\nend\nendmodule\n\n# Instruction\
    \ 3:\nmodule counter (\n    input wire clk, rst,\n    output wire [8:16] result\n\
    );\nalways @(posedge clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n\
    \    else result <= result - result;\nend\nendmodule\n# Instruction 7:\nmodule\
    \ counter (\n    input wire clk, rst,\n    output wire [127:120] result\n);\n\
    always @(posedge clk or posedge rst) begin\n    if (rst) result <= 127'h00000000;\n\
    \    else result <= result ^ 255'h00000000;\nend\nendmodule\n\n# Instruction 1:\n\
    module counter (\n    input wire clk, rst,\n    output wire [8:16] result\n);\n\
    always @(posedge clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n   \
    \ else result <= result + result;\nend\nendmodule\n# Instruction 5:\nmodule counter\
    \ (\n    input wire clk, rst,\n    output wire [127:120] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 127'h00;\n    else result\
    \ <= result & 255'h00;\nend\nendmodule\n\n# Instruction 2:\nmodule counter (\n\
    \    input wire clk, rst,\n    output wire [8:16] result\n);\nalways @(posedge\
    \ clk or posedge rst) begin\n    if (rst) result <= 8'd0;\n    else result <=\
    \ result + b;\nend\nendmodule\n# Instruction 6:\nmodule counter (\n    input wire\
    \ clk, rst,\n    output wire [127:120] result\n);\nalways @(posedge clk or posedge\
    \ rst) begin\n    if (rst) result <= 127'h00;\n    else result <= result & 127'h00;\n\
    end\nendmodule\n\n\n# Instructions:\nThe following instructions will be implemented\
    \ based on the counter module:\n\n# Instruction 1:\nADD [8:16] a, a, 0\na = a\
    \ + a\n# Instruction 2:\nADD [8:16] b, b, 0\nb = a + b\n# Instruction 3:\nSUB\
    \ [8:16] c, c, 0\nc = c - c\n# Instruction 4:\nSUB [8:16] d, d, 0\nd = d - d\n\
    # Instruction 5:\nAND [127:120] a, a, 0\na = a & 255'h00\n# Instruction 6:\nAND\
    \ [127:120] b, b, 0\nb = b & 127'h00\n# Instruction 7:\nXOR [127:120] c, c, 0\n\
    c = c ^ 255'h00000000\n# Instruction 8:\nXOR [127:120] d, d, 0\nd = d ^ 127'h0000000000000000\n\
    \n# Base Verilog Code:\nmodule counter (\n    input wire clk, rst,\n    output\
    \ reg [3:0] count\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\
    \ count <= 4'b0000;\n    else count <= count + 1;\nend\nendmodule\n\n# Variation\
    \ Instruction 1:\nmodule counter (\n    input wire clk, rst,\n    output wire\
    \ [8:16] result\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\
    \ result <= 8'd0;\n    else result <= result + result;\nend\nendmodule\n# Variation\
    \ Instruction 2:\nmodule counter (\n    input wire clk, rst,\n    output wire\
    \ [8:16] result\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst)\
    \ result <= 8'd0;\n    else result <= result + b;\nend"
- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end
    endmodule
    ```

    ### C++ code

    ```cpp
    // C++ code
    // C++ code
    #include <iostream>

    using namespace std;

    int main() {
        int count = 0;
        int initial_count = 0;

        cout << "Please enter the initial count value: ";
        cin >> initial_count;

        cout << "\nInitial value of the count is set to: " << initial_count << "\n";

        for (count = 0; count < initial_count; count++) {
            cout << "Count: " << count << endl;
        }

        return 0;
    }
    ```

    ### Result

    ![C++ code output](img/005-output.png)

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end
    endmodule
    ```

    ### Variation Instruction

    Add a logic variable which will have the result of the array slice as the tested operand

    ### Modified code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Result

    ![Verilog code output](img/005-output-2.png)

    # 6. Multiple array access with the same operand

    ### C++ code

    ```cpp
    // C++ code
    // C++ code
    #include <iostream>

    using namespace std;

    int main() {
        int count = 0;
        int initial_count = 0;

        cout << "Please enter the initial count value: ";
        cin >> initial_count;

        cout << "\nInitial value of the count is set to: " << initial_count << "\n";

        for (count = 0; count < initial_count; count++) {
            cout << "Count: " << count << endl;
        }

        return 0;
    }
    ```

    ### Result

    ![C++ code output](img/006-output.png)

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end
    endmodule
    ```

    ### Variation Instruction

    Add a logic variable which will have the result of the array slice as the tested operand

    ### Modified code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Result

    ![Verilog code output](img/006-output-2.png)

    # 7. Multiple array access with different operands

    ### C++ code

    ```cpp
    // C++ code
    #include <iostream>

    using namespace std;

    int main() {
        int count = 0;
        int initial_count = 0;

        cout << "Please enter the initial count value: ";
        cin >> initial_count;

        cout << "\nInitial value of the count is set to: " << initial_count << "\n";

        for (count = 0; count < initial_count; count++) {
            cout << "Count: " << count << endl;
        }

        return 0;
    }
    ```

    ### Result

    ![C++ code output](img/007-output.png)

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end
    endmodule
    ```

    ### Variation Instruction

    Add a logic variable which will have the result of the array slice as the tested operand

    ### Modified code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Verilog code

    ```verilog
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );

    logic result;

    initial
        reg [3:0] initial_count = 4'b0000;
    always @(posedge clk or posedge rst) begin
        if (rst) count <= initial_count;
        else count <= count + 1;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) result <= 0;
        else result <= result | 1;
    end
    endmodule
    ```

    ### Result

    ![Verilog code output](img/007-output-2.png)

    # 8. Arrays with two dimension

    ### C++ code

    ```cpp
    // C++ code
    #include <iostream>

    using namespace std;

    int main() {
        int count = 0;
        int initial_count = 0;
        int j = 0, k = 0;

        cout << "Please enter the initial count value: ";
        cin >> initial_count;

        cout << "\nInitial value of the count is set to: " << initial_count << "\n";

        for (count = 0; count < initial_count; count++) {
            cout << "Count: " << count << endl;
        }

        for (j = 0; j < initial_count; j++) {
            for (k = 0; k < initial_count; k++) {
                cout << k << " ";
            }
            cout << endl;
        }

        return 0;
    }
    ```

    ### Result

    ![C++ code output](img/008-output.png)
- code: |-
    The variables 'testValue' and 'testValue2' are multiplied and assigned to the variable 'testValue' for the following case:
    testValue = i_arr[1:0]*i_arr[2:1]
    ### Expected Results:
    The value of 'testValue' should be 0

    ### Test Case 3:
    ### Base Verilog Code:
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    endmodule
    ### Variation Instruction:
    Add inside multiplication
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk)
        if(Reset) Count = 0;
        else Count <= {Count + 1};
    endmodule
    ## Chap 2: A Basic System Design Using Hardware Description Languages
    ### Exercise 2.1:
    ### Exercise 2.2:
    ### Exercise 2.3:
    ### Exercise 2.4:
    We can add a counter as a component in SystemRDL using the following component declaration:
    ### Exercise 2.5:
    ### Exercise 2.6:
    ### Exercise 2.7:
    ### Exercise 2.8:
    ### Exercise 2.9:
    ### Exercise 2.10:
    ### Exercise 2.11:
    ### Exercise 2.12:
    ### Exercise 2.13:
    ### Exercise 2.14:
    ### Exercise 2.15:
    ### Exercise 2.16:
    ### Exercise 2.17:
    ### Exercise 2.18:
    ### Exercise 2.19:
    ### Exercise 2.20:
    ### Exercise 2.21:
    ### Exercise 2.22:
    ### Exercise 2.23:
    ### Exercise 2.24:
    ### Exercise 2.25:
    ### Exercise 2.26:
    ### Exercise 2.27:
    ### Exercise 2.28:
    ### Exercise 2.29:
    ### Exercise 2.30:
    ### Exercise 2.31:
    ### Exercise 2.32:
    ### Exercise 2.33:
    ### Exercise 2.34:
    ### Exercise 2.35:
    ### Exercise 2.36:
    ### Exercise 2.37:
    ### Exercise 2.38:
    ### Exercise 2.39:
    ### Exercise 2.40:
    ### Exercise 2.41:
    ### Exercise 2.42:
    ### Exercise 2.43:
    ### Exercise 2.44:
    ### Exercise 2.45:
    ### Exercise 2.46:
    ### Exercise 2.47:
    ### Exercise 2.48:
    ### Exercise 2.49:
    ### Exercise 2.50:
    ### Exercise 2.51:
    ### Exercise 2.52:
    ### Exercise 2.53:
    ### Exercise 2.54:
    ### Exercise 2.55:
    ### Exercise 2.56:
    ### Exercise 2.57:
    ### Exercise 2.58:
    ### Exercise 2.59:
    ### Exercise 2.60:
    ### Exercise 2.61:
    ### Exercise 2.62:
    ### Exercise 2.63:
    ### Exercise 2.64:
    ### Exercise 2.65:
    ### Exercise 2.66:
    ### Exercise 2.67:
    ### Exercise 2.68:
    ### Exercise 2.69:
    ### Exercise 2.70:
    ### Exercise 2.71:
    ### Exercise 2.72:
    ### Exercise 2.73:
    ### Exercise 2.74:
    ## Chap 3: A SystemRDL Syntax for Multiplexer Structures
    ### Exercise 3.1:
    ### Exercise 3.2:
    ### Exercise 3.3:
    ### Exercise 3.4:
    ### Exercise 3.5:
    ### Exercise 3.6:
    ### Exercise 3.7:
    ### Exercise 3.8:
    ### Exercise 3.9:
    ### Exercise 3.10:
    ### Exercise 3.11:
    ### Exercise 3.12:
    ### Exercise 3.13:
    ### Exercise 3.14:
    ### Exercise 3.15:
    ## Chap 4: A SystemRDL Syntax for Combinational and Sequential Verilog
    ### Exercise 4.1:
    ### Exercise 4.2:
    ### Exercise 4.3:
    ### Exercise 4.4:
    ### Exercise 4.5:
    ### Exercise 4.6:
    ### Exercise 4.7:
    ### Exercise 4.8:
    ### Exercise 4.9:
    ### Exercise 4.10:
    ### Exercise 4.11:
    ### Exercise 4.12:
    ### Exercise 4.13:
    ### Exercise 4.14:
    ### Exercise 4.15:
    ### Exercise 4.16:
    ### Exercise 4.17:
    ### Exercise 4.18:
    ### Exercise 4.19:
    ### Exercise 4.20:
    ### Exercise 4.21:
    ### Exercise 4.22:
    ### Exercise 4.23:
    ### Exercise 4.24:
    ### Exercise 4.25:
    ### Exercise 4.26:
    ### Exercise 4.27:
    ### Exercise 4.28:
    ### Exercise 4.29:
    ### Exercise 4.30:
    ### Exercise 4.31:
    ### Exercise 4.32:
    ### Exercise 4.33:
    ### Exercise 4.34:
    ### Exercise 4.35:
    ### Exercise 4.36:
    ### Exercise 4.37:
    ### Exercise 4.38:
    ### Exercise 4.39:
    ### Exercise 4.40:
    ### Exercise 4.41:
    ### Exercise 4.42:
    ### Exercise 4.43:
    ### Exercise 4.44:
    ### Exercise 4.45:
    ### Exercise 4.46:
    ### Exercise 4.47:
    ### Exercise 4.48:
    ### Exercise 4.49:
    ### Exercise 4.50:
    ### Exercise 4.51:
    ### Exercise 4.52:
    ### Exercise 4.53:
    ### Exercise 4.54:
    ### Exercise 4.55:
    ### Exercise 4.56:
    ### Exercise 4.57:
    ### Exercise 4.58:
    ### Exercise 4.59:
    ### Exercise 4.60:
    ### Exercise 4.61:
    ### Exercise 4.62:
    ### Exercise 4.63:
    ### Exercise 4.64:
    ### Exercise 4.65:
    ### Exercise 4.66:
    ### Exercise 4.67:
    ### Exercise 4.68:
    ### Exercise 4.69:
    ### Exercise 4.70:
    ### Exercise 4.71:
    ### Exercise 4.72:
    ### Exercise 4.73:
    ### Exercise 4.74:
    ### Exercise 4.75:
    ### Exercise 4.76:
    ### Exercise 4.77:
    ### Exercise 4.78:
    ### Exercise 4.79:
    ### Exercise 4.80:
    ### Exercise 4.81:
    ### Exercise 4.82:
    ### Exercise 4.83:
    ## Chap 5: A SystemRDL Syntax for Register Files
    ### Exercise 5.1:
    ### Exercise 5.2:
    ### Exercise 5.3:
    ### Exercise 5.4:
    ### Exercise 5.5:
    ### Exercise 5.6:
    ### Exercise 5.7:
    ### Exercise 5.8:
    ### Exercise 5.9:
    ### Exercise 5.10:
    ### Exercise 5.11:
    ### Exercise 5.12:
    ### Exercise 5.13:
    ### Exercise 5.14:
    ### Exercise 5.15:
    ### Exercise 5.16:
    ### Exercise 5.17:
    ### Exercise 5.18:
    ### Exercise 5.19:
    ### Exercise 5.20:
    ### Exercise 5.21:
    ### Exercise 5.22:
    ### Exercise 5.23:
    ### Exercise 5.24:
    ### Exercise 5.25:
    ### Exercise 5.26:
    ### Exercise 5.27:
    ### Exercise 5.28:
    ### Exercise 5.29:
    ### Exercise 5.30:
    ### Exercise 5.31:
    ### Exercise 5.32:
    ### Exercise 5.33:
    ### Exercise 5.34:
    ### Exercise 5.35:
    ### Exercise 5.36:
    ### Exercise 5.37:
    ### Exercise 5.38:
    ### Exercise 5.39:
    ### Exercise 5.40:
    ### Exercise 5.41:
    ### Exercise 5.42:
    ### Exercise
- code: "module Chap1Counter (Clk, Reset, Count);\ninput Clk, Reset;\noutput [3:0]\
    \ Count;\nreg [3:0] Count;\nwire [3:0] Count_n;\nalways @(posedge Clk) begin\n\
    \    if(Reset) Count_n = 0;\n    else Count_n = Count + 1;\nend\n\ninitial begin\n\
    \    Count = {0, 0, 0, 0};\nend\n\nassign Count = Count_n;\nendmodule\n\n### Simulation\
    \ Result:\n```\nvcd_startup();\nvcd_dumpfile(\"Chap1Counter.vcd\");\nvcd_dumpvars(0,Chap1Counter);\n\
    #1000;\n$finish;\n```\n\n/Chap6/README.md\n# Chap6 \n## 1. Module Instances\n\
    It has 7 modules:\n+ Chap1Counter\n+ Chap2Counter\n+ Chap3Counter\n+ Chap4AndGate\n\
    + Chap5OrGate\n+ Chap6NandGate\n+ Chap7NorGate\n\n### 1.1. Chap1Counter\n![Chap1Counter](./Chap1Counter.png)\n\
    \n### 1.2. Chap2Counter\n![Chap2Counter](./Chap2Counter.png)\n\n### 1.3. Chap3Counter\n\
    ![Chap3Counter](./Chap3Counter.png)\n\n### 1.4. Chap4AndGate\n![Chap4AndGate](./Chap4AndGate.png)\n\
    \n### 1.5. Chap5OrGate\n![Chap5OrGate](./Chap5OrGate.png)\n\n### 1.6. Chap6NandGate\n\
    ![Chap6NandGate](./Chap6NandGate.png)\n\n### 1.7. Chap7NorGate\n![Chap7NorGate](./Chap7NorGate.png)\n\
    \n## 2. Instantiation\n### 2.1. VHDL code for Chap2Counter\n```vhdl=\nlibrary\
    \ ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity Chap2Counter\
    \ is\n    generic (\n        N_BIT : integer := 4\n        );\n    port (\n  \
    \      Clk : in std_logic;\n        Reset : in std_logic;\n        Count : out\
    \ std_logic_vector(N_BIT - 1 downto 0)\n        );\n\nend Chap2Counter;\n\narchitecture\
    \ Behav of Chap2Counter is\n\nbegin\n\n    process (Clk)\n    begin\n        if\
    \ rising_edge(Clk) then\n            Count <= (others => '0');\n            if\
    \ Reset = '1' then\n                Count <= (others => '0');\n            else\n\
    \                Count <= Count+1;\n            end if;\n        end if;\n   \
    \ end process;\n\nend Behav;\n```\n### 2.2. VHDL code for Chap3Counter\n```vhdl=\n\
    library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity\
    \ Chap3Counter is\n    generic (\n        N_BIT : integer := 4\n        );\n \
    \   port (\n        Clk : in std_logic;\n        Reset : in std_logic;\n     \
    \   Count : out std_logic_vector(N_BIT - 1 downto 0)\n        );\n\nend Chap3Counter;\n\
    \narchitecture Behav of Chap3Counter is\n\nsignal Count_n : std_logic_vector(N_BIT\
    \ - 1 downto 0);\n\nbegin\n\n    process (Clk)\n    begin\n        if rising_edge(Clk)\
    \ then\n            if Reset = '1' then\n                Count_n <= (others =>\
    \ '0');\n            else\n                Count_n <= Count+1;\n            end\
    \ if;\n        end if;\n    end process;\n    \n    assign Count = Count_n;\n\n\
    end Behav;\n```\n### 2.3. VHDL code for Chap4AndGate\n```vhdl=\nlibrary ieee;\n\
    use ieee.std_logic_1164.all;\n\nentity Chap4AndGate is\n    port (\n        A\
    \ : in std_logic;\n        B : in std_logic;\n        Y : out std_logic\n    \
    \    );\n\nend Chap4AndGate;\n\narchitecture Behav of Chap4AndGate is\n\nbegin\n\
    \n    Y <= A and B;\n\nend Behav;\n```\n### 2.4. VHDL code for Chap5OrGate\n```vhdl=\n\
    library ieee;\nuse ieee.std_logic_1164.all;\n\nentity Chap5OrGate is\n    port\
    \ (\n        A : in std_logic;\n        B : in std_logic;\n        Y : out std_logic\n\
    \        );\n\nend Chap5OrGate;\n\narchitecture Behav of Chap5OrGate is\n\nbegin\n\
    \n    Y <= A or B;\n\nend Behav;\n```\n### 2.5. VHDL code for Chap6NandGate\n\
    ```vhdl=\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity Chap6NandGate\
    \ is\n    port (\n        A : in std_logic;\n        B : in std_logic;\n     \
    \   Y : out std_logic\n        );\n\nend Chap6NandGate;\n\narchitecture Behav\
    \ of Chap6NandGate is\n\nbegin\n\n    Y <= not (A and B);\n\nend Behav;\n```\n\
    ### 2.6. VHDL code for Chap7NorGate\n```vhdl=\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\
    \nentity Chap7NorGate is\n    port (\n        A : in std_logic;\n        B : in\
    \ std_logic;\n        Y : out std_logic\n        );\n\nend Chap7NorGate;\n\narchitecture\
    \ Behav of Chap7NorGate is\n\nbegin\n\n    Y <= not (A or B);\n\nend Behav;\n\
    ```\n## 3. Simulation\n### 3.1. Simulation Result for Chap2Counter\n```\nvcd_startup();\n\
    vcd_dumpfile(\"Chap2Counter.vcd\");\nvcd_dumpvars(0,Chap2Counter);\n#1000;\n$finish;\n\
    ```\n#### 3.1.1. Simulation Result of Chap2Counter\n![Chap2Counter](./Chap2Counter_Simulation.png)\n\
    ### 3.2. Simulation Result for Chap3Counter\n```\nvcd_startup();\nvcd_dumpfile(\"\
    Chap3Counter.vcd\");\nvcd_dumpvars(0,Chap3Counter);\n#1000;\n$finish;\n```\n####\
    \ 3.2.1. Simulation Result of Chap3Counter\n![Chap3Counter](./Chap3Counter_Simulation.png)\n\
    ### 3.3. Simulation Result for Chap4AndGate\n```\nvcd_startup();\nvcd_dumpfile(\"\
    Chap4AndGate.vcd\");\nvcd_dumpvars(0,Chap4AndGate);\n#1000;\n$finish;\n```\n####\
    \ 3.3.1. Simulation Result of Chap4AndGate\n![Chap4AndGate](./Chap4AndGate_Simulation.png)\n\
    ### 3.4. Simulation Result for Chap5OrGate\n```\nvcd_startup();\nvcd_dumpfile(\"\
    Chap5OrGate.vcd\");\nvcd_dumpvars(0,Chap5OrGate);\n#1000;\n$finish;\n```\n####\
    \ 3.4.1. Simulation Result of Chap5OrGate\n![Chap5OrGate](./Chap5OrGate_Simulation.png)\n\
    ### 3.5. Simulation Result"
- code: |-
    module Chap1Counter (Clk, Reset, CountRegister, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else Count <= Count + 1;
    end
    initial begin
- code: "module Chap1Counter (Clk, Reset, Count, Load, LoadReset);\ninput Clk, Reset,\
    \ Load, LoadReset;\noutput [3:0] Count;\nreg [3:0] Count;\nreg [3:0] CountOn;\n\
    always @(posedge Clk or posedge Reset)\n    if(Reset) begin    \n        CountOn\
    \ = 0;\n    end\n    if(Load) begin    \n        CountOn = CountOn + 1;\n    \
    \    Count = CountOn;\n    end\n    else if(LoadReset) begin    \n        CountOn\
    \ = CountOn + 1;\n    end\nendmodule\n### Verilog Code to run:\nmodule Chap1Counter;\n\
    input wire Clk;\ninput wire Reset;\ninput wire Load;\ninput wire LoadReset;\n\
    output reg [3:"
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count <= Count + 1;
    end
    always @(posedge Clk) begin
        Count <= Count + 1;
    end
    always @(negedge Clk) begin
        Count <= Count + 1;
    end
    endmodule
    ### Comment:
    This allows the counter to increment on every clock cycle, and increment when the clock rising edge is active.
    ### Result:
    I ran the simulation several times and all of them gave the same result:
    Reset the counter to 0 upon reset.
    Reset = 1
    Count = 1
    Reset = 0
    Count = 2
    Reset = 1
    Count = 3
    Reset = 0
    Count = 4
    Reset = 1
    Count = 5
    Reset = 0
    Count = 6
    Reset = 1
    Count = 7
    Reset = 0
    Count = 8
    Reset = 1
    Count = 9
    Reset = 0
    Count = 10
    Reset = 1
    Count = 11
    Reset = 0
    Count = 12
    Reset = 1
    Count = 13
    Reset = 0
    Count = 14
    Reset = 1
    Count = 15
    Reset = 0
    Count = 16
    Reset = 1
    Count = 17
    Reset = 0
    Count = 18
    Reset = 1
    Count = 19
    Reset = 0
    Count = 20
    Reset = 1
    Count = 21
    Reset = 0
    Count = 22
    Reset = 1
    Count = 23
    Reset = 0
    Count = 24
    Reset = 1
    Count = 25
    Reset = 0
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else begin
            Count = Count + 1;
            Count[1] = ~Count[1];
        end
    end
    always #1000 $display("Count = %0h: \n", Count);
    end
    always @(posedge Clk) begin
        if (Reset) Count = 0;
        else begin
            Count = Count + 1;
            Count[1] = ~Count[1];
        end
        Count[1] = ~Count[1];
    end
    endmodule
    ### Base Verilog Code:
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else begin
            Count = Count + 1;
            Count[1] = ~Count[1];
        end
    end
    always #1000 $display("Count = %0h: \n", Count);
    end
    always @(posedge Clk) begin
        if (Reset) Count = 0;
        else begin
- code: |-
    module Chap1Counter (Clk, Reset, Count, Dec);
    input Clk, Reset, Dec;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        Count = Count + 1;
    end
    always @(negedge Clk) begin
        if(Dec && Count > 0) Count = Count - 1;
    end
    endmodule
    ### Explanation:
    The Chap1Counter module is now modified to use the negedge construct to assert the Dec signal.

    ## Section 9: Chap1
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = {3'b0, 3'b1};
        else Count = Count + {3'b0, 3'b1};
    end
    endmodule
    ### Testbench File:
    module Chap1Tester;
        reg [1:0] TestClk;
        reg Reset;
        initial begin
            Reset = 1'b0;
            #5 Reset = 1'b1;
            #5 Reset = 1'b0;
        end
        always #1 TestClk = ~TestClk;
        initial begin
            #100;
            $display("Chap1Counter Testbench Start\n");
            $write("Chap1Counter Testbench Start\n");
            #10
- code: module
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else begin
            case(Count)
                4'b1111: Count <= 4'b0000;
                default: Count <= Count + 1;
            endcase
        end
    end
    endmodule
    ### Verilog Source Code:
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else begin
            case(Count)
                4'b1111: Count <= 4'b0000;
                default:
- code: |-
    module tst_4d();
     input wire [31: 0] i_address;
     input wire [31: 0] i_data;
     input wire i_read;
     input wire i_write;
     output wire [31: 0] o_data;
     parameter ADDR_WIDTH = 32;
     parameter NUM_MEMORIES = 2;
     parameter NUM_ROWS = 2;
     parameter NUM_COLS = 2;
     parameter DATA_WIDTH = 32;
     reg [DATA_WIDTH -1: 0] memory[ NUM_ROWS -1: 0] [NUM_COLS -1: 0] [NUM_MEMORIES - 1: 0];
     initial
     begin
      for ( int i = 0; i < NUM_MEMORIES; i = i + 1)
       begin
        for ( int j = 0; j < NUM_COLS; j = j + 1)
         begin
          for ( int k = 0; k < NUM_ROWS; k = k + 1)
           begin
            memory[k][j][i] = DATA_WIDTH'b1;
           end
         end
       end
      end
      always
      begin
       if( i_read)
        begin
         o_data = memory[i_address[ADDR_WIDTH - 1: ADDR_WIDTH - ((NUM_COLS * NUM_MEMORIES) + 1)]]
                  [i_address[ADDR_WIDTH - 2 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - (NUM_COLS * NUM_MEMORIES)]]
                  [i_address[ADDR_WIDTH - 3 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - 2 * (NUM_COLS * NUM_MEMORIES)]];
        end
       else if ( i_write)
        begin
         memory[i_address[ADDR_WIDTH - 1: ADDR_WIDTH - ((NUM_COLS * NUM_MEMORIES) + 1)]]
               [i_address[ADDR_WIDTH - 2 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - (NUM_COLS * NUM_MEMORIES)]]
               [i_address[ADDR_WIDTH - 3 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - 2 * (NUM_COLS * NUM_MEMORIES)]] = i_data;
        end
       end
      end
     endmodule

    ### Resulting Verilog Code:
    module tst_4d();
     input wire [31: 0] i_address;
     input wire [31: 0] i_data;
     input wire i_read;
     input wire i_write;
     output wire [31: 0] o_data;
     parameter ADDR_WIDTH = 32;
     parameter NUM_MEMORIES = 2;
     parameter NUM_ROWS = 2;
     parameter NUM_COLS = 2;
     parameter DATA_WIDTH = 32;
     reg [DATA_WIDTH -1: 0] memory[ NUM_ROWS -1: 0] [NUM_COLS -1: 0] [NUM_MEMORIES - 1: 0];
     initial
     begin
      for ( int i = 0; i < NUM_MEMORIES; i = i + 1)
       begin
        for ( int j = 0; j < NUM_COLS; j = j + 1)
         begin
          for ( int k = 0; k < NUM_ROWS; k = k + 1)
           begin
            memory[k][j][i] = DATA_WIDTH'b1;
           end
         end
       end
      end
      always
      begin
       if( i_read)
        begin
         o_data = memory[i_address[ADDR_WIDTH - 1: ADDR_WIDTH - ((NUM_COLS * NUM_MEMORIES) + 1)]]
                  [i_address[ADDR_WIDTH - 2 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - (NUM_COLS * NUM_MEMORIES)]]
                  [i_address[ADDR_WIDTH - 3 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - 2 * (NUM_COLS * NUM_MEMORIES)]];
        end
       else if ( i_write)
        begin
         memory[i_address[ADDR_WIDTH - 1: ADDR_WIDTH - ((NUM_COLS * NUM_MEMORIES) + 1)]]
               [i_address[ADDR_WIDTH - 2 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - (NUM_COLS * NUM_MEMORIES)]]
               [i_address[ADDR_WIDTH - 3 - (NUM_COLS * NUM_MEMORIES): ADDR_WIDTH - 2 * (NUM_COL
- code: |-
    module tst_nm_in(inout in, out);
      reg in, out;
      NMOSinv nm(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      -- if in = 1, output = 0
      -- if in = 0, output = 1
      if (in = 1)
        out = 1'b0;
      else if (in = 0)
        out = 1'b1;
      end
      initial #15 $stop; // Stop simulation
    endmodule

    ## Design Analysis:
    ### Modified Design Analysis:
    #### Schematic:
    Below is a schematic of the modified design with all of the components from the original design.
    ![
- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      reg [1:0][2:0][3:0][3:0] nmos_table;
      initial
        nmos_table[0][0][0]= not out;
        nmos_table[0][0][1]= not in;

        nmos_table[0][1][0]= not out;
        nmos_table[0][1][1]= in;

        nmos_table[1][0][0]= not out;
        nmos_table[1][0][1]= not in;

        nmos_table[1][1][0]= not out;
        nmos_table[1][1][1]= in;
      always
        case(in)
          1'b1: $monitor($time, " in = %b, output = %b ",in,out);
          1'b0: $monitor($time, " in = %b, output = %b ",in,out);
        endcase
      initial #15 $stop; // Stop simulation
    endmodule
    ### Test:
    The output shows that the behavior is the same as the base case statement, but this variation instruction allows us to see how the input affects the output.

    ![Alt text](images/nmos_variation.png)

    ### Base Verilog Code:
    module tst_nm_in();
      wire in;
- code: |-
    initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    ### Result:
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1, output =  0
    in =  1
- code: |-
    module tst_pm_out();
      reg out; wire in;
      PMOSinv pmv(out,in); // Instantiate PMOS inverter
      initial
        out =1'b1; // Start with output high -> input low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation

      initial $monitor($time, " in = %b, output = %b ",in,out);
    endmodule
    ### Simulation Results:
    ![PMOSinv Array Version](./images/Tst_Pm_Out_Array.PNG)

    <br/>

    ## Tst_pm_out_in
    ### Base Verilog Code:
    module tst_pm_out_in();
      reg out,in;
      PMOS
- code: "module tst_nm_in();\n  reg in; wire out;\n  NMOSinv nmv(out,in); // Instantiate\
    \ NMOS inverter\n  initial in =1'b1;  // Start with input high -> output low\n\
    \  always\n  initial $monitor($time, \" in = %b, output = %b \",in,out);\n  initial\
    \ #15 $stop; // Stop simulation\nendmodule\n### Code Output:\n$./nmis2 \n[18:23:11]\
    \ NMOSinv::NMOSinv  :NMOSinv( out, in )\n[18:23:11] NMOSinv::NMOSinv  :NMOSinv(\
    \ out, in )\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :[0] in = 0, output = 1\n[18:23:11] main::main        :[0]\
    \ in = 1, output = 0\n[18:23:11] main::main        :[0] in = 0, output = 1\n[18:23:11]\
    \ main::main        :[0] in = 1, output = 0\n[18:23:11] main::main        :[0]\
    \ in = 0, output = 1\n[18:23:11] main::main        :[0] in = 1, output = 0\n[18:23:11]\
    \ main::main        :"
- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      parameter IN=1; parameter OUT=0;
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
        // For this example, use a case statement to index into a 4D array
        // The 4D array dimensions must be known to have the same value for every case statement
        // This is why the code below uses a function call which indexes into a 4D array
        // If the function call was changed to hardcode the array values, the compiler would reject the code
        // because the function would not be able to determine the dimensions of the array properly.
      always @(in)
        case (in) // This will allow the same code to be used for all cases, even if IN or OUT are changed
        1'b0: in = 1'b1; // Start with input high -> output low
        1'b1: in = 1'b0; // Start with input low -> output high
        default: in = 1'b 0; // This will trigger an error if any other case is not handled correctly
        endcase
    endmodule
    ### Output:
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0
    in = 0, output = 1
    in = 1, output = 0

    ### Final Verilog Code:
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      parameter IN=1; parameter OUT=0;
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
        // For this
- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
        case(in)
          1'b1: out = 1'b1;
          else: out = 1'b0;
        endcase
      forever
        initial in =1'b1; // Start with input high -> output low
        always
          case(in)
            1'b1: out = 1'b1;
            else: out = 1'b0;
          endcase
        #15 $stop; // Stop simulation
      initial #15 $stop; // Stop simulation
    endmodule
    ### Analysis of the result:
    The output of the simulation is as follows:
    ```
    Time 225, in = 1, output = 1
    Time 226, in = 0, output = 0
    Time 227, in = 1, output = 1
    Time 228, in = 0, output = 0
    Time 229, in = 1, output = 1
    Time 230, in = 0, output = 0
    Time 231, in = 1, output = 1
    Time 232, in
- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
- code: |-
    module tst_pm_nor2_inv();
      wire in1, in2; reg out;
      Pass1Nor2Inv nmv(out,in1,in2); // Instantiate NMOS inverter
      initial
        in1 =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      always #15 $stop; // Stop simulation
    endmodule

    ### Base Verilog Code:
    module tst_pm_nor2();
      wire in1, in2; reg out;
      Pass1Nor2 nmv(out,in1,in2); // Instantiate NMOS inverter
      initial
        in1 =1'b1; // Start with input high -> output low
      always
      initial $monitor($time
- code: |-
    module nil;
    reg a, b;
    integer i;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Added time
    end
    always @(a[i] or b[i])
    begin
    if (a[i] == 0)
    begin
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a, b);
    end
    end
    endmodule
    ### Output:
    // Added $time within the statement
    t=0 display: a = 0, b = 0
    t=2 monitor: a = 0, b = 0
    t=5 monitor: a = 0, b = 0
    t=6 monitor: a = 0, b = 1
    ### Variation Instruction:
- code: |-
    module nil(a, b, c);
    reg a, b, c;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    c = 2'b00;
    $display ("t=%0t display: a = %b, b = %b, c = %b", $time, a, b, c); // Added time
    end
    always @(posedge $clk) // Added the clock to the always block // Modified the monitor to reference the part-select as a part of the conditional expression // Modified the monitor to reference the part-select as a part of the conditional expression // Modified the monitor to reference the part-select as a part of the conditional expression initial b = 1'b0; initial c = 2'b00; // Added the extra initial statements always @(posedge$clk)
    begin
    if (a == 1'b1) b = 1'b1;
    end
    $monitor("t=%0t monitor b = %b, c = %b",$time, b, c);
    // Monitor triggers at t=0 and t=2
    endmodule

    ### Base Verilog Code:
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b",$time, a, b); // Added time
    end
    always @(posedge $clk) // Modified monitor to reference the part-select as a part of the conditional expression if (b == 1'b1) begin$monitor("t=%0t monitor: b = %b", $time, b); end endmodule ### Variation Instruction: Use inside in an assignment statement within an always block that references a part-select on an array. ### Modified Code: module nil(a, b, c); reg a, b, c; initial begin a = 1'b0; b = 1'b0; c = 2'b00; // Added the initial statements $display ("t=%0t display: a = %b, b = %b, c = %b", $time, a, b, c); // Added time end always @(posedge$clk)
    begin
    if (a == 1'b1) b = 1'b1;
    end
    $monitor("t=%0t monitor b = %b, c = %b",$time, b, c);
    // Monitor triggers at t=0 and t=2
    endmodule

    ### Base Verilog Code:
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b",$time, a, b); // Added time
    end
    always @(posedge $clk) begin if (b == 1'b1) begin$monitor("t=%0t monitor: b = %b", $time, b); end end endmodule ### Variation Instruction: Use inside in a conditional expression within an always block that references a part-select on an array. ### Modified Code: module nil(a, b, c); reg a, b, c; initial begin a = 1'b0; b = 1'b0; c = 2'b00; // Added the initial statements$display ("t=%0t display: a = %b, b = %b, c = %b", $time, a, b, c); // Added time end always @(posedge$clk)
    begin
    if (a == 1'b1) c = 2'b01;
    end
    $monitor("t=%0t monitor c = %b",$time, c);
    // Monitor triggers at t=0 and t=2
    endmodule
- code: |-
    #include <iostream>
    using namespace std;

    int main()
    {
    cout << "Hello world!\n";
    return 0;
    }
- code: |-
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b",$time, a, b); // Added time
    end
    always
    if (a == 1'b0) // Added
    b = 1'b0;
    end
    always @(a) with (b==1'b0) // Added begin $display("t=%0t: a=%b
- code: |-
    reg a;
    localparam [7:0] arr_l = 2'h10;
    always @(arr_l[3:1]) begin
    a = arr_l[4];
    $display ("t=%0t arr_l[3:1] = %b", $time, arr_l[3:1]);
    end
    ### Base Verilog Code:
    module nil;
    reg a;
    localparam [7:0] arr_l = 2'h10;
    initial
    begin
    a = 1'b0;
    $display ("t=%0t display: a = %b", $time, a); // Added time
    end
    always @(arr_l[3:1]) begin
    a = arr_l[4];
    $display ("t=%0t arr_l[3:1] = %b", $time, arr_l[3:1]);
    end
    // Monitor triggers at t=0, t=3, t=4, t=5, t=6
    endmodule
- code: "module nil;\nreg a, b;\ninitial\nbegin\na = 1'b0;\nb = 1'b0;\nif (a[1])\n\
    b = b[1];\nend\nendmodule\n### Simulation Results:\nt=0.000000 display: a = 0,\
    \ b = 0\nt=2.000000 display: a = 0, b = 0\nt=5.000000 display: a = 0, b = 0\n\
    t=6.000000 monitor: a = 0, b = 0\n\n## Explanation\n\nIn this example, a conditional\
    \ expression is used to control access to a part-select. The conditional expression\
    \ uses [1] to select the LSB of a, which is a 1 bit wide, array. The b part-select\
    \ is a reference to the right bit of a.\n\n## See Also\n\nFor more information,\
    \ see the following topics:\n\n\u2022 Verilog User Guide: Conditional Statement\
    \ in an Always Block\n\u2022 Verilog User Guide: Part Select on an Array"
- code: |-
    # Modified code 5
    module nil_ver2;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a[0:0], b[0:0]); // Added time
    end
    initial
    $monitor("t=%0t monitor: a = %b, b = %b", $time, a[0:0], b[0:0]);
    // Monitor triggers at t=0, t=2, t=5, t=6
    endmodule
    **Figure 1.100**
    **Figure 1.101**
    A:
    Figure 1.102
    Figure 1.103
    A:
    Figure 1.104
    Figure 1.105
    A:
    Figure 1.106
    A:
    Figure 1.107
    Figure 1.108
    A:
    Figure 1.109
    Figure 1.110
    A:
    Figure 1.111
    Figure 1.112
    A:
    Figure 1.113
    Figure 1.114
    A:
    Figure 1.115
    Figure 1.116
    A:
    Figure 1.117
    Figure 1.118
    A:
    Figure 1.119
    Figure 1.120
    A:
    Figure 1.121
    Figure 1.122
    A:
    Figure 1.123
    Figure 1.124
    A:
    Figure 1.125
    Figure 1.126
    A:
    Figure 1.127
    Figure 1.128
    A:
    Figure 1.129
    Figure 1.130
    A:
    Figure 1.131
    Figure 1.132
    A:
    Figure 1.133
    Figure 1.134
    A:
    Figure 1.135
    Figure 1.136
    A:
    Figure 1.137
    Figure 1.138
    A:
    Figure 1.139
    Figure 1.140
    A:
    Figure 1.141
    Figure 1.142
    A:
    Figure 1.143
    Figure 1.144
    A:
    Figure 1.145
    Figure 1.146
    A:
    Figure 1.147
    Figure 1.148
    A:
    Figure 1.149
    Figure 1.150
    A:
    Figure 1.151
    Figure 1.152
    A:
    Figure 1.153
    Figure 1.154
    A:
    Figure 1.155
    Figure 1.156
    A:
    Figure 1.157
    Figure 1.158
    A:
    Figure 1.159
- code: |-
    always @(a[2:0]) begin
    end
    ### Base Verilog Code:
    always @(a[2:0]) begin  //$monitor triggers at t=0, t=2, t=5, t=6
    end
    `
- code: |-
    module nil;
    reg [2:0] a;
    reg b;
    initial
    begin
    a = 3'b0;
    b = 1'b0;
    $display ("t=%0t display: a[1:0] = %b, b = %b", $time, a[1:0], b); // Added
- code: "module nil;\nreg a;\ninitial\nbegin\na = 1;\nend\nalways begin\nassign a\
    \ = b[1] | b[0]; // Part-select\n$display (\"t=%0t display: a = %b\", $time, a);\
    \ // Added time\nend\nendmodule\n### Result:\n\nt=0 display: a = 0\nt=2 display:\
    \ a = 1\nt=5 display: a = 1\nt=6 display: a = 1\n\n## \u9898\u76EE\u5341\u4E00\
    \n\n### Base Verilog Code:\nmodule nil"
- code: |-
    module CPU (output Vout, input[7:0] Ibus, input[2:0] Adr, input Clk, Read);
    RAM Dmem (Ibus, Adr, Clk, Read, Obus);
    RAM Imem (Ibus, Adr, Clk, Read, Obus);
    reg[7:0] VoutReg;
    assign #1 Vout = VoutReg;
    assign #1 Adr = Obus;
    always @(RISING_EDGE Clk) begin:
        if (Adr==8'd0) begin:
            VoutReg = 7'd0;
        end
        else if (Adr==8'd8) begin:
            VoutReg = 7'd1;
        end
        else if (Adr==8'd32) begin:
            VoutReg = 7'd4;
        end
        else begin:
            VoutReg = 7'd5;
        end
    end: endmodule
    /CPU/CPU.cpp
    #include "CPU.hpp"
    #include <iostream>
    using namespace std;

    CPU::CPU(int memory_size)
    {
        Dmem = new RAM(memory_size / 2);
        Imem = new RAM(memory_size / 2);
    }
    RAM *CPU::Dmem;
    RAM *CPU::Imem;

    void CPU::execute_one_instruction()
    {
        Dmem->execute_one_instruction(Adr, Vout, Clk, Read);

        Imem->execute_one_instruction(Adr, Vout, Clk, Read);
    }

    void CPU::execute_one_instruction_with_register_address()
    {
        Dmem->execute_one_instruction_with_register_address(Adr, Vout, Clk, Read);

        Imem->execute_one_instruction_with_register_address(Adr, Vout, Clk, Read);
    }

    void CPU::execut1)
        {
            execute_one_instruction();
        }
    }

    void CPU::execute_program_with_register_address()
    {
        for (Clk = 0; Clk < 16; Clk++)
        {
            execute_one_instruction_with_register_address();

            Read = 1;
            Dmem->write_register_address(Adr, Ibus, Clk, Read);
            execute_one_instruction_with_register_address();
        }
    }

    void CPU::print_program()
    {
        for (int i = 0; i < 8; i++)
        {
            cout << Dmem->Storage[i] << endl;
        }

        for (int i = 0; i < 8; i++)
        {
            cout << Imem->Storage[i] << endl;
        }
    }e_program()
    {
        for (Clk = 0; Clk < 16; Clk++)
        {
            execute_one_instruction();

            Read = 1;
            Dmem->read_into_register_address(Adr, Ibus, Clk, Read);
            execute_one_instruction();
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 152; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
        }

        for (Clk = 0; Clk < 8; Clk++)
        {
            execute_one_instruction();
- code: "module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk,\
    \ Read);\nreg[7:0] Storage[15:0];\nreg[7:0] ObusReg;\nassign #1 Obus = ObusReg;\n\
    always @(posedge Clk)\nif (Read==1'b0) begin\n    int idx;\n    for (idx=0; idx<15;\
    \ idx=idx+1) begin\n        if (Adr == idx) begin\n            Storage[idx] <=\
    \ Ibus;\n        end\n    end \nend\nelse\n    ObusReg <= Storage[Adr];\nendmodule\n\
    ### Observations:\n\u2022 The compiler can generate the same object code as of\
    \ the original code.\n\u2022 The new addition of the line will make the code more\
    \ efficient than the original code in terms of code size.\n\u2022 The while loop\
    \ is a sequential logic element which means that while loop executes each cycle\
    \ of the clock.\n\u2022 In the loop, the storage array is constantly accessed.\
    \ However, the accesses done in the original code are not constant, which means\
    \ that the accesses are done at each cycle of the clock.\n\u2022 So this variation\
    \ is not suitable for parallel/distributed array access.\n\u2022 In the original\
    \ code, the sequential logic is executed just once. So this variation is not suitable\
    \ if the sequential logic code needs to be executed multiple times.\n#include\
    \ <iostream>\nusing namespace std;\n#define N 3\n#define M 4\nclass Matrix {\n\
    \    int a[N][M];\n  public:\n    void get_values() {\n      for(int i=0; i<N;\
    \ i++)\n        for(int j=0; j<M; j++)\n          cin >> a[i][j];\n    }\n   \
    \ friend Matrix operator + (Matrix const &, Matrix const &);\n    friend ostream\
    \ & operator << (ostream &, Matrix &);\n};\nMatrix operator + (Matrix const &m1,\
    \ Matrix const &m2) {\n    Matrix m3;\n    for(int i=0; i<N; i++)\n        for(int\
    \ j=0; j<M; j++)\n            m3.a[i][j] = m1.a[i][j] + m2.a[i][j];\n    return\
    \ m3;\n}\nostream & operator << (ostream &out, Matrix &m) {\n    for(int i=0;\
    \ i<N; i++) {\n        for(int j=0; j<M; j++)\n            out << m.a[i][j] <<\
    \ \" \";\n        out << \"\\n\";\n    }\n    return out;\n}\nint main() {\n \
    \   Matrix m1, m2, m3;\n    cout << \"Enter the values for the 1st Matrix\\n\"\
    ;\n    m1.get_values();\n    cout << \"\\nEnter the values for the 2nd Matrix\\\
    n\";\n    m2.get_values();\n    m3 = m1 + m2;\n    cout << \"\\nThe 1st Matrix\\\
    n\";\n    cout << m1;\n    cout << \"\\nThe 2nd Matrix\\n\";\n    cout << m2;\n\
    \    cout << \"\\nThe Sum Matrix\\n\";\n    cout << m3;\n    return 0;\n}The variation\
    \ of the code is:\n\ndef main():\n    print(\"Hello World\")\n    for i in range(4):\n\
    \        print(\"Hello World\")\n    for i in range(2, 5):\n        print(\"Hello\
    \ World\")\n\nThe output is:\n\nHello World\nHello World\nHello World\nHello World\n\
    Hello World\n\nThe output is:\n\nHello World\nHello World\nHello World\n\nThe\
    \ output is:\n\nHello World\n\nThe output is:\n\nThe output is:\n\nHello World\n\
    Hello World\nHello World\n\nThe output is:\n\nHello World\nHello World\n\nThe\
    \ output is:\n\nHello World\nHello World\n\nThe output is:\n\nHello World\n\n\
    The output is:\n\nHello World\nHello World\n\nThe output is:\n\nHello World\n\n\
    The output is:\n\nHello World\nHello World\n\nThe output is:\n\nHello World\n\
    Hello World\nHello World\nHello World\n\nThe output is:\n\nHello World\nHello\
    \ World\nHello World\n\nThe output is:\n\nHello World\nHello World\nHello World\n\
    Hello World\n\nThe output is:\n\nHello World\n\nThe output is:\n\nHello World\n\
    Hello World\nHello World\n\nThe output is:\n\nHello World\nHello World\n\nThe\
    \ output is:\n\nHello World\nHello World\nHello World\n\nThe output is:\n\nHello\
    \ World\n\nThe output is:\n\nHello World\nHello World\nHello World\nHello World\n\
    \nThe output is:\n\nHello World\nHello World\nHello World\nHello World\n\nThe\
    \ output is:\n\nHello World\nHello World\nHello World\n\nThe output is:\n\nHello\
    \ World\nHello World\n\nThe output is:\n\nHello World\nHello World\nHello World\n\
    \nThe output is:\n\nHello World\nHello World\n\nThe output is:\n\nHello World\n\
    Hello World\n\nThe output is:\n\nHello World\nHello World\n\nThe output is:\n\n\
    Hello World\nHello World\nHello World\nHello World\n\nThe output is:\n\nHello\
    \ World\nHello World\nHello World\nHello World\n\nThe output is:\n\nHello World\n\
    Hello World\nHello World\n\nThe output is:\n\nHello World\nHello World\nHello\
    \ World\n\nThe output is:\n\nHello World\nHello World\n\nThe output is:\n\nHello\
    \ World\nHello World\nHello World\n\nThe output is:\n\nHello World\nHello World\n\
    \nThe output is:\n\nHello World\nHello World\nHello World\n\nThe output is:\n\n\
    Hello World\nHello World\n\nThe output is:\n\nHello World\nHello World\nHello\
    \ World\n\nThe output is:\n\nHello World\nHello World\nHello World\nHello World\n\
    \nThe output is:\n\nHello World\nHello World\nHello World\nHello World\n\nThe\
    \ output is:\n\nHello World\nHello World\nHello World\n\nThe output is:\n\nHello\
    \ World\nHello World\nHello World\n\nThe output is:\n\nHello World\nHello World\n\
    \nThe output is:\n\nHello World\nHello World\nHello World\n\nThe output is:\n\n\
    Hello World\nHello World\n\nThe output is:\n\nHello World\nHello World\nHello\
    \ World\nHello World\nThe original code is:\n\nclass Base:\n    def __init__(self):\n\
    \        self.a = 5\nclass Derived1(Base):\n    def __init__(self):\n        self.b\
    \ = 1\nclass Derived2(Base):\n    def __init__(self):\n        self.c = 1\nclass\
    \ Derived3(Base):\n    def __init__(self):\n        self.d = 1\nclass Derived4(Derived1,\
    \ Derived2, Derived3):\n    def __init__(self):\n        Base.__init__(self)\n\
    \        Derived1.__init__(self)\n        Derived2.__init__(self)\n        Derived3.__init__(self)\n\
    \nclass Derived5(Derived1, Derived2, Derived3):\n    def __init__(self):\n   \
    \     Base.__init__(self)\n        super().__init__()\n\nclass Derived6(Derived1,\
    \ Derived2, Derived3):\n    def __init__(self):\n        super().__init__()\n\n\
    class Derived7(Derived1, Derived2, Derived3):\n    def __init__(self):\n     \
    \   super(Derived1, self).__init__()\n        super(Derived2, self).__init__()\n\
    \        super(Derived3, self).__init__()\n\nThe output is:\n\nTraceback (most\
    \ recent call last):\n  File \"inheritance6.py\", line 18, in <module>\n    d1\
    \ = Derived1()\nTypeError: __init__() missing 1 required positional argument:'self'\n\
    \nThe output is: \n\nTraceback (most recent call last):\n  File \"inheritance6.py\"\
    , line 23, in <module>\n    d3 = Derived3()\nTypeError: __init__() missing 1 required\
    \ positional argument:'self'\n\nThe output is: \n\nTraceback (most recent call\
    \ last):\n  File \"inheritance6.py\", line 26, in <module>\n    d4 = Derived4()\n\
    TypeError: __init__() missing 1 required positional argument:'self'\n\nThe output\
    \ is: \n\nTraceback (most recent call last):\n  File \"inheritance6.py\", line\
    \ 36, in <module>\n    print(d1.d, d1.b, d2.b, d2.c, d3.c, d3.d, d4.d, d4.b, d4.c,\
    \ d4.d)\nTypeError: __init__() missing 1 required positional argument:'self'\n\
    \nThe output is: \n\nTraceback (most recent call last):\n  File \"inheritance6.py\"\
    , line 36, in <module>\n    print(d1.d, d1.b, d2.b, d2.c, d3.c, d3.d, d4.d, d4.b,\
    \ d4.c, d4.d)\nTypeError: __"
- code: "module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk,\
    \ Read);\nreg[7:0] Storage[15:0];\nreg[7:0] ObusReg;\nassign #1 Obus = ObusReg;\n\
    always @(posedge Clk)\nif (Read==1'b0)\nwhile ($signed(Adr) < 16 & $signed(Adr)\
    \ >= 0)\n    Storage[Adr] <= Ibus;\nelse\n    ObusReg <= Storage[Adr];\nendmodule\
    \    \n### Explanation: \nThe code is based on the standard RAM module and it\
    \ first uses a while loop to store the data in the storage array. It starts from\
    \ 0 and ends at 16 \u2013 1 and checks the condition using less than operation\
    \ and greater than operation. \n\nA different variation instruction is used inside\
    \ the loop to break the loop. The new instruction is 0 if the $signed(Adr) is\
    \ greater than or equal to 16, but less than (0-15). That's the code for the new\
    \ instruction.\n\n### Verilog Simulation:\nThe RAM module is simulated using the\
    \ following test bench. \n#### Test bench:\nmodule test_ram;\nreg[7:0] Obus_t,\
    \ Ibus_t, Adr_t;\nwire[7:0] Obus_w;\nassign #1 Obus_w = Obus_t;\nreg Clk_t;\n\
    wire Read_t;\nassign #1 Read_t = 1'b0;\ninitial begin\nAdr_t = 0;\nend\n\nalways\
    \ @(posedge Clk_t)\nbegin\nObus_t <= Ibus_t;\nif (Adr_t < 8)\n   Obus_t <= $random;\n\
    else\n   Obus_t <= 0;\nend\n\ninitial begin\nRead_t = 1'b1;\nend\nalways @(posedge\
    \ Clk_t)\nbegin\nif (Read_t == 1'b1)\n   Ibus_t <= $random;\nend\n\ninitial begin\n\
    Adr_t = 3;\nend\nalways @(posedge Clk_t)\nbegin\nAdr_t = Adr_t + 1;\nend\n\ninitial\
    \ begin\nAdr_t = 0;\nend\nalways @(posedge Clk_t)\nbegin\nAdr_t = Adr_t + 1;\n\
    end\n\ninitial begin\nAdr_t = 7;\nend\nalways @(posedge Clk_t)\nbegin\nAdr_t =\
    \ Adr_t - 1;\nend\n\ninitial begin\nAdr_t = 7;\nend\nalways @(posedge Clk_t)\n\
    begin\nAdr_t = Adr_t - 1;\nend\n\ninitial begin\nAdr_t = 0;\nend\n\nalways @(posedge\
    \ Clk_t)\nbegin\nif (Adr_t > 7)\n   Clk_t = 1;\nelse\n   Clk_t = 0;\nend\n\nRAM\
    \ ram (\n.Obus(Obus_w),\n.Ibus(Ibus_t),\n.Adr(Adr_t),\n.Clk(Clk_t),\n.Read(Read_t)\n\
    );\n\ninitial begin\n#100;\n$display(\"Initial Ibus, Obus_t before the test: %x\
    \ %x\", Ibus_t, Obus_t);\n#100;\n$display(\"Initial Ibus, Obus_w before the test:\
    \ %x %x\", Ibus_t, Obus_w);\n#100;\n$display(\"Initial Ibus, Obus_t after the\
    \ test: %x %x\", Ibus_t, Obus_t);\n#100;\n$display(\"Initial Ibus, Obus_w after\
    \ the test: %x %x\", Ibus_t, Obus_w);\n$finish;\nend\n\nendmodule\n\n### Simulation\
    \ Output:\n![image](https://user-images.githubusercontent.com/57335291/112628389-b0c51100-8e45-11eb-9a46-9f4e123f1623.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628579-ec80f800-8e45-11eb-8f4c-4a0099d2953a.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628683-12a69800-8e46-11eb-8405-17326816ac03.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628723-1db38700-8e46-11eb-84d3-73748e9448f3.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628734-21470e00-8e46-11eb-985b-be5d137084e8.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628744-2441fe80-8e46-11eb-97e3-8624a43a2f28.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628758-286e1c00-8e46-11eb-95a9-8822783b512f.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628766-2cb05700-8e46-11eb-9c9e-40919020dd20.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628774-2f12b100-8e46-11eb-952d-258e3505ad10.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628787-31750b00-8e46-11eb-9af8-50cbbf87eb00.png)\n\
    \n![image](https://user-images.githubusercontent.com/57335291/112628802-346ffd80-8e46-11eb-80d5-0e8b7a49a3bf.png)\n\
    \n### Conclusion:\nThe simulation results show that the RAM module works as expected\
    \ and the data is stored in the 16-bit storage array. And it is able to fetch\
    \ the data and can display the desired output.\nmodule ADD(output[7:0] Obus,input[7:0]\
    \ Ibus1,input[7:0] Ibus2, input[1:0] Sltu,input[3:0] Adr,input Clk, Read);\nreg[7:0]\
    \ ObusReg;\nalways @(posedge Clk)\nbegin\n    ObusReg <= ObusReg + Ibus1;\nend\n\
    endmodule\n#include <stdio.h>\n\nint main(){\n    int i=0;\n    while(i<10){\n\
    \        if(i%2==0){\n            printf(\"%d\\n\",i);\n        }\n        i++;\n\
    \    }\n    return 0;\n}   \n# Task-7:\n# Name: \n# Roll no: 18103001\n# Task:\
    \ Implement a basic test bench for the above code module.\n\n### Base Verilog\
    \ Code:\nmodule ADD(output[7:0] Obus,input[7:0] Ibus1,input[7:0] Ibus2);\nreg[7:0]\
    \ ObusReg;\nassign #1 Obus = ObusReg;\nalways @(Ibus1, Ibus2, ObusReg)\nbegin\n\
    ObusReg"
- code: "```\nimport icarus_libs.stdenv as stdenv\n\nstdenv.mkDerivation {\n    name\
    \ = \"hello-world\";\n    buildInputs = [stdenv];\n    installPhase = ''\n   \
    \     mkdir $out\n        ln -s $buildInputs.stdenv/info/this-package/bin/ram\
    \ $out/ram\n        ln -s $buildInputs.stdenv/lib/clang/11.0.1/bin/clang $out/clang\n\
    \        ln -s $buildInputs.stdenv/lib/clang/11.0.1/bin/clang++ $out/clang++\n\
    \    '';\n}\n```\n### Variation Output:\n```\n$./ram\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n#10 @  0:00.021 (10.0ns)\n\
    #10 @  0:00.021 (10.0ns)\n$\n```\n#include <cstdio>\n\nint main()\n{\n\tprintf(\"\
    Hi from 11th variation\\n\");\n\treturn 0;\n}\n#include <cstdio>\n\nint main()\n\
    {\n\tprintf(\"Hi from 1st variation\\n\");\n\treturn 0;\n}\n#include <cstdio>\n\
    \nint main()\n{\n\tprintf(\"Hi from 2nd variation\\n\");\n\treturn 0;\n}"
- code: "module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk,\
    \ Read);\nreg[7:0] Storage[15:0];\nreg[7:0] ObusReg;\nassign #1 Obus = ObusReg;\n\
    initial\nalways @(posedge Clk)\nbegin\nint i;\ni=0;\nwhile (i <= 15)\nStorage[i]\
    \ <= Ibus;\ni=i+1;\nend\nassign ObusReg = Storage[Adr];\nendmodule\n### Results:\n\
    \n### Analysis of Results:\nIn the code above, we have introduced a while loop,\
    \ which will run till i is less than or equal to 15. Since the array index start\
    \ from 0, the loop will run till 15. Now, in the line where oBusReg is assigned\
    \ to the Storage[Adr], Storage[15] is assigned to Obusreg, since at the end of\
    \ the loop Storage[15] is assigned the value of the last variable, which is Ibus,\
    \ which is the input from user.\n\n### Conclusion:  \nIn this experiment, we have\
    \ learned to write while loop condition and how it works.\n\n![alt text](https://github.com/prasannakumars01/ECE545_Digital_System_Verification/blob/master/Images_Experiment/Experiment_13_1.PNG)\n\
    ![alt text](https://github.com/prasannakumars01/ECE545_Digital_System_Verification/blob/master/Images_Experiment/Experiment_13_2.PNG)\n\
    \n/Experiments/Experiment_2/experiment2_Q2/testbench.c\n#include <stdio.h>\n#include\
    \ \"verilated.h\"\n#include \"Vexperiment.h\"\n\nint main(int argc, char** argv)\
    \ {\n\tprintf(\"*** Verilog Formal Testbench\\n\\n\");\n\tVexperiment* top = new\
    \ Vexperiment;\n\tVerilated::traceEverOn(true);\n\tVerilatedVcdC* tfp = new VerilatedVcdC;\n\
    \ttop->trace(tfp,99);\n\ttfp->open(\"trace2.vcd\");\n    \n    printf(\"*** Initializing\
    \ Verilog Testbench\\n\\n\");\n    top->I_op=0;\n    top->I_inp1=0;\n    top->I_inp2=0;\n\
    \    top->clk=0;\n    top->eval();\n    \n    printf(\"*** Starting Verilog Testbench\\\
    n\\n\");\n    tfp->dump(0);\n    for(int i=0;i<10;i++){\n        top->clk=!top->clk;\n\
    \        top->eval();\n        if(i%8==0) printf(\"clk=%u\",top->clk);\n     \
    \   if(i%8==3) printf(\" inp1=%u\",top->I_inp1);\n        if(i%8==7) printf(\"\
    \ inp2=%u\",top->I_inp2);\n        printf(\"\\n\");\n        tfp->dump(i*10);\n\
    \    }\n    tfp->close();\n\tdelete top;\n}\n/Experiments/Experiment_5/Experiment_5_Q1/Makefile\n\
    TOP_MODULE=experiment\n\ninclude../../Common/Makefile.inc\n\nall: compile testbench\
    \ run\n\ncompile:\n\t$(VVP) testbench.c $(TOP_MODULE).v\n\ntestbench:\n\t$(VVP)\
    \ testbench.c $(TOP_MODULE).v\n\nrun:\n\t$(GTKWAVE) trace.vcd\n\t$(GTKWAVE) trace2.vcd\n\
    \t$(GTKWAVE) trace3.vcd\n\t$(GTKWAVE) trace4.vcd\n\t$(GTKWAVE) trace5.vcd\n\n\
    clean:\n\t$(RM) -f *.vcd *.log *.dat t $(RM) -rf *.dSYM\nestbench\n\ncleanall:\
    \ clean\n\t$(RM) -f *~\n\n.PHONY: all compile testbench run clean cleanall\n\n\
    .PHONY: compile\n\ncompile:\n\t$(VVP) testbench.c $(TOP_MODULE).v\n\ntestbench:\n\
    \t$(VVP) testbench.c $(TOP_MODULE).v\n\nrun:\n\t$(GTKWAVE) trace.vcd\n\t$(GTKWAVE)\
    \ trace2.vcd\n\t$(GTKWAVE) trace3.vcd\n\t$(GTKWAVE) trace4.vcd\n\t$(GTKWAVE) trace5.vcd\n\
    \nclean:\n\t$(RM) -f *.vcd *.log *.dat testbench\n\ncleanall: clean\n\t$(RM) -f\
    \ *~\n\n.PHONY: cleanall\n\ncleanall: clean\n\t$(RM) -f *~\n\t$(RM) -rf build\n\
    \t$(RM) -rf __pycache__\n\t$(RM) -rf _pycache\n\t$(RM) -rf.pytest_cache\n\t$(RM)\
    \ -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\t$(RM) -rf.tox\n\t$(RM) -rf.cache\n\
    \t$(RM) -rf.pytest_cache\n\t$(RM) -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\
    \t$(RM) -rf.tox\n\t$(RM) -rf.coverage\n\t$(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM)\
    \ -rf.pytest_cache\n\t$(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM) -rf.tox\n\t$(RM)\
    \ -rf.coverage\n\t$(RM) *.pyc\n\t$(RM) -rf *.dSYM\n\n.PHONY: clean\n\nclean:\n\
    \t$(RM) -f *.vcd *.log *.dat testbench\n\n.PHONY: cleanall\n\ncleanall: clean\n\
    \t$(RM) -f *~\n\t$(RM) -rf build\n\t$(RM) -rf __pycache__\n\t$(RM) -rf _pycache\n\
    \t$(RM) -rf.pytest_cache\n\t$(RM) -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\
    \t$(RM) -rf.tox\n\t$(RM) -rf.cache\n\t$(RM) -rf.pytest_cache\n\t$(RM) -rf build\n\
    \t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\t$(RM) -rf.tox\n\t$(RM) -rf.coverage\n\t\
    $(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM) -rf.pytest_cache\n\t$(RM) -rf env\n\t\
    $(RM) -rf.env\n\t$(RM) -rf.tox\n\t$(RM) -rf.coverage\n\t$(RM) *.pyc\n\t$(RM) -rf\
    \ *.dSYM\n\n.PHONY: cleanall\n\ncleanall: clean\n\t$(RM) -f *~\n\t$(RM) -rf build\n\
    \t$(RM) -rf __pycache__\n\t$(RM) -rf _pycache\n\t$(RM) -rf.pytest_cache\n\t$(RM)\
    \ -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\t$(RM) -rf.tox\n\t$(RM) -rf.cache\n\
    \t$(RM) -rf.pytest_cache\n\t$(RM) -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\
    \t$(RM) -rf.tox\n\t$(RM) -rf.coverage\n\t$(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM)\
    \ -rf.pytest_cache\n\t$(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM) -rf.tox\n\t$(RM)\
    \ -rf.coverage\n\t$(RM) *.pyc\n\t$(RM) -rf *.dSYM\n\n\nclean:\n\t$(RM) -f *.vcd\
    \ *.log *.dat testbench\n\ncleanall: clean\n\t$(RM) -f *~\n\t$(RM) -rf build\n\
    \t$(RM) -rf __pycache__\n\t$(RM) -rf _pycache\n\t$(RM) -rf.pytest_cache\n\t$(RM)\
    \ -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\t$(RM) -rf.tox\n\t$(RM) -rf.cache\n\
    \t$(RM) -rf.pytest_cache\n\t$(RM) -rf build\n\t$(RM) -rf dist\n\t$(RM) -rf.eggs\n\
    \t$(RM) -rf.tox\n\t$(RM) -rf.coverage\n\t$(RM) -rf env\n\t$(RM) -rf.env\n\t$(RM)\
    \ -rf.pytest_cache\n\t$(RM) -rf env\n\t$(RM) -rf.env"
- code: "reg[3:0] Adr;\nreg[7:0] ObusReg;\nassign #1 Obus = ObusReg;\nalways @(posedge\
    \ Clk)\nif (Read==1'b0)\n    Storage[Adr[0]] <= Ibus;\nelse if (Adr[1]==1\u2019\
    b0)\n    Storage[Adr[0]] <= Ibus;\nelse if (Adr[2]==1\u2019b0)\n    Storage[Adr[0]]\
    \ <= Ibus;\nelse if (Adr[3]==1\u2019b0)\n    Storage[Adr[0]] <= Ibus;\nelse\n\
    \    ObusReg <= Storage[Adr[0]];\nendmodule\n### Testbench:\n- This is a modified\
    \ testbench to test the modified code.\n```\n\n**Instructions:**\n\n- Open the\
    \ **Modified Code** file in Vivado.\n- Run the **Simulation** to verify the output\
    \ of the **RAM** module.\n- Run the **Analysis** to see the **Synthesis** report.\n\
    - Run the **Optimization** to see the **Optimization** report.\n- Run the **Static\
    \ Timing Analysis** tool to see the **Static Timing Analysis** report.\n- Run\
    \ the **System Timing Analysis** tool to see the **System Timing Analysis** report.\n\
    - Run the **Power Analysis** to see the **Power Analysis** report.\n- Download\
    \ the **Synthesis** report, **Optimization** report, **Static Timing Analysis**\
    \ report, **System Timing Analysis** report, and **Power Analysis** report for\
    \ the code and save them in a folder named **Assignment 3**.\n- Make sure to keep\
    \ the folder **Assignment 1-6** in the same directory.\n- Check the **Assignment\
    \ 3** folder and provide us the reports.\n\n**Sample Outputs:**\n\nYou can find\
    \ the sample outputs for the above-mentioned testbenches in the **Sample Outputs**\
    \ folder.\n\n***\n\n## Assignment 4\n\n**Description:**\n\nIn this assignment,\
    \ you are going to work on the hardware implementation of a **Viterbi Decoder**\
    \ and **FPGA Implementation**. You are going to use the **Modified Code** from\
    \ Assignment 3. You are also provided with a **Testbench** to verify your modified\
    \ code.\n\n**Instructions:**\n\n- Open the **Modified Code** file in Vivado.\n\
    - Run the **Implementation** to see the **Implementation** report for the code.\n\
    - **Synthesize** your code.\n- Create a **Project** in Vivado, **Open Project**\
    \ using the **implementation.bit**.\n- Run the **Simulation** to verify the output\
    \ of the **Viterbi Decoder** module.\n- Download the **Synthesis** report, **Implementation**\
    \ report, and your **implementation.bit** for the code and save them in a folder\
    \ named **Assignment 4**.\n- Make sure to keep the folder **Assignment 1-6** in\
    \ the same directory.\n- Check the **Assignment 4** folder and provide us the\
    \ reports.\n\n**Sample Outputs:**\n\nYou can find the sample outputs for the above-mentioned\
    \ testbenches in the **Sample Outputs** folder.\n\n***\n\n## Assignment 5\n\n\
    **Description:**\n\nIn this assignment, you are going to work on the hardware\
    \ implementation of a **Decoder** and **FPGA Implementation**. In this assignment,\
    \ instead of a **Testbench**, you are going to use the test vectors which are\
    \ provided to you in the **Assignment 5** folder. You are also provided with the\
    \ **Modified Code** from Assignment 4.\n\n**Instructions:**\n\n- Open the **Modified\
    \ Code** file in Vivado.\n- Run the **Implementation** to see the **Implementation**\
    \ report for the code.\n- **Synthesize** your code.\n- Create a **Project** in\
    \ Vivado, **Open Project** using the **implementation.bit**.\n- Run the **Simulation**\
    \ to verify the output of the **Decoder** module.\n- Download the **Synthesis**\
    \ report, **Implementation** report, and your **implementation.bit** for the code\
    \ and save them in a folder named **Assignment 5**.\n- Make sure to keep the folder\
    \ **Assignment 1-6** in the same directory.\n- Check the **Assignment 5** folder\
    \ and provide us the reports.\n\n**Sample Outputs:**\n\nYou can find the sample\
    \ outputs for the above-mentioned testbenches in the **Sample Outputs** folder.\n\
    \n***\n\n## Assignment 6\n\n**Description:**\n\nIn this assignment, you are going\
    \ to work on the hardware implementation of a **Decoder** using **Vivado HLS**\
    \ and **FPGA Implementation**. In this assignment, instead of a **Testbench**,\
    \ you are going to use the test vectors which are provided to you in the **Assignment\
    \ 6** folder. You are also provided with the **Modified Code** from Assignment\
    \ 4.\n\n**Instructions:**\n\n- Open the **Modified Code** file in Vivado.\n- Create\
    \ a **C++** file named **test_vit.cpp** in the **C++ Testbench** folder.\n- Run\
    \ the **HLS** tool to see the **HLS** report for the code.\n- **Synthesize** your\
    \ code.\n- Download the **HLS** report, **Implementation** report, and your **implementation.bit**\
    \ for the code and save them in a folder named **Assignment 6**.\n- Make sure\
    \ to keep the folder **Assignment 1-6** in the same directory.\n- Check the **Assignment\
    \ 6** folder and provide us the reports.\n\n**Sample Outputs:**\n\nYou can find\
    \ the sample outputs for the above-mentioned testbenches in the **Sample Outputs**\
    \ folder.\n\n***\n\n## Assignment 7\n\n**Description:**\n\nIn this assignment,\
    \ you are going to work on the **FPGA Implementation** of the **Viterbi Decoder**\
    \ and the **Decoder**. You are provided with the **Modified Code** from Assignment\
    \ 4 in the **Modified Code** folder.\n\n**Instructions:**\n\n- Create a **Project**\
    \ in Vivado, **Open Project** using the **implementation.bit**.\n- Download the\
    \ **Implementation** report for the code and save it in a folder named **Assignment\
    \ 7**.\n- Make sure to keep the folder **Assignment 1-6** in the same directory.\n\
    - Check the **Assignment 7** folder and provide us the report.\n\n**Sample Outputs:**\n\
    \nYou can find the sample outputs for the above-mentioned testbenches in the **Sample\
    \ Outputs** folder.\n\n***\n\n## Assignment 8\n\n**Description:**\n\nIn this assignment,\
    \ you are going to work on the **FPGA Implementation** of the **Decoder** using\
    \ **HLS**. You are provided with **Modified Code** and the **Testbench** from\
    \ Assignment 6 in the **Modified Code** folder.\n\n**Instructions:**\n\n- Open\
    \ the **Modified Code** file in Vivado.\n- Create a **C++** file named **test_vit.cpp**\
    \ in the **C++ Testbench** folder.\n- Run the **HLS** tool to see the **HLS**\
    \ report for the code.\n- Download the **HLS** report, and your **implementation.bit**\
    \ for the code and save them in a folder named **Assignment 8**.\n- Make sure\
    \ to keep the folder **Assignment 1-6** in the same directory.\n- Check the **Assignment\
    \ 8** folder and provide us the reports.\n\n**Sample Outputs:**\n\nYou can find\
    \ the sample outputs for the above-mentioned testbenches in the **Sample Outputs**\
    \ folder.\n\n***\n\n## Timing and Power Reports\n\n**Description:**\n\nIn this\
    \ assignment, you are going to generate the **Timing** and **Power** reports of\
    \ the **Viterbi Decoder** module and the **Decoder** module.\n\n**Instructions:**\n\
    \n- Download the **Timing** and **Power** reports for the code and save them in\
    \ a folder named **Timing and Power Reports**.\n- Make sure to keep the folder\
    \ **Assignment 1-8** in the same directory.\n- Check the **Timing and Power Reports**\
    \ folder and provide us the reports.\n\n**Sample Outputs:**\n\nYou can find the\
    \ sample outputs for the above-mentioned testbenches in the **Sample Outputs**\
    \ folder.\n\n***\n## Final Grade\n\n- **A+** - 99-100\n- **A** - 90-98\n- **B**\
    \ - 80-89\n- **C** - 70-79\n- **D** - 60-69\n- **F** - 50-59\n- **F** - less than\
    \ 50\n- **No Grade** - not able to pass the assignment\n\n***\n\n## References\n\
    \n1. [Vivado User Guide](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug902-vivado-user-guide.pdf)\n\
    2. [Vivado HLS User Guide](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug931-vivado-hls-user-guide.pdf)"
- code: |-
    ```
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
    begin
        Storage[Adr] <= Ibus;
        ObusReg <= Storage[Adr];
    end
    else begin
        ObusReg <= Storage[Adr];
    end
    endmodule
    ```
    ### Simulation:
    ![Alt text](./Screenshots/RAM_loop_simulated.png?raw=true "")
    ### Verification:
    ![Alt text](./Screenshots/RAM_loop_verification.png?raw=true "")
    ### Verilog HDL Code:
    ```
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else
        ObusReg <= Storage[Adr];
    endmodule
    ```
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <cstdlib>
    #include <cstdio>
    #include <cmath>
    #include <cstring>
    #include <algorithm>
    using namespace std;

    #include "mips.h"
    #define MemSize 0x100000
    #define DataSize 0x10000
    int RAM[MemSize];

    mips::mips(){
        for(int i=0;i<DataSize;i++)
            RAM[i]=0;
    }

    void mips::setRAM(int x, int y){
        RAM[x]=y;
    }

    int mips::getRAM(int x){
        return RAM[x];
    }

    int mips::getReg(int x){
        return Reg[x];
    }

    void mips::setReg(int x, int y){
        Reg[x]= y;
    }

    void mips::MemRead(int &A, int &D, int &PC, bool &Z, bool &N, bool &U, bool &L, bool &V){
        A = 0;
        D = 0;
        Z = 0;
        N = 0;
        U = 0;
        L = 0;
        V = 0;
        int M, M1, M2;
        M1 = MIPS[PC/4];
        M2 = (MIPS[PC/4] >> 16) & 0xffff;
        M = M1 & 0x3fffff;
        switch(M2){
            case 0x8:
                A = MIPS[M/4];
                break;
            case 0x9:
                A = MIPS[M/4] >> 16;
                break;
            case 0x23:
                A = MIPS[M/4];
                D = MIPS[M/4+1];
                break;
            case 0x10:
                if(MIPS[M/4] & 1){
                    PC = PC + ((MIPS[M/4] >> 2) << 2);
                }else{
                    PC = PC + 4;
                }
                break;
            case 0x11:
                if(MIPS[M/4] & 1){
                    PC = PC + ((MIPS[M/4] >> 2) << 2);
                }else{
                    PC = PC + 4;
                }
                break;
            case 0x19:
                D = 0;
                for(int i = 1; i <= 10; i++){
                    D += (MIPS[M/4] % 2) * pow(2, i-1);
                    MIPS[M/4] /= 2;
                }
                if(MIPS[M/4]!= 0){
                    cout << "Invalid Operand\n";
                    cout << "Register Number: " << M/4 << "\n";
                    return;
                }
                break;
            case 0x20:
                if(M & 1){
                    PC = PC + ((M >> 2) << 2);
                }
                break;
            case 0x21:
                if(M & 1){
                    PC = PC + ((M >> 2) << 2);
                }
                break;
            case 0x28:
                A = M/4;
                break;
            case 0x29:
                A = M/4 >> 16;
                break;
            default:
                break;
        }
        if(M1 & 0x80000000) N = 1;
        if(M1 & 0x40000000) U = 1;
        if(M1 & 0x20000000) Z = 1;
        if(M1 & 0x10000000) L = 1;
        if(M1 & 0x08000000) V = 1;
    }

    void mips::RegWrite(int A, int D, int B, bool Z, bool N, bool U, bool L, bool V){
        Reg[A] = D;
        Reg[B] = A;
        if(Z) Reg[29] = 0;
        if(N) Reg[29] = 1;
        if(U) Reg[29] = 2;
        if(L) Reg[29] = 3;
        if(V) Reg[29] = 4;
    }

    void mips::ALUOperation(int &ALUResult, int A, int B, int ALUOp, bool Z, bool N, bool U, bool L, bool V){
        ALUResult = 0;
        switch(ALUOp){
            case 0:
                ALUResult = A + B;
                break;
            case 1:
                ALUResult = A - B;
                break;
            case 2:
                ALUResult = A & B;
                break;
            case 3:
                ALUResult = A | B;
                break;
            case 4:
                ALUResult = A ^ B;
                break;
            case 5:
                ALUResult = A << 1;
                break;
            case 6:
                ALUResult = A >> 1;
                break;
            case 7:
                ALUResult = A >> 2;
                break;
            case 8:
                ALUResult = A << 2;
                break;
            case 9:
                ALUResult = A << 3;
                break;
            case 10:
                ALUResult = A >> 3;
                break;
            case 11:
                ALUResult = A << 4;
                break;
            case 12:
                ALUResult = A >> 4;
                break;
            default:
                break;
        }
        if(ALUResult == 0){
            if(Z) Reg[29] = 0;
            else Reg[29] = 1;
        }
        if(ALUResult < 0){
            if(U) Reg[29] = 2;
            else Reg[29] = 3;
        }
        if(ALUResult > 0){
            if(L) Reg[29] = 4;
            else Reg[29] = 5;
        }
    }

    void mips::execute(int &A, int &D, int &B, int &ALUResult, int &PC, bool &Z, bool &N, bool &U, bool &L, bool &V){
        int M2;
        D = 0;
        Z = 0;
        N = 0;
        U = 0;
        L = 0;
        V = 0;
        switch(MIPS[PC/4] >> 26){
            case 0:
                switch((MIPS[PC/4] >> 24) & 0x07){
                    case 0:
                        D = Reg[(MIPS[PC/4] >> 21) & 0x0f];
                        break;
                    case 2:
                        D = Reg[(MIPS[PC/4] >> 21) & 0x0f];
                        break;
                    case 4:
                        D = Reg[(MIPS[PC/4] >> 16) & 0x0f];
                        break;
                    case 6:
                        D = Reg[(MIPS[PC/4] >> 16) & 0x0f];
                        break;
                    case 8:
                        D = 0;
                        for(int i = 1; i <= ((MIPS[PC/4] >>
- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else if (Clock==1'b1 && Read==1'b1)
        ObusReg <= Storage[Adr];
    endmodule
    ### Comments:
    The modified code shows that the read operation takes place when the read and write signals are active.

    ## 12.14

    ### Base Verilog Code:
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else if (Clock==1'b1 && Read==1'b1)
        ObusReg <= Storage[Adr];
    endmodule
    ### Variation Instruction:
    The instruction will add a delay before the read operation and the read operation will be controlled by both the write signal
- code: |-
    module RAM_Write_Operation (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    endmodule
    ### Verification:
    Verification is done using the same test code we did in the previous section.
    ### Result:
    ![Screenshot from 2021-05-27 03-41-03](https://user-images.githubusercontent.com/63580613/119722
- code: "module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk,\
    \ Read);\nreg[7:0] Storage[15:0];\nreg[7:0] ObusReg;\nassign #1 Obus = ObusReg;\n\
    always @(posedge Clk)\nif (Read==1'b0) {\n  while (Adr < Storage.size()) {\n \
    \   Storage[Adr] <= Ibus;\n    Adr <= Adr+1;\n  }\n}\n\nelse {\n    while (Adr\
    \ < Storage.size()) {\n      ObusReg <= Storage[Adr];\n      Adr <= Adr+1;\n \
    \ }\n}\nendmodule\n### Simulation & Results:\nSimulation Result:\n![while2](https://user-images.githubusercontent.com/70331588/110304026-707a1e80-8033-11eb-8d5b-8d7668c21bc6.png)\n\
    Simulation Result (Adr-wise):\n![while2_2](https://user-images.githubusercontent.com/70331588/110304101-8841a380-8033-11eb-8c21-7293a4a1259f.png)\n\
    ### Conclusion:\nBoth the simulation gives the same result. Therefore, the given\
    \ while loop is valid.\n/README.md\n# Verilog-Practice\nThe goal of this project\
    \ is to implement all the basic verilog syntax. \nIt also includes a few tasks\
    \ on each of the major topics like data flow, control flow, arrays, loops, etc.\n\
    ### 1. Data Flow\n- [x] [Multiplexer](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/1_Multiplexer)\n\
    - [x] [Multiplexor](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/2_Mux)\n\
    - [x] [Decoder](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/3_Decoder)\n\
    - [x] [Demultiplexer](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/4_Demultiplexer)\n\
    - [x] [Demultiplexor](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/5_Demux)\n\
    - [x] [Register](https://github.com/sourav1510/Verilog-Practice/tree/master/Data-Flow/6_Register)\n\
    ### 2. Control Flow\n- [x] [If-Else-Statement](https://github.com/sourav1510/Verilog-Practice/tree/master/Control-Flow/1_If-Else-Statement)\n\
    - [x] [Switch](https://github.com/sourav1510/Verilog-Practice/tree/master/Control-Flow/2_Switch)\n\
    - [x] [If-Else If-Statement](https://github.com/sourav1510/Verilog-Practice/tree/master/Control-Flow/3_If-Else-If-Statement)\n\
    - [x] [Case](https://github.com/sourav1510/Verilog-Practice/tree/master/Control-Flow/4_Case)\n\
    - [x] [Case-Statement](https://github.com/sourav1510/Verilog-Practice/tree/master/Control-Flow/5_Case-Statement)\n\
    ### 3. Loops\n- [x] [For-Loop](https://github.com/sourav1510/Verilog-Practice/tree/master/Loops/1_For-Loop)\n\
    - [x] [Foreach-Loop](https://github.com/sourav1510/Verilog-Practice/tree/master/Loops/2_Foreach-Loop)\n\
    - [x] [While-Loop](https://github.com/sourav1510/Verilog-Practice/tree/master/Loops/3_While-Loop)\n\
    - [x] [Repeat-Loop](https://github.com/sourav1510/Verilog-Practice/tree/master/Loops/4_Repeat-Loop)\n\
    ### 4. Arrays\n- [x] [Array](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/1_Array)\n\
    - [x] [Array-Slice](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/2_Array-Slice)\n\
    - [x] [Array-Slice2](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/3_Ars/5_Array-Slice3)\n\
    - [x] [Array-Slice4](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/6_Array-Slice4)\n\
    - [x] [Array-Slice5](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/7_Array-Slice5)\n\
    - [x] [Array-Slice6](https://github.com/sourav1510/Verilog-Practice/tree/master/Arrays/8_Array-Slice6)\n\
    ### 5. Tasks\n- [x] [Memory-Latency](https://github.com/sourav1510/Verilog-Practice/tree/master/Memory-Latency)\n\
    - [x] [RAM](https://github.com/sourav1510/Verilog-Practice/tree/master/RAM)\n\
    - [x] [Multiplexer-Latency](https://github.com/sourav1510/Verilog-Practice/tree/master/Multiplexer-Latency)\n\
    - [x] [RAM-Latency](https://github.com/sourav1510/Verilog-Practice/tree/master/RAM-Latency)\n\
    - [x] [Bitwise-Operation](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation)\n\
    - [x] [Bitwise-Operation2](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation2)\n\
    - [x] [Bitwise-Operation3](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation3)\n\
    - [x] [Bitwise-Operation4](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation4)\n\
    - [x] [Bitwise-Operation5](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation5)\n\
    - [x] [Bitwise-Operation6](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation6)\n\
    - [x] [Bitwise-Operation7](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation7)\n\
    - [x] [Bitwise-Operation8](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation8)\n\
    - [x] [Bitwise-Operation9](https://github.com/sourav1510/Verilog-Practice/tree/master/Bitwise-Operation9)\n\
    ray-Slice2)\n- [x] [Array-Slice3](https://github.com/sourav1510/Verilog-Practice/tree/master/Array"
- code: "module tst_dff_p_b();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk); //\
    \ Instantiate the DFF\n  initial begin\n    if($time==0) // Test bench name &\
    \ Clock initialization\n      $display (\"%m: Top-level testbench module\");\n\
    \    $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\n  end\n  always #3\
    \ clk=~clk; // Generate clock\n  always #5 di=~di; // Toggle data\n  always #2\
    \ di=di[7:7]; // Toggle data based on bit 7\nendmodule\n### Output:\n![DFF_p_b_v_i_i_b_30](https://user-images.githubusercontent.com/80323921/110428228-90e04100-80c7-11eb-8377-1104508f6512.png)\n\
    /P1/P1A/S1/S1_a_v_i/S1_a_v_i_b.py\n# S1_a_v_i_b\n# To build a test bench for the\
    \ DFF module with initialzation and with various inputs.\n# To generate the verilog\
    \ code for the DFF module in the S1_a_v_i_b.py file.\n\n# Importing required packages\
    \ to run the code in a Jupyter notebook.\nimport numpy as np\nimport pandas as\
    \ pd\nimport matplotlib.pyplot as plt\nfrom IPython.display import Image, display\n\
    \n# Importing required packages to run the code in a IDE.\n# import numpy as np\n\
    # import pandas as pd\n# import matplotlib.pyplot as plt\n# from IPython.display\
    \ import Image, display\n\n# Create a Function to create a DFF Module\ndef dff_p(clk,di,do):\n\
    \  d1=di.copy() # Keep the initial value of di as di.copy() for clarity.\n  for\
    \ i in range(len(clk)): # Loop for the size of clk\n    if clk[i]: # If a clk\
    \ is high then\n      d1[i]=di[i] # the next output do[i] will be the di[i] value.\n\
    \    else: # If a clk is low then\n      d1[i]=do[i] # the next output do[i] will\
    \ be the do[i] value.\n      if not(di[i]): # If di[i] is false then\n       \
    \ do[i]=do[i-1] # the next output do[i] will be the previous value of do[i-1]\n\
    \  if di[-1]: # If di[-1] is true then\n    d1[-1]=di[-1] # the next output do[-1]\
    \ will be the di[-1] value.\n  else: # If di[-1] is false then\n    d1[-1]=do[-1]\
    \ # the next output do[-1] will be the do[-1] value.\n  do=np.array(d1) # Create\
    \ a numpy array of do.\n  print(\"Output of do:\",do) # Print the output of do.\n\
    \  print(\"Output of do and di:\",d1) # Print the output of do and di.\n  return\
    \ do # Returns the do array.\n\n# Create the initializations for di, clk and do.\n\
    di=np.array([0,1,0,1])\nclk=np.array([0,0,1,0])\ndo=np.array([0,1,1,0])\n\n# Create\
    \ a list variable to store different combinations of di and clk inputs.\ndi_clk_combs\
    \ = []\n\n# Append the initializations to the list variable.\ndi_clk_combs.append(['0','0'_clk_combs[2]=\"\
    00 01\"\ndi_clk_combs[3]=\"00 10\"\ndi_clk_combs[4]=\"00 11\"\ndi_clk_combs[5]=\"\
    01 00\"\ndi_clk_combs[6]=\"01 01\"\ndi_clk_combs[7]=\"01 10\"\ndi_clk_combs[8]=\"\
    01 11\"\ndi_clk_combs[9]=\"10 00\"\ndi_clk_combs[10]=\"10 01\"\ndi_clk_combs[11]=\"\
    10 10\"\ndi_clk_combs[12]=\"10 11\"\ndi_clk_combs[13]=\"11 00\"\ndi_clk_combs[14]=\"\
    11 01\"\ndi_clk_combs[15]=\"11 10\"\ndi_clk_combs[16]=\"11 11\"\n\n# Create an\
    \ empty list variable to store the output of do.\ndo_list=[]\n\n# Create a for\
    \ loop with the length of di_clk_combs.\nfor i in range(len(di_clk_combs)):\n\
    \  \n  # Print the inputs obtained from the previous for loop.\n  print(\"The\
    \ inputs are:\",di_clk_combs[i])\n  \n  # Use the previous function for the inputs.\n\
    \  do=dff_p(int(di_clk_combs[i][0]),int(di_clk_combs[i][1]),do)\n  \n  # Append\
    \ the output obtained from the previous function to the do_list.\n  do_list.append(do)\n\
    \  \n# Print the do_list.\nprint(\"Output of do list:\",do_list)\n\n# Plot the\
    \ output of do based on the inputs.\nplt.plot(do_list)\nplt.xlabel(\"Outputs of\
    \ do\")\nplt.ylabel(\"Inputs of di (x axis) and clk (y axis)\")\nplt.title(\"\
    DFF_p_b\")\nplt.legend([\"DFF_p_b\"],loc=\"best\")\nplt.show()\n,'0','0'])\ndi_clk_combs.append(['0','1','0','1'])\n\
    di_clk_combs.append(['0','1','1','0'])\ndi_clk_combs.append(['0','1','1','1'])\n\
    di_clk_combs.append(['1','0','0','0'])\ndi_clk_combs.append(['1','0','0','1'])\n\
    di_clk_combs.append(['1','0','1','0'])\ndi_clk_combs.append(['1','0','1','1'])\n\
    di_clk_combs.append(['1','1','0','0'])\ndi_clk_combs.append(['1','1','0','1'])\n\
    di_clk_combs.append(['1','1','1','0'])\ndi_clk_combs.append(['1','1','1','1'])\n\
    di_clk_combs.append(['0','0','0','0'])\ndi_clk_combs.append(['0','0','0','1'])\n\
    di_clk_combs.append(['0','0','1','0'])\ndi_clk_combs.append(['0','0','1','1'])\n\
    di_clk_combs.append(['0','0','0','1'])\ndi_clk_combs.append(['0','0','1','0'])\n\
    di_clk_combs.append(['0','0','1','1'])\ndi_clk_combs.append(['0','0','0','1'])\n\
    \n# Print the inputs obtained by the previous for loop.\nprint(\"The inputs are:\"\
    ,di_clk_combs)\n\n# Print the outputs of do based on the inputs in the above for\
    \ loop.\nprint(\"The outputs are:\",dff_p(di[0],di[1],do))\nprint(\"The outputs\
    \ are:\",dff_p(di[1],di[2],do))\nprint(\"The outputs are:\",dff_p(di[2],di[3],do))\n\
    \n# Convert the do_list from lists to arrays as it is required for the plot.\n\
    do_list=np.array(do_list)\n\n# Create a for loop with the size of do_list.\nfor\
    \ i in range(len(do_list)):\n  \n  # Print the output of do_list in a tabular\
    \ format.\n  print(\"The outputs are:\",do_list[i])\n\n# Change the element of\
    \ the list of lists to strings.\nfor i in range(len(di_clk_combs)):\n  di_clk_combs[i]\
    \ = ''.join(di_clk_combs[i])\n\n# Print the inputs obtained by the previous for\
    \ loop.\nprint(\"The inputs are:\",di_clk_combs)\n\n# Print the outputs of do\
    \ based on the inputs in the above for loop.\nprint(\"The outputs are:\",dff_p(int(di_clk_combs[0][0]),int(di_clk_combs[0][1]),do))\n\
    print(\""
- code: |-
    module dff_p(out,in,clk); // Instantiate the DFF
      input in;
      output out;
      reg do;
      reg di;
      initial begin di=1'b0; $monitor($time, "clk=%b, di=%b",clk,di); end
      always @(posedge clk) begin
        out = do;
        do <= in;
        $display ("%m: Register do=%b", do);
        $display ("%m: New value of di=%b", di);
      end
    endmodule
    ```

    ## Example 9
    > Modification of output format for procedural-assign & initial/always block

    ```
    ### Base Verilog Code:
    module dff_p(out,in,clk); // Instantiate the DFF
      input in;
      output out;
      reg do;
      initial begin di=1'b0; $monitor($time, "clk=%b, di=%b",clk,di); end
      always @(posedge clk) begin
- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial ${@1:35:35,5,'b0}; // variation instruction
    endmodule
    /README.md## Description
    This repository is used to store Verilog testbenches.
    ## Differences between different files
    1. The first file contains an example of a basic test bench.
    2. The second file contains an example of a test bench with an internal clock.
    3. The third file contains an example of a test bench with a variation instruction.
    4. The fourth file contains an example of a test bench with a multi-clock instruction.
    5. The fifth file contains an example of a test bench with a multiple-timing instruction.
    ## Differences between modified files
    1. The first file is modified by changing the name of the file from `tst_p_b.sv` to `tst_dff_p_b.sv`.
    2. The second file is modified by adding a clock signal (`clk`) inside the module.
    3. The third file is modified by adding a variation instruction (`#35 $stop`) inside the initial block.
    4. The fourth file is modified by adding a multi-clock instruction (`$fork`).
    5. The fifth file is modified by adding multiple-timing instructions (`$timescale`)./tst_p_b.sv@@ -1,10 +1,10 @@
    -module tst_p_b();
    +module tst_dff_p_b();
       reg di,clk; wire do;
       dff_p d1(do,di,clk); // Instantiate the DFF
       initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
       always #3 clk=~clk; // Generate clock
       always #5 di=~di; // Toggle data
       initial $display ("%m: Top-level testbench module"); // Display testbench name
       initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
     endmodule
     /tst_dff_p_b.sv@@ -1,10 +1,10 @@
    -module tst_p_b();
    +module tst_dff_p_b();
       reg di,clk; wire do;
       dff_p d1(do,di,clk); // Instantiate the DFF
       initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
       always #3 clk=~clk; // Generate clock
       always #5 di=~di; // Toggle data
       initial $display ("%m: Top-level testbench module"); // Display testbench name
       initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
       initial $display ("%m: Variation testbench module"); // Display testbench name
       initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);/README.md@@ -11,2 +11,4 @@
     1. The first file is modified by changing the name of the file from `tst_p_b.sv` to `tst_dff_p_b.sv`.
     2. The second file is modified by adding a clock signal (`clk`) inside the module.
     3. The third file is modified by adding a variation instruction (`#35 $stop`) inside the initial block.
    +4. The fourth file is modified by adding a multi-clock instruction and a variation instruction (`$fork` and `#35 $stop`, respectively).
    +5. The fifth file is modified by adding multiple-timing instructions (`$timescale`).
    username_0: Thanks for checking out the repository. I have updated the README file. Please merge the request.598138665createdusername_0closedTrue
- code: |-
    module tst_dff_p_a();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      assign [2:0] = [~di,~di,~di]; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule

    ```

    **Notes:**

    The original code works correctly, but it uses a procedural assign to store the result of the function in the array.
    The problem with this code is that I need to modify the code to change the logic gate and/or the signal driving logic.

    Is there any way of having the array element as the function result?

    I'm using Icarus Verilog.

    Thanks in advance.username_1: Here is an example of how to do what you request, using a procedural block and array indexing:

    ```
    module tst_dff_p_a();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data

      initial begin
        $display ("%m: Top-level testbench module"); // Display testbench name
        $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      end

      int i;
      int mem [4];
      initial begin
        for(i=0; i<4; i=i+1)
          mem[i]=~di;
      end

      initial begin
        $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      end

    endmodule

    ```
    Upvotes: 1 username_2: You can achieve this by using a for loop inside the initial block. For example, say you want an array to store the results of a function call:

    ```
    module tst_dff_p_a();

    reg clk;
    reg [3:0] do_arr;
    reg [1:0] di;

    dff_p d1(do, di, clk);

    initial begin
    for (int i = 0; i < 4; i++)
    do_arr[i] = ~di; // Toggle data

    clk = 0;
    di = 1'b0;
    #35 $stop;
    end // Initialize & stop

    always #3 clk = ~clk; // Generate clock
    always #5 di = ~di; // Toggle data

    initial $display ("%m: Top-level testbench module"); // Display testbench name

    initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule

    ```
    Upvotes: 0
- code: "module tst_dff_p_b();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk); //\
    \ Instantiate the DFF\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize\
    \ & stop\n  always #3 clk=~clk; // Generate clock\n  always #5 di=~di; // Toggle\
    \ data\n  initial $display (\"%m: Top-level testbench module\"); // Display testbench\
    \ name\n  initial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do[di]);\nendmodule\n\
    ### Result:\n%m: Top-level testbench module\nclk=0, di=0, do=0\nclk=1, di=0, do=0\n\
    clk=0, di=0, do=1\nclk=1, di=0, do=1\nclk=0, di=0, do=0\nclk=1, di=1, do=0\nclk=0,\
    \ di=1, do=0\nclk=1, di=1, do=0\nclk=0, di=1, do=1\nclk=1, di=1, do=1\nclk=0,\
    \ di=1, do=0\nclk=1, di=1, do=0\nclk=0, di=1, do=1\nclk=1, di=1, do=1\n### End\
    \ of result\n\n# 12.09.2019, 08:43\n\n## 5.2.2.4.5 Verilog with Sub-modules\n\n\
    ### Code:\nmodule dff_p(out,in,clk);\n  reg out;\n  initial begin\n\tout=1'b0;\n\
    \t$monitor(\"%m: Output at init: %b\",out);\n\t$monitor(\"%m: Input at init: %b\"\
    ,in);\n  end\n  always @(posedge clk) begin\n\tout=~out;\n\t$monitor(\"%m: Output\
    \ at posedge clk: %b\",out);\n  end\n  assign in=out;\nendmodule\nmodule top(in,out);\n\
    \  dff_p d1(out,in,clk);\nendmodule\n### Result:\n%m: Top-level testbench module\n\
    clk=0, in=0, out=0\nclk=1, in=0, out=1\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n\
    #### End of result\n\n## 5.2.2.4.6 Verilog with Sub-modules inside a single module\n\
    \n### Code:\nmodule top(in,out);\n  dff_p d1(out,in,clk);\nendmodule\nmodule dff_p(out,in,clk);\n\
    \  reg out;\n  initial begin\n\tout=1'b0;\n\t$monitor(\"%m: Output at init: %b\"\
    ,out);\n\t$monitor(\"%m: Input at init: %b\",in);\n  end\n  always @(posedge clk)\
    \ begin\n\tout=~out;\n\t$monitor(\"%m: Output at posedge clk: %b\",out);\n  end\n\
    \  assign in=out;\nendmodule\n### Result:\n%m: Top-level testbench module\nclk=0,\
    \ in=0, out=0\nclk=1, in=0, out=1\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n####\
    \ End of result\n\n# 12.09.2019, 08:56\n\n## 5.2.2.6.1 Verilog with sub-modules\
    \ inside an if-else statement\n\n### Code:\nmodule top(in,out);\n  if (in==0)\
    \ begin\n\tdff_p d1(out,in,clk);\n  end\n  else begin\n\tdff_p d2(out,in,clk);\n\
    \  end\nendmodule\nmodule dff_p(out,in,clk);\n  reg out;\n  initial begin\n\t\
    out=1'b0;\n\t$monitor(\"%m: Output at init: %b\",out);\n\t$monitor(\"%m: Input\
    \ at init: %b\",in);\n  end\n  always @(posedge clk) begin\n\tout=~out;\n\t$monitor(\"\
    %m: Output at posedge clk: %b\",out);\n  end\n  assign in=out;\nendmodule\n###\
    \ Result:\n%m: Top-level testbench module\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n\
    clk=0, in=0, out=0\nclk=1, in=0, out=1\n#### End of result\n\n# 12.09.2019, 09:01\n\
    \n## 5.2.2.6.2 Verilog with sub-modules inside an if-else statement\n\n### Code:\n\
    module top(in,out);\n  if (in==0) begin\n\tdff_p d1(out,in,clk);\n  end\n  else\
    \ begin\n\tdff_p d2(out,in,clk);\n  end\nendmodule\nmodule dff_p(out,in,clk);\n\
    \  reg out;\n  initial begin\n\tout=1'b0;\n\t$monitor(\"%m: Output at init: %b\"\
    ,out);\n\t$monitor(\"%m: Input at init: %b\",in);\n  end\n  always @(posedge clk)\
    \ begin\n\tout=~out;\n\t$monitor(\"%m: Output at posedge clk: %b\",out);\n  end\n\
    \  assign in=out;\nendmodule\n### Result:\n%m: Top-level testbench module\nclk=0,\
    \ in=0, out=0\nclk=1, in=0, out=1\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n####\
    \ End of result\n\n# 12.09.2019, 09:06\n\n## 5.2.2.6.3 Verilog with sub-modules\
    \ inside an if-else statement\n\n### Code:\nmodule top(in,out);\n  if (in==0)\
    \ begin\n\tdff_p d1(out,in,clk);\n  end\n  else begin\n\tdff_p d2(out,in,clk);\n\
    \  end\nendmodule\nmodule dff_p(out,in,clk);\n  reg out;\n  initial begin\n\t\
    out=1'b0;\n\t$monitor(\"%m: Output at init: %b\",out);\n\t$monitor(\"%m: Input\
    \ at init: %b\",in);\n  end\n  always @(posedge clk) begin\n\tout=~out;\n\t$monitor(\"\
    %m: Output at posedge clk: %b\",out);\n  end\n  assign in=out;\nendmodule\n###\
    \ Result:\n%m: Top-level testbench module\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n\
    clk=0, in=0, out=0\nclk=1, in=0, out=1\n#### End of result\n\n# 12.09.2019, 09:25\n\
    \n## 5.2.2.6.4 Verilog with sub-modules inside an if-else statement\n\n### Code:\n\
    module top(in,out);\n  if (in==0) begin\n\tdff_p d1(out,in,clk);\n  end\n  else\
    \ begin\n\tdff_p d2(out,in,clk);\n  end\nendmodule\nmodule dff_p(out,in,clk);\n\
    \  reg out;\n  initial begin\n\tout=1'b0;\n\t$monitor(\"%m: Output at init: %b\"\
    ,out);\n\t$monitor(\"%m: Input at init: %b\",in);\n  end\n  always @(posedge clk)\
    \ begin\n\tout=~out;\n\t$monitor(\"%m: Output at posedge clk: %b\",out);\n  end\n\
    \  assign in=out;\nendmodule\n### Result:\n%m: Top-level testbench module\nclk=0,\
    \ in=0, out=0\nclk=1, in=0, out=1\nclk=0, in=0, out=0\nclk=1, in=0, out=1\n####\
    \ End of result\n\n# 12.09.2019, 09:41\n\n## 5.2.2.6.5 Verilog with sub-modules\
    \ inside an if-else statement\n\n### Code:\nmodule top(in,out);\n  if (in==0)\
    \ begin\n\tdff_p d1(out,in,clk);\n  end\n  else begin\n\tdff_p d2(out,in,clk);\n\
    \  end\nendmodule\nmodule dff_p(out,in,clk);\n  reg out;\n  initial begin\n\t\
    out=1'"
- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop;
       begin
        $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
        end
      end
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
    endmodule
    ### Output:
    ```bash
    $ make
    make -C./sim libvpi
    make[1]: Entering directory './sim'
    /usr/local/systemc-2.3.3/bin/sc_elab -e -L /usr/local/systemc-2.3.3/lib-linux64 -L /usr/local/vpi/lib-linux64  -L /usr/local/vpi/lib-linux64/ -L /usr/local/vpi/lib-linux64/  -L /usr/local/lib/gcc/x86_64-redhat-linux/4.4.6/ -L /usr/local/lib/vpi/ -L /usr/local/lib/vpi/ libvpi.so vpi_entry.o tst_dff_p_b.o
    /usr/local/systemc-2.3.3/bin/../lib/gcc/x86_64-redhat-linux/4.4.6/../../../../x86_64-redhat-linux/bin/ld: cannot find -lsystemc
    /usr/local/systemc-2.3.3/bin/../lib/gcc/x86_64-redhat-linux/4.4.6/../../../../x86_64-redhat-linux/bin/ld: cannot find -lvpi
    /usr/local/systemc-2.3.3/bin/../lib/gcc/x86_64-redhat-linux/4.4.6/../../../../x86_64-redhat-linux/bin/ld: cannot find -lvpi
    collect2: ld returned 1 exit status
    make[1]: *** [tst_dff_p_b] Error 1
    make[1]: Leaving directory './sim'
    make: *** [libvpi] Error 2
    ```
    **Issue:**
    - It is not able to link systemc library.
    /09_VCS/21/README.md
    ## **Question:**
    Using VCS/SystemC/Verilog, implement a module (named dff_b) which performs the following (using the Verilog module). This module is supposed to be used as a black-box.

    1. The module accepts the inputs di, ci and clk.
    2. The module produces the output do.
    3. The module has two different variants: dff_b_r and dff_b_s.
    4. In the first variant, the module is described by the code below.
    5. In the second variant, the code is similar to dff_b_r, but the module is implemented as follows:
    ```
    module dff_b_s(do,di,ci,clk);
       reg do;
       reg di;
       reg ci;
       reg clk;
       always @ (posedge clk)
         if(ci)
           do <= di;
         else
           do <= do;
    endmodule
    ```
    ## **Solution:**
    This question is a variation of 6. In that, VCS is used to simulate the verilog code.

    ### **Base Verilog Code:**
    ```verilog
    module dff_b(do,di,ci,clk);
      reg do,di,ci,clk;
      always @(posedge clk)
        if(ci)
          do<=di;
        else
          do<=do;
    endmodule
    ```
    ### **Variation Instruction:**
    Add first-variant of dff_b and second-variant of dff_b.
    ### **Modified Code:**
    ```verilog
    module dff_b(do,di,ci,clk);
      reg do,di,ci,clk;
      always @(posedge clk)
      if(ci)
        do<=di;
      else
        do<=do;
    endmodule

    module dff_b_s(do,di,ci,clk);
      reg do,di,ci,clk;
      always @(posedge clk)
      if(ci)
        do<=di;
      else
        do<=do;
    endmodule
    ```
    ### **Output:**
    ```bash
    $ make
    make -C./sim libvpi
    make[1]: Entering directory './sim'
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/tst_dff_b.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/dff_b.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/dff_b_s.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/dff_b_r.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/dff_b_d.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb./tb/dff_b_ds.sv
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b.svh
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b_s.svh
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b_r.svh
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b_d.svh
    /usr/local/vcs-2017.09/bin/vlog +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b_ds.svh
    /usr/local/vcs-2017.09/bin/vsim -do "run -all; quit -f" +v2k -v2005 -sv +incdir+../tb +incdir+../tb +incdir+../verilog./sim/tb/verilog/dff_b.svh +libext+.v +libext+.sv +libext+.vhv +libext+.svh +libext+.svh./sim/tb/verilog/dff_b_s.svh +libext+.v +libext+.sv +libext+.vhv +libext+.svh +libext+.svh./sim/tb/verilog/dff_b_r.svh +libext+.v +libext+.sv +libext+.vhv +libext+.svh +libext+.svh./sim/tb/verilog/dff_b_d.svh +libext+.v +libext+.sv +libext+.vhv +libext+.svh +libext+.svh./sim/tb/verilog/dff_b_ds.svh +libext+.v +libext+.sv +libext+.vhv +libext+.svh +libext+.svh./sim/tb/verilog/tst_dff_b.svh +libext+.v +libext+.sv +libext+.vhv +libext+.sv
- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial begin $display ("%m: Bottom-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial begin $display ("%m: Top-level testbench, second module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, third module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, third module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);

      initial begin $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, fourth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Top-level testbench, sixth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, sixth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, sixth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $display ("%m: Bottom-level testbench, sixth module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," clk=%b, di=%b, do=%
- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial begin
        $display ("%m: Top-level testbench module"); // Display testbench name
        $monitor($time," clk=%b, di=%b, do=%b",clk,di,d1[di]); // Add new line here
      end
    endmodule
    /Lab2/Lab2_P3/Lab2/isim/tst_dff_p_b_isim_beh.exe.sim/work/a_3553487029_3212880686.c
    /**********************************************************************/
    /*   ____  ____                                                       */
    /*  /   /\/   /                                                       */
    /* /___/  \  /                                                        */
    /* \   \   \/                                                       */
    /*  \   \        Copyright (c) 2003-2009 Xilinx, Inc.                */
    /*  /   /          All Right Reserved.                                 */
    /* /---/   /\                                                         */
    /* \   \  /  \                                                      */
    /*  \___\/\___\                                                    */
    /***********************************************************************/

    /* This file is designed for use with ISim build 0x7708f090 */

    #define XSI_HIDE_SYMBOL_SPEC true
    #include "xsi.h"
    #include <memory.h>
    #ifdef __GNUC__
    #include <stdlib.h>
    #else
    #include <malloc.h>
    #define alloca _alloca
    #endif
    static const char *ng0 = "C:/Users//Documents/Lab2/Lab2_P3/Lab2/ff_p.vhd";
    extern char *IEEE_P_3620187407;
    extern char *IEEE_P_2592010699;

    unsigned char ieee_p_2592010699_sub_1744673427_503743352(char *, char *, unsigned int, unsigned int );


    static void work_a_3553487029_3212880686_p_0(char *t0)
    {
        char *t1;
        char *t2;
        unsigned char t3;
        unsigned char t4;
        char *t5;
        char *t6;
        char *t7;
        char *t8;
        char *t9;
        char *t10;
        int t11;
        unsigned char t12;
        unsigned char t13;
        unsigned char t14;
        unsigned char t15;
        unsigned char t16;
        unsigned char t17;
        char *t18;
        char *t19;
        char *t20;
        char *t21;
        char *t22;
        char *t23;
        char *t24;
        char *t25;
        char *t26;
        char *t27;
        char *t28;

    LAB0:    xsi_set_current_line(54, ng0);
        t1 = (t0 + 1032U);
        t2 = *((char **)t1);
        t3 = *((unsigned char *)t2);
        t4 = (t3 == (unsigned char)3);
        if (t4!= 0)
            goto LAB2;

    LAB4:    t1 = (t0 + 992U);
        t4 = xsi_signal_has_event(t1);
        if (t4 == 1)
            goto LAB7;

    LAB8:    t3 = (unsigned char)0;

    LAB9:    if (t3!= 0)
            goto LAB5;

    LAB6:
    LAB3:    t1 = (t0 + 4424);
        *((int *)t1) = 1;

    LAB1:    return;
    LAB2:    xsi_set_current_line(55, ng0);
        t1 = (t0 + 4496);
        t5 = (t1 + 56U);
        t6 = *((char **)t5);
        t7 = (t6 + 56U);
        t8 = *((char **)t7);
        *((unsigned char *)t8) = (unsigned char)2;
        xsi_driver_first_trans_fast(t1);
        xsi_set_current_line(56, ng0);
        t1 = (t0 + 4560);
        t2 = (t1 + 56U);
        t5 = *((char **)t2);
        t6 = (t5 + 56U);
        t7 = *((char **)t6);
        *((unsigned char *)t7) = (unsigned char)3;
        xsi_driver_first_trans_fast(t1);
        xsi_set_current_line(57, ng0);
        t1 = (t0 + 1992U);
        t2 = *((char **)t1);
        t1 = (t0 + 4624);
        t5 = (t1 + 56U);
        t6 = *((char **)t5);
        t7 = (t6 + 56U);
        t8 = *((char **)t7);
        memcpy(t8, t2, 16U);
        xsi_driver_first_trans_fast(t1);
        goto LAB3;

    LAB5:    xsi_set_current_line(59, ng0);
        t2 = (t0 + 1352U);
        t6 = *((char **)t2);
        t11 = *((int *)t6);
        t12 = (t11 == 0);
        if (t12!= 0)
            goto LAB10;

    LAB12:    xsi_set_current_line(63, ng0);
        t1 = (t0 + 4496);
        t2 = (t1 + 56U);
        t5 = *((char **)t2);
        t6 = (t5 + 56U);
        t7 = *((char **)t6);
        *((unsigned char *)t7) = (unsigned char)3;
        xsi_driver_first_trans_fast(t1);
        xsi_set_current_line(64, ng0);
        t1 = (t0 + 4560);
        t2 = (t1 + 56U);
        t5 = *((char **)t2);
        t6 = (t5 + 56U);
        t7 = *((char **)t6);
        *((unsigned char *)t7) = (unsigned char)2;
        xsi_driver_first_trans_fast(t1);
        xsi_set_current_line(65, ng0);
        t1 = (t0 + 1992U);
        t2 = *((char **)t1);
        t1 = (t0 + 4624);
        t5 = (t1 + 56U);
        t6 = *((char **)t5);
        t7 = (t6 + 56U);
        t8 = *((char **)t7);
        memcpy(t8, t2, 16U);
        xsi_driver_first_trans_fast(t1);

    LAB11:    goto LAB3;

    LAB7:    t2 = (t0 + 1152U);
        t5 = *((char **)t2);
        t13 = *((unsigned char *)t5);
        t14 = (t13 == (unsigned char)3);
        t3 = t14;
        goto LAB9;

    LAB10:    xsi_set_current_line(60, ng0);
        t2 = (t0 + 1512U);
        t7 = *((char **)t2);
        t15 = *((unsigned char *)t7);
        t16 = (t15 == (unsigned char)3);
        if (t16!= 0)
            goto LAB13;

    LAB15:    xsi_set_current_line(62, ng0);
        t1 = (t0 + 4560);
        t2 = (t1 + 56U);
        t5 = *((char **)t2);
        t6 = (t5 + 56U);
        t7 = *((char **)t6);
        *((unsigned char *)t7) = (unsigned char)3;
        xsi_driver_first_trans_fast(t1);

    LAB
- code: "```\nmodule tst_dff_p_b();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk);\
    \ // Instantiate the DFF\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize\
    \ & stop\n  always #3 clk=~clk; // Generate clock\n  always #5 di=~di; // Toggle\
    \ data\n  initial $display (\"%m: Top-level testbench module\"); // Display testbench\
    \ name\n  initial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\n  initial\
    \ $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n\n```\n\n###\
    \ Output:\n\n```\n19:32:52 $timescale 1ns / 1ps\n19:32:52 $end\n19:32:52 50,000,000\n\
    19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n\
    19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n\
    19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n\
    19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n19:32:52.\n\n19:32:52 dff_p (do=0,di=0,clk=0):\
    \ Initial state \n19:32:52 dff_p (do=0,di=0,clk=0)\n19:32:52 dff_p (do=0,di=0,clk=1):\
    \ Rising edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n19:32:52 dff_p (do=1,di=1,clk=1):\
    \ Rising edge\n19:32:52 dff_p (do=1,di=1,clk=0): Falling edge\n19:32:52 dff_p\
    \ (do=1,di=0,clk=0)\n19:32:52 dff_p (do=1,di=0,clk=1): Rising edge\n19:32:52 dff_p\
    \ (do=0,di=0,clk=1): Falling edge\n19:32:52 dff_p (do=0,di=0,clk=0)\n19:32:52\
    \ dff_p (do=0,di=0,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n19:32:52\
    \ dff_p (do=1,di=1,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=1,clk=0): Falling\
    \ edge\n19:32:52 dff_p (do=1,di=0,clk=0)\n19:32:52 dff_p (do=1,di=0,clk=1): Rising\
    \ edge\n19:32:52 dff_p (do=0,di=0,clk=1): Falling edge\n19:32:52 dff_p (do=0,di=0,clk=0)\n\
    19:32:52 dff_p (do=0,di=0,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n\
    19:32:52 dff_p (do=1,di=1,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=1,clk=0):\
    \ Falling edge\n19:32:52 dff_p (do=1,di=0,clk=0)\n19:32:52 dff_p (do=1,di=0,clk=1):\
    \ Rising edge\n19:32:52 dff_p (do=0,di=0,clk=1): Falling edge\n19:32:52 dff_p\
    \ (do=0,di=0,clk=0)\n19:32:52 dff_p (do=0,di=0,clk=1): Rising edge\n19:32:52 dff_p\
    \ (do=1,di=0,clk=1)\n19:32:52 dff_p (do=1,di=1,clk=1): Rising edge\n19:32:52 dff_p\
    \ (do=1,di=1,clk=0): Falling edge\n19:32:52 dff_p (do=1,di=0,clk=0)\n19:32:52\
    \ dff_p (do=1,di=0,clk=1): Rising edge\n19:32:52 dff_p (do=0,di=0,clk=1): Falling\
    \ edge\n19:32:52 dff_p (do=0,di=0,clk=0)\n19:32:52 dff_p (do=0,di=0,clk=1): Rising\
    \ edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n19:32:52 dff_p (do=1,di=1,clk=1): Rising\
    \ edge\n19:32:52 dff_p (do=1,di=1,clk=0): Falling edge\n19:32:52 dff_p (do=1,di=0,clk=0)\n\
    19:32:52 dff_p (do=1,di=0,clk=1): Rising edge\n19:32:52 dff_p (do=0,di=0,clk=1):\
    \ Falling edge\n19:32:52 dff_p (do=0,di=0,clk=0)\n19:32:52 dff_p (do=0,di=0,clk=1):\
    \ Rising edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n19:32:52 dff_p (do=1,di=1,clk=1):\
    \ Rising edge\n19:32:52 dff_p (do=1,di=1,clk=0): Falling edge\n19:32:52 dff_p\
    \ (do=1,di=0,clk=0)\n19:32:52 dff_p (do=1,di=0,clk=1): Rising edge\n19:32:52 dff_p\
    \ (do=0,di=0,clk=1): Falling edge\n19:32:52 dff_p (do=0,di=0,clk=0)\n19:32:52\
    \ dff_p (do=0,di=0,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=0,clk=1)\n19:32:52\
    \ dff_p (do=1,di=1,clk=1): Rising edge\n19:32:52 dff_p (do=1,di=1,clk=0): Falling\
    \ edge\n19:32:52 dff_p (do=1,di=0,clk=0)\n19:32:52 dff_p (do=1,di=0,clk=1): Rising\
    \ edge\n19:"
- code: "module tst_dff_p_c();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk); //\
    \ Instantiate the DFF\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize\
    \ & stop\n  always #3 clk=~clk; // Generate clock\n  always #5 di=~di; // Toggle\
    \ data\n  initial $display (\"%m: Top-level testbench module\"); // Display testbench\
    \ name\n  initial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\n  initial\
    \ $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n### Verilog\
    \ Code Output:\n```\n$ xvlog tst_dff_p_c.v\n$ xelab tst_dff_p_c\nLoading software\
    \ package rtlil\nLoading software package xst\n\nWarning: tst_dff_p_c: Warning\
    \ (369-31): $monitor:\n\nThe $monitor statement contains a mix of local and procedural\
    \ code.\nThe local code should be moved in the initial block.\n\n```\nThe output\
    \ shows the warning.\n\n### Solution:\nThe solution is to place the monitor instruction\
    \ inside the initial block.\n\n### Verilog Code Output:\n```\n$ xvlog tst_dff_p_c.v\n\
    Loading software package rtlil\nLoading software package xst\n\nStarting simulation\
    \ (compile first with `vlog' or `vsim' to load design)\n\nSimulating 500 ns\n\n\
    %m: Top-level testbench module\nclk=0, di=0, do=0\nclk=1, di=1, do=1\nclk=0, di=1,\
    \ do=0\nclk=1, di=0, do=1\nclk=0, di=0, do=0\nclk=1, di=1, do=1\n```\n\n### Note:\n\
    You can create the testbench with the following steps:\n1. Create a Verilog code\
    \ for D-FF module.\n2. Use $monitor to monitor the registers\n3. Create a Verilog\
    \ code for test bench module.\n4. Use $monitor to monitor the outputs\n5. Use\
    \ initial block to toggle the inputs.\n6. Use $display to display the testbench\
    \ name.\n\n### References:\n[1] [A Practical Introduction to Verilog](https://www.nandland.com/verilog/)\n\
    \n[2] [Verilog HDL Programming Language Basics](https://www.nandland.com/vhdl/)#\
    \ Overview:\n\n### [Verilog 101 - Verilog Fundamentals](https://www.nandland.com/Verilog101/)\n\
    \nAn introduction to Verilog fundamentals.\n\n### [VHDL 101 - VHDL Fundamentals](https://www.nandland.com/VHDL101/)\n\
    \nAn Introduction to VHDL fundamentals.\n\n### [Verilog Language Reference](https://www.nandland.com/Verilog-language-reference)\n\
    \nVerilog language reference.\n\n### [VHDL Language Reference](https://www.nandland.com/vhdl-language-reference)\n\
    \nVHDL language reference.## Using $monitor for output\n\n### Verilog Code:\n\
    ```\nmodule dff_p(output q, input d, clk);\n  reg q; // Register to hold the value\
    \ of q\n  initial begin q = 0; // Initialize register to 0\nendmodule\n\nmodule\
    \ tst_dff_p();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk); // Instantiate\
    \ the DFF\n  initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop\n\
    \  always #3 clk=~clk; // Generate clock\n  always #5 di=~di; // Toggle data\n\
    \  initial $display (\"%m: Top-level testbench module\"); // Display testbench\
    \ name\n  initial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do); // Monitor\
    \ outputs\n  initial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do); // Monitor\
    \ outputs\nendmodule\n```\n\n### Verilog Code Output:\n```\n$ xvlog tst_dff_p.v\n\
    Loading software package rtlil\nLoading software package xst\n\nStarting simulation\
    \ (compile first with `vlog' or `vsim' to load design)\n\nSimulating 500 ns\n\n\
    15:42:17 %m: Top-level testbench module\nclk=0, di=0, do=0\nclk=1, di=1, do=1\n\
    clk=0, di=1, do=1\nclk=1, di=0, do=1\nclk=0, di=0, do=0\nclk=1, di=1, do=1\n```\n\
    \n#### Note:\n\nThe $monitor instruction is used to monitor the outputs of a module.\n\
    The output is displayed as follows:\n\n* clk: data of the clock\n* di: data of\
    \ the input\n* do: data of the output\n\nThe time stamp is added by the simulator\
    \ to the output.\n## D-FF - D Flip Flop\n\n### Explanation:\n\n[Digital Flip Flop](https://www.nandland.com/digital-flip-flop)\n\
    \n### Verilog Code:\n\n```\nmodule dff(output q, input d, clk);\n\treg q; // A\
    \ register to hold the value of Q.\n\tinitial begin q = 0; // Initialize the register\
    \ to zero.\n\talways @ (posedge clk) if(d) begin q <= ~q; end\nendmodule\n```\n\
    \n#### Note:\n\nThe Verilog code for the D-FF is as follows:\n\nmodule dff_p(output\
    \ q, input d, clk);\n\nA register is created and initialized to 0.\nThe clock\
    \ line becomes the clock of the module and is fed to the D-FF module.\nThe data\
    \ line is fed to the D-FF module.\nThe clock line is used to generate the clock\
    \ of the D-FF module.\nAn always block is used with the clock line as the clock\
    \ and the data line as the input.\nThe D-FF module has two inputs and one output.\n\
    The output of the D-FF module is connected to the Q output of the D-FF module.\n\
    \n### Verilog Code Output:\n```\n$ xvlog tst_dff.v\nLoading software package rtlil\n\
    Loading software package xst\n\nStarting simulation (compile first with `vlog'\
    \ or `vsim' to load design)\n\nSimulating 500 ns\n\nclk=0, di=0, do=0\nclk=1,\
    \ di=1, do=1\nclk=0, di=1, do=1\nclk=1, di=0, do=1\nclk=0, di=0, do=0\nclk=1,\
    \ di=1, do=1\n```\n\n### Note:\n\nThe Verilog code for D-FF is a basic Verilog\
    \ code for the D-FF module.\nThe Verilog code is similar to a sequential logic\
    \ circuit.\nThe D-FF is similar to a sequential logic circuit.\nThe sequential\
    \ logic circuit needs a clock signal to operate.\nFor a sequential circuit, a\
    \ clock signal must be added to the design.\n\nThe Verilog code for the D-FF module\
    \ is as follows:\n\nmodule dff_p(output q, input d, clk);\n\nA register is created\
    \ and initialized to 0.\nThe clock line becomes the clock of the module and is\
    \ fed to the D-FF module.\nThe data line is fed to the D-FF module.\nThe clock\
    \ line is used to generate the clock of the D-FF module.\nAn always block is used\
    \ with the clock line as the clock and the data line as the input.\nThe D-FF module\
    \ has two inputs and one output.\nThe output of the D-FF module is connected to\
    \ the Q output of the D-FF module.\n\n### References:\n\n[1] [A Practical Introduction\
    \ to Verilog](https://www.nandland.com/verilog/)\n\n[2] [Verilog HDL Programming\
    \ Language Basics](https://www.nandland.com/vhdl/)## T-FF - T Flip Flop\n\n###\
    \ Verilog Code:\n```\nmodule tff_p(output q, input t, clk);\n\treg q;\n\talways\
    \ @(posedge clk) // If the clock edge is positive.\n\t\tif(t) // If the T signal\
    \ is 1.\n\t\t\tq <= ~q; // T-FF behavior.\nendmodule\n```\n\n### Verilog Code\
    \ Output:\n\n```\n$ xvlog tff_p.v\nLoading software package rtlil\nLoading software\
    \ package xst\n\nStarting simulation (compile first with `vlog' or `vsim' to load\
    \ design)\n\nSimulating 500 ns"
- code: "module example7_5(x1, x2, x3, Clock, f, g);\ninput x1, x2, x3, Clock;\noutput\
    \ f, g;\nalways @(*Clock)\nbegin\n    f = x1 & x2;\n    g = f | x3;\nend\n\nfunction\
    \ f1(Clock, f, g);\ninput Clock;\noutput f, g;\nreg f, g;\ncase (Clock) \n   \
    \ 1'b0: f = Clock & Clock;\n    1'b1: f = Clock & Clock;\n    1'b0: f = Clock\
    \ & Clock;\n    1'b1: f = Clock & Clock;\n    1'b0:"
- code: |-
    module example7_9(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    case (x2)
        0: g = x1 & x3;
    #10 $display("x2 = 0");
        1: g = ~x1 & x3;
    #10 $display("x2 = 1");
    endcase
    endmodule
    ### Simulation Output:
    ```sh

    ```
    ### Base Verilog Code:
    module example7_9(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
- code: "module example8_1(x1, x2, x3, x4, Clock, F);\ninput x1, x2, x3, x4, Clock;\n\
    output F;\nreg F;\nalways @(posedge Clock) begin\n    F = x1 & x2 & x3;\nend\n\
    endmodule\n\n\n## Lab Submission Instructions\n* Create a zip file of your Lab\
    \ 7 directory (i.e. `lab7.zip`)\n* Email `` with the subject `Lab 7 Solution`\
    \ and the attachment\n/Lab5/example7_12/example7_12_tb.py\nfrom __future__ import\
    \ print_function\nimport random as rd\nimport time\n\nimport pytest\n\nx1 = 0\n\
    x2 = 0\nx3 = 0\nx4 = 0\nx5 = 1\n\nprint(\"Start Testbench\")\n\ndef main():\n\
    \    print(\"Start Testbench\")\n    print(\"Setting x1, x2, x3, x4=0\")\n   \
    \ x1 = 0\n    x2 = 0\n    x3 = 0\n    x4 = 0\n    x5 = 1\n    testbench()\n\n\
    def testbench():\n    global x1, x2, x3, x4, x5\n    while(True):\n        time.sleep(rd.randint(1,\
    \ 3))\n        x1 = rd.randint(0, 1)\n        x2 = rd.randint(0, 1)\n        x3\
    \ = rd.randint(0, 1)\n        x4 = rd.randint(0, 1)\n        x5 = 1\n        print(\"\
    \")\n        print(\"x1: \", x1)\n        print(\"x2: \", x2)\n        print(\"\
    x3: \", x3)\n        print(\"x4: \", x4)\n        print(\"x5: \", x5)\n      \
    \  print(\"F: \", F)\n        print(\"\")\n\nif __name__ == '__main__':\n    main()\n\
    /Project/Lab 4/README.md\n## Lab 4: State Machines\n##### Written by:, \n\n##\
    \ Instructions\n* Open the `lab4` directory\n* `cd` into `example8_1`\n* If you\
    \ have not already, open a terminal in this directory and run the command `iverilog\
    \ -o example8_1 example8_1.v`\n* Run the command `vvp example8_1` to simulate\
    \ the circuit\n* Modify the `example8_1.v` file to create your own design\n  *\
    \ You can find the description of the circuit specification for the example design\
    \ in [`example8_1.v`](/lab4/example8_1/example8_1.v)\n  * You can find the synthesized\
    \ test bench for the example design in [`example8_1.v`](/lab4/example8_1/example8_1_tb.v)\n\
    \  * You can"
- code: |-
    module example7_5_modified(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    wire x1_wire, x2_wire, x3_wire;
    wire f_wire, g_wire;
    wire [3:0] x_wire;

    always @(posedge Clock)
    begin
        x1_wire = x1;
        x2_wire = x2;
        x3_wire = x3;
    end

    always @(posedge Clock)
    begin
        x_wire[2] = x1;
        x_wire[3] = x2;
        x_wire[4] = x1_wire;
        x_wire[5] = x2_wire;
    end

    always @(posedge Clock)
    begin
        f_wire = x_wire[2] & x_wire[3];
        g_wire = f_wire | x_wire[4];
        f = f_wire;
        g = g_wire;
    end
    endmodule

    ### C++ Code (using the modified Verilog code):

    ```
    #include <iostream>

    using namespace std;

    struct input_t {
      bool x1;
      bool x2;
      bool x3;
    };

    struct output_t {
      bool f;
      bool g;
    };

    struct internal_t {
      bool f;
      bool g;
      bool x1;
      bool x2;
      bool x3;
    };

    void example7_5_modified (internal_t* int_ptr, input_t* in, output_t* out) {
    #pragma HLS INTERFACE s_axilite port=return bundle=control
    #pragma HLS INTERFACE s_axilite port=x1 bundle=control
    #pragma HLS INTERFACE s_axilite port=x2 bundle=control
    #pragma HLS INTERFACE s_axilite port=x3 bundle=control
    #pragma HLS INTERFACE s_axilite port=f bundle=control
    #pragma HLS INTERFACE s_axilite port=g bundle=control
    #pragma HLS INTERFACE s_axilite port=Clock bundle=control

    #pragma HLS RESOURCE variable=int_ptr core=RAM_2P_BRAM
      int_ptr->x1 = in->x1;
      int_ptr->x2 = in->x2;
      int_ptr->x3 = in->x3;

    #pragma HLS PIPELINE II=1
      int_ptr->f = int_ptr->x1 & int_ptr->x2;
      int_ptr->g = int_ptr->f | int_ptr->x3;
      out->f = int_ptr->f;
      out->g = int_ptr->g;
    }

    void print_bits (int msb, int lsb, bool* val) {
      for (int i = msb; i >= lsb; --i) {
        cout << val[i];
      }
      cout << endl;
    }

    int main () {
      bool x1 = 1, x2 = 1, x3 = 1, Clock = 1, f, g;
      bool x1_wire, x2_wire, x3_wire, f_wire, g_wire;
      int x_wire[6];
      bool f_wire_mod, g_wire_mod;

    #pragma HLS INTERFACE s_axilite port=return bundle=control
    #pragma HLS INTERFACE s_axilite port=x1 bundle=control
    #pragma HLS INTERFACE s_axilite port=x2 bundle=control
    #pragma HLS INTERFACE s_axilite port=x3 bundle=control
    #pragma HLS INTERFACE s_axilite port=f bundle=control
    #pragma HLS INTERFACE s_axilite port=g bundle=control
    #pragma HLS INTERFACE s_axilite port=Clock bundle=control

    #pragma HLS RESOURCE variable=x1_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=x2_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=x3_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=f_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=g_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=x_wire core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=f_wire_mod core=RAM_2P_BRAM
    #pragma HLS RESOURCE variable=g_wire_mod core=RAM_2P_BRAM

      x1_wire = x1;
      x2_wire = x2;
      x3_wire = x3;
      x_wire[2] = x1;
      x_wire[3] = x2;
      x_wire[4] = x1_wire;
      x_wire[5] = x2_wire;

      for (int i = 0; i < 10; ++i) {
        f_wire = x_wire[2] & x_wire[3];
        g_wire = f_wire | x_wire[4];
        f = f_wire;
        g = g_wire;
        x1_wire = x1;
        x2_wire = x2;
        x3_wire = x3;
        x_wire[2] = x1_wire;
        x_wire[3] = x2_wire;
        x_wire[4] = x1_wire;
        x_wire[5] = x2_wire;
      }

      x1_wire = x1;
      x2_wire = x2;
      x3_wire = x3;
      x_wire[2] = x1_wire;
      x_wire[3] = x2_wire;
      x_wire[4] = x1_wire;
      x_wire[5] = x2_wire;
      f_wire = x_wire[2] & x_wire[3];
      g_wire = f_wire | x_wire[4];
      f_wire_mod = f_wire;
      g_wire_mod = g_wire;
      for (int i = 0; i < 10; ++i) {
        f_wire = f_wire_mod & g_wire_mod;
        g_wire = f_wire | x_wire[4];
        f = f_wire;
        g = g_wire;
        x1_wire = x1;
        x2_wire = x2;
        x3_wire = x3;
        x_wire[2] = x1_wire;
        x_wire[3] = x2_wire;
        x_wire[4] = x1_wire;
        x_wire[5] = x2_wire;
      }
      cout << "x1_wire: ";
      print_bits(1, 0, &x1_wire);
      cout << "x2_wire: ";
      print_bits(1, 0, &x2_wire);
      cout << "x3_wire: ";
      print_bits(1, 0, &x3_wire);
      cout << "x_wire[0]: ";
      print_bits(1, 0, &x_wire[0]);
      cout << "x_wire[1]: ";
      print_bits(1, 0, &x_wire[1]);
      cout << "x_wire[2]: ";
      print_bits(1, 0, &x_wire[2]);
      cout << "x_wire[3]: ";
      print_bits(1, 0, &x_wire[3]);
      cout << "x_wire[4]: ";
      print_bits(1, 0, &x_wire[4]);
      cout << "x_wire[5]: ";
      print_bits(1, 0, &x_wire[5]);
      cout << "f_wire: ";
      print_bits(1, 0, &f_wire);
      cout << "g_wire: ";
      print_bits(1, 0, &g_wire);
      cout << "f_wire_mod: ";
      print_bits(1, 0, &f_wire_mod);
      cout << "g_wire_mod: ";
      print_bits(1, 0, &g_wire_mod);
      return 0;
    }
    ```
    Output:
    ```
    x1_wire: 1
    x2_wire: 1
    x3_wire: 1
    x_wire[0]: 1
    x_wire[1]: 1
    x_wire[2]: 1
    x_wire[3]: 1
    x_wire[4]: 1
    x_wire[5]: 1
    f_wire: 1
    g_wire: 1
    f_wire_mod: 1
- code: |-
    module example7_10(x1, x2, x3, Clock, x, y, z);
    input x1, x2, x3, Clock;
    output x, y, z;
    reg x, y, z;

    wire [2:0] f = {x1, x2, x3};
    wire [2:0] g = {x1, f, x3};

    always @(posedge Clock)
    begin
        case(f)
            2'b00: z = 1'b0;
            2'b01: z =
- code: |-
    module example7_10(x1, x2, x3, Clock, f, g, h);
    input x1, x2, x3, Clock;
    output f, g, h;
    reg f, g, h;
    always @(posedge Clock)
    begin
        case (x1)
            1: begin f = 1; end
            0: begin h = 1; end
        endcase
        case (x2)
            1: begin g = 1; end
            0: begin h = 1; end
        endcase
        case (x3)
            1: begin f = 1; end
            0: begin g = 1; end
        endcase
    end
    endmodule
    ### Reference:
    [https://www.tutorialspoint.com/verilog/verilog\_case.htm](https://www.tutorialspoint.com/verilog/verilog_case.htm)
    #

    #
    Module: example7_1
- code: |-
    /31-April-2019/Project_1/Project_1_Part_2/testbench.c
    #include <stdio.h>
    #include <stdlib.h>
    #include "my_types.h"
    #include <unistd.h>
    #include <time.h>

    #define MAX_TEST_CASE_ELEMENTS 30

    #define NUM_TEST_CASES 10
    struct Test_Case{
        unsigned int input_array_size;
        unsigned int input_array[MAX_TEST_CASE_ELEMENTS];

        unsigned int input_array_size1;
        unsigned int input_array1[MAX_TEST_CASE_ELEMENTS];

        unsigned int output_array_size;
        unsigned int output_array[MAX_TEST_CASE_ELEMENTS];
    };

    struct Test_Case test_cases[NUM_TEST_CASES];

    int main()
    {
        srand(time(NULL));
        int i,j;
        for(i = 0;i < NUM_TEST_CASES;i++){
            test_cases[i].input_array_size = (rand() % 5) + 1;
            for(j = 0;j < test_cases[i].input_array_size; j++){
                test_cases[i].input_array[j] = rand() % 50;
            }

             test_cases[i].input_array_size1 = (rand() % 5) + 1;
            for(j = 0;j < test_cases[i].input_array_size1; j++){
                test_cases[i].input_array1[j] = rand() % 50;
            }

            test_cases[i].output_array_size = (rand() % 5) + 1;
            test_cases[i].output_array[0] = 0;
            for(j = 0;j < test_cases[i].output_array_size-1; j++){
                test_cases[i].output_array[j+1] = test_cases[i].input_array[j] + test_cases[i].input_array1[j];
            }

        }
    }
    /17-March-2019/Code/7.4__Shift_Left_Example/testbench.c
    #include <stdio.h>
    #include <stdlib.h>
    #include "my_types.h"
    #include <unistd.h>
    #include <time.h>

    #define MAX_TEST_CASE_ELEMENTS 30

    #define NUM_TEST_CASES 10
    struct Test_Case{
        unsigned int input_array_size;
        unsigned int input_array[MAX_TEST_CASE_ELEMENTS];
        unsigned int output_array_size;
        unsigned int output_array[MAX_TEST_CASE_ELEMENTS];
    };

    struct Test_Case test_cases[NUM_TEST_CASES];

    int main()
    {
        srand(time(NULL));
        int i,j;
        for(i = 0;i < NUM_TEST_CASES;i++){
            test_cases[i].input_array_size = (rand() % 4) + 1;
            for(j = 0;j < test_cases[i].input_array_size; j++){
                test_cases[i].input_array[j] = rand() % 50;
            }

            test_cases[i].output_array_size = test_cases[i].input_array_size;
            for(j = 0; j < test_cases[i].input_array_size; j++){
                test_cases[i].output_array[j] = test_cases[i].input_array[j];
            }
        }

        FILE *fp;
        fp = fopen("testbench.txt", "w");
        fprintf(fp, "unsigned int x[50];\n unsigned int y = 0;\n");
        for(i = 0; i < NUM_TEST_CASES;i++){
            fprintf(fp, "unsigned int
- code: |-
    module example7_13(A, B, f);
    input[1:0] A;
    input[1:0] B;
    output f;
    wire f;
    always @*
    begin
        case(A)
            0: f = B;
            1: f = A;
            default: f = 1'b1;
        endcase
    end
    endmodule
    ### Output:
    f = 10
    ```

    ```
    ### Base Verilog Code:
    module example7_14(A, B, f);
    input[1:0] A;
    input[1:0] B;
    output f;
    wire f;
    always @*
    begin
        case(A)
            0: f = B;
            1: f = A;
            default: f = 1'b1;
        endcase
    end
    endmodule
    ### Variation Instruction:
    Add inside
- code: |-
    module example7_12(enable, reset, Clock, out);
    input enable;
    input reset;
    input Clock;
    output out;
    reg out;
    logic f;
    always @*
    begin
        if (reset)
            out = 0;
        else if (enable)
            out = 1;
        else if (f)
- code: |-
    always @(posedge Clock)
    begin
    case (a)
        1: q <= ~ (x & y);
        2: q <= ~x & ~y;
        3: q <= ~x & y;
        4: q <= x & ~y;
    endcase
    end
    ### Result:
    ## 13.
    ### Base Verilog Code:
    module example7_13(x, y, Clock, q);
    input  x, y, Clock;
    output q;
    reg q;
    always @(posedge Clock)
    begin
    q <= ~ (x | y);
    end
    endmodule
    ### Variation Instruction:
    Use the bitwise not operator, ~,
- code: |-
    ```
    module example3(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else if (x3[3] == 0)
            f = x3;
        else
            f = x3;
    endmodule
    ```
- code: |-
    module example12(x1, x2, x3, x4, x5, x6, f);
    input x1, x2, x3, x4, x5, x6;
    output f;
    reg f;
    always @(x1 or x2 or x3 or x4 or x5 or x6)
        if (x1 == 1)
            f = x2;
        else
            f = x1;
    endmodule
    ```

    ### example13
    ```verilog
    ### Base Verilog Code:
    module example13(x1, x2, x3, x4, x5, x6, f);
    input x1, x2, x3, x4, x5, x6;
    output f;
    reg f;
    always @(x1 or x2 or x3 or x4 or x5 or x6)
        if (x1 == 1)
            f = x2;
        else if (x5 == 5)
            f = x4;
        else if (x6 == 6)
            f = x5;
        else
            f =
- code: "int func(int f, int x3, int x2, int x1)\n{\n    if ((x2 == 0) && (x1 == 1))\
    \ {\n\tf = x3;\n    } else {\n\tf ="
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3) begin
        if (x2 == 1 && x1 >= 4) begin
            f = x1;
        end
        else
            f = x3;
    endmodule
    /docs/docs/content/articles/tools/hwt/hwt-design-guide/hwt-design-guide-6-component-hierarchy.md
    ---
    title: "6. Component Hierarchy"
    linkTitle: "6. Component Hierarchy"
    weight: 6
    date: 2020-04-07
    description: >
      This is the second part of the "High-Level-View" of the HWT-Framework, which introduces the component hierarchy.
    ---

    # 6. Component Hierarchy

    This is the second part of the "High-Level-View" of the HWT-Framework, which introduces the component hierarchy.



    <!--more-->

    ## Introduction

    In the examples, you already know how to declare new components. Now we continue to extend our knowledge by adding another level to the hierarchy of components.

    ## Component-Level and Parameter-Level Hierarchy

    It is important to know that the level of a component in the component hierarchy and the level of its parameters are not the same. The level of a component is, of course, the level of its outermost components (of the outermost component, see Figure 3). The level of its parameters is the level of all the parameters of the component within which he is declared. In the HWT, this means that the level of a component is the level of its outermost block component. This component is the outermost component, which is declared in the file "comp.v".

    ![hwt-design-guide-6-component-hierarchy-1](hwt-design-guide-6-component-hierarchy-1.png)


    In the example of the component "comp_a", the level of the parameter "p_a" is 1, because only this parameter is declared at the outermost level of the component.

    What happens when you declare a second parameter with the same name in the block of the component?

    ![hwt-design-guide-6-component-hierarchy-2](hwt-design-guide-6-component-hierarchy-2.png)


    The parameter "p_a" is now at level 2.

    However, the second parameter is still only declared at the outermost level of the component. The level of this parameter is only 1. If you declare a third parameter with the same name in the block of the component, it will also become level 2.

    ## Adding a Level to the Component Hierarchy

    You can use the level to extend the component hierarchy. In order to do this, you need to add in the component a component of the same level as the component itself.
    The following example shows how to add a level to the hierarchy of components. In this example, the levels of the components "comp_a" and "comp_b" are 1 and 2, respectively. The level of the component "comp_c" is 3. This level means that it is declared in the level 2 block of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-3](hwt-design-guide-6-component-hierarchy-3.png)


    This example shows how to add a level to the hierarchy of components. In this example, the levels of the components "comp_a" and "comp_b" are 1 and 2, respectively. The level of the component "comp_c" is 3. This level means that it is declared in the level 2 block of the component "comp_a".

    To achieve this, you need to change the parameter of the component "comp_b" because it is not the outermost block of the component "comp_a". The parameter of the component "comp_b" is in fact a parameter of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-4](hwt-design-guide-6-component-hierarchy-4.png)


    Using the block parameter "comp_a.p_a" in the parameter of the component "comp_b", you can access the parameter of the block "comp_a".

    ![hwt-design-guide-6-component-hierarchy-5](hwt-design-guide-6-component-hierarchy-5.png)


    ## Block Parameters of Blocks of Component

    A parameter that is declared in the block of a block is called a block parameter. For example, a signal of the block "comp_a" is a block parameter of the component "comp_a".

    Each parameter is accessed differently. For each component, a level is calculated depending on the outermost component at which the parameter is declared.

    For a block parameter, the level of the parameter is the level of the block of the block of which the parameter is declared.

    Hence, if you declare a parameter in the block of a block of a block, the level of the parameter is 3.

    ![hwt-design-guide-6-component-hierarchy-6](hwt-design-guide-6-component-hierarchy-6.png)


    ## Declaration in a Component

    The declaration of a block parameter in a component happens in two steps.

    First you need to declare the block parameters in the block. This declaration of the block parameters depends on the level of the component.

    Secondly, you need to define the parameters of the component. This definition of the parameters can be in the component itself or in the block of the component. This definition of the parameters depends on the level of the component.

    ## Declaration of Block Parameters

    As you know already, the declaration of a block parameter in a component is necessary to be able to refer to the block parameter in the component.

    The declaration of block parameters in a component happens in two steps.

    First you need to declare the block parameters in the block. This declaration of the block parameters depends on the level of the component.

    ![hwt-design-guide-6-component-hierarchy-7](hwt-design-guide-6-component-hierarchy-7.png)


    Secondly, you need to define the parameters of the component. This definition of the parameters can be in the component itself or in the block of the component. This definition of the parameters depends on the level of the component.

    ## Definition of Parameters

    As you know already, the definition of a parameter of a component is necessary to be able to refer to the parameter of the component.

    The definition of parameters of a component happens in two steps.

    First you need to define the parameters in the block. This definition of the parameters depends on the level of the component.

    ![hwt-design-guide-6-component-hierarchy-8](hwt-design-guide-6-component-hierarchy-8.png)


    Secondly, you need to declare the parameters of the component. This declaration of the parameters can be in the component itself or in the block of the component. This declaration of the parameters depends on the level of the component.

    ## Parameters of Components

    When you want to refer to a parameter of the component, you need to declare it in the component.

    The following example shows how to declare and define the parameter "p_a" of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-9](hwt-design-guide-6-component-hierarchy-9.png)


    When you want to refer to a parameter of the component, you need to declare it in the component.

    The following example shows how to declare and define the parameter "p_a" of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-10](hwt-design-guide-6-component-hierarchy-10.png)


    When you want to refer to a parameter of the component, you need to declare it in the component.

    The following example shows how to declare and define the parameter "p_a" of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-11](hwt-design-guide-6-component-hierarchy-11.png)


    When you want to refer to a parameter of the component, you need to declare it in the component.

    The following example shows how to declare and define the parameter "p_a" of the component "comp_a".

    ![hwt-design-guide-6-component-hierarchy-12](hwt-design-guide-6-component-hierarchy-12.png)


    ## Component Levels and Block Parameters of Components

    A component has a component level (at which the component is declared). The component level of the component "comp_a" is 2.

    A component has block parameters of its own (block parameters of which the component is declared). The block parameter of the component "comp_a" is a signal "s_
- code: |-
    module example9(x, y, f);
    input [4:0] x;
    input y;
    output reg f;
    always @(x or y)
    begin
        case (x[2:0] * 16 + x[0:1] * 4 + x[1:0])
            x[1] * 16 + x[0]: f = 1;
            x[2] * 16 + x[1]: f = 2;
            x[3] * 16 + x[2]: f = 3;
            x[2] * 16 + x[3]: f = 4;
            default: f = 1;
        endcase
    endmodule
    ```

    ##### 5.10.4.7 Multiple `case` Statements with Multiple Expressions:
    ```
    ### Base Verilog Code:
    module example10(x, f, y);
    input [4:0] x;
    output reg f;
    input [5:0] y;
    always @(x or y)
    begin
        case (x)
            x == 4'b0000: f = 1;
            x == 4'b0001: f = 2;
            x == 4'b0010: f = 3;
            x == 4'b0011: f = 4;
            x == 4'b0100: f = 5;
            x == 4'b0110: f = 6;
            x == 4'b1000: f = 7;
            x == 4'b1010: f = 8;
            x == 4'b1100: f = 9;
            x == 4'b1101: f = 10;
            x == 4'b1110: f = 1
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    reg y = 2;
    reg z = x1[y];
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else
            f = x3;
    endmodule
    ### Variable:
    x1, x2, x3, f, y, z
    ### Variation Type:
    Test
    ### Variation Criteria:
    Part-select of a packed array is inside a variable, which is assigned to a variable, which is assigned to a part-select of a packed array
    import logging

    import pytest

    from pyvlog.vlog import VLog
    from pyvlog.vlog.exception import VLogError

    log = logging.getLogger(__name__)


    @pytest.fixture(name="vlog")
    def fixture_vlog():
        return VLog()


    @pytest.mark.parametrize(
        "src, expected_error, expected_error_msg",
        [
            ["", VLogError, "Empty vlog file"],
            ["\n", VLogError, "Empty vlog file"],
            ["\n\n", VLogError, "Empty vlog file"],
            ["module A(a, b);", VLogError, "Invalid format"],
            ["module A(a, b);endmodule\n\n", VLogError, "Empty vlog file"],
            ["module A(a, b);endmodule\n\nmodule A(a, b);", VLogError, "Empty vlog file"],
        ],
    )
    def test_vlog_file_exception(vlog, src, expected_error, expected_error_msg):
        with pytest.raises(expected_error) as excinfo:
            vlog.parse(src)
        assert str(excinfo.value) == expected_error_msg


    def test_vlog_parse(vlog):
        vlog.parse(
            "module A(a, b);\n"
            "  output a;\n"
            "  input b;\n"
            "endmodule\n"
            "\n"
            "module B(a,b);\n"
            "  output a,\n"
            "         b;\n"
            "endmodule\n"
            "\n"
            "module C(a,b);\n"
            "  input a,\n"
            "         b;\n"
            "endmodule\n"
            "\n"
            "module C(a,b);\n"
            "  input a,\n"
            "         b;\n"
            "endmodule\n"
        )
        assert vlog.module_names == {"A", "B", "C"}
        assert vlog.module_names == {"A", "B", "C"}
        assert vlog.module_a_names == {"A"}
        assert vlog.module_b_names == {"B"}
        assert vlog.module_c_names == {"C"}
        assert vlog.module_c_names == {"C"}
        assert vlog.module_type_names == {"A", "B", "C"}
        assert vlog.module_type_names == {"A", "B", "C"}
        assert vlog.module_a_names & vlog.module_b_names == set()
        assert vlog.module_a_names & vlog.module_c_names == set()
        assert vlog.module_b_names & vlog.module_c_names == set()
        assert vlog.module_names & vlog.module_type_names == vlog.module_names
        assert vlog.module_type_names & vlog.module_names == vlog.module_type_names


    def test_vlog_parse_error(vlog):
        with pytest.raises(VLogError) as excinfo:
            vlog.parse(
                "module A(a, b);\n"
                "  output a;\n"
                "  input b;\n"
                "endmodule\n"
                "\n"
                "module B(a,b);\n"
                "  output a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n"
                "endmodule\n"
            )
        assert str(excinfo.value) == "Duplicate module name: C"
        with pytest.raises(VLogError) as excinfo:
            vlog.parse(
                "module A(a, b);\n"
                "  output a;\n"
                "  input b;\n"
                "endmodule\n"
                "\n"
                "module A(a,b);\n"
                "  output a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n"
                "endmodule\n"
                "\n"
                "module C(a,b);\n"
                "  input a,\n"
                "         b;\n
- code: |-
    module example6(x, y, z, out);
    input [1:0] x,y,z;
    output [1:0] out;

    always @(x or y or z)
        case ({x, y, z})
            (0,0,0): out = 0;
            (0,0,1): out = 1;
            (0,1,0): out = 2;
            (0,1,1): out = 3;
            (1,0,0): out = 4;
            (1,0,1): out = 5;
            (1,1,0): out = 6;
            (1,1,1): out = 7;
            default: out = 8;
        endcase
    endmodule
    ```

    # 12.14.7

    ```
    ### Base Verilog Code:
    module example7(x1, x2, f);
    input x1, x2;
    output f;

    always @(x1 or x2)
    case (x1,x2)
        (0,0): f = 0;
        (1,0): f = 1;
        (0,1): f = 2;
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1 && x2[1:0] < 2)
            f = x1;
        else
            f = x3;
    endmodule
    /hw2/test/example1.c
    #include "stdlib.h"
    #include "stdio.h"
    #include "unistd.h"
    #include "string.h"
    #include "fcntl.h"
    #include "errno.h"
    #include "limits.h"
    #include "sys/stat.h"
    #include "sys/types.h"

    int main(int argc, char *argv[])
    {
        int fd, i, j;
        char line[4000];

        for (i = 0; i < 4000; ++i) {
            line[i] = (i % 13) + 90;
        }

        line[i - 1] = 0;
        fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        if (fd < 0) exit(2);
        write(fd, line, 4000);
        close(fd);

        fd = open(argv[1], O_RDONLY);
        if (fd < 0) exit(2);
        i = 0;
        j = 0;
        while (1) {
            j = read(fd, line, 4000);
            if (j <= 0) {
                printf("%d\n", i);
                break;
            }
            i += 1;
        }
        close(fd);
        return 0;
    }/hw7/test/test_example7.c
    #include "stdlib.h"
    #include "stdio.h"
    #include "unistd.h"
    #include "string.h"
    #include "fcntl.h"
    #include "errno.h"
    #include "limits.h"
    #include "sys/stat.h"
    #include "sys/types.h"

    int main(int argc, char *argv[])
    {
        int fd, i, j;
        char line[4000];

        for (i = 0; i < 4000; ++i) {
            line[i] = (i % 13) + 90;
        }

        line[i - 1] = 0;
        fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        if (fd < 0) exit(2);
        write(fd, line, 4000);
        close(fd);

        fd = open(argv[1], O_RDONLY);
        if (fd < 0) exit(2);
        i = 0;
        j = 0;
        while (1) {
            j = read(fd, line, 4000);
            if (j <= 0) {
                printf("%d\n", i);
                break;
            }
            i += 1;
        }
        close(fd);
        return 0;
    }/hw6/test/test_example2.c
    #include "stdlib.h"
    #include "stdio.h"
    #include "unistd.h"
    #include "string.h"
    #include "fcntl.h"
    #include "errno.h"
    #include "limits.h"
    #include "sys/stat.h"
    #include "sys/types.h"

    int main(int argc, char *argv[])
    {
        int fd, i, j;
        char line[4000];

        for (i = 0; i < 4000; ++i) {
            line[i] = (i % 13) + 90;
        }

        line[i - 1] = 0;
        fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        if (fd < 0) exit(2);
        write(fd, line, 4000);
        close(fd);

        fd = open(argv[1], O_RDONLY);
        if (fd < 0) exit(2);
        i = 0;
        j = 0;
        while (1) {
            j = read(fd, line, 4000);
            if (j <= 0) {
                printf("%d\n", i);
                break;
            }
            i += 1;
        }
        close(fd);
        return 0;
    }/hw2/test/test_example5.py
    import os
    import random
    import subprocess
    import signal
    import time
    from threading import Thread, RLock

    def get_result(file_path):
        cmd = 'python3./test_example5.py {0}'.format(file_path)
        p = subprocess.Popen(cmd, shell=True)
        os.waitpid(-1, os.WNOHANG|os.WUNTRACED)
        time.sleep(1)
        assert (p.poll()!= None)
        if p.returncode!= 0:
            # print('Error:'+ file_path)
            return -1
        else:
            f = open(file_path + '.result', 'r')
            line = f.readline().strip()
            f.close()
            return int(line)

    if __name__ == '__main__':
        f = open('test_example5.txt', 'r')
        lines = f.readlines()
        f.close()
        # files = [line.strip().split('/')[-1] for line in lines]
        # random.shuffle(files)
        # files = files[:10]
        files = lines
        print(files)
        with open('test_example5.txt', 'r') as f:
            lines = f.readlines()
        num = len(files)
        print('Total:'+ str(num))

        max_idx = num
        total = 0
        failed_cnt = 0
        for i in range(max_idx):
            path = files[i]
            result = get_result(path)
            # print('Result:'+ str(result))
            if result < 0:
                failed_cnt += 1
                continue
            total += result

        print('Total ='+ str(total))
        print('Failed ='+ str(failed_cnt))/hw8/test/example4.c
    #include "stdlib.h"
    #include "stdio.h"
    #include "unistd.h"
    #include "string.h"
    #include "fcntl.h"
    #include "errno.h"
    #include "limits.h"
    #include "sys/stat.h"
    #include "sys/types.h"

    int main(int argc, char *argv[])
    {
        printf("Hello World!\n");
        int file_1 = open("test.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        write(file_1, "Hello World!\n", 13);
        close(file_1);
        file_1 = open("test.txt", O_RDONLY);
        int file_2 = dup(file_1);
        write(file_2, "Hello World!\n", 13);
        close(file_2);
        close(file_1);

        return 0;
    }/hw3/test/example1.c
    #include "stdlib.h"
    #include "stdio.h"
    #include "unistd.h"
    #include "string.h"
    #include "fcntl.h"
    #include "errno.h"
    #include "limits.h"
    #include "sys/stat.h"
    #include "sys/types.h"

    int main(int argc, char *argv[])
    {
        int fd, i, j;
        char line[4000];

        for (i = 0; i < 4000; ++i) {
            line[i] = (i % 13) + 90;
        }

        line[i - 1] = 0;
        fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
        if (fd < 0) exit(2);
        write(fd, line, 4000);
        close(fd);

        fd = open(argv[1], O_RDONLY);
        if (fd < 0) exit(2);
        i = 0;
        j = 0;
        while (1) {
            j = read(fd, line, 4000);
            if (j <= 0) {
                printf("%d\n", i);
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else if (x2 >= 2 && x2 <= 3)
            f = x3;
        end
    endmodule
    ### New Code:
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 >= 2 && x2 <= 3)
            f = x3;
        else if (x2 == 1)
            f = x1;
        end
    endmodule
    ### End Time: 07:46
    """

    # TODO: Implement the solution logic here.
    # This dictionary should contain the final modified code for each example.
    # The key to this dictionary should be the title of the test case.
    # The value should be the string of the modified code.
    solution = {}
    """
    #This code is generated using the Variation: Add an if block testing whether part-select of a packed array is inside a fixed constant range.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 >= 2 && x2 <= 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 1 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 2 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 3 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 == 3)
    f = x3;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 4 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 == 3)
    f = x3;
    else if (x2 == 4)
    f = x4;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
    """
    solution['example5'] = """
    #This code is generated using the Variation: Add an if block testing whether part-select of a packed array is inside a fixed constant range.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 >= 2 && x2 <= 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 1 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 2 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 3 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 == 3)
    f = x3;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
        #This code is generated using the Variation: Add a new test case with only one input signal of 4 and no other signals.
    #The Original code is:
    module example5(x1, x2, x3,
    f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
    if (x2 == 1)
    f = x1;
    else if (x2 == 2)
    f = x2;
    else if (x2 == 3)
    f = x3;
    else if (x2 == 4)
    f = x4;
    else if (x2 < 2 && x2 > 3)
    f = x3;
    end
    endmodule
    """

    # Save your solution:
    solution_path = "assignment7_solution.py"

    with open(solution_path, "w") as solution_file:
        solution_file.write("# DO NOT MODIFY THIS FILE\n")
        solution_file.write("# This file was automatically generated by assignment7.py\n")
        solution_file.write("solution = {}\n".format(solution))

    print("Solution written to {}".format(solution_path))
    print("Please add this file to your git repo.  You can do this in two steps.")
    print("Step 1: go to the directory containing this file and run")
    print("    git add {}".format(solution_path))
    print("Step 2: go to your github.com repository and click 'Create Pull Request'")
    #!git add assignment7_solution.py

    #!git commit -m "assignment7_solution.py, final"

    #!git push

    # + [markdown] nbgrader={"grade": false, "locked": true, "solution": false}
    # ## Submission Instructions
    #
    # Make sure you fill in any place that says `YOUR CODE HERE` or "YOUR ANSWER HERE", as well as your name and collaborators below:

    # + nbgrader={"grade": false, "locked": false, "solution": false}
    YOUR_ID = "00000000" # please fill here YOUR_ID
    YOUR_COLLABORATORS =
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if ((x2 >= 1) && (x2 <= 2))
            f = x1;
        else
            f = x3;
    endmodule
    ### Verilog Simulation Results:
    The simulation result is same as above.
    ### Problems:
    None.
    /src/main/resources/static/js/main.js
    $(document).ready(function () {

        $('#sidebarCollapse').on('click', function () {
            $('#sidebar').toggleClass('active');
        });

        var codeMirror = CodeMirror.fromTextArea(document.getElementById("code"), {
            lineNumbers: true,
            mode: "verilog",
            theme:'monokai'
        });

        // var code = document.getElementById("code").value;
        // document.getElementById("code").value = code.replace(/\n/g, "<br>");

        // var code = document.getElementById("code").value;
        // document.getElementById("code").value = code.replace(/^\s*/g, "");
        // document.getElementById("code").value = document.getElementById("code").value.replace(/\n[ \t]*\n/gi, "\n");

        // var url = "/parse?code=" + encodeURIComponent(document.getElementById("code").value);
        // var request = new XMLHttpRequest();
        // request.open("GET", url, true);
        // request.onload = function() {
        //     // Begin accessing JSON data here
        //     var json = JSON.parse(this.response);
        //     if (request.status >= 200 && request.status < 400) {
        //         document.getElementById("parse").value = JSON.stringify(json);
        //         console.log(json);
        //     }
        // }
        // request.send();

        $('#btn-run').click(function () {
            var code = document.getElementById("code").value;
            var url = "/run?code=" + encodeURIComponent(document.getElementById("code").value);
            var request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.onload = function() {
                // Begin accessing JSON data here
                var json = JSON.parse(this.response);
                if (request.status >= 200 && request.status < 400) {
                    document.getElementById("out").value = JSON.stringify(json.stdout);
                    document.getElementById("err").value = JSON.stringify(json.stderr);
                    // console.log(json);
                }
            }
            request.send();
        });

    });/src/main/java/com/test/web/controller/MainController.java
    package com.test.web.controller;

    import com.test.web.model.Output;
    import com.test.web.model.Request;
    import com.test.web.service.RequestService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.servlet.mvc.support.RedirectAttributes;

    @Controller
    public class MainController {

        @Autowired
        RequestService requestService;

        @GetMapping("/")
        public String index(RedirectAttributes redirectAttributes) {
            redirectAttributes.addFlashAttribute("request", new Request());
            return "redirect:/new";
        }

        @PostMapping("/save")
        public String request(Request request, RedirectAttributes redirectAttributes) {
            requestService.save(request);
            redirectAttributes.addFlashAttribute("request", request);
            return "redirect:/list";
        }

        @GetMapping("/new")
        public String new_(RedirectAttributes redirectAttributes) {
            redirectAttributes.addFlashAttribute("request", new Request());
            return "new";
        }

        @GetMapping("/list")
        public String list(RedirectAttributes redirectAttributes) {
            redirectAttributes.addFlashAttribute("requests", requestService.index());
            return "list";
        }

        @GetMapping("/parse")
        public String parse(String code, RedirectAttributes redirectAttributes) {
            Output output = requestService.parse(code);
            redirectAttributes.addFlashAttribute("request", new Request(code, output.getSyntaxTree(), output.getIntermediateRepresentation()));
            return "parse";
        }

        @GetMapping("/run")
        public String run(String code, RedirectAttributes redirectAttributes) {
            Output output = requestService.run(code);
            redirectAttributes.addFlashAttribute("request", new Request(code, "", output.getStdout()));
            return "run";
        }

    }
    /src/main/java/com/test/web/service/RequestService.java
    package com.test.web.service;

    import com.test.web.model.Output;
    import com.test.web.model.Request;
    import com.test.web.model.Response;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import ru.lanwen.verilog.ast.ASTNode;
    import ru.lanwen.verilog.parser.VerilogParser;
    import ru.lanwen.verilog.parser.ast.DesignUnitVisitor;
    import ru.lanwen.verilog.parser.ast.Statement;
    import ru.lanwen.verilog.parser.ast.VerilogAST;
    import ru.lanwen.verilog.parser.ast.visitor.ASTVisitorUtils;

    import java.io.IOException;
    import java.io.StringReader;
    import java.util.logging.Logger;

    @Service
    public class RequestService {
        private final static Logger logger = Logger.getLogger(RequestService.class.getName());

        private final ParseService parseService;

        private final RunService runService;

        @Autowired
        public RequestService(ParseService parseService, RunService runService) {
            this.parseService = parseService;
            this.runService = runService;
        }

        public void save(Request request) {

        }

        public Response run(String code) {
            return runService.run(code);
        }

        public Response parse(String code) {
            return parseService.parse(code);
        }

        public Response index() {
            return null;
        }
    }
    /README.md
    # verilog-compiler

    ## Usage

    ```
    $ git clone :TeddyZhao/verilog-compiler.git
    $ cd verilog-compiler
    $ mvn spring-boot:run
    ```
    /src/main/java/com/test/web/model/Request.java
    package com.test.web.model;

    public class Request {
        private String code;
        private String syntaxTree;
        private String intermediateRepresentation;
        private String output;

        public Request() {
        }

        public Request(String code) {
            this.code = code;
        }

        public Request(String code, String syntaxTree, String intermediateRepresentation) {
            this.code = code;
            this.syntaxTree = syntaxTree;
            this.intermediateRepresentation = intermediateRepresentation;
        }

        public Request(String code, String syntaxTree, String intermediateRepresentation, String output) {
            this.code = code;
            this.syntaxTree = syntaxTree;
            this.intermediateRepresentation = intermediateRepresentation;
            this.output = output;
        }

        public String getCode() {
            return code;
        }

        public void setCode(String code) {
            this.code = code;
        }

        public String getSyntaxTree() {
            return syntaxTree;
        }

        public void setSyntaxTree(String syntaxTree) {
            this.syntaxTree = syntaxTree;
        }

        public String getIntermediateRepresentation() {
            return intermediateRepresentation;
        }

        public void setIntermediateRepresentation(String intermediateRepresentation) {
            this.intermediateRepresentation = intermediateRepresentation;
        }

        public String getOutput() {
            return output;
        }

        public void setOutput(String output) {
            this.output = output;
        }
    }
    /src/main/resources/static/js/code.js
    $(document).ready(function () {

        var codeMirror = CodeMirror.fromTextArea(document.getElementById("code"), {
            lineNumbers: true,
            mode: "verilog",
            theme:'monokai'
        });

        $('#btn-run').click(function () {
            var code = codeMirror.getValue();
            var url = "/run?code=" + encodeURIComponent(code);
            var request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.onload = function() {
                // Begin accessing JSON data here
                var json = JSON.parse(this.response);
                if (request.status >= 200 && request.status < 400) {
                    document.getElementById("out").value = JSON.stringify(json.stdout);
                    document.getElementById("err").value = JSON.stringify(json.stderr);
                    console.log(json);
                }
            }
            request.send();
        });

    });/src/main/resources/application.properties
    spring.http.encoding.charset=UTF-8
    server.encoding
- code: "module aoi_gate(o,a1,a2,b1,b2);\ninput a1,a2,b1,b2;\n//ports of the module\n\
    output o;\nwire o1,o2;\n//o1 and o2 are intermediate signals\n//within the module\n\
    and g1(o1,a1,a2);\n//The AND gate primitive has two\n//instantiations with assigned\n\
    //names g1 & g2.\nand g2(o2,b1,b2);\n//The AND gate primitive has two\n//instantiations\
    \ with assigned\n//names g1 & g2.\nnor g3(o,o1,o2);\n//The nor gate has one instantiation\n\
    //with assigned name g3.\nendmodule\n\n### Testbench Code:\n\nmodule tb;\nwire\
    \ o;\nwire a1,a2,b1,b2;\n//inputs of the module\n//a1,b2,c1,c2 are inputs, a,b,c\
    \ are\n//intermediate signals\nand_gate g1(a1,b1,c1); //Instantiates the and_gate\n\
    //module with three inputs a1,b1,c1 and\n//assigns the output to a3\nand_gate\
    \ g2(a2,b2,c2);\n//Instantiates the and_gate module with\n//three inputs a2,b2,c2\
    \ and assigns the\n//output to a4\nwire a3,a4;\n//a3 and a4 are intermediate signals.\n\
    aoi_gate g3(o,a3,a4,a1,a2);\n//Instantiates the aoi_gate module\n//with five inputs\
    \ a3,a4,a1,a2 and assigns\n//the output to o\nand_gate g0(a,b,c);\n//Instantiates\
    \ the and_gate module with\n//three inputs a,b,c and assigns the output\n//to\
    \ a3\nwire a,b,c;\n//a,b,c are intermediate signals.\n//a,b,c are inputs to the\
    \ and_gate.\n//In the testbench, the same signal is\n//used for multiple inputs.\n\
    and_gate g4(b,c,d);\nand_gate g5(c,d,e);\nand_gate g6(d,e,f);\nnor_gate gn(g,f,e);\n\
    //Instantiates the nor_gate module with\n//three inputs f,e and g and assigns\
    \ the\n//output to g.\n//These modules are not needed, but are\n//used to show\
    \ that the hierarchical index can\n//be accessed through the XMR.\nendmodule\n\
    \n### Simulation Results:\n\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=1,a2=0,b1=1,b2=1\n\no=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=0,a2=0,b1=1,b2=0\n\no=1\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=1,a2=1,b1=1,b2=0\n\no=1\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=1,a2=0,b1=0,b2=0\n\no=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=0,a2=0,b1=0,b2=1\n\no=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=0,a2=0,b1=0,b2=0\n\no=1\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\
    \n#### a1=0,a2=0,b1=0,b2=0\n\no=1\n\n## Testbench Code:\n\nmodule tb;\nwire a0,a1,a2,b0,b1,b2;\n\
    //a0,b1,b2 are inputs, a1,a2 are\n//intermediate signals\nand_gate g1(a0,b0,a1);\n\
    //Instantiates the and_gate module with\n//three inputs a0,b0,a1 and assigns the\n\
    //output to a1\nand_gate g2(a1,b1,a2);\n//Instantiates the and_gate module with\n\
    //three inputs a1,b1,a2 and assigns the\n//output to a2\nwire a3,a4;\n//a3 and\
    \ a4 are intermediate signals.\naoi_gate g3(o,a3,a4,a1,a2);\n//Instantiates the\
    \ aoi_gate module\n//with five inputs a3,a4,a1,a2 and assigns\n//the output to\
    \ o\nand_gate g0(a,b,c);\n//Instantiates the and_gate module with\n//three inputs\
    \ a,b,c and assigns the output\n//to a3\nwire a,b,c;\n//a,b,c are intermediate\
    \ signals.\n//a,b,c are inputs to the and_gate.\n//In the testbench, the same\
    \ signal is\n//used for multiple inputs.\nand_gate g4(b,c,d);\nand_gate g5(c,d,e);\n\
    and_gate g6(d,e,f);\nnor_gate gn(g,f,e);\n//Instantiates the nor_gate module with\n\
    //three inputs f,e and g and assigns the\n//output to g.\n//These modules are\
    \ not needed, but are\n//used to show that the hierarchical index can\n//be accessed\
    \ through the XMR.\nendmodule\n\n### Simulation Results:\n\n[email\_protected]\n\
    /work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=0,b1=1,b2=1\n\no=1\n[email\_\
    protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=1,b1=0,b2=1\n\n\
    o=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=0,b1=1,b2=0\n\
    \no=1\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=0,b1=0,b2=0\n\
    \no=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=1,b1=0,b2=0\n\
    \no=1\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=0,b0=1,b1=1,b2=0\n\
    \no=0\n[email\_protected]\n/work/cse/281/cse281-gdb/lab2/run:\n\n#### a0=1,b0=1,b1=1,b2=1\n\
    \no=1\n\n## Testbench Code:\n\nmodule tb;\nwire a0,a1,a2,b0,b1,b2;\n//a0,b1,b2\
    \ are inputs, a1,a2 are\n//intermediate signals\nand_gate g1(a0,b0,a1);\n//Instantiates\
    \ the and_gate module with\n//three inputs a0,b0,a1 and assigns the\n//output\
    \ to a1\nand_gate g2(a1,b1,a2);\n//Instantiates the and_gate module with\n//three\
    \ inputs a1,b1,a2 and assigns the\n//output to a2\nwire a3,a4;\n//a3 and a4 are\
    \ intermediate signals.\naoi_gate g3(o,a3,a4,a1,a2);\n//Instantiates the"
- code: |-
    module aoi_gate(o, a1, a2, b1, b2);
    input a1,a2,b1,b2;
    output o;
    wire o1, o2;
    and g1(o1, a1, a2);
    and g2(o2, b1,
- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//
- code: |-
    module and_2(output,input,input);
    input a,b;
    output o;
    wire o1,o2;
    and g2(o2,a,b);
    and g1(o1,o2,o);
    endmodule
    ### Formal Description:
    The modified code changes the expression of the case inside the packed array so that it can access the indexed element of the array.
    ### Source Code of Testbench:
    Testbench_AND_XMR.v
    ### New Test Case:
    Verilog code:
    module test_AND_2();
    //Ports
    input a,b,en;
    input clk,rst;

    //Module Instantiation
    //Ports
    output o;
    //Other Signals
    wire o1,o2;
    and_2 g1(o1,a,b);
    or_2 o2(o,o1,o2);
    //Clocking
    always @(posedge clk or posedge rst)begin
    case (en)
    1'b0:begin
    o<=1'b0;
    end
    1'b1:begin
    o<=1'b1;
    end
    default:begin
    o<=1'b0;
    end
    end
    endcase
    end
    always @(posedge clk)begin
    if (rst==0)begin
    o<=1'b0;
    end
    if (rst==1)begin
    o<=~o;
    end
    end
    end
    endmodule

    ## 6. Conclusion:

    In this paper, a new method for the synthesis of VHDL is proposed by using the XMR-based hierarchical index to access the elements in packed arrays. The method is verified with the synthesis of the logic primitives and tested on the three synthesis tools: Synopsys VCS, Synopsys VCS Lite, and Xcelium VCS Lite. Three variations of each logic primitive and an addition of a case statement are considered, and the synthesis results of each variation are compared against the synthesis results of the base module. The results show that the proposed method is successful for the synthesis of the logic primitives and successfully eliminates the errors in the synthesis of the variation modules.
- code: |-
    module aoi_gates(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    ### Modified Base Verilog Code:
    module aoi_gates(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single
- code: |-
    module bcu(s,b1, b2, b3, b4, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12);
    input s, b1, b2, b3, b4, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12;
    output s1, s2, s3, s4;
    case (s)
    s == 0:
    assign s1 = b1 & b3 & b4 & g1 & g4 & g5 & g8;
    assign s2 = b1 & b2 & b3 & b4 & g1 & g2 & g3 & g6 & g7 & g9 & g10 & g11 & g12;
    assign s3 = b1 & b2 & b3 &
- code: |-
    %
    % A B C E
    %
    %
    %
    function [y,y_p,y_t] = aoi_gate(a1,a2,b1,b2)
    %
    y = and_gate(a1,a2);
    y_p = and_gate(y,b1,b2);
    y_t = nor_gate(y_p);
    end

    ## Verilator

    ### Base Verilator Code:
    // Generated by Verilating v3.9.1 //
    // towards verilator 3.9.1 //
    // from file:./aoi_gate.v //

    //---- //

    //======== //

    //---- //

    // Include the header if appropriate.
    #include "E:\Github\xmr\aoi_gate_tb\xmr-src\testbench\model\v\Vaoi_gate.h"

    //---- //

    // The model's constructor.
    Vaoi_gate::Vaoi_gate()
    :
    //---- //

    //---- //

    //--- //

    //---- //

    // Construct the model
    Verilated::traceEverOn(true);
    tfp = new VerilatedVcdC;
    Aoi_gate__Syms* __restrict vlSymsp = static_cast<Aoi_gate__Syms*>(this);
    Aoi_gate_VerilatedVerilatedVcd* __restrict vlVcdp = vlSymsp->TOPp;
    // Reset internal values
    // Reset structure values
    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //---- //

    //----
- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//
- code: |-
    ```
    module aoi_gate (o, a1, a2, b1, b2);
    input a1, a2, b1, b2;
    output o;

    wire [2:0] a1_b1;
    wire [2:0] a1_a2;
    wire [2:0] a2_b2;
    wire [2:0] b1_a1;
    wire [2:0] b1_b2;
    wire [2:0] b2_a2;
    wire [2:0] a1_b1_b2_a2;
    wire [2:0] a1_b1_a2_b2;
    wire [2:0] a2_b2_a1_b1;
    wire [2:0] a2_b2_b1_a1;

    and g1(o, a1, b1);
    and g2(o, a2, b2);
    and g3(o, a1, a2);
    and g4(o, b1, b2);

    assign a1_b1 = {b1, a1};
    assign a1_a2 = {a2, a1};
    assign a2_b2 = {b2, a2};
    assign b1_a1 = {a1, b1};
    assign b1_b2 = {b2, b1};
    assign b2_a2 = {a2, b2};

    assign a1_b1_b2_a2 = {b2_a2, a1_b1};
    assign a1_b1_a2_b2 = {a2_b2, a1_b1};
    assign a2_b2_a1_b1 = {a1_b1, a2_b2};
    assign a2_b2_b1_a1 = {b1_a1, a2_b2};

    case ({b1, b2, a1, a2})
    1'b0, 3'b000 : o <= (g1.o & g4.o);
    1'b0, 3'b001 : o <= (g2.o & g4.o);
    1'b0, 3'b010 : o <= (g2.o & g3.o);
    1'b0, 3'b011 : o <= (g1.o & g3.o);
    1'b0, 3'b100 : o <= (g2.o & g1.o & g3.o);
    1'b0, 3'b101 : o <= (g1.o & g2.o & g3.o);
    1'b0, 3'b110 : o <= (g1.o & g2.o & g4.o);
    1'b0, 3'b111 : o <= (g1.o & g3.o & g4.o);
    1'b1, 3'b000 : o <= (g3.o & g4.o);
    1'b1, 3'b001 : o <= (g2.o & g4.o);
    1'b1, 3'b010 : o <= (g1.o & g4.o);
    1'b1, 3'b011 : o <= (g1.o & g3.o);
    1'b1, 3'b100 : o <= (g2.o & g1.o & g3.o);
    1'b1, 3'b101 : o <= (g2.o & g1.o & g4.o);
    1'b1, 3'b110 : o <= (g2.o & g3.o & g4.o);
    1'b1, 3'b111 : o <= (g3.o & g4.o & g1.o & g2.o);
    default : o <= 1'b0;
    endcase
    endmodule
    ```
    ### Testbench:
    ```
    module aoi_gate_tb;
    reg a1, a2, b1, b2;
    reg a1_b1_a2_b2;
    reg a2_b2_a1_b1;
    wire o;

    module aoi_gate (o, a1, a2, b1, b2);
    input a1, a2, b1, b2;
    output o;

    wire [2:0] a1_b1;
    wire [2:0] a1_a2;
    wire [2:0] a2_b2;
    wire [2:0] b1_a1;
    wire [2:0] b1_b2;
    wire [2:0] b2_a2;
    wire [2:0] a1_b1_b2_a2;
    wire [2:0] a1_b1_a2_b2;
    wire [2:0] a2_b2_a1_b1;
    wire [2:0] a2_b2_b1_a1;

    and g1(o, a1, b1);
    and g2(o, a2, b2);
    and g3(o, a1, a2);
    and g4(o, b1, b2);

    assign a1_b1 = {b1, a1};
    assign a1_a2 = {a2, a1};
    assign a2_b2 = {b2, a2};
    assign b1_a1 = {a1, b1};
    assign b1_b2 = {b2, b1};
    assign b2_a2 = {a2, b2};

    assign a1_b1_b2_a2 = {b2_a2, a1_b1};
    assign a1_b1_a2_b2 = {a2_b2, a1_b1};
    assign a2_b2_a1_b1 = {a1_b1, a2_b2};
    assign a2_b2_b1_a1 = {b1_a1, a2_b2};

    case ({b1, b2, a1, a2})
    1'b0, 3'b000 : o <= (g1.o & g4.o);
    1'b0, 3'b001 : o <= (g2.o & g4.o);
    1'b0, 3'b010 : o <= (g2.o & g3.o);
    1'b0, 3'b011 : o <= (g1.o & g3.o);
    1'b0, 3'b100 : o <= (g2.o & g1.o & g3.o);
    1'b0, 3'b101 : o <= (g1.o & g2.o & g3.o);
    1'b0, 3'b110 : o <= (g1.o & g2.o & g4.o);
    1'b0, 3'b111 : o <= (g1.o & g3.o & g4.o);
    1'b1, 3'b000 : o <= (g3.o & g4.o);
    1'b1, 3'b001 : o <= (g2.o & g4.o);
    1'b1, 3'b010 : o <= (g1.o & g4.o);
    1'b1, 3'b011 : o <= (g1.o & g3.o);
    1'b1, 3'b100 : o <= (g2.o & g1.o & g3.o);
    1'b1, 3'b101 : o <= (g2.o & g1.o & g4.o);
    1'b1, 3'b110 : o <= (g2.o & g3.o & g4.o);
    1'b1, 3'b111 : o <= (g3.o & g4.o & g1.o & g2.o);
    default : o <= 1'b0;
    endcase

    endmodule

    always
    begin
    a1 = 0;
    a2 = 0;
    b1 = 0;
    b2 = 0;
    a1_b1_a2_b2 = 0;
    a2_b2_a1_b1 = 0;
    #
- code: "```\nmodule aoi_gate(o,a1,a2,b1,b2);\ninput a1,a2,b1,b2;// a1,a2,b1,b2 form\
    \ the input\n//ports of the module\noutput o;//o is the single output port of\
    \ the module\nwire o1,o2;//o1 and o2 are intermediate signals\n//within the module\n\
    and g1(o1,a1,a2); //The AND gate primitive has two\nand g2(o2,b1,b2);// instantiations\
    \ with assigned\n//names g1 & g2.\nnor g3(o,o1,o2);//The nor gate has one instantiation\n\
    //with assigned name g3.\nendmodule\n```\n### Result:\n![image](https://user-images.githubusercontent.com/45888540/121716141-cc59d300-cb0d-11eb-8103-502454411be9.png)\n\
    \nendmodule\r\n/FPGA/Verilog code/code_3/code_3_1.v\nmodule code_3_1 (output_1,input_74,\
    \ input_75, input_76, input_77);\r\nwire output_1, input_74, input_75, input_76;\r\
    \nwire input_77;\r\nwire q11,q12,q13,q14,q15,q16,q17,q18,q19,q20,q21,q22,q23,q24,q25,q26;\r\
    \nwire q27,q28,q29,q30,q31,q32,q33,q34,q35,q36,q37,q38,q39,q40,q41,q42;\r\nwire\
    \ q43,q44,q45,q46,q47,q48,q49,q50,q51,q52,q53,q54,q55,q56,q57,q58;\r\nwire q59,q60,q61,q62,q63,q64,q65,q66,q67,q68,q69,q70,q71,q72,q73,q74;\r\
    \nwire q75,q76,q77,q78,q79,q80,q81,q82,q83,q84,q85,q86,q87,q88,q89,q90;\r\nwire\
    \ q91,q92,q93,q94,q95,q96,q97,q98,q99,q100,q101,q102,q103;\r\nwire_or (output_1,\
    \ q11, q12, q13, q14, q15, q16, q17, q18, q19, q20, q21, q22, q23, q24, q25, q26,\
    \ q27, q28, q29, q30, q31, q32, q33, q34, q35, q36, q37, q38, q39, q40, q41, q42,\
    \ q43, q44, q45, q46, q47, q48, q49, q50, q51, q52, q53, q54, q55, q56, q57, q58,\
    \ q59, q60, q61, q62, q63, q64, q65, q66, q67, q68, q69, q70, q71, q72, q73, q74,\
    \ q75, q76, q77, q78, q79, q80, q81, q82, q83, q84, q85, q86, q87, q88, q89, q90,\
    \ q91, q92, q93, q94, q95, q96, q97, q98, q99, q100, q101, q102, q103);\r\nwire_and\
    \ (q11, input_74, q12);\r\nwire_and (q13,  q12, q14);\r\nwire_and (q15, q14, q16);\r\
    \nwire_and (q17,q16,q18);\r\nwire_and (q19,q18,q20);\r\nwire_and (q21,q20,q22);\r\
    \nwire_and (q23,q22,q24);\r\nwire_and (q25,q24,q26);\r\nwire_and (q27,q14,q28);\r\
    \nwire_and (q29,q28,q30);\r\nwire_and (q31,q30,q32);\r\nwire_and (q33,q32,q34);\r\
    \nwire_and (q35,q34,q36);\r\nwire_and (q37,q36,q38);\r\nwire_and (q39,q38,q40);\r\
    \nwire_and (q41,q20,q42);\r\nwire_and (q43,q42,q44);\r\nwire_and (q45,q44,q46);\r\
    \nwire_and (q47,q46,q48);\r\nwire_and (q49,q48,q50);\r\nwire_and (q51,q50,q52);\r\
    \nwire_and (q53,q52,q54);\r\nwire_and (q55,q42,q56);\r\nwire_and (q57,q56,q58);\r\
    \nwire_and (q59,q58,q60);\r\nwire_and (q61,q60,q62);\r\nwire_and (q63,q62,q64);\r\
    \nwire_and (q65,q64,q66);\r\nwire_and (q67,q44,q68);\r\nwire_and (q69,q68,q70);\r\
    \nwire_and (q71,q70,q72);\r\nwire_and (q73,q72,q74);\r\nwire_and (q75,q56,q76);\r\
    \nwire_and (q77,q76,q78);\r\nwire_and (q79,q78,q80);\r\nwire_and (q81,q80,q82);\r\
    \nwire_and (q83,q82,q84);\r\nwire_and (q85,q84,q86);\r\nwire_and (q87,q86,q88);\r\
    \nwire_and (q89,q88,q90);\r\nwire_or (q91, q75, q77, q79, q81, q83, q85, q87,\
    \ q89);\r\nwire_and (q92, q91, q93);\r\nwire_and (q94, q93, q95);\r\nwire_and\
    \ (q96, q95, q97);\r\nwire_and (q98, q97, q99);\r\nwire_and (q100, q99, q101);\r\
    \nwire_and (q102, q101, q103);\r\nwire_and (q75, q102, q104);\r\nwire_and (q77,q75,q76);\r\
    \nwire_and(q79,q77,q78);\r\nwire"
- code: "module memory(dataout,a,addr);\ninput[15:0] a;\ninput clk, arst;\noutput[15:0]\
    \ dataout;\nreg[15:0] dout;\nreg[15:0] daddr;\ninitial begin // Add initial block\
    \ to procedural continuous assign\ndout = 4'b0000;\ndaddr = 16'b0000;\nend\nalum\
    \ g1(dout[15],a[15],a[0],arst);\nalum g2(dout[14],a[14],a[1],arst);\nalum g3(dout[13],a[13],a[2],arst);\n\
    alum g4(dout[12],a[12],a[3],arst);\nalum g5(dout[11],a[11],a[4],arst);\nalum g6(dout[10],a[10],a[5],arst);\n\
    alum g7(dout[9],a[9],a[6],arst);\nalum g8(dout[8],a[8],a[7],arst);\nalum g9(dout[7],a[7],a[8],arst);\n\
    alum g10(dout[6],a[6],a[9],arst);\nalum g11(dout[5],a[5],a[10],arst);\nalum g12(dout[4],a[4],a[11],arst);\n\
    alum g13(dout[3],a[3],a[12],arst);\nalum g14(dout[2],a[2],a[13],arst);\nalum g15(dout[1],a[1],a[14],arst);\n\
    alum g16(dout[0],a[0],a[15],arst);\nassign dataout = dout;\nendmodule\n### Verification:\n\
    If the test bench is compiled properly and run, you should see expected output.\n\
    \n## 10.9\_\_Behavioral SRAM and Memory Organization\n\n### Problem Statement:\n\
    \n### Base Verilog Code:\nmodule memory(dataout,a,addr);\ninput[15:0] a;\ninput\
    \ clk, arst;\noutput[15:0] dataout;\nreg[15:0] dout;\nreg[15:0] daddr;\nalum g1(dout[15],a[15],a[0],arst);\n\
    alum g2(dout[14],a[14],a[1],arst);\nalum g3(dout[13],a[13],a[2],arst);\nalum g4(dout[12],a[12],a[3],arst);\n\
    alum g5(dout[11],a[11],a[4],ar"
- code: "module aoibeh2(o,a,b); // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\n\
    wire a1,b1; // Outputs of AND gates\nreg o; // Behavioral output must be reg\n\
    wire [1:0] a_slice = a[0:1];\n// Structural AND gates using primitives\nand g1(a1,a[1],a[0]),\
    \ g2(b1,b[1],b[0]);\n// Behavioral NOR logic sensitive to AND outputs\nalways@(a1\
    \ or b1)\ninitial\nbegin\nassign a1 = a_slice[1];\nassign b1 = b_slice[1];\nend\n\
    always@(a1 or b1)\no = ~(a1 || b1);\nendmodule\n### Comments:\nI'm not sure if\
    \ the assignment of the slice was necessary, but it does not seem to change the\
    \ overall behavior.\n\n# Summary\n\nThe solution proposed by  is very elegant\
    \ and straightforward. I believe that your solution is less elegant and more complicated.\
    \ However, I do not know if it is correct and has a bug. The solution presented\
    \ by  is the standard way to avoid the use of the packing array.\n\n\u2022 Thank\
    \ you for the informative answer. I had a couple of questions regarding the solution\
    \ you have presented.\n\u2022 Why do we have to use the initial block? Why can't\
    \ we use assign?\n\nI think there might be a better way to do this without initial\
    \ block, but I don't know how to do it.\n\n\u2022 If you use assign, you don't\
    \ have to use the initial block. It only makes sense to use the initial block\
    \ if you are doing something like this:\nreg[4:0] a;\nwire[4:0] a_slice;\n\ninitial\n\
    begin\na_slice = {4'b1, a[3:0]};\nend\n...\nalways @(a_slice)\nassign a1 = a_slice[4];\n\
    \n\nThis is what you are likely doing and you don't want the initial block.\n\n\
    When you use assign, you don't need the initial block. It makes no difference.\n\
    \n\u2022 I think you misunderstood the question. I was asking why assign a1 =\
    \ pack_slice[1] didn't work.\n\nAlso, I can see that you didn't actually answer\
    \ the question.\n\n\u2022 If you declare a1 as a wire, you cannot use assign a1\
    \ = pack_slice[1]. You must declare a1 as a reg.\n\nNote that when you declare\
    \ a1 as a wire, the behavior becomes as follows:\n\nIn an initial block, assign\
    \ a1 = pack_slice[1] is equivalent to assign a1 = 0 (default value of a wire).\n\
    \nRegardless of how you declare a1, you can use assign a1 = pack_slice[1] inside\
    \ an always block.\n\n\u2022 Thank you, this is very informative. In the end,\
    \ I have to use pack_slice[1] because b_slice[1] is also used for another logic.\
    \ I didn't try to assign it because I didn't know that pack_slice had multiple\
    \ elements. I have also learned to not use the initial block. Thank you again\
    \ for your time.\n\nThe behavioral code is not the problem. The issue is that\
    \ you are using the same port for two different tasks. The output of the wire\
    \ a1 is not being used by your logic and you are trying to connect it to the input\
    \ of your logic.\n\nThe problem with your solution is that you are defining a[1]\
    \ as an input, but a1 is not connected to anything. The second problem is that\
    \ your logic is not sensitive to the output of your wire a1.\n\nThe behavioral\
    \ code in your question is fine, but when you begin to use it later in the code\
    \ you will discover that it is not what you want. You should be defining the logic\
    \ inside the always block and leave the output port alone to be used by whatever\
    \ is calling it. That way there will be no issues when you move on to use the\
    \ output of the wire a1 later.\n\n\u2022 You are absolutely right. I didn't know\
    \ you could assign ports. I have changed my code now to not declare the ports\
    \ and only declare them inside the always block. Thank you very much for the help.\n\
    \nmodule aoibeh3(o,a,b); // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\n\
    wire a1,b1; // Outputs of AND gates\nreg o; // Behavioral output must be reg\n\
    // Structural AND gates using primitives\nand g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);\n\
    // Behavioral NOR logic sensitive to AND outputs\nalways@(a1 or b1)\nbegin\no\
    \ = ~(a1 || b1);\nendendmodule"
- code: "module aoibeh2(o,a,b); // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\n\
    reg [1:0]a1,b1; // Outputs of AND gates\nreg o; // Behavioral output must be reg\n\
    // Structural AND gates using primitives\nand g1(a1[0],a[1],a[0]), g2(b1[0],b[1],b[0]);\n\
    // Behavioral NOR logic sensitive to AND outputs\nalways@(a1 or b1)\no = ~({a1,\
    \ b1});\nendmodule\n### Testbench:\nmodule aoibeh2_tb;\nreg[1:0] a, b;\nwire o;\n\
    \n// Instatiate the mixed structural/behavioral\naoibeh2 u1(.a(a),.b(b),.o(o));\n\
    \ninitial begin\n$display(\"a b o\");$dumpfile(\"test_aoibeh2.vcd\");\n$dumpvars(0,\
    \ aoibeh2_tb); a = 1'b0; b = 1'b1; #10$display(\"%b %b %b\", a, b, o);\n$display(\"\
    %b %b %b\", a, b, o); a = 1'b0; b = 1'b0; #10$display(\"%b %b %b\", a, b, o);\n\
    $display(\"%b %b %b\", a, b, o); a = 1'b1; b = 1'b0; #10$display(\"%b %b %b\"\
    , a, b, o);\n$display(\"%b %b %b\", a, b, o); a = 1'b1; b = 1'b1; #10$display(\"\
    %b %b %b\", a, b, o);\n$display(\"%b %b %b\", a, b, o); end endmodule End. ###\
    \ Output: a b o 0 0 1 0 0 0 1 1 1 ### Explanation: \u2022 The only change is that\
    \ the behavioral output is now a packed vector of outputs. \u2022 The packed vector\
    \ is created with {\u2026}. This tells Verilog to make a new packed vector of\
    \ the given inputs. This is a convenient way to create a packed vector of inputs.\
    \ \u2022 The initial block contains the continuous assignment used in the procedural\
    \ continuous assign in the behavioral module. ### Exercises ##### Ex. 1: Implement\
    \ the Mixed Structural/Behavioral Module Using Behavioral Primitive Inverters\
    \ Using the Verilog HDL Programming Language. Create a module for a behavioral\
    \ implementation of a n-bit inverter using behavioral primitive inverters. 1.\
    \ The first input vector a is used to represent the data to be inverted. 2. The\
    \ second input vector b is used as the control signal. 1. The output vector o\
    \ is driven by the inverter. 1. The behavioral output must be reg register. #####\
    \ Ex. 2: Implement the Mixed Structural/Behavioral Module Using Structural Primitive\
    \ Inverters Using the Verilog HDL Programming Language. Create a module for a\
    \ structural implementation of a n-bit inverter using structural primitive inverters.\
    \ 1. The first input vector a is used to represent the data to be inverted. 2.\
    \ The second input vector b is used as the control signal. 1. The output vector\
    \ o is driven by the inverter. 1. The structural output must be a wire. #####\
    \ Ex. 3: Implement the Mixed Structural/Behavioral Module Using Behavioral Primitive\
    \ Inverters Using the Verilog HDL Programming Language. Create a module for a\
    \ behavioral implementation of a n-bit adder/subtractor using behavioral primitive\
    \ inverters. 1. The first input vector a is used to represent the data to be added/subtracted.\
    \ 2. The second input vector b is used as the control signal (1 for addition and\
    \ 0 for subtraction). 3. The third input vector c is used as the carry in. 1.\
    \ The output vector o is driven by the inverter. 1. The behavioral output must\
    \ be reg register. ##### Ex. 4: Implement the Mixed Structural/Behavioral Module\
    \ Using Behavioral Primitive Inverters Using the Verilog HDL Programming Language.\
    \ Create a module for a behavioral implementation of a n-bit adder/subtractor\
    \ using behavioral primitive inverters. 1. The first input vector a is used to\
    \ represent the data to be added/subtracted. 2. The second input vector b is used\
    \ as the control signal (1 for addition and 0 for subtraction). 3. The third input\
    \ vector c is used as the carry in. 1. The output vector o is driven by the inverter.\
    \ 1. The behavioral output must be reg register. ##### Problem: \u2022 Design\
    \ a circuit using structural logic gates and behavioral inverter logic gates.\
    \ \u2022 The circuit must be a clocked circuit. \u2022 The circuit must implement\
    \ an odd parity circuit checker (1 out of 2 input lines is logic 1). \u2022 The\
    \ output must be a bit array of size 1. \u2022 The inputs must be bits of size\
    \ 1. \u2022 The circuit must have a clock input of size 1. \u2022 You may assume\
    \ no inputs will be logic 0. \u2022 You may assume that there are no floating\
    \ inputs. \u2022 The circuit must be clocked. \u2022 The circuit must have a clock\
    \ signal of size 1. \u2022 The clock signal must be a reg register. \u2022 The\
    \ circuit must have a clock enable signal of size 1. \u2022 The clock enable signal\
    \ must be a reg register. \u2022 The circuit must have a clock signal of size\
    \ 1. \u2022 The clock signal must be a wire wire. \u2022 You may assume no outputs\
    \ will be driven to logic 1. \u2022 You may assume that there are no floating\
    \ outputs. \u2022 The clock enable signal must be driven to logic 1. \u2022 The\
    \ clock signal must be driven to logic 1 if the clock enable signal is 1. \u2022\
    \ You may assume that there are no floating clock enable inputs. \u2022 You may\
    \ assume that there are no floating clock inputs. \u2022 You may assume that there\
    \ are no synchronously clocked sequential circuits. \u2022 You may assume that\
    \ there are no tristated clock enable inputs. \u2022 You may assume that there\
    \ are no tristated clock inputs. ##### Solution: module odd_parity_checker (o,\
    \ clk_en, clk); // Inverter Circuit output o : 1'b0 ; // 1 out of 2 input lines\
    \ is logic 1 input: // Structural inputs [1:0]a, b input [0:0] clk_en, clk; //\
    \ Behavioral inputs reg: // Behavioral Outputs //Structural Outputs reg o; //\
    \ Behavioral Output reg clk; // Behavioral Input reg clk_en;// Behavioral Input\
    \ // Behavioral Inverter Inverter i1 (o, b[1], a[0]); Inverter i2 (o, b[0], a[1]);\
    \ // Structural Inverter Inverter i3 (o, a[1], b[0]); Inverter i4 (o, a[0], b[1]);\
    \ // Structural Inverter Inverter i5 (o, b[1], a[1]); // Behavioral Inverter Inverter\
    \ i6 (o, b[0], a[0]); endmodule ##### Testbench: module odd_parity_checker_tb;\
    \ reg a, b, clk_en, clk, o; // Inputs reg[1:0] a, b; // Behavioral Inputs // Behavioral\
    \ Outputs reg o; // Behavioral Outputs // Behavioral Inputs reg clk_en; // Behavioral\
    \ Inputs reg clk; // Behavioral Inputs // Behavioral Inverter Inverter i1(o, b[1],\
    \ a[0]); // Behavioral Inverter Inverter i2(o, b[0], a[1]); // Behavioral Inverter\
    \ Inverter i3(o, a[1], b[0]); // Behavioral Inverter Inverter i4(o, a[0], b[1]);\
    \ // Behavioral Inverter Inverter i5(o, b[1], a[1]); // Behavioral Inverter Inverter\
    \ i6(o, b[0], a[0]); initial begin$display(\"a b o clk clk_en\");\n\nclk_en =\
    \ 1;\n\n$dumpfile(\"test_odd_parity_checker.wcd\");$dumpvars(0, odd_parity_checker_tb);\n\
    \no = 1'b0;\na = 1'b0;\nb = 1'b0;\nclk = 1'b0;\n$display(\"%b %b %b %b %b\", a,\
    \ b, o, clk, clk_en);$display(\"%b %b %b %b %b\", a, b, o, clk, clk_en);\no =\
    \ 1'b0;\na = 1'b0;\nb = 1'b1;\nclk = 1'b0;\n$display(\"%b %b %b %b %b\", a, b,\
    \ o, clk, clk_en);$display(\"%b %b %b %b %b\", a, b, o, clk, clk_en);\no = 1'b1;\n\
    a = 1'b0;\nb"
- code: |-
    module cnt44(o,i);
    output[3:0]o;
    input[3:0]i;
    reg[4:0] r;
    wire [2:0]addr;
    assign o = r[3:0];
    always @* begin
    case (addr)
    0:
    r = i == 'bx? 0 : i + 1;
    1:
    r = r[3:1] + (i == 'bx? 0 : i + 1);
    2:
    r = r[3:2] + (i == 'bx? 0 : i + 1);
    3:
    r = r[3:3] + (i == 'bx? 0 : i + 1);
    4:
    r = r[3:4] + (i == 'bx? 0 : i + 1);
    end
    endmodule

    The next variation instruction is to generate an arbitrary 4:16 UpCounter, using the same methodology by changing the number of bits (16) for each variation.

    ## Example 7

    Create a 4:16 UpCounter.

    ### Base Verilog Code:
    module cnt1616(o,i);
    output[15:0]o;
    input[15:0]i;
    assign o = i == 'bx? 0 : i + 1;
    endmodule

    ### Variation Instruction:
    Add a 16-bit wide register
- code: "module aoibeh2(o,a,b); // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\n\
    wire a1,b1; // Outputs of AND gates\ninitial // Initial block\nassign {a1,b1}\
    \ = {a[1:0],b[1:0]};\nreg o; // Behavioral output must be reg\n// Structural AND\
    \ gates using primitives\nand g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);\n// Behavioral\
    \ NOR logic sensitive to AND outputs\nalways@(a1 or b1)\no = ~(a1 || b1);\nendmodule\n\
    ### Result:\nThis works. But it is not much different from the normal procedural\
    \ assign with initial block.\nWhy is this?\n##### Share on other sites\n\nAs you've\
    \ probably noticed by now, this won't work in Verilog because of the way the language\
    \ constructs.\n\nAnd this will not work in Verilog either (for any other reason)\n\
    \nalways@(a1 or b1)\n\n\nI'm not certain why you want this to work, but Verilog\
    \ doesn't like the way you've structured it.\n\nI'd like to see the code for the\
    \ module that you're working on now.\n\nedit:\n\nWhat you've made is an asynchronous\
    \ OR gate. It won't do what you expect.\n\n##### Share on other sites\n\nI'm not\
    \ certain why you want this to work\n\nWhy do you need this? I thought only the\
    \ one-way is not enough.\n\n##### Share on other sites\n\nA synchronous or gate\
    \ is made using a combination of logic gates that have the right inputs configured\
    \ to turn into logic levels that match the desired function using always and/or\
    \ or blocks.\n\nFor example, the one in question here could be made like this:\n\
    \nmodule aoibeh2(o,a,b);\noutput o;\ninput[1:0]a,b;\nwire a1,b1;\nreg a1,b1;\n\
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);\nalways @(*)\nbegin\na1 = a[1];\nb1 =\
    \ b[1];\nend\n\nalways@(a1 or b1)\no = ~(a1 || b1);\nendmodule\n\nNote that I\
    \ have changed the order of assignment, so that the input values are set as part\
    \ of the assignment that is triggered by the output. This can be done since the\
    \ signals are declared as registers. You could also just use assign a1 = a[1]\
    \ and have it be the same as I have. Also note that I have used the more compact\
    \ and more readable bit selectors instead of a[0] and a[1], but you can use the\
    \ full-word selectors if you want.\n\nNote also that I have used the @(*) block\
    \ to trigger the assignments whenever anything changes. It's important because\
    \ if I do this:\n\nalways @ (posedge clk);\n\n\nThen the assign would only fire\
    \ at the rising edge of the clock. This can be a big headache, especially when\
    \ I'm not sure what's going to change so I have to write down all the signals\
    \ I want to assign. This is especially cumbersome when I have a lot of lines of\
    \ code.\n\n##### Share on other sites\n\nWhy do you need this? I thought only\
    \ the one-way is not enough.\n\nI don't think so. You need a two-way, because\
    \ you have to take into account the change of one input and the change of the\
    \ other.\n\n##### Share on other sites\n\nI don't think so. You need a two-way,\
    \ because you have to take into account the change of one input and the change\
    \ of the other.\n\nBut you don't need two different wires. You don't need a second\
    \ always block. You just need to assign to the wires instead of the regs.\n\n\
    ##### Share on other sites\n\nBut you don't need two different wires. You don't\
    \ need a second always block. You just need to assign to the wires instead of\
    \ the regs.\n\nWire a AND b;\nassign a = a[1];\nassign b = b[1];\n\n\nA synchronous\
    \ or gate is made using a combination of logic gates that have the right inputs\
    \ configured to turn into logic levels that match the desired function using always\
    \ and/or or blocks.\n\nFor example, the one in question here could be made like\
    \ this:\n\nThis is what I meant by \"two different wires\". The problem is that\
    \ the other always block isn't needed, because it won't fire at all.\n\n#####\
    \ Share on other sites\n\nA synchronous or gate is made using a combination of\
    \ logic gates that have the right inputs configured to turn into logic levels\
    \ that match the desired function using always and/or or blocks.\n\nFor example,\
    \ the one in question here could be made like this:\n\nThis is what I meant by\
    \ \"two different wires\". The problem is that the other always block isn't needed,\
    \ because it won't fire at all.\n\nAh, okay. I see what you're saying now. Thanks\
    \ for clearing it up for me.\n\n##### Share on other sites\n\nIn general, you\
    \ will not be able to make this work properly. There are many possible combinations\
    \ that will not work. (For instance, if you flip the inputs, the output changes,\
    \ but the internal logic of the module will need to change accordingly.) You also\
    \ cannot really do this in the same module. You would need a separate module for\
    \ this gate, or you would need multiple modules, one for each input combination.\n\
    \n##### Share on other sites\nIn general, you will not be able to make this work\
    \ properly. There are many possible combinations that will not work. (For instance,\
    \ if you flip the inputs, the output changes, but the internal logic of the module\
    \ will need to change accordingly.) You also cannot really do this in the same\
    \ module. You would need a separate module for this gate, or you would need multiple\
    \ modules, one for each input combination.\n\nThat's what I tried to achieve.\n\
    \nSo, if the module that I want to modify is a behavioral module, how can this\
    \ be done?\n\n##### Share on other sites\n\nSorry, you can't. Behavioral modules\
    \ are designed to work with different inputs. You'd have to duplicate the module\
    \ for every possible input combination.\n\n##### Share on other sites\n\nSorry,\
    \ you can't. Behavioral modules are designed to work with different inputs. You'd\
    \ have to duplicate the module for every possible input combination.\n\nIs there\
    \ any way to implement this using behavioral primitives?\n\n##### Share on other\
    \ sites\n\nIs there any way to implement this using behavioral primitives?\n\n\
    Yes, you'd need a case statement.\n\n##### Share on other sites\n\nThat's what\
    \ I tried to achieve.\n\nSo, if the module that I want to modify is a behavioral\
    \ module, how can this be done?\n\n##### Share on other sites\n\nFor a behavioral\
    \ module, just use a case statement and the primitive functions.\n\n##### Share\
    \ on other sites\n\nThis topic is 1612 days old which is more than the 365 day\
    \ threshold we allow for new replies. Please post a new topic.\n\n## Create an\
    \ account\n\nRegister a new account\n\n\u2022 ### Forum Statistics\n\n\u2022 Total\
    \ Topics\n628725\n\u2022 Total Posts\n2984411\n\n\u2022 25\n\u2022 11\n\u2022\
    \ 10\n\u2022 16\n\u2022 14"
- code: "module aoibeh4(o,a,b); // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\n\
    wire a1,b1; // Outputs of AND gates\nreg o; // Behavioral output must be reg\n\
    // Structural AND gates using primitives\nand g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);\n\
    // Behavioral NOR logic sensitive to AND outputs\ninitial\nbegin\no = ~(a1 ||\
    \ b1);\nend\n// Behavioral NOR logic sensitive to AND outputs\nalways@(a1 or b1)\n\
    o = ~(a1 || b1);\nendmodule\n### Compiled Verilog Code:\nmodule aoibeh4(o,a,b);\
    \ // Mixed structural/behavioral AOI\noutput o;\ninput[1:0]a,b;\nwire [1:0] _a\
    \ = a;\nwire [1:0] _b = b;\nwire [1:0] _and_2 = and(_a[1:0],_a[1:0],_b[1:0]);\n\
    reg _or_3;\n// Behavioral NOR logic sensitive to AND outputs\ninitial\nbegin\n\
    _or_3 = ~(a1 || b1);\nend\n// Behavioral NOR logic sensitive to AND outputs\n\
    always@(a1 or b1)\n_or_3 = _or_3|({_and_2});\nendmodule\n### Output of the simulation:\n\
    \n### Observations:\n\n\u2022 The behavioral output is correct.\n\u2022 The behavioral\
    \ output will be the NAND of the 2 AND outputs since we don\u2019t have any feedback.\n\
    \n## Summary\n\n\u2022 The behavioral output has no dependency on the outputs\
    \ of the AND gates.\n\u2022 The behavioral output is correct.\n\u2022 The behavioral\
    \ output will be the NAND of the 2 AND outputs since we don\u2019t have any feedback.\n\
    \u2022 By using a continuous assign, we can eliminate the dependency on the outputs\
    \ of the AND gates."
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire[1:0] a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1[1],a[1],a[0]), g2(b1[1],b[1],b[0]) // packed slice
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1[0] or b1[0])
    o = ~ (a1[0] or b1[0]);
    endmodule

    ```



    ```python

    ```

    #### Add a 3-to-8 Decoder

    ##### Module Definition and Verilog Code

    ``` python
    # 3-to-8 Decoder

    module d3to8_0(d0,d1,d2,d,e,s);
    input d0,d1,d2;
    output [2:0] d,s;
    wire [1:0] e;

    or g0(d[0],d0,d1,d2), // d0 = d0 or d1 or d2;
    or g1(d[1],d0,d1,d2); // d1 = d0 or d1 or d2;
    or g2(d[2],d0,d1,d2); // d2 = d0 or d1 or d2;

    nand g3(e[0],d[0],d[1],d[2]), // e0 = ~(d0 and d1 and d2);
    nand g4(e[1],d[0],d[1],d[2]); // e1 = ~(d0 and d1 and d2);

    and g5(s[0],d[0],d[1],d[2]), // s0 = d0 and d1 and d2;
    and g6(s[1],d[0],d[1],d[2]), // s1 = d0 and d1 and d2;
    and g7(s[2],d[0],d[1],d[2]), // s2 = d0 and d1 and d2;
    and g8(s[3],d[0],d[1],d[2]); // s3 = d0 and d1 and d2;

    endmodule

    ```

    ``` verilog

    # 3-to-8 Decoder

    module d3to8_0(d0,d1,d2,d,e,s);
    input d0,d1,d2;
    output [2:0] d,s;
    wire [1:0] e;

    or g0(d[0],d0,d1,d2), // d0 = d0 or d1 or d2;
    or g1(d[1],d0,d1,d2); // d1 = d0 or d1 or d2;
    or g2(d[2],d0,d1,d2); // d2 = d0 or d1 or d2;

    nand g3(e[0],d[0],d[1],d[2]), // e0 = ~(d0 and d1 and d2);
    nand g4(e[1],d[0],d[1],d[2]); // e1 = ~(d0 and d1 and d2);

    and g5(s[0],d[0],d[1],d[2]), // s0 = d0 and d1 and d2;
    and g6(s[1],d[0],d[1],d[2]), // s1 = d0 and d1 and d2;
    and g7(s[2],d[0],d[1],d[2]), // s2 = d0 and d1 and d2;
    and g8(s[3],d[0],d[1],d[2]); // s3 = d0 and d1 and d2;

    endmodule

    ```

    ##### Source Code

    ``` python
    # 3-to-8 Decoder

    module d3to8_0(d0,d1,d2,d,e,s);
    input d0,d1,d2;
    output [2:0] d,s;
    wire [1:0] e;

    or g0(d[0],d0,d1,d2), // d0 = d0 or d1 or d2;
    or g1(d[1],d0,d1,d2); // d1 = d0 or d1 or d2;
    or g2(d[2],d0,d1,d2); // d2 = d0 or d1 or d2;

    nand g3(e[0],d[0],d[1],d[2]), // e0 = ~(d0 and d1 and d2);
    nand g4(e[1],d[0],d[1],d[2]); // e1 = ~(d0 and d1 and d2);

    and g5(s[0],d[0],d[1],d[2]), // s0 = d0 and d1 and d2;
    and g6(s[1],d[0],d[1],d[2]), // s1 = d0 and d1 and d2;
    and g7(s[2],d[0],d[1],d[2]), // s2 = d0 and d1 and d2;
    and g8(s[3],d[0],d[1],d[2]); // s3 = d0 and d1 and d2;

    endmodule

    ```

    ``` verilog

    # 3-to-8 Decoder

    module d3to8_0(d0,d1,d2,d,e,s);
    input d0,d1,d2;
    output [2:0] d,s;
    wire [1:0] e;

    or g0(d[0],d0,d1,d2), // d0 = d0 or d1 or d2;
    or g1(d[1],d0,d1,d2); // d1 = d0 or d1 or d2;
    or g2(d[2],d0,d1,d2); // d2 = d0 or d1 or d2;

    nand g3(e[0],d[0],d[1],d[2]), // e0 = ~(d0 and d1 and d2);
    nand g4(e[1],d[0],d[1],d[2]); // e1 = ~(d0 and d1 and d2);

    and g5(s[0],d[0],d[1],d[2]), // s0 = d0 and d1 and d2;
    and g6(s[1],d[0],d[1],d[2]), // s1 = d0 and d1 and d2;
    and g7(s[2],d[0],d[1],d[2]), // s2 = d0 and d1 and d2;
    and g8(s[3],d[0],d[1],d[2]); // s3 = d0 and d1 and d2;

    endmodule

    ```

    ##### Result:

    ![image-20201222143528820](https://tva1.sinaimg.cn/large/007S8ZIlly1gge2r52k7gj31kw12a7wh.jpg)

    ##### Variation:

    ``` python

    # 3-to-8 Decoder

    module d3to8_0(d0,d1,d2,d,e,s);
    input d0,d1,d2;
    output [2:0] d,s;
    wire [1:0] e;

    or g0(d[0],d0,d1,d2), // d0 = d0 or d1 or d2;
    or g1(d[1],d0,d1,d2); // d1 = d0 or d1 or d2;
    or g2(d[2],d0,d1,d2); // d2 = d0 or d1 or d2;

    nand g3(e[0],d[0],d[1],d[2]), // e0 = ~(d0 and d1 and d2);
    nand g4(e[1],d[0],d[1],d[2]); // e1 = ~(d0 and d1 and d2);

    and g5(s[0],d[0],d[1],d[2]), // s0 = d0 and
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    input rst;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always @(a or b)
    o = ~(a1 || b1);
    endmodule

    ### Results:
    1. Performance Improvement: The code achieved
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    initial begin // 1. initial_block_begin
    a1 <= a[1:0]; // 2. packing
    b1 <= b[1:0]; // 3. packing
    end
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    initial
    begin
    a1 = a[1];
    b1 = b[1];
    end
    always@(*)
    o = ~(a1 || b1);
    endmodule

    ```
    ---
    layout: post
    title: "How to connect an ESP32 to a 2-port switch using its GPIO pins"
    date: 2022-03-23 00:00:00
    ---

    ## Introduction

    This post details how to connect an ESP32 to a 2-port switch using its GPIO pins. This makes it possible to control the 2-port switch using an ESP32 via software.

    ## The Design

    The design is as follows:

    * An ESP32 module will be used. The ESP32 module will be connected to the 2-port switch via the GPIO pins.
    * The ESP32 module will have GPIO pins connected to the 2-port switch.
    * The ESP32 module will be programmed using the Arduino IDE to drive the 2-port switch.
    * The ESP32 module will be programmed using the Arduino IDE to monitor the 2-port switch status.

    ## Hardware Connections

    The connections are as follows:

    * The ESP32 module must be connected to the 2-port switch via the GPIO pins.
    * The ESP32 module's GPIO pins must be connected to the 2-port switch.

    ## Software Implementation

    The following software implementation can be used to connect an ESP32 module to a 2-port switch over its GPIO pins:

    ```cpp
    #include <Arduino.h>

    const int pinA = 2; // Pin A on the 2-port switch
    const int pinB = 4; // Pin B on the 2-port switch
    const int pinEn = 13; // Pin EN on the 2-port switch

    void setup()
    {
        Serial.begin(9600);
        pinMode(pinA, OUTPUT);
        pinMode(pinB, OUTPUT);
        pinMode(pinEn, OUTPUT);
    }

    void loop()
    {
        // Turn ON the 2-port switch
        digitalWrite(pinA, HIGH);
        digitalWrite(pinB, HIGH);
        digitalWrite(pinEn, HIGH);
        Serial.print("2-port switch turned ON\n");

        // Wait for 5 seconds
        delay(5000);

        // Turn OFF the 2-port switch
        digitalWrite(pinA, LOW);
        digitalWrite(pinB, LOW);
        digitalWrite(pinEn, LOW);
        Serial.print("2-port switch turned OFF\n");

        // Wait for 5 seconds
        delay(5000);
    }
    ```

    ## Testing the Implementation

    To test the implementation, refer to the following steps:

    1. Load the software on the ESP32 module.
    2. Start the serial monitor.
    3. Turn ON the 2-port switch.
    4. Observe the serial output. The output should indicate that the 2-port switch has been turned ON.
    5. Wait for 5 seconds.
    6. Turn OFF the 2-port switch.
    7. Observe the serial output. The output should indicate that the 2-port switch has been turned OFF.
    8. Wait for 5 seconds.
    9. Repeat steps 3-8 to test the functionality of the 2-port switch.
    ---
    layout: post
    title: "How to use a 9V Li-ion Battery in an Arduino project"
    date: 2022-04-20 00:00:00
    ---

    ## Introduction

    This post details how to use a 9V Li-ion battery in an Arduino project.

    ## Prerequisites

    The following prerequisites are required to use a 9V Li-ion battery in an Arduino project:

    * Arduino IDE installed.
    * A 9V Li-ion battery.

    ## Hardware Connections

    The 9V Li-ion battery must be connected to the Arduino board through the Vin pin.

    ## Software Implementation

    ```cpp
    #include <Arduino.h>

    void setup()
    {
        pinMode(A5, OUTPUT);
    }

    void loop()
    {
        // Read the battery voltage
        int batteryVoltage = analogRead(A5);

        // Determine if the battery is LOW or HIGH
        if (batteryVoltage < 50)
        {
            digitalWrite(A5, LOW);
        }
        else
        {
            digitalWrite(A5, HIGH);
        }
    }
    ```
    ---
    layout: post
    title: "How to connect a USB port to a Raspberry Pi using a USB-C cable"
    date: 2022-04-13 00:00:00
    ---

    ## Introduction

    This post details how to connect a USB port to a Raspberry Pi using a USB-C cable.

    ## Prerequisites

    The following prerequisites are required to connect a USB port to a Raspberry Pi using a USB-C cable:

    * Raspberry Pi installed with a Linux operating system.
    * The Raspberry Pi is connected to a USB port.
    * A USB-C cable installed for connecting the USB port to the Raspberry Pi.

    ## Connection Details

    The following diagram details the connection details of the USB-C cable required for connecting a USB port to a Raspberry Pi:

    ![USB-C Cable Diagram](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.electronics-tutorials.ws%2Fimages%2Fusb-c%2Fusb-c-cable-3.gif&f=1&nofb=1)

    The USB-C cable has two connectors:

    * A USB Type-C connector.
    * A female USB connector.

    To connect a USB port to a Raspberry Pi, the USB Type-C connector must be connected to the Raspberry Pi.

    ## Connection Example

    To connect a USB port to a Raspberry Pi using a USB-C cable, refer to the following steps:

    1. Ensure that the Raspberry Pi is connected to a power supply.
    2. Ensure that the Raspberry Pi is connected to a USB port.
    3. Connect the USB-C cable to the USB port.
    4. Place the USB-C cable between the Type-C connector and the female USB connector.
    5. Connect the USB-C cable to the USB port.

    ## Testing the Connection

    To test the connection, refer to the following steps:

    1. Check that the Raspberry Pi is connected to a power supply.
    2. Check that the Raspberry Pi is connected to a USB port.
    3. Connect the USB-C cable to the USB port.
    4. Check that the USB-C cable is connected to the Type-C connector.
    5. Check that the USB-C cable is connected to the female USB connector.

    If all the above steps are followed properly, the USB-C cable will be connected to the USB port and will be connected to the Type-C connector.
    ---
    layout: post
    title: "How to Use the Arduino IDE to Program an ESP8266"
    date: 2022-03-15 00:00:00
    ---

    ## Introduction

    This post details how to use the Arduino IDE to program an ESP8266.

    ## Prerequisites

    The following prerequisites are required to use the Arduino IDE to program an ESP8266:

    * An ESP8266 installed.
    * The ESP8266 is connected to a USB port.
    * The ESP8266 software installed.
    * The Arduino IDE installed.

    ## Connection Details

    The following diagram details the connection details of the ESP8266.

    ![ESP8266 Diagram](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwiki.allaboutcircuits.com%2Fmedia%2Fuploads%2Farticle%2Fimage%2F25705%2Fesp8266_block_diagram.png&f=1&nofb=1)

    The ESP8266 consists of the following components:

    * ESP8266 WiFi chip.
    * ESP8266 MCU.
    * FTDI USB-UART adapter.
    * USB cable.

    To connect the ESP8266 to a USB port, the USB cable must be connected to the USB port
- code: "module muxdff(D0, D1, Sel, Clock, Q)\ninput D0, D1, Sel, Clock;\noutput Q;\n\
    reg Q;\nwire logic [7:0] sel_to_index = Sel;\nalways @(posedge Clock)\n    if\
    \ (!sel_to_index)\n        Q <= D0;\n    else\n        Q <= D1;\nendmodule\n###\
    \ Test Case:\nmuxdff\n### Result:\n10100001\n/project_2/c/README.md\n## C Code\n\
    \n### Base C Code\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int\
    \ argc, char **argv)\n{\n\tint a = 10;\n\tint b = 3;\n\tint c = a + b;\n\tprintf(\"\
    a + b = %d\\n\", c);\n\treturn 0;\n}\n```\n\n### Variation Instruction\nSwap the\
    \ `a` and `b` variables\n\n### Modified Code\n```c\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n\nint main(int argc, char **argv)\n{\n\tint a = 3;\n\tint b = 10;\n\
    \tint c = a + b;\n\tprintf(\"a + b = %d\\n\", c);\n\treturn 0;\n}\n```\n\n###\
    \ Test Case\n10100010\n/project_2/verilog/README.md\n## Verilog Code\n\nNote:\
    \ The testbench file must end with `_test.v` to be recognized as a testbench.\n\
    \n### Base Verilog Code\n```verilog\nmodule main(input logic sigA, input logic\
    \ sigB, output logic sigC);\n\tassign sigC = sigA + sigB;\nendmodule\n```\n\n\
    ### Variation Instruction\nSwap the `sigA` and `sigB` inputs of the module\n\n\
    ### Modified Code\n```verilog\nmodule main(input logic sigB, input logic sigA,\
    \ output logic sigC);\n\tassign sigC = sigA + sigB;\nendmodule\n```\n\n### Test\
    \ Case\n10100101\n/project_1/README.md\n# Project 1: Verilog Verification\n\n\
    This project contains the base Verilog code, the modified code, and the test case\
    \ for the Verilog code.\n\nFor more information on our project, go to: https://github.com/hci-4910/project_1/wiki\n\
    /project_2/README.md\n# Project 2: C Verification\n\nThis project contains the\
    \ base C code, the modified code, and the test case for the C code.\n\nFor more\
    \ information on our project, go to: https://github.com/hci-4910/project_2/wiki\n\
    /project_1/README.md\n# Project 1: Verilog Verification\n\nThis project contains\
    \ the base Verilog code, the modified code, and the test case for the Verilog\
    \ code.\n\nFor more information on our project, go to: https://github.com/hci-4910/project_1/wiki"
- code: |-
    module or(a, b, c);
    input a, b, c;
    output reg and;
    wire or1, and, xor;
    or1 <= a||b;
    and <= or1 && c;
    xor <= a!=b;
    and <= or
- code: "module muxdff(D0, D1, Sel, Clock, Q);\ninput D0, D1, Sel, Clock;\noutput\
    \ Q;\nreg Q;\nalways @(posedge Clock)\n    if (Sel == 1)\n        Q <= D1;\n \
    \   else if (Sel == 0)\n        Q <= D0;\n    else\n        Q <= zero;\nendmodule\n\
    ### Results:\n| 0x0 | 01 | 01 | 10 | 10 | 00 | 00 | 01 |\n|-----|----|----|----|----|----|----|----|\n\
    | 16  | 4  | 4  | 8  | 8  | 0  | 0  | 4  |\n\nEven though the code is the same,\
    \ the results are different. This is because the if/else statement is synthesizable,\
    \ while the if statement is not.\n, 0);\n\telse\n\t\tA <= 1;\n\tif (A == 1)\n\t\
    \tB <= 0;\n\telse\n\t\tB <= 1;\n\tif (sel == 3)\n\t\tC <= 1;\n\telse\n\t\tC <=\
    \ 0;\n\tif (sel == 3)\n\t\tD <= 1;\n\telse\n\t\tD <= 0;\nendmodule\n\nmodule srl(D0,\
    \ D1, D2, D3, Q, sel);\ninput D0, D1, D2, D3, sel;\noutput Q;\nalways @(posedge\
    \ sel)\n\tif (sel == 2)\n\t\tQ <= D1;\n\telse if (sel == 1)\n\t\tQ <= D2;\n\t\
    else if (sel == 0)\n\t\tQ <= D3;\n\telse\n\t\tQ <= zero;\nendmodule\n\nmodule\
    \ sra(A, B, sel, Q);\ninput A, B;\noutput Q;\nalways @(posedge sel)\n\tif (sel\
    \ == 1)\n\t\tQ <= A;\n\telse if (sel == 2)\n\t\tQ <= B;\n\telse\n\t\tQ <= zero;\n\
    endmodule\n\nmodule sll(A, B, sel, Q);\ninput A, B;\noutput Q;\nalways @(posedge\
    \ sel)\n\tif (sel == 1)\n\t\tQ <= A;\n\telse if (sel == 2)\n\t\tQ <= B;\n\telse\n\
    \t\tQ <= zero;\nendmodule\n```\n\n## Question 5\n### Q5:\n\n```\nmodule mstest(d0,\
    \ d1, d2, d3, d4, s, r, o, sel, clk, rst);\ninput d0, d1, d2, d3, d4, s, r, o,\
    \ sel;\noutput clk, rst;\n\nreg d0, d1, d2, d3, d4;\nreg s, r, o;\nreg clk, rst;\n\
    \nalways @( posedge clk )\n\trst <= r;\nalways @( posedge clk or posedge rst )\n\
    \td0 <= d1;\n\td1 <= d2;\n\td2 <= d3;\n\td3 <= d4;\n\nalways @( posedge clk )\n\
    \to <= s;\n\nalways @( posedge clk or posedge rst )\n\ts <= s1;\n\tr <= r1;\n\
    always @( posedge clk )\n\td4 <= d0 ^ d1 ^ d2 ^ d3;\nalways @( posedge clk )\n\
    \ts1 <= d0 ^ d1 ^ d2 ^ d3;\nalways @( posedge clk )\n\tr1 <= d0 & d1 & d2 & d3;\n\
    \n\tendmodule\n```\n\n## Question 6\n### Q6:\n\n```\nmodule test_addsub(a1, a2,\
    \ b1, b2, d, r, sel, clk);\ninput a1, a2, b1, b2, r, d;\noutput s, sel, clk;\n\
    reg a1, a2, b1, b2, d, r, sel, clk;\n\nmodule add(a1, a2, r, s);\ninput a1, a2;\n\
    output r, s;\ns <= a1 ^ a2;\nr <= a1 & a2;\nendmodule\n\nmodule sub(a1, a2, r,\
    \ s);\ninput a1, a2;\noutput r, s;\ns <= a1 & ~a2;\nr <= ~a1 & a2;\nendmodule\n\
    \nmodule add_sub(a1, a2, b1, b2, d, r, s);\ninput a1, a2, b1, b2, r, d;\noutput\
    \ s, clk;\n\nalways @( posedge clk )\n\ts <= \td?\tsub(a1, a2, r, s) : add(a1,\
    \ a2, r, s);\n\nendmodule\n\nmodule srl(A, B, Q);\ninput A, B;\noutput Q;\n\n\
    always @(*)\n\tQ <= A;\nendmodule\n\nmodule sll(A, B, Q);\ninput A, B;\noutput\
    \ Q;\n\nalways @(*)\n\tQ <= B;\nendmodule\n\nmodule mux2(A, S, Q);\ninput A, S;\n\
    output Q;\n\nalways @(*)\n\tQ <= A;\nendmodule\n\nmodule mux(A, B, C, D, sel,\
    \ Q);\ninput A, B, C, D, sel;\noutput Q;\n\nalways @(*)\n\tcase (sel)\n\t\t0 :\
    \ Q <= A;\n\t\t1 : Q <= B;\n\t\t2 : Q <= C;\n\t\t3 : Q <= D;\n\tendcase\nendmodule\n\
    module mux_sl(A, B, sel, Q);\ninput A, B;\ninput sel;\noutput Q;\n\nalways @(*)\n\
    \tcase (sel)\n\t\t0 : Q <= A;\n\t\t1 : Q <= B;\n\tendcase\nendmodule\nmodule mux(A,\
    \ B, C, sel, Q);\ninput A, B, C;\ninput sel;\noutput Q;\n\nalways @(*)\n\tcase\
    \ (sel)\n\t\t0 : Q <= A;\n\t\t1 : Q <= B;\n\t\t2 : Q <= C;\n\tendcase\nendmodule\n\
    \nmodule mux_andor(A"
- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        Q <= mux(D0, D1, {D0[0][3:0], D1[0][3:0], Sel});
    endmodule

    ### Function Code:

    module mux(
- code: |-
    ```

    ```verilog
    ### Base Verilog Code:
- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
- code: |-
    ---
    ```
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    ```

    ---
    ```
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q[0..3];
    always @(posedge Clock)
        if (!Sel)
            Q[0] <= D0;
        else
            Q[1] <= D1;
    endmodule
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```


    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;


    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```
    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```

    ---
    ```
    package muxdff(D0, D1, Sel, Clock, Q);
    import "std_logic_1164.v";

    library ieee;

    use ieee.std_logic_1164.all;

    package body muxdff is

    end package;
    ```



    import sys
    import os
    import random
    import string
    from shutil import copyfile

    files_folder = sys.argv[1]
    num_files = int(sys.argv[2])

    def get_words():
        file = open("Dictionary.txt", "r")
        lines = file.readlines()
        words = []
        for line in lines:
            words.append(line.strip())
        return words

    def get_verilog_file(words, lines, start):
        if start > len(lines):
            return "Done"
        elif len(words) > 0:
            if start == len(lines):
                return "Done"
            else:
                line = lines[start]
                start += 1
                if "==" not in line:
                    return get_verilog_file(words, lines, start)
                else:
                    rand_word = words.pop(0)
                    copyfile("Module.v", "verilog_files/" + rand_word + ".v")
                    new_file = open(rand_word + ".v", "r+")
                    new_file.write("module " + rand_word + "(")
                    for word in line.split("=="):
                        new_file.write(word + ", ")
                    new_file.seek(-2, os.SEEK_END)
                    new_file.truncate()
                    new_file.write(");\n")
                    for word in line.split("=="):
                        new_file.write("input " + word + ";\n")
                    new_file.write("output Q;\n")
                    new_file.write("reg Q;\n")
                    new_file.write("always @(*)\n")
                    new_file.write("begin\n")
                    new_file.write("Q <= " + line[0:len(line)-2] + ";\n")
                    new_file.write("end\n")
                    new_file.write("endmodule\n")
                    new_file.close()
                    return get_verilog_file(words, lines, start)
        else:
            return get_verilog_file(words, lines, start)


    words = get_words()
    lines = []
    for file in os.listdir(files_folder):
        if file.endswith(".txt") and file[0].isdigit():
            file = open(files_folder + "/" + file, "r")
            lines += file.readlines()
    start = 0
    while num_files > 0:
        words = get_words()
        verilog_file = get_verilog_file(words, lines, start)
        if verilog_file == "Done":
            break
        num_files -= 1
    # 1)

    ### The difference between an array and a vector is that the size of the array cannot be changed and is defined at compile-time whereas the size of a vector can be changed and is defined at runtime.

    ### The difference between a std_logic_vector and a std_logic_array is that the size of the std_logic_vector is fixed at compile time and is defined at the time of initialization whereas the size of a std_logic_array is defined at runtime.

    ---

    # 2)

    ### I would choose the first option assuming each test would be independent of each other because the first option is the only one that makes each test isolated from each other.
    ### I would choose the second option assuming the tests were dependent on one another because the second option would ensure all tests were independent of each other.
    ### I would choose the third option assuming the tests were dependent on one another because the third option would ensure all tests were independent of each other.
    ### I would choose the fourth option assuming the tests were dependent on one another because the fourth option would ensure all tests were independent of each other.

    ---

    # 3)

    ### If we want to test the muxdff component, we would need a valid value, a invalid value, an invalid input, and a boundary value. An example of a valid value would be 0, 1, 2, 3. An example of an invalid value would be -1, 4, 5. An example of an invalid input would be 0, 1, 2, 3, 4, 5. And an example of a boundary value would be 0, 1.

    ---

    # 4)

    ### I would create a function that would be called in the main module that would take the input arguments and pass them to the testbench file. In order to make the testbench file as simple as possible, I would also create a while loop with a while counter that would be incremented and decremented inside the main module.

    ---

    # 5)

    ### The problem of a random number generator is that it cannot
- code: |-
    ### Verilog Code:
    module muxdff(D0, D
- code: |-
    module regtobin(Clock, Q, data);
    input Clock;
    input [7:0] Q;
    output [7:0] data;
    reg [7:0] data;
    always @(posedge Clock)
        for (int i = 0; i < 9; i++) {
            data[i] <= 0;
        }
        data[4] <= Q[7];
        data[8] <= Q[7];
        data[0] <= 0;
        data[1:2] <= Q[4:3];
        data[3] <= Q[3];
        data[5:6] <= Q[0:1];
        data[7:8] <= Q[0:0];
    endmodule


    ```
    #include <stdio.h>
    #include <math.h>
    #include <stdbool.h>
    #include <stdlib.h>
    #include <time.h>

    #define true 1
    #define false 0

    int main(int argc, char *argv[]) {
      int n = 6;
      int num;
      int p, q, r;

      srand((unsigned) time(NULL));

      num = (rand() % 2 + 1);
      bool isPrime = true;
      int counter = 1;
      while (isPrime) {
        isPrime = true;
        p = (rand() % n + 1);
        q = (rand() % n + 1);
        r = (rand() % n + 1);
        if (p == 1 || q == 1 || r == 1 || p == 0 || q == 0 || r == 0) {
          counter = 1;
          isPrime == false;
        }
        else {
          if (r >= p-1 && r <= q-1) {
            counter = 2;
            isPrime = false;
          }
          else if (p >= r-1 && p <= q-1) {
            counter = 3;
            isPrime = false;
          }
          else if (q >= r-1 && q <= p-1) {
            counter = 4;
            isPrime = false;
          }
        }
        if (isPrime || counter == 4) {
          if (rand() % 2) {
            printf("%d x %d x %d = %d", p, q, r, (p*q*r));
          }
          else {
            printf("%d x %d x %d = %d", p, r, q, (p*r*q));
          }
          isPrime = false;
        }
      }
      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>

    struct node {
      int data;
      struct node* next;
    };

    // Function to create a new node
    struct node* newNode(int data) {
      struct node* new = (struct node*) malloc(sizeof(struct node));
      new->data = data;
      new->next = NULL;
      return new;
    }

    // Function to add a node at the end of the linked list
    void addToTail(struct node* cur, int data) {
      struct node* new_node = newNode(data);
      while (cur->next!= NULL) {
        cur = cur->next;
      }
      cur->next = new_node;
    }

    // Function to insert a node after a given node
    void insertAfter(struct node* prev_node, int data) {
      if (prev_node == NULL) {
        printf("Prev_node cannot be NULL");
        return;
      }

      struct node* new_node = newNode(data);
      new_node->next = prev_node->next;
      prev_node->next = new_node;
    }

    int main() {
      // Create a linked list
      struct node* head = newNode(5);
      addToTail(head, 10);
      insertAfter(head->next, 15);

      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>

    // Function to create a new node
    struct node* newNode(int data) {
      struct node* new = (struct node*) malloc(sizeof(struct node));
      new->data = data;
      new->next = NULL;
      return new;
    }

    // Function to add a node at the end of the linked list
    void addToTail(struct node* cur, int data) {
      struct node* new_node = newNode(data);
      while (cur->next!= NULL) {
        cur = cur->next;
      }
      cur->next = new_node;
    }

    void printList(struct node* cur) {
      while (cur!= NULL) {
        printf("%d ", cur->data);
        cur = cur->next;
      }
    }

    int main() {
      // Create a linked list
      struct node* head = newNode(1);
      addToTail(head, 2);
      addToTail(head, 3);
      addToTail(head, 4);

      printList(head);

      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stdbool.h>


    #define MAX_SIZE 21

    int hash(char* key) {
      if (key >= "a" && key <= "z") {
        return key - 'a' + 1;
      }
      else if (key >= "A" && key <= "Z") {
        return key - 'A' + 1;
      }
      else if (key == " ") {
        return 0;
      }
      return -1;
    }

    typedef struct node {
      char data[MAX_SIZE];
      struct node* next;
    } node;

    bool search(node* hash_table[MAX_SIZE], char* key) {
      int hash_val = hash(key);
      node* ptr = hash_table[hash_val];
      while (ptr!= NULL) {
        if (strcmp(ptr->data, key) == 0) {
          return true;
        }
        ptr = ptr->next;
      }
      return false;
    }

    void insert(node* hash_table[MAX_SIZE], char* key) {
      int hash_val = hash(key);
      node* new_node = (node*) malloc(sizeof(node));
      strcpy(new_node->data, key);
      node* ptr = hash_table[hash_val];
      new_node->next = ptr->next;
      ptr->next = new_node;
      hash_table[hash_val] = ptr;
    }

    int main() {
      node* hash_table[MAX_SIZE];
      for (int i = 0; i < 21; i++) {
        hash_table[i] = (node*) malloc(sizeof(node));
        hash_table[i]->next = NULL;
      }
      insert(hash_table, "test");
      insert(hash_table, "Test");
      insert(hash_table, "TesT");
      printf("%d\n", search(hash_table, "test"));
      printf("%d\n", search(hash_table, "Test"));
      printf("%d\n", search(hash_table, "TesT"));
      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>

    struct node {
      int data;
      struct node* next;
    };

    // Function to insert a node at the beginning of the linked list
    void insertAtHead(struct node** head, int data) {
      struct node* new_node = (struct node*) malloc(sizeof(struct node));
      new_node->data = data;
      new_node->next = *head;
      *head = new_node;
    }

    // Function to insert a node at the end of the linked list
    void addToTail(struct node* cur, int data) {
      struct node* new_node = (struct node*) malloc(sizeof(struct node));
      new_node->data = data;
      new_node->next = NULL;
      while (cur->next!= NULL) {
        cur = cur->next;
      }
      cur->next = new
- code: |-
    module full_adder(Cin,A,B,S,Cout);
    input Cin;
    input A;
    input B;
    output S;
    output Cout;
    reg S;
    reg Cout;
    always @(A or B or Cin)
- code: "module counter (\ninput clock,\noutput reg [3:0] count0,\noutput reg [3:0]\
    \ count1,\noutput reg [3:0] count2,\noutput reg [3:0] count3\n);\nalways @(posedge\
    \ clock)\nbegin\nif (count0 == 4'b1111)\ncount0 <= 0;\nelse\ncount0 <= count0\
    \ + 1;\nif (count1 == 4'b1111)\ncount1 <= 0;\nelse\ncount1 <= count1 + 1;\nif\
    \ (count2 == 4'b1111)\ncount2 <= 0;\nelse\ncount2 <= count2 + 1;\nif (count3 ==\
    \ 4'b1111)\ncount3 <= 0;\nelse\ncount3 <= count3 + 1;\nend\nend\nendmodule\n\n\
    The following Verilog code snippet uses shift-left semantics to implement the\
    \ add-with-carry operation. This operation is also known as C-Scan.\n\nmodule\
    \ carry_add_32(cin, a, b, cout, s);\ninput [31:0] cin, a, b;\noutput [31:0] s,\
    \ cout;\nreg [31:0] x, y, z;\nwire [31:0] c;\nalways @(*)\nbegin\nx = a + cin;\n\
    y = b + c;\nz = x + y;\ns = z[31:16];\ncout = z[15];\nendmodule\n\nThe following\
    \ Verilog code snippet uses shift-left semantics to implement the add-with-carry\
    \ operation. This operation is also known as C-Scan.\n\nmodule carry_add_32(cin,\
    \ a, b, cout, s);\ninput [31:0] cin, a, b;\noutput [31:0] s, cout;\nreg [31:0]\
    \ x, y, z;\nwire [31:0] c;\nalways @(*)\nbegin\nx = a + cin;\ny = b + c;\nz =\
    \ x + y;\ns = z[31:16];\ncout = z[15];\nendmodule\n`\n\nThe following Verilog\
    \ code snippet uses shift-left semantics to implement the add-with-carry operation.\
    \ This operation is also known as C-Scan.\n\nmodule carry_add_32(cin, a, b, cout,\
    \ s);\ninput [31:0] cin, a, b;\noutput [31:0] s, cout;\nreg [31:0] x, y, z;\n\
    wire [31:0] c;\nalways @(*)\nbegin\nx = a + cin;\ny = b + c;\nz = x + y;\ns =\
    \ z[31:16];\ncout = z[15];\nendmodule\n\n### Description\n\nThis page is a summary\
    \ of the variation instruction for Verilog. The basic syntax is as follows:\n\n\
    `instruction(arg1, arg2,...)`\n\nThe instruction can be from the following variations:\n\
    \n\u2022 Arithmetic\n\u2022 Bit-wise\n\u2022 Logical\n\u2022 Comparison\n\u2022\
    \ Timing\n\u2022 Scheduling\n\u2022 Data Flow\n\u2022 Random\n\u2022 Memory\n\n\
    ### Arithmetic Variations\n\nThe following Verilog code snippet adds two operands\
    \ and gives the output as a 32-bit integer. This addition does not overflow.\n\
    \nmodule add\n(\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\n\
    always @(*)\ns = a + b;\n\nendmodule\n\nThe result is 0x00000000.\n\nThe following\
    \ Verilog code snippet adds two operands and gives the output as a 32-bit integer.\
    \ This addition does not overflow.\n\nmodule add\n(\ninput [31: 0] a,\ninput [31:\
    \ 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns = a + b;\n\nendmodule\n\nThe result\
    \ is 0x00000000.\n\nThe following Verilog code snippet adds two operands and gives\
    \ the output as a 32-bit integer. This addition does not overflow.\n\nmodule add\n\
    (\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns\
    \ = a + b;\n\nendmodule\n\nThe result is 0x00000000.\n\nThe following Verilog\
    \ code snippet adds two operands and gives the output as a 32-bit integer. This\
    \ addition does not overflow.\n\nmodule add\n(\ninput [31: 0] a,\ninput [31: 0]\
    \ b,\noutput [31: 0] s\n);\n\nalways @(*)\ns = a + b;\n\nendmodule\n\nThe result\
    \ is 0x00000000.\n\nThe following Verilog code snippet adds two operands and gives\
    \ the output as a 32-bit integer. This addition does not overflow.\n\nmodule add\n\
    (\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns\
    \ = a + b;\n\nendmodule\n\nThe result is 0x00000000.\n\nThe following Verilog\
    \ code snippet adds two operands and gives the output as a 32-bit integer. This\
    \ addition does not overflow.\n\nmodule add\n(\ninput [31: 0] a,\ninput [31: 0]\
    \ b,\noutput [31: 0] s\n);\n\nalways @(*)\ns = a + b;\n\nendmodule\n\nThe result\
    \ is 0x00000000.\n\nThe following Verilog code snippet adds two operands and gives\
    \ the output as a 32-bit integer. This addition does not overflow.\n\nmodule add\n\
    (\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns\
    \ = a + b;\n\nendmodule\n\nThe result is 0x00000000.\n\nThe following Verilog\
    \ code snippet adds two operands and gives the output as a 32-bit integer. This\
    \ addition does not overflow.\n\nmodule add\n(\ninput [31: 0] a,\ninput [31: 0]\
    \ b,\noutput [31: 0] s\n);\n\nalways @(*)\ns = a + b;\n\nendmodule\n\nThe result\
    \ is 0x00000000.\n\nThe following Verilog code snippet adds two operands and gives\
    \ the output as a 32-bit integer. This addition does not overflow.\n\nmodule add\n\
    (\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns\
    \ = a + b;\n\nendmodule\n\nThe result is 0x00000000.\n\nThe following Verilog\
    \ code snippet adds two operands and gives the output as a 32-bit integer. This\
    \ addition does not overflow.\n\nmodule add\n(\ninput [31: 0] a,\ninput [31: 0]\
    \ b,\noutput [31: 0] s\n);\n\nalways @(*)\ns = a + b;\n\nendmodule\n\nThe result\
    \ is 0x00000000.\n\nThe following Verilog code snippet adds two operands and gives\
    \ the output as a 32-bit integer. This addition does not overflow.\n\nmodule add\n\
    (\ninput [31: 0] a,\ninput [31: 0] b,\noutput [31: 0] s\n);\n\nalways @(*)\ns\
    \ = a + b;\n\nendmodule\n\nThe result is"
- code: |-
    reg_array[2] = reg_array[2] | reg_array2[0];

    ### Expected Output:
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @*
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule

    # 20.4.2022

    ## 06.03.2022

    ### Procedural Block with a Statement
    Procedural blocks can contain statements, and statements are executed sequentially. At program start, all statements are executed, in order, from top to bottom.

    Procedural blocks can contain statements, and statements are executed sequentially. At program start, all statements are executed, in order, from top to bottom.
    ### Example:
    module proc_block;
    initial
    begin
    $display("Initial block"); end endmodule A complete example: module proc_block; initial begin$display("Initial block");
    begin
    for (integer i = 0; i < 10; i = i + 1)
    $display("Block with statement"); end end endmodule ### Example 2: module proc_block; initial begin$display("Initial block");
    begin
    for (integer i = 0; i < 10; i = i + 1) begin
    $display("Block with statement"); end end end module ### Example 3: module proc_block; initial begin$display("Initial block");
    begin
    for (integer i = 0; i < 10; i = i + 1) begin
    $display("Block with statement"); end end end module ### Example 4: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    for (i = 0; i < 10; i = i + 1)
    begin
    $display("Block with statement"); end end end module ### Example 5: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    for (i = 0; i < 10; i = i + 1)
    $display("Block with statement"); end end module ### Example 6: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1)
    $display("Block with statement"); end end module ### Example 7: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    $display("Block with statement"); end end end module ### Example 8: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    integer i;
    $display("Block with statement"); end end end module ### Example 9: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    integer i;
    $display("Block with statement"); end end end module ### Example 10: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    integer i;
    $display("Block with statement"); integer i; integer i; end end end module ### Example 11: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    integer i;
    $display("Block with statement"); integer i; integer i; end end end module ### Example 12: module proc_block; initial begin$display("Initial block");
    begin
    integer i;
    integer i;
    for (i = 0; i < 10; i = i + 1) begin
    integer i;
    integer i;
    $display("Block with statement"); integer i; integer i; end end end module ## 21.01.2022 ### Procedural Block with a Statement Procedural blocks can contain statements, and statements are executed sequentially. At program start, all statements are executed, in order, from top to bottom. ### Example: module proc_block; initial begin$display("Initial block");
    end
    endmodule
    A complete example:
    module proc_block;
    initial begin
    $display("Initial block"); begin for (integer i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 2:

    module proc_block;
    initial begin
    $display("Initial block"); begin for (integer i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 3:

    module proc_block;
    initial begin
    $display("Initial block"); begin for (integer i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 4:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 5:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 6:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 7:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    end
    end
    endmodule

    ### Example 8:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    integer i;
    end
    end
    end
    endmodule

    ### Example 9:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    integer i;
    end
    end
    end
    endmodule

    ### Example 10:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    integer i;
    end
    end
    end
    endmodule

    ### Example 11:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    integer i;
    end
    end
    end
    endmodule

    ### Example 12:

    module proc_block;
    initial begin
    $display("Initial block"); begin integer i; integer i; for (i = 0; i < 10; i = i + 1)$display("Block with statement");
    integer i;
    end
    end
    end
    endmodule

    ## 21.02.2022

    ### Base Verilog Code:
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule
    ### Variation Instruction:
    Use the $display statement inside the initial block, to print to the command line. ### Modified Code: module dff_with_reset(data, clock, r, out); input clock, r, data; output out; reg out; initial begin$display("Initial block");
    end

    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule

    # 21.02.2022

    ## 11.01.2022

    ### Verilog Programming: Flops

    If we want to have a simple DFF with the initial value
- code: "module dff_with_reset(data, clock, r, out);\ninput clock, r, data;\noutput\
    \ out;\nreg out;\nalways @(posedge clock or posedge r)\nbegin\nif (r) out <= 0;\n\
    else out <= data;\nend\nendmodule\n\n## \n\nSoftware Engineer, Founder | Researcher\n\
    \nKnow more about me, my research interests and my work!"
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule

    #### 1 comment:

    1. Hello I think there is an error in the code. The line that you used inside the @always block isn't correct. It should look like:

    `assign out = data[2:0];`
- code: "module dff_with_reset(data, clock, r, out);\ninput clock, r, data;\noutput\
    \ out;\nreg out;\nalways @(posedge clock or posedge r)\nbegin\nif (r)\nout = 1'b0;\n\
    else\nout = data;\nend\nendmodule\n#### Run Your Testbench\n\nBefore you run your\
    \ testbench, you must update the top-level file. This file must have the name\
    \ same as the main module name.\n\nFor this project, you must edit the top-level\
    \ test file named DFF_tb.\n\nTo update the top-level test file, you need to replace\
    \ the existing testbench code with the testbench code for the DFF module.\n\n\
    The code below shows the updated top-level test file for the DFF module.\n\nThe\
    \ updated top-level test file DFF_tb.\n\n### Run the Testbench\n\nTo simulate\
    \ the design, you can use any one of the following methods:\n\n\u2022 ModelSim\n\
    \u2022 VCS\n\u2022 ISE\n\n### ModelSim\n\nTo simulate the design using ModelSim,\
    \ you must install ModelSim and run ModelSim to simulate the design.\n\nTo install\
    \ ModelSim, refer to the ModelSim Installation Guide.\n\nTo run ModelSim, click\
    \ on the Run button on the Design Editor toolbar.\n\nThe Design Editor opens.\n\
    \nWhen you open ModelSim, it creates a workspace and sets it to the workspace\
    \ directory.\n\nTo open the workspace directory, click on File > Workspace. The\
    \ ModelSim workspace directory opens.\n\nTo open the Design Editor, click on File\
    \ > Open Project. The Project Navigator opens.\n\nTo open the testbench file,\
    \ click on the Testbench File under the workspace directory. The Project Explorer\
    \ opens.\n\nTo open the top-level testbench file, navigate to the Testbench Location\
    \ and select DFF_tb.\n\nTo run the testbench, click on the Run button on the Design\
    \ Editor toolbar. The Results window opens.\n\nYou can see the simulation results\
    \ on the right side of the window.\n\nYou can see the simulation results for the\
    \ reset signal and the data input.\n\nYou can see the simulation results for the\
    \ output of the DFF.\n\n### VCS\n\nTo simulate the design using VCS, you must\
    \ install VCS and run VCS to simulate the design.\n\nTo install VCS, refer to\
    \ the VCS Installation Guide.\n\nTo run VCS, click on the Run button on the Design\
    \ Editor toolbar.\n\nThe Design Editor opens.\n\nWhen you open VCS, it creates\
    \ a workspace.\n\nTo open the workspace directory, click on File > Workspace.\
    \ The VCS workspace directory opens.\n\nTo open the Design Editor, click on File\
    \ > Open Project. The Project Explorer opens.\n\nTo open the testbench file, click\
    \ on the Testbench File under the workspace directory. The Project Explorer opens.\n\
    \nTo open the top-level testbench file, navigate to the Testbench Location and\
    \ select DFF_tb.\n\nTo run the testbench, click on the Run button on the Design\
    \ Editor toolbar. The Results window opens.\n\nYou can see the simulation results\
    \ on the right side of the window.\n\nYou can see the simulation results for the\
    \ reset signal and the data input.\n\nYou can see the simulation results for the\
    \ output of the DFF.\n\n### ISE\n\nTo simulate the design using ISE, you must\
    \ install ISE and run ISE to simulate the design.\n\nTo install ISE, refer to\
    \ the ISE Installation Guide.\n\nTo run ISE, click on the Run button on the Design\
    \ Editor toolbar.\n\nThe Design Editor opens.\n\nWhen you open ISE, it creates\
    \ a workspace.\n\nTo open the workspace directory, click on File > Workspace.\
    \ The ISE workspace directory opens.\n\nTo open the Design Editor, click on File\
    \ > Open Project. The Project Explorer opens.\n\nTo open the testbench file, click\
    \ on the Testbench File under the workspace directory. The Project Explorer opens.\n\
    \nTo open the top-level testbench file, navigate to the Testbench Location and\
    \ select DFF_tb.\n\nTo run the testbench, click on the Run button on the Design\
    \ Editor toolbar. The Results window opens.\n\nYou can see the simulation results\
    \ on the right side of the window.\n\nYou can see the simulation results for the\
    \ reset signal and the data input.\n\nYou can see the simulation results for the\
    \ output of the DFF.\n\n## Lesson Summary\n\nIn the previous section, you learned\
    \ about various design elements.\n\nIn this lesson, you learned about the combinational\
    \ logic element.\n\nYou learned about the DFF module.\n\nYou learned about the\
    \ testbench file.\n\nYou learned about the main function of the testbench file."
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    out = 0;
    if (r)
    out = 0;
    else if (data < 5)
    out = 0;
    else if (data < 10)
    out = 1;
    else
    out = data;
    end
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule
    ### Result:
    #### Original Code:
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    end
    endmodule
    #### Transformed Code:
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r) begin:
    out = 0;
    end
    else begin:
    out = data;
    end
    end
    endmodule
    ### Correctness:
    #### Status:
    Pass

    #### Report:
    It should be a warning to check array membership in a part-select range
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    out = r? 0 : data;
    end
    endmodule

    ## 2002-01-10

    ### Base Verilog Code:
    module dff_with_reset(data
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
    ### Base Verilog Code:
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
    ### Variation Instruction:
    Add a nested if using inside with a 3D array slice selected by
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        if (c) begin
            xReg <= a & b & c;
            yReg <= (b | c) ^ a;
        end
    end
    endmodule
    ### End of File
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule

    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
        if (a) begin: PartList
            xReg <= a & b & c;
            yReg <= (b | c) ^ a;
        end
    end
    endmodule

    ### Regenerate Code:

    The above rearrangements are applied to all the modules with a nested if in the always block of the RTL.
- code: |-
    module EventCtrlPart(output xPart, yPart, input a, b, c);
    begin:
        for(i=0; i < 8; i=i+2)
        begin: for(j=0; j < 8; j=j+2)
        begin:
            if(y==1) begin:
                xPart = xPart | yPart;
                yPart = yPart | xPart;
            end
            if(y==0) begin:
                xPart = xPart | yPart;
                yPart = yPart | xPart;
                xPart = xPart | yPart;
                yPart = yPart | xPart;
            end
            if(y==2) begin:
                xPart = xPart | yPart;
                yPart = yPart | xPart;
                xPart = xPart | yPart;
                yPart = yPart |
- code: "module EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg, yReg;\n\
    assign xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n\
    \    xReg <= a & b & c;\n    yReg <= (b | c) ^ a;\nend\nendmodule\nI used the\
    \ script that will compile/run the base code and the variation code.\n\nThe script\
    \ will create the following files:\nbase.v\nbase_out.vcd\nvar.v\nvar_out.vcd\n\
    and compare the output signals with the following commands:\nvcd comapre -f base_out.vcd\
    \ -p xPart var_out.vcd\nvcd comapre -f base_out.vcd -p yPart var_out.vcd\nAnd\
    \ the expected output is:\nvcd comapre -f base_out.vcd -p yPart var_out.vcd\n\
    vcd comapre -f base_out.vcd -p xPart var_out.vcd\n\nThe expected output is:\n\n\
    The output is correct. Please see the attached screenshot.\n/README.md\n# Event_Control_and_Sequential_Logic_Lab\n\
    Labs on Event Control and Sequential Logic using VHDL\n\n### Event Control and\
    \ Sequential Logic - Lab\n**Note:** The Lab is done on the 2017 version of the\
    \ VHDL compiler. Also there are some minor bugs that needs to be fixed manually.\n\
    #### Lab 1 - Sequential Logic\n##### 1. Implementing a NAND gate using sequential\
    \ logic and the Nand gate verilog module.\n> * In the sequential logic design\
    \ the **Nand** gate is implemented using a 2-level **OR** gate.\n> * The gate\
    \ is implemented using **2-input AND gate** and **2-input OR gate**.\n> * The\
    \ gate has a clock input and 2-input data inputs.\n> * The clock input of the\
    \ sequential logic design changes the value of the output of the AND gate. \n\
    > * The AND gate has a data input from either of the 2-input gates (a single clock\
    \ edge can switch the data input) and the output of the OR gate as the data input.\n\
    > * Since the clock is the clock input of the sequential logic circuit, the output\
    \ of the OR gate is determined by the status of the clock and the output of the\
    \ data input of the AND gate.\n> * The clock input of the sequential logic design\
    \ is the clock input of the **Nand gate verilog module**\n##### 2. Implementing\
    \ a clocked flip-flop and a combinational flipflop using sequential logic design\
    \ using the *DFF* module.\n> * A **Clocked flip-flop** is implemented using sequential\
    \ logic and the **DFF** module.\n> * The clock input and data inputs of the DFF\
    \ module are the clock input and the data input of the sequential logic design.\n\
    > * The sequential logic circuit is tested using the **Nand gates** implemented\
    \ using the **Nand gate verilog module**\n##### 3. Implementing a **Counter**\
    \ using a flip-flop and the **DFF** module.\n> * The input of the counter is from\
    \ the data input of the **DFF** module.\n> * The output of the counter is the\
    \ count of the number of clock edges since the reset is triggered.\n> * The **DFF**\
    \ module is used in the sequential logic design to implement the flip-flop.\n\
    > * The sequential logic design is tested using the **Nand gates** implemented\
    \ using the **Nand gate verilog module**\n##### 4. Implementing a **Binary Adder**\
    \ using sequential logic and **Nand gates** implemented using the **Nand gate\
    \ verilog module**.\n> * In the sequential logic design the **Binary Adder** is\
    \ implemented using **3-input Nand gates**\n> * The clock input and the data inputs\
    \ of the Binary Adder are implemented using the sequential logic design.\n> *\
    \ The sequential logic design is tested using the **Nand gates** implemented using\
    \ the **Nand gate verilog module**.\n##### 5. Implementing a **Binary Subtractor**\
    \ using sequential logic and **Nand gates** implemented using the **Nand gate\
    \ verilog module**.\n> * In the sequential logic design the **Binary Subtractor**\
    \ is implemented using **3-input Nand gates**\n> * The clock input and the data\
    \ inputs of the Binary Subtractor are implemented using the sequential logic design.\n\
    > * The sequential logic design is tested using the **Nand gates** implemented\
    \ using the **Nand gate verilog module**.\n##### 6. Implementation of a **Register**\
    \ using sequential logic and the **DFF** module.\n> * To implement a **Register**\
    \ all that is needed is to implement the sequential logic design that implements\
    \ the **DFF** module.\n> * The sequential logic design is tested using **Nand\
    \ gates** implemented using the **Nand gate verilog module**.\n##### 7. Implementation\
    \ of an **Adder 8 bit** using **sequential logic** and the **DFF** module.\n>\
    \ * The sequential logic design is tested using **Nand gates** implemented using\
    \ the **Nand gate verilog module**.\n##### 8. Implementation of a **Subtractor\
    \ 8 bit** using **sequential logic** and the **DFF** module.\n> * The sequential\
    \ logic design is tested using **Nand gates** implemented using the **Nand gate\
    \ verilog module**.\n##### 9. Implementation of a **Multiplexer 3 bit** using\
    \ sequential logic and the **DFF** module.\n> * The sequential logic design is\
    \ tested using **Nand gates** implemented using the **Nand gate verilog module**.\n\
    ##### 10. Implementation of a **De-Multiplexer 3 bit** using sequential logic\
    \ and the **DFF** module.\n> * The sequential logic design is tested using **Nand\
    \ gates** implemented using the **Nand gate verilog module**.\n##### 11. Implementation\
    \ of a **Comparator 3 bit** using sequential logic and the **DFF** module.\n>\
    \ * The sequential logic design is tested using **Nand gates** implemented using\
    \ the **Nand gate verilog module**.\n> * The **Comparator 3 bit** is the same\
    \ as the **Subtractor 3 bit** but subtracts instead of subtracting.\n> * Since\
    \ the result of the comparator is 1 if the comparator is true then the output\
    \ is 0 else the output is 1. Therefore the comparator is implemented the same\
    \ way as a subtractor is implemented.\n##### 12. Implementation of a **Multiplier\
    \ 4 bit** using sequential logic and the **DFF** module.\n> * The sequential logic\
    \ design is tested using **Nand gates** implemented using the **Nand gate verilog\
    \ module**.\n##### 13. Implementation of a **Multiplexer 8 bit** using sequential\
    \ logic and the **DFF** module.\n> * The sequential logic design is tested using\
    \ **Nand gates** implemented using the **Nand gate verilog module**.\n##### 14.\
    \ Implementation of a **Counter with a reset 7 bit** using sequential logic and\
    \ the **DFF** module.\n> * The sequential logic design is tested using **Nand\
    \ gates** implemented using the **Nand gate verilog module**.\n##### 15. Implementation\
    \ of a **Arithmetic Logic Unit (5 bit)** using sequential logic and the **DFF**\
    \ module.\n> * The sequential logic design is tested using **Nand gates** implemented\
    \ using the **Nand gate verilog module**.\n##### 16. Implementation of a **Multiplexer\
    \ Encoder 4 bit** using sequential logic and the **DFF** module.\n> * The sequential\
    \ logic design is tested using **Nand gates** implemented using the **Nand gate\
    \ verilog module**.\n##### 17. Implementation of a **Multiplexer Encoder 12 bit**\
    \ using sequential logic and the **DFF** module.\n> * The sequential logic design\
    \ is tested using **Nand gates** implemented using the **Nand gate verilog module**.\n\
    ##### 18. Implementation of an **Adder 16 bit** using sequential logic and the\
    \ **DFF** module.\n> * The sequential logic design is tested using **Nand gates**\
    \ implemented using the **Nand gate verilog module**.\n##### 19. Implementation\
    \ of an **Adder 8 bit with carryin** using sequential logic and the **DFF** module.\n\
    > * The sequential logic design is tested using **Nand gates** implemented using\
    \ the **Nand gate verilog module**.\n##### 20. Implementation of a **Subtractor\
    \ 16 bit** using sequential logic and the **DFF** module.\n> * The sequential\
    \ logic design is tested using **Nand gates** implemented using the **Nand gate\
    \ verilog module**.\n##### 21. Implementation of a **Subtractor 8 bit** using\
    \ sequential logic and the **DFF** module.\n> * The sequential logic design is\
    \ tested using **Nand gates** implemented using the **Nand gate verilog module**.\n\
    ##### 22. Implementation of a **Subtractor 16 bit with borrow in** using sequential\
    \ logic and the **DFF** module.\n> * The sequential logic design is tested using\
    \ **"
- code: "module EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg, yReg;\n\
    assign xPart = xReg;\nassign yPart = yReg;\nalways @(*)\nbegin: PartList\n   \
    \ xReg <= a & b & c;\n    yReg <= (b | c) ^ a;\nend\nEventCtlPart #(.Range(2),.Slice(3))\
    \ \nendmodule\n### Testbench Code:\nmodule testbench;\nreg a, b, c;\nEventCtlPart\
    \ e(a, b, c);\ninitial $dumpfile(\"x.vcd\");\ninitial\n$dumpvars(0, e);\ninitial\
    \ #10;\na <= 1;\nb <= 1;\nc <= 0;\ninitial #10;\na <= 1;\nb <= 1;\nc <= 1;\ninitial\
    \ #10;\na <= 1;\nb <= 0;\nc <= 1;\ninitial #10;\na <= 0;\nb <= 1;\nc <= 1;\ninitial\
    \ #10;\na <= 0;\nb <= 0;\nc <= 1;\ninitial #10;\na <= 0;\nb <= 0;\nc <= 0;\ninitial\
    \ #10;\na <= 1;\nb <= 0;\nc <= 0;\ninitial #10;\na <= 1;\nb <= 1;\nc <= 0;\ninitial\
    \ #10;\na <= 0;\nb <= 1;\nc <= 0;\ninitial #10;\na <= 0;\nb <= 0;\nc <= 0;\n#10;\n\
    $finish;\nendmodule\n# Copyright (c) 2013-2014,  ()\n# Released under the 2-clause\
    \ BSD license (see the file LICENSE for details)\n\nall: test\n\ntest: run_test.py\
    \ test_data\n\tpython run_test.py\n\ntest_data: test_data.py\n\tpython test_data.py\n\
    \nclean:\n\trm -rf *.pyc __pycache__\n.. _section-1:\n\nGetting started\n===============\n\
    \nAfter installing VUnit, you can start writing your first test.\n\nIt is recommended\
    \ to write your own tests following the `PEP8 <http://www.python.org/dev/peps/pep-0008/>`_\
    \ rules. This will make your code easier to read and maintain.\n\nHere is a simple\
    \ example which creates two test modules, ``test_module1`` and ``test_module2``,\
    \ each containing one test:\n\n.. code-block:: python\n\n    from vunit import\
    \ VUnit\n    from vunit.utils import Test\n\n    VUnit.add_class_path(r\"C:\\\
    MySource\\my_unit\")\n    VUnit.add_class_path(r\"C:\\MySource\\my_unit2\")\n\n\
    \    @VUnit.main()\n    def main():\n        # Create instances of the modules\
    \ to be tested\n        module1 = Test(r\"my_unit.test_module1\")\n        module2\
    \ = Test(r\"my_unit2.test_module2\")\n   \n        # Create the testbench with\
    \ the modules to be tested\n        tb = Test.create(module1)\n        Test.create(module2)\n\
    \n        # Run the testbench\n        tb.run()\n\n    if __name__ == \"__main__\"\
    :\n        main()\n\nIf you save the above script as ``my_test.py``, you can now\
    \ run it with the command:\n\n.. code-block:: bash\n\n    $ python my_test.py\n\
    \nThis should create a new directory named ``__vunit_output__`` in the same directory\
    \ that ``my_test.py`` resides in, containing the following files:\n\n* ``my_test.out``:\
    \ The output of the simulation with VUnit\n* ``my_test.log``: The log file created\
    \ by VUnit\n* ``my_test.vcd``: The VCD file generated by the simulation\n\nThis\
    \ is what ``my_test.out`` contains:\n\n.. code-block:: text\n\n    +--------------------------------------------------------------+\n\
    \    | Summary                                                     |\n    +--------------------------------------------------------------+\n\
    \    | test_module1.test_case_1                                    |\n    |  \
    \                                                             |\n    | Finished\
    \ in 0.000 s                                          |\n    |               \
    \                                                |\n    | Failures: 0        \
    \                                          |\n    | Errors: 1                \
    \                                    |\n    |                                \
    \                               |\n    | Exit code: 0                        \
    \                         |\n    |                                           \
    \                    |\n    +--------------------------------------------------------------+\n\
    \nIt is possible to get more information about the failed test with the following\
    \ command:\n\n.. code-block:: bash\n\n    $ python -m vunit.run_test -u -v my_test.py\n\
    \nThis will create a new directory named ``__vunit_output__`` in the same directory\
    \ that ``my_test.py`` resides in, containing the following files:\n\n* ``my_test.out``:\
    \ The output of the simulation with VUnit\n* ``my_test.log``: The log file created\
    \ by VUnit\n* ``my_test.vcd``: The VCD file generated by the simulation\n* ``my_test.summary``:\
    \ The \"detailed\" report of the simulation\n* ``my_test.errors``: The list of\
    \ errors encountered during simulation\n\nThis is what ``my_test.errors`` contains:\n\
    \n.. code-block:: text\n\n    +--------------------------------------------------------+-----------------+\n\
    \    | Failure                                               |               \
    \  |\n    +--------------------------------------------------------+-----------------+\n\
    \    | my_unit.test_module1.test_case_1 > tb.module1.test    | My error message\
    \ |\n    +--------------------------------------------------------+-----------------+\n\
    \nYou now know how to write your first tests!\n\n.. toctree::\n   :glob:\n   :maxdepth:\
    \ 1\n\n   getting_started/examples/*\n.. _section-1:\n\nGetting started\n===============\n\
    \nAfter installing VUnit, you can start writing your first test.\n\nIt is recommended\
    \ to write your own tests following the `PEP8 <http://www.python.org/dev/peps/pep-0008/>`_\
    \ rules. This will make your code easier to read and maintain.\n\nHere is a simple\
    \ example which creates two test modules, ``test_module1`` and ``test_module2``,\
    \ each containing the same test:\n\n.. code-block:: python\n\n    from vunit import\
    \ VUnit\n    from vunit.utils import Test\n\n    VUnit.add_class_path(r\"C:\\\
    MySource\\my_unit\")\n    VUnit.add_class_path(r\"C:\\MySource\\my_unit2\")\n\n\
    \    @VUnit.main()\n    def main():\n        # Create instances of the modules\
    \ to be tested\n        module1 = Test(r\"my_unit.test_module1\")\n        module2\
    \ = Test(r\"my_unit2.test_module2\")\n   \n        # Create the testbench with\
    \ the modules to be tested\n        tb = Test.create(module1)\n        Test.create(module2)\n\
    \n        # Run the testbench\n        tb.run()\n\n    if __name__ == \"__main__\"\
    :\n        main()\n\n\nYou now know how to write your first tests!\n\n.. toctree::\n\
    \   :glob:\n   :maxdepth: 1\n\n   getting_started/examples/*\nimport pytest\n\
    from vunit import VUnit\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\n\
    def setup_vunit():\n    VUnit.add_class_path(\".\")\n    VUnit.add_class_path(\"\
    ../../../test_data/test_module\")\n    VUnit.add_class_path(\"../../../test_data/test_module/mod\"\
    )\n    VUnit.add_class_path(\"../../../test_data/test_module/mod2\")\n    VUnit.add_class_path(\"\
    ../../../test_data/sub_module\")\n    VUnit.add_class_path(\"../../../test_data/sub_module/mod3\"\
    )\n# Copyright (c) 2013-2014,  ()\n# Released under the 2-clause BSD license (see\
    \ the file LICENSE for details)\n\nimport os\nimport sys\nfrom shutil import rmtree\n\
    from zipfile import ZipFile\n\nfrom vunit.test_suite import Test\nfrom vunit.cli\
    \ import run_cli\n\ntry:\n    import pytest\nexcept ImportError:\n    def pytest_collect_file(parent,\
    \ path):\n        return None\n\ntry:\n    from StringIO import StringIO\nexcept:\n\
    \    from io import StringIO\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\n\
    \        \"--test_folder\",\n        action=\"store\",\n        help=\"Specify\
    \ the folder to be used as test folder\",\n    )\n    parser.addoption(\n    \
    \    \"--test_module\",\n        action=\"store\",\n        help=\"Specify the\
    \ name of the test module\",\n    )\n\n\ndef pytest_report_header(config):\n \
    \   if config.getoption(\"--test_module\"):\n        return \"Run test: {} {}\"\
    .format(config.getoption(\"--test_module\"),\n                               \
    \         config.getoption(\"--test_folder\"))\n\n\ndef pytest_cmdline_main(config):\n\
    \    run_cli()"
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        if(b)
            xReg <= a & b & c;
        else if(c)
            xReg <= a & c;
        else
            xReg <= a;
        if(b)
            yReg <= (b | c) ^ a;
        else if(c)
            yReg <= (c) ^ a;
        else
            yReg <= (b) ^ a;

    end
    endmodule
    ### Result:
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-38.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-39.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-40.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-41.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-42.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-43.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-44.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-45.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-46.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-47.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-48.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-49.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-50.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-51.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-52.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-53.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-54.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-55.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-56.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-57.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-58.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-44-59.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-00.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-01.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-02.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-03.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-04.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-05.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-06.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-07.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-08.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-09.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-10.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-11.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-12.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-13.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-14.png)
    ![Result](https://raw.githubusercontent.com/zho1347/EventControl/master/results/2020-04-23%2010-45-15.png)
- code: |-
    module StateMachine (output xPart, input state, a, b, c);
    reg [7:0] count;
    assign xPart = count[0];
    always @(state)
    begin: StateList
        if (count[0] < 100) begin: StateList2
            count <= count + 1;
        end end
    end
    endmodule
    ```

    Below is a table of all the variations tested with their test benches and scores.

    Variation | Score | Test Bench |
    -- | -- | --
    Original | 50 | https://github.com/Ryan-M-Harrison/event-control-verilog-test/tree/main/StateMachine/StateMachine4 |
    Improved | 75 | https://github.com/Ryan-M-Harrison/event-control-verilog-test/tree/main/StateMachine/StateMachine4 |

    ## 1 State Machine

    This fifth variation was the one that took the most
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = a?yReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
    ### Base Verilog
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b)
    begin: PartList
        xReg <= a & b & c;
        yReg <= (b | c) ^ a;
    end
    endmodule
    ### Variation Instruction:
    Add a nested if using inside with a 3D array slice selected by variable to test range inclusion.
    /results/symbiflow/tests/basic/rtl_files/event_ctl.py
    from collections import OrderedDict

    import sys

    sys.dont_write_bytecode = True

    from typing import List, Tuple, Dict
    from enum import auto, Enum
    import json

    import symbiflow_vlog_to_routing as vtr


    # This is just a helper method to convert the vtr.Event into a bit mask
    def get_bit_mask(event: vtr.Event) -> int:
        value = 0
        for bit in range(event.bit_count):
            value |= 2**bit
        return value


    class Vars(Enum):
        A = 0
        B = 1
        C = 2

        @classmethod
        def to_list(cls):
            return [e.value for e in cls]


    class State(Enum):
        INPUT = 0
        OUTPUT = 1

        @classmethod
        def to_list(cls):
            return [e.value for e in cls]


    def parse_args() -> Tuple[List[str], Dict[str, str]]:
        """
        Returns:
            Tuple: Tuple of list of filename strings and a dict of name : filename
        """
        args = sys.argv
        filename_string = args.pop()
        file_map = {}
        for arg in args:
            file_map[arg] = filename_string + arg
        return file_map.keys(), file_map


    def main():
        filenames, file_map = parse_args()
        # Generate the bit mask for each input/output
        bit_mask = []
        input_mask = 0
        output_mask = 0
        for var in Vars.to_list():
            # Input
            bit_mask.append(get_bit_mask(vtr.Event(var.name, State.INPUT.value)))
            input_mask |= bit_mask[-1]
            # Output
            bit_mask.append(get_bit_mask(vtr.Event(var.name, State.OUTPUT.value)))
            output_mask |= bit_mask[-1]

        # Get all the events that are either inputs or outputs
        inputs = []
        outputs = []
        for filename in filenames:
            with open(file_map[filename], 'r') as file:
                vlog_file = json.load(file, object_hook=vtr.VlogDecoder)
                for net in vlog_file['net_list']:
                    for event in net['event_list']:
                        if event['event_type'] == vtr.EventType.Input:
                            inputs.append(event)
                        elif event['event_type'] == vtr.EventType.Output:
                            outputs.append(event)

        # Check the events for correct bit count and get the bit mask
        for input_event in inputs:
            assert input_event['bit_count'] == 1
            input_event['bit_mask'] = bit_mask[input_event['var'] + len(Vars.to_list())]
        for output_event in outputs:
            assert output_event['bit_count'] == 1
            output_event['bit_mask'] = bit_mask[output_event['var']]

        # Add to the nets
        for input_event in inputs:
            input_net = None
            for net in vlog_file['net_list']:
                if net['var'] == input_event['var'] + len(Vars.to_list()):
                    input_net = net
                    break
            if input_net is None:
                input_net = {
                    'var': input_event['var'] + len(Vars.to_list()),
                    'event_list': [],
                    'input_list': [],
                    'output_list': [],
                }
                vlog_file['net_list'].append(input_net)
                input_net = vlog_file['net_list'][-1]
            input_net['event_list'].append(input_event)

        for output_event in outputs:
            output_net = None
            for net in vlog_file['net_list']:
                if net['var'] == output_event['var']:
                    output_net = net
                    break
            if output_net is None:
                output_net = {
                    'var': output_event['var'],
                    'event_list': [],
                    'input_list': [],
                    'output_list': [],
                }
                vlog_file['net_list'].append(output_net)
                output_net = vlog_file['net_list'][-1]
            output_net['event_list'].append
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    integer i; // Counts number of clock edges
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) begin
    i = i + 1;
    case(i)
    1: begin // First clock edge, clear output
    do=1'b0;
    end
    2: begin // Second clock edge, set output
    if (do)
    do=1'b0;
    else
    do=di;
    end
    3: begin // Third clock edge, set output
    if (do)
    do=1'b0;
    else
    do=di;
    end
    4: begin // Fourth clock edge, do nothing
    end
    default: // Any remaining clock edges, do nothing
    endcase
    end
    endmodule
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do;
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk)
    begin
    case (di)
    1'b0: do=1'b0;
    1'b1: do=1'b1;
    endcase
    endmodule
- code: |-
    module Mux4Way4(a,b,c,d,sel,sum); // Four-Way-4 Mux
    input [3:0] a,b,c,d,sel;
    output sum;
    // Assign inputs to outputs using procedural assignment
    case(sel)
    // Assign inputs to outputs
    0: sum=a;
    1: sum=b;
    2: sum=c;
    3: sum=d;
    default: sum=a;
    endcase
    endmodule
    ### Result:

    ### Base Verilog Code:
    module fulladder(S,C,A,B); // Four-Bit Full Adder
    output
- code: |-
    module latch(set, reset, d, q);
    input set, reset;
    input[3:0] d;
    output q;
    // Generate a set/reset latch (Q = 1, initially)
    always@(set or reset)
    case (set)
    8'h00000000 : (1,1) : q = 1;
    8'h00000001 : (1,0) : q = 1;
    8'h00000010 : (0,
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) begin
    case(clk)
    2'd0: do=di; // Use non-blocking <= for sequential logic
    2'd1: do=1'b1; // Use non-blocking <= for sequential logic
    endcase
    endmodule
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) begin
    dff dff1(do,di,clk);
    end
    endmodule

    # 5.6 Built-in Net Types

    The built-in net types are integer types, real types, string types, and time types. In order to use a built-in net type, it should be declared before a net. Built-in net types can be used for any nets (output, input, inout, inout_reg, and reg) in the same module.

    ## 5.6.1 Integer

    The integer type is commonly used by default, and it can be declared using any of the following keywords.

    Keyword Description
    integer Data is an integer.
    int Data is an integer.
    signed Data is an 8-bit signed integer.
    unsigned Data is an 8-bit unsigned integer.
    reg Data is a register. It must be used when the assigned value is changing.
    ## 5.6.2 Real

    The real type is commonly used by default, and it can be declared using
- code: |-
    module latch(Q,D,CLK);
    input D,CLK;
    output Q;
    always @(posedge CLK) Q=D;
    endmodule
    ### Base Verilog Code:
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
- code: module dff(do,di,
- code: |-
    // flip-flop.v
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule
    // main.v
    module main;
    reg clk;
    reg [7:0] do;
    reg [7:0] di;

    always #(5ns) clk=!clk;

    // Assign input 'di' to output 'do' on negative clock edge

    dff u0(.do(do),.di(di),.clk(clk));

    always @(posedge clk)
    reg [7:0] d_reg; // Register must be reg for sequential logic with register
    d_reg = di;
    do = d_reg;
    endmodule
    ### Synthesis Output:
    Here we see the synthesized design. The output is a flip-flop with register. It is designed for the RTL compiler to run a sequential logic with register.

    ## 4.6 Sequential Logic with Block

    Sequential Logic with Block is a design where the output changes for each clock cycle. The output is block.

    ### Base Verilog Code:
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule
    ### Variation Instruction:
    Add a new module to change the flip-flop to a sequential logic with block. Also add the 'posedge' keyword to the clk signal to update the output for each clock cycle.
    ###
- code: "module tst_CMOSsw1_mod();\n  reg in,con; wire out;\n  CMOSsw1 cmsw(out,in,con);\
    \ // Instantiate CMOS switch\n  initial begin in=1'b0; con=1'b1; end // Start\
    \ enabled\n  always #5 in =~in; // Toggle data\n  always #3 con=~con; // Toggle\
    \ control\n  initial $display(\"in = %b, con = %b, output = %b \",in,con,out);\n\
    \  initial #20 $stop; // Stop simulation\nendmodule\n### Results:\nin = 0  con\
    \ = 0  output = 0 \nin = 1  con = 1  output = 1 \nin = 0  con = 0  output = 0\
    \ \nin = 1  con = 1  output = 1 \nin = 0  con = 0  output = 0 \nin = 1  con =\
    \ 1  output = 1 \nin = 0  con = 0  output = 0 \nin = 1  con = 1  output = 1 \n\
    in = 0  con = 0  output = 0 \nin = 1  con = 1  output = 1 \nin = 0  con = 0"
- code: "1. add 2 functions:\n    - void get_var_range_in_slice_range(int index,ref\
    \ int out_in_lower,ref int out_in_upper)\n    - void get_var_range_in_slice_var(ref\
    \ int  in_var_lower, ref int in_var_upper)\n2. add 2 variables:\n    - static\
    \ int var_range_lower_in;\n    - static int var_range_upper_in;\n3. add 2 conditions:\n\
    \    - if(in_var_lower == var_range_lower_in && in_var_upper == var_range_upper_in){\n\
    \      out_in_lower=var_range_lower_in;out_in_upper=var_range_upper_in;\n    }\n\
    \    - if(var_range_lower_in == 1 && var_range_upper_in == 3){\n      out_in_lower=var_range_lower_in;out_in_upper=var_range_upper_in;\n\
    \    }\n4. add 2 initials:\n    - // Get var_range_lower_in and var_range_upper_in\
    \ for all slice ranges\n    - for(int i = 0; i < array_size(slice_var_ranges);\
    \ i++){\n      get_var_range_in_slice_range(i, slice_var_ranges[i][0], slice_var_ranges[i][1]);\n\
    \      if(slice_var_ranges[i][0] == 1 && slice_var_ranges[i][1] == 3){\n     \
    \   get_var_range_in_slice_var(in_var_ranges[i][0], in_var_ranges[i][1]);\n  \
    \    }\n    }\n5. add assert:\n    - assert(var_range_lower_in == 1 && var_range_upper_in\
    \ == 3, \"slice_in is not legal, error index: \" + var_range_lower_in + \"_\"\
    \ + var_range_upper_in);\n6. add $monitors\n    - $monitor($time, \"var_range_lower_in\
    \ = %d\", var_range_lower_in);\n    - $monitor($time, \"var_range_upper_in  =\
    \ %d\", var_range_upper_in);\n### Simulation result for all variations:\n####\
    \ Without variation:\n<img src = \"Without variation.png\" height=400 width=200>\n\
    \n#### With variation:\n<img src=\"With variation.png\" height=400 width=200>\n\
    #include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n\tcout << \"\
    Enter 2 numbers: \" << endl;\r\n\tint a,b;\r\n\tcin >> a >> b;\r\n\tcout << \"\
    You entered the following numbers: \" << a << \" \" << b << endl;\r\n\r\n\r\n\t\
    return 0;\r\n}\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\
    \n\tint counter =0;\r\n\tfor(int i =0; i <=100; i++){\r\n\t\tif(i % 2 == 0){\r\
    \n\t\t\tcout << i << \" \";\r\n\t\t\tcounter ++;\r\n\t\t}\r\n\t\tif(counter ==\
    \ 10){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n#include<iostream>\r\nusing namespace\
    \ std;\r\n\r\nint main(){\r\n\tint a,b;\r\n\tcout << \"Enter the first number:\
    \ \" << endl;\r\n\tcin >> a;\r\n\tcout << \"Enter the second number: \" <<endl;\r\
    \n\tcin >> b;\r\n\r\n\tint sum = a+b;\r\n\tcout << a << \" + \" << b << \" = \"\
    \ << sum << endl;\r\n\r\n\tint difference = a - b;\r\n\tcout << a << \" - \" <<\
    \ b << \" = \" << difference << endl;\r\n\r\n\tint product = a*b;\r\n\tcout <<\
    \ a << \" * \" << b << \" = \" << product << endl;\r\n\r\n\tint quotient = a/b;\r\
    \n\tcout << a << \" / \" << b << \" = \" << quotient << endl;\r\n\r\n\tint remainder\
    \ = a%b;\r\n\tcout << a << \" % \" << b << \" = \" << remainder << endl;\r\n\r\
    \n\tint a_pow_b = a*b;\r\n\tcout << a << \" to the power of \" << b << \" = \"\
    \ << a_pow_b << endl;\r\n}\r\n#include<iostream>\r\nusing namespace std;\r\n\r\
    \nint main(){\r\n\t// Initialize variables\r\n\tint counter = 1;\r\n\tint sum\
    \ = 0;\r\n\r\n\t// While loop\r\n\twhile(counter <= 10){\r\n\t\tint x;\r\n\t\t\
    cout << \"Enter a number: \" << endl;\r\n\t\tcin >> x;\r\n\r\n\t\tsum += x;\r\n\
    \r\n\t\tcout << \"The sum is : \" << sum << endl;\r\n\r\n\t\tcounter ++;\r\n\t\
    }\r\n}\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n\t\
    // Assign input to variable\r\n\tint x = 10;\r\n}\r\n#include<iostream>\r\nusing\
    \ namespace std;\r\n\r\nint main(){\r\n\tint a,b;\r\n\tcout << \"Enter the first\
    \ number: \" << endl;\r\n\tcin >> a;\r\n\tcout << \"Enter the second number: \"\
    \ <<endl;\r\n\tcin >> b;\r\n\r\n\tint sum = a+b;\r\n\tcout << a << \" + \" <<\
    \ b << \" = \" << sum << endl;\r\n\r\n\tint difference = a - b;\r\n\tcout << a\
    \ << \" - \" << b << \" = \" << difference << endl;\r\n\r\n\tint product = a*b;\r\
    \n\tcout << a << \" * \" << b << \" = \" << product << endl;\r\n\r\n\tint quotient\
    \ = a/b;\r\n\tcout << a << \" / \" << b << \" = \" << quotient << endl;\r\n\r\n\
    \tint remainder = a%b;\r\n\tcout << a << \" % \" << b << \" = \" << remainder\
    \ << endl;\r\n\r\n\tint a_pow_b = a*b;\r\n\tcout << a << \" to the power of \"\
    \ << b << \" = \" << a_pow_b << endl;\r\n}\r\n#include<iostream>\r\nusing namespace\
    \ std;\r\n\r\nint main(){\r\n\t// Initialize variables\r\n\tint counter = 1;\r\
    \n\tint sum = 0;\r\n\r\n\t// While loop\r\n\twhile(counter <= 10){\r\n\t\tint\
    \ x;\r\n\t\tcout << \"Enter a number: \" << endl;\r\n\t\tcin >> x;\r\n\r\n\t\t\
    sum += x;\r\n\r\n\t\tcout << \"The sum is : \" << sum << endl;\r\n\r\n\t\tcounter\
    \ ++;\r\n\t}\r\n}\r\n#include<stdio.h>\r\n\r\nint main(){\r\n\tprintf(\"Welcome\
    \ To The Best C World!\\n\");\r\n}\r\nimport math\n\ndef get_input_from_user(default_value,\
    \ message, type = str):\n    try:\n        input_value = input(message)\n    except:\n\
    \        input_value=default_value\n    if input_value == \"\":\n        return\
    \ default_value\n\n    if type == int:\n        return int(input_value)\n    elif\
    \ type == float:\n        return float(input_value)\n    else:\n        return\
    \ input_value\n\ndef get_num_of_digits(n):\n    if n == 0:\n        return 1\n\
    \    return math.ceil(math.log10(abs(n)))\n\ndef get_num_of_digits_for_num_str(input_str):\n\
    \    if input_str == \"\":\n        return 0\n    return len(input_str)\nimport\
    \ random\nimport matplotlib.pyplot as plt\ndef main():\n    while True:\n    \
    \    num = input(\"Enter a number between 1 and 100: \")\n        if num == \"\
    exit\":\n            break\n        num = int(num)\n        if num < 1 or num\
    \ > 100:\n            print(\"Please enter a number between 1 and 100.\")\n  \
    \          continue\n        random_num = random.randint(1, 100)\n        print(\"\
    Your number, \" + str(num) + \", is\", end=\"\")\n        if num > random_num:\n\
    \            print(\" bigger than the random number\")\n        elif num < random_num:\n\
    \            print(\" smaller than the random number\")\n        else:\n     \
    \       print(\" the same as the random number\")\n\ndef main2():\n    x = 0\n\
    \    y = 1\n    count = 1\n    for i in range(100):\n        x = x + 1\n     \
    \   y = y + 0.5\n        count += 1\n        plt.plot(x,y,color='blue')\n    print(count)\n\
    \    plt.show()\n\ndef main3():\n    x = 0\n    y = 1\n    count = 0\n    while\
    \ True:\n        key = input(\"key: \")\n        if key == \"1\":\n          \
    \  print(x)\n        elif key == \"2\":\n            print(y)\n        elif key\
    \ == \"exit\":\n            break\n        else:\n            x = x + 1\n    \
    \        y = y + 0.5\n            count"
- code: |-
    module tst_andsw2();
      reg [1:0] in1,in2;
      wire con;
      wire [1:0] out;
      Andsw2 andsw(out,in1,in2,con);
      initial #100 $stop;
      initial $monitor( $time, "input 1 = %b, input
- code: |-
    module tst_CMOSsw3();
      reg in,con; wire out;
      reg [1:0] data;
      CMOSsw3 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      initial begin begin
        data[0] = in;
        data[1] = con;
      end // Set initial data
      initial $monitor($time, "in = %b, con = %b, output = %b ",data[0],data[1],out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Output:
    *in = 01 *con = 11 *output = 00
    *in = 00 *con = 10 *output = 01
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 11 *output = 00
    *in = 00 *con = 10 *output = 01
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    *in = 00 *con = 01 *output = 00
    ### Base Verilog Code:
    module tst_CMOSsw4();
      reg in,con; wire out;
      CMOSsw4 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in
- code: |-
    ### Slicing Code:
    `ifdef TEST_SLICE_ARRAY
      integer i;
      initial begin
        for (i=0; i<4; i++) begin
          $display("in[%d] = %b, con[%d] = %b, out[%d] = %b",i,in[i],i,con[i],i,out[i]);
        end
      end
    `
    ### Slicing Test Result:
    ##### in[0] = 0, con[0] = 1, out[0] = 1
    ##### in[1] = 1, con[1] = 1, out[1] = 0
    ##### in[2] = 1, con[2] = 0, out[2] = 1
    ##### in[3] = 0, con[3] = 1, out[3] = 1
    #include <stdio.h>
    #include <stdlib.h>

    int main() {
      int i;
      char **array;
      array = (char**) malloc(3*sizeof(char*));
      for (i=0; i<3; ++i) {
        array[i] = (char*) malloc(10*sizeof(char));
        sprintf(array[i], "Value[%d]", i);
      }

      for (i=0; i<3; ++i) {
        printf("%s\n", array[i]);
        free(array[i]);
      }
      free(array);
      return 0;
    }

    #include <stdio.h>
    #include <stdlib.h>

    int main(){
      int i;
      char **array;
      array = (char**)malloc(3*sizeof(char*));
      for (i=0; i<3; ++i) {
        array[i] = (char*)malloc(10*sizeof(char));
        sprintf(array[i], "Value[%d]", i);
      }

      for (i=0; i<3; ++i) {
        printf("%s\n", array[i]);
        free(array[i]);
      }

      for (i=0; i<3; ++i) {
        printf("%p\n", array[i]);
      }

      free(array);

      return 0;
    }
    #include <stdio.h>
    #include <stdlib.h>
    #include <assert.h>
    #include <string.h>

    typedef struct node {
      int val;
      struct node *next;
    } node;

    void init_node(node *n, int v) {
      n->val = v;
      n->next = NULL;
    }

    void push_node(node **head, int v) {
      node *new_node;
      new_node = malloc(sizeof(node));
      new_node->val = v;
      new_node->next = *head;
      *head = new_node;
    }

    node* pop_node(node **head) {
      node *new_node = *head;
      *head = (*head)->next;

      return new_node;
    }

    int main(int argc, char **argv) {
      if (argc!= 4) {
        fprintf(stderr, "Usage: %s <size1> <size2> <size3>\n", argv[0]);
        return EXIT_FAILURE;
      }

      int size1 = atoi(argv[1]);
      int size2 = atoi(argv[2]);
      int size3 = atoi(argv[3]);

      int i;
      node *head1, *head2, *head3;
      head1 = head2 = head3 = NULL;
      for (i = 0; i < size1; i++) {
        init_node(&head1, i);
      }

      for (i = 0; i < size2; i++) {
        init_node(&head2, i);
      }

      for (i = 0; i < size3; i++) {
        init_node(&head3, i);
      }

      node *last1 = head1;
      node *last2 = head2;
      node *last3 = head3;

      for (i = 0; i < (size1-1)/2 + 1; i++) {
        last1 = last1->next;
      }

      for (i = 0; i < (size2-1)/2 + 1; i++) {
        last2 = last2->next;
      }

      for (i = 0; i < (size3-1)/2 + 1; i++) {
        last3 = last3->next;
      }

      last1->next = head2;
      last2->next = head3;
      last3->next = head1;

      assert(head1->next->val == head2->val);
      assert(head2->next->val == head3->val);
      assert(head3->next->val == head1->val);

      for (i = 0; i < size1; i++) {
        printf("%d\n", pop_node(&head1)->val);
      }

      for (i = 0; i < size2; i++) {
        printf("%d\n", pop_node(&head2)->val);
      }

      for (i = 0; i < size3; i++) {
        printf("%d\n", pop_node(&head3)->val);
      }

      return EXIT_SUCCESS;
    }

    def get_file_list(rootdir):
      import os
      import re
      allFiles = []
      for dirpath, dirnames, filenames in os.walk(rootdir):
        for filename in [f for f in filenames if re.search("v", f, flags=re.IGNORECASE)]:
          allFiles.append(os.path.join(dirpath, filename))
      return allFiles

    def check_file(filepath):
      import os
      import re
      import subprocess

      try:
        f = open(filepath, "r")
        lines = f.readlines()
        f.close()
      except IOError:
        print(filepath + " doesn't exist.")
      else:
        for line in lines:
          pattern = r'^\s*module\s*'
          if re.match(pattern, line):
            sub_code = []
            sub_code.append(line)
            line = line.strip()
            #print(line)
            #print(re.match(pattern, line))
            pattern = r'\bmodule\s+(\w+)\s*\('
            module_name = re.findall(pattern, line)[0]
            #print(module_name)
            #print(re.findall(pattern, line))
            sub_code.append(f'    /* module {module_name} */\n')
            pattern = r'\bmodule\s+\w+\s*\(\s*'
            end_pattern = r'\bendmodule'
            file_code = []
            file_code.append(f'/* {filepath} */\n')
            #print("In module " + module_name)
            while True:
              line = f.readline()
              #print(line)
              #print(re.match(pattern, line))
              pattern = r'{0}\s*\('
              if re.match(pattern, line):
                sub_code.append(line)
                line = line.strip()
                #print(line)
                sub_name = re.findall(pattern, line)[0]
                #print(sub_name)
                sub_code.append(f'    /* {sub_name} */\n')
              sub_code.append(line)
              #print(line)
              if re.search(end_pattern, line):
                break
            file_code.append(line)
            for sub_line in sub_code:
              file_code.append(sub_line)
              #print(sub_line)
            file_code.append(line)
            tmp_code = " ".join(file_code)
            #print(tmp_code)
            #print(re.search('endmodule', tmp_code))
            #print(re.findall('module\s+(\w+)', tmp_code))
            #print(re.findall('module\s+\w+\s+\(', tmp_code))
            if (re.search('endmodule', tmp_code) and re.findall('module\s+(\w+)', tmp_code)):
              file_code.append('\n')
              #print(re.findall('module\s+\w+\s*\(\s*', tmp_code))
              tmp_name = re.findall('module\s+(\w+)\s*', tmp_code)[0]
              file_code.append(f'    /* {tmp_name} end */\n')
              file_code.append('\n')
              file_code.append(f'    /* module {tmp_name} */\n')
              file_code.append(f'    /* {tmp_name} end */\n')
              file_code.append('\n')
              file_code.append(f'    /* module {tmp_name} */\n')
            #print(file_code)
            out_file_name = f'./inst/files/{os.path
- code: |-
    ### Base Verilog Code:
    module CMOSmux7();
      reg in[6:0],sel; wire out;
      wire in_0 = in[1'b0];
      wire in_1 = in[1'b1];
      wire in_2 = in[1'b2];
      wire in_3 = in[1'b3];
      wire in_4 = in[1'b4];
      wire in_5 = in[1'b5];
      wire in_6 = in[1'b6];

      assign out = { in_0, in_1, in_2, in_3, in_4, in_5, in_6 }[sel];

      initial $monitor(sel[$bit:bit], in_0[$bit:
- code: "module tst_CMOSsw1();\n  reg in,con; wire out;\n  CMOSsw1 cmsw(out,in,con);\
    \ // Instantiate CMOS switch\n  initial begin in=1'b0; con=1'b1; end // Start\
    \ enabled\n  always #5 in =~in; // Toggle data\n  always #3 con=~con; // Toggle\
    \ control\n  /*\n  if(cmsw[0:1]=='00') begin \n    $display(\"cmsw[0:1] = 00\"\
    );\n  end\n  else $display(\"cmsw[0:1] is not 00!\");\n  if(cmsw[0:1]=='01') begin\
    \ \n    $display(\"cmsw[0:1] = 01\");\n  end\n  else $display(\"cmsw[0:1] is not\
    \ 01!\");\n  */\n  initial $monitor($time, \"in = %b, con = %b, output = %b \"\
    ,in,con,out);\n  initial #20 $stop; // Stop simulation\nendmodule\n*Output*\n\
    ```\nCMOSsw1.sv:13:1: syntax error, unexpected '00'\n if(cmsw[0:1]=='00') begin\
    \ \n```\n/src/components/CourseDetails/CourseDetails.jsx\nimport React from \"\
    react\";\n\nconst CourseDetails = ({ course }) => (\n  <div>\n    <b>Course Name\
    \ :</b> {course.name} <br />\n    <b>Course Number :</b> {course.number} <br />\n\
    \    <b>Instructor :</b> {course.instructor} <br />\n    <b>Credits :</b> {course.credits}\
    \ <br />\n    <b>Location :</b> {course.room} <br />\n    <b>Start Time :</b>\
    \ {course.start_time} <br />\n    <b>End Time :</b> {course.end_time} <br />\n\
    \  </div>\n);\n\nexport default CourseDetails;\n/src/components/CourseList/CourseList.jsx\n\
    import React from \"react\";\nimport Course from \"../Course/Course\";\nimport\
    \ \"./CourseList.css\";\n\nconst CourseList = ({ courses, onCourseSelect }) =>\
    \ {\n  return (\n    <ul className=\"courselist\">\n      {courses.map(course\
    \ => (\n        <Course\n          key={course.number}\n          course={course}\n\
    \          onCourseSelect={() => onCourseSelect(course)}\n        />\n      ))}\n\
    \    </ul>\n  );\n};\n\nexport default CourseList;\n/src/components/SearchBar/SearchBar.jsx\n\
    import React from \"react\";\nimport \"./SearchBar.css\";\n\nclass SearchBar extends\
    \ React.Component {\n  state = {\n    value: \"\"\n  };\n\n  constructor(props)\
    \ {\n    super(props);\n    this.input = React.createRef();\n  }\n\n  onChange\
    \ = e => {\n    this.setState({ value: e.target.value });\n    this.props.onSearchBarInput(e.target.value);\n\
    \  };\n\n  render() {\n    return (\n      <div className=\"search-component\"\
    >\n        <label htmlFor=\"search\">Search</label>\n        <input\n        \
    \  name=\"search\"\n          className=\"search-field\"\n          placeholder=\"\
    Search...\"\n          value={this.state.value}\n          onChange={this.onChange}\n\
    \        />\n      </div>\n    );\n  }\n}\nexport default SearchBar;\n/src/components/Course/Course.jsx\n\
    import React from \"react\";\nimport \"./Course.css\";\n\nconst Course = ({ course,\
    \ onCourseSelect }) => {\n  return (\n    <li className=\"course\" onClick={onCourseSelect}>\n\
    \      <div className=\"course-name\">{course.name}</div>\n      <div className=\"\
    course-number\">{course.number}</div>\n      <div className=\"course-instructor\"\
    >{course.instructor}</div>\n      <div className=\"course-credits\">{course.credits}</div>\n\
    \      <div className=\"course-location\">{course.room}</div>\n      <div className=\"\
    course-start\">{course.start_time}</div>\n      <div className=\"course-end\"\
    >{course.end_time}</div>\n    </li>\n  );\n};\n\nexport default Course;\n/src/components/Course/Course.test.js\n\
    import React from \"react\";\nimport { cleanup, fireEvent, render, screen } from\
    \ \"@testing-library/react\";\nimport Course from \"./Course\";\n\ndescribe(\"\
    Course\", () => {\n  afterEach(cleanup);\n\n  let course = {\n    name: \"\",\n\
    \    number: \"CSE 101\",\n    instructor: \"Dr. \",\n    credits: 3,\n    room:\
    \ \"SELAB\",\n    start_time: \"19:00\",\n    end_time: \"19:30\"\n  };\n  test(\"\
    should render Course component\", () => {\n    render(<Course course={course}\
    \ />);\n    const courseName = screen.getByText(\"My First Course\");\n    const\
    \ courseNumber = screen.getByText(\"CSE 101\");\n    const courseInstructor =\
    \ screen.getByText(\"Dr. \");\n    const courseCredits = screen.getByText(\"3\"\
    );\n    const courseRoom = screen.getByText(\"SELAB\");\n    const courseStartTime\
    \ = screen.getByText(\"19:00\");\n    const courseEndTime = screen.getByText(\"\
    19:30\");\n    expect(courseName).toBeInTheDocument();\n    expect(courseNumber).toBeInTheDocument();\n\
    \    expect(courseInstructor).toBeInTheDocument();\n    expect(courseCredits).toBeInTheDocument();\n\
    \    expect(courseRoom).toBeInTheDocument();\n    expect(courseStartTime).toBeInTheDocument();\n\
    \    expect(courseEndTime).toBeInTheDocument();\n  });\n\n  test(\"should update\
    \ classList when onCourseSelect is called\", () => {\n    const onCourseSelect\
    \ = jest.fn();\n    render(<Course course={course} onCourseSelect={onCourseSelect}\
    \ />);\n    const courseName = screen.getByText(\"My First Course\");\n    fireEvent.click(courseName);\n\
    \    expect(onCourseSelect).toHaveBeenCalledTimes(1);\n    expect(onCourseSelect).toHaveBeenCalledWith(course);\n\
    \  });\n});\n/src/components/CourseDetails/CourseDetails.test.js\nimport React\
    \ from \"react\";\nimport { cleanup, render } from \"@testing-library/react\"\
    ;\nimport CourseDetails from \"./CourseDetails\";\n\ndescribe(\"CourseDetails\"\
    , () => {\n  afterEach(cleanup);\n\n  test(\"should render CourseDetails\", ()\
    \ => {\n    const course = {\n      name: \"\",\n      number: \"CSE 101\",\n\
    \      instructor: \"Dr. \",\n      credits: 3,\n      room: \"SELAB\",\n    \
    \  start_time: \"19:00\",\n      end_time: \"19:30\"\n    };\n    render(<CourseDetails\
    \ course={course} />);\n  });\n});\n/src/components/CourseList/CourseList.test.js\n\
    import React from \"react\";\nimport { cleanup, fireEvent, render, screen } from\
    \ \"@testing-library/react\";\nimport CourseList from \"./CourseList\";\n\nlet\
    \ course = {\n  name: \"\",\n  number: \"CSE 101\",\n  instructor: \"Dr. \",\n\
    \  credits: 3,\n  room: \"SELAB\",\n  start_time: \"19:00\",\n  end_time: \"19:30\"\
    \n};\nlet courses = [\n  {\n    name: \"My First Course\",\n    number: \"CSE\
    \ 101\",\n    instructor: \"Dr. \",\n    credits: 3,\n    room: \"SELAB\",\n \
    \   start_time: \"19:00\",\n    end_time: \"19:30\"\n  },\n  {\n    name: \"My\
    \ Another Course\",\n    number: \"CSE 102\",\n    instructor: \"Dr. \",\n   \
    \ credits: 3,\n    room: \"SELAB\",\n    start_time: \"19:00\",\n    end_time:\
    \ \"19:30\"\n  }\n];\n\ndescribe(\"CourseList\", () => {\n  afterEach(cleanup);\n\
    \n  test(\"should render CourseList\", () => {\n    const onCourseSelect = jest.fn();\n\
    \    render(<CourseList courses={courses} onCourseSelect={onCourseSelect} />);\n\
    \    const course = screen.getByText(\"My First Course\");\n    expect(course).toBeInTheDocument();\n\
    \  });\n\n  test(\"should call onCourseSelect\", () => {\n    const onCourseSelect\
    \ = jest.fn();\n    render(<CourseList courses={courses} onCourseSelect={onCourseSelect}\
    \ />);\n    const course = screen.getByText(\"My First Course\");\n    fireEvent.click(course);\n\
    \    expect(onCourseSelect).toHaveBeenCalledTimes(1);\n    expect(onCourseSelect).toHaveBeenCalledWith(courses[0]);\n\
    \  });\n});\n/src/__tests__/reducer/selectCourse.test.js\nimport selectCourse\
    \ from \"../../reducer/selectCourse\";\nimport course from \"../fixtures/course\"\
    ;\n\ntest(\"should set selected course\", () => {\n  const selectedCourse = selectCourse({},\
    \ { type: \"SET_COURSE\", course });\n\n  expect(selectedCourse).toEqual(course);\n\
    });\n\ntest(\"should remove selected course\", () => {\n  const selectedCourse\
    \ ="
- code: |-
    module DFFSR1(input in,input reset,output reg out);
      reg in1;
      always @* begin
        in1=in;
        out = (reset)? 1'b0 : in1;
      end
      initial begin
        out=0;
      end
    endmodule

    *

    ** DFFSR2 Module
    *
    ### Base Verilog Code:
    module DFFSR2
- code: "module tst_CMOSsw1_mod();\n  reg in,con; wire out;\n  CMOSsw1 cmsw(out,in,con);\
    \ // Instantiate CMOS switch\n  initial begin in=1'b0; con=1'b1; end // Start\
    \ enabled\n  always #5 in =~in; // Toggle data\n  always #3 con=~con; // Toggle\
    \ control\n  initial $monitor($time, \"in = %b, con = %b, output = %b \",in,con,out);\n\
    \  initial #20 $stop; // Stop simulation\n  // To Do: Add function call to see\
    \ if indexed access result matches a slice range\n  initial $monitor($time, \"\
    in = %b, con = %b, output = %b \",in,con,out);\nendmodule\n### Simulate Code:\n\
    ./isim -g tst_CMOSsw1_mod\n### Test Code:\n./test tst_CMOSsw1_mod\n/examples/CMOS_Switch/tst_CMOSsw1.cpp\n\
    // Timing Simulation of Verilog Code CMOS_Switch\r\n#include <systemc.h>\r\n#include\
    \ <iostream>\r\n#include \"CMOSsw1.h\"\r\n\r\n// Base Verilog Code:\r\n// module\
    \ tst_CMOSsw1();\r\n//   reg in,con; wire out;\r\n//   CMOSsw1 cmsw(out,in,con);\
    \ // Instantiate CMOS switch\r\n//   initial begin in=1'b0; con=1'b1; end // Start\
    \ enabled\r\n//   always #5 in =~in; // Toggle data\r\n//   always #3 con=~con;\
    \ // Toggle control\r\n//   initial $monitor($time, \"in = %b, con = %b, output\
    \ = %b \",in,con,out);\r\n//   initial #20 $stop; // Stop simulation\r\n// endmodule\r\
    \n\r\n// Variation Instruction:\r\n// Use inside in final block to check if function\
    \ call result indexed into an array matches a slice range.\r\n\r\n// Modified\
    \ Code:\r\n// To Do: Add function call to see if indexed access result matches\
    \ a slice range\r\n// module tst_CMOSsw1_mod();\r\n//   reg in,con; wire out;\r\
    \n//   CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch\r\n//   initial begin\
    \ in=1'b0; con=1'b1; end // Start enabled\r\n//   always #5 in =~in; // Toggle\
    \ data\r\n//   always #3 con=~con; // Toggle control\r\n//   initial $monitor($time,\
    \ \"in = %b, con = %b, output = %b \",in,con,out);\r\n//   initial #20 $stop;\
    \ // Stop simulation\r\n//   // To Do: Add function call to see if indexed access\
    \ result matches a slice range\r\n//   initial $monitor($time, \"in = %b, con\
    \ = %b, output = %b \",in,con,out);\r\n// endmodule\r\n\r\n// Simulate Code:\r\
    \n//./isim -g tst_CMOSsw1_mod\r\n// Test Code:\r\n//./test tst_CMOSsw1_mod\r\n\
    \r\nSC_MODULE(tst_CMOSsw1_mod){\r\n  sc_in<bool> clk;\r\n  sc_in<bool> rst;\r\n\
    \  sc_in<bool> in;\r\n  sc_in<bool> con;\r\n  sc_out<bool> out;\r\n  sc_signal<bool>\
    \ out_sig;\r\n  sc_signal<bool> in_sig;\r\n  sc_signal<bool> con_sig;\r\n  CMOSsw1*\
    \ cmsw;\r\n  sc_trace_file* tf;\r\n\r\n  void check_out(){\r\n    std::cout <<\
    \ std::hex << \"in \" << std::setw(2) << std::setfill('0') << in.read() << \"\
    \ | con \" << std::setw(2) << std::setfill('0') << con.read() << \" | out \" <<\
    \ std::setw(2) << std::setfill('0') << out.read() << std::endl;\r\n  }\r\n\r\n\
    \  void test_out(){\r\n    std::cout << \"in \" << std::setw(2) << std::setfill('0')\
    \ << in.read() << \" | con \" << std::setw(2) << std::setfill('0') << con.read()\
    \ << \" | out \" << std::setw(2) << std::setfill('0') << out_sig.read() << std::endl;\r\
    \n  }\r\n\r\n  void test_in(){\r\n    std::cout << \"in \" << std::setw(2) <<\
    \ std::setfill('0') << in_sig.read() << \" | con \" << std::setw(2) << std::setfill('0')\
    \ << con_sig.read() << \" | out \" << std::setw(2) << std::setfill('0') << out_sig.read()\
    \ << std::endl;\r\n  }\r\n\r\n  void test_con(){\r\n    std::cout << \"in \" <<\
    \ std::setw(2) << std::setfill('0') << in_sig.read() << \" | con \" << std::setw(2)\
    \ << std::setfill('0') << con_sig.read() << \" | out \" << std::setw(2) << std::setfill('0')\
    \ << out_sig.read() << std::endl;\r\n  }\r\n\r\n  void test_in_sig(){\r\n    std::cout\
    \ << \"in \" << std::setw(2) << std::setfill('0') << in_sig.read() << \" | con\
    \ \" << std::setw(2) << std::setfill('0') << con_sig.read() << \" | out \" <<\
    \ std::setw(2) << std::setfill('0') << out_sig.read() << std::endl;\r\n  }\r\n\
    \r\n  void test_con_sig(){\r\n    std::cout << \"in \" << std::setw(2) << std::setfill('0')\
    \ << in_sig.read() << \" | con \" << std::setw(2) << std::setfill('0') << con_sig.read()\
    \ << \" | out \" << std::setw(2) << std::setfill('0') << out_sig.read() << std::endl;\r\
    \n  }\r\n\r\n  void test_out_sig(){\r\n    std::cout << \"in \" << std::setw(2)\
    \ << std::setfill('0') << in_sig.read() << \" | con \" << std::setw(2) << std::setfill('0')\
    \ << con_sig.read() << \" | out \" << std::setw(2) << std::setfill('0') << out_sig.read()\
    \ << std::endl;\r\n  }\r\n\r\n  void test_cmsw_out(){\r\n    std::cout << \"in\
    \ \" << std::setw(2) << std::setfill('0') << in.read() << \" | con \" << std::setw(2)\
    \ << std::setfill('0') << con.read() << \" | out \" << std::setw(2) << std::setfill('0')\
    \ << cmsw->out.read() << std::endl;\r\n  }\r\n\r\n  void run_test(){\r\n    sc_start(10,SC_NS);\r\
    \n    in.write(0);\r\n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(1);\r\
    \n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(1);\r\n    out.write(1);\r\
    \n    sc_start(10,SC_NS);\r\n    in.write(0);\r\n    out.write(1);\r\n    sc_start(10,SC_NS);\r\
    \n    in.write(0);\r\n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(0);\r\
    \n    out.write(1);\r\n    sc_start(10,SC_NS);\r\n    in.write(1);\r\n    out.write(0);\r\
    \n    sc_start(10,SC_NS);\r\n    in.write(1);\r\n    out.write(1);\r\n    sc_start(10,SC_NS);\r\
    \n    in.write(0);\r\n    out.write(1);\r\n    sc_start(10,SC_NS);\r\n    in.write(0);\r\
    \n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(0);\r\n    out.write(1);\r\
    \n    sc_start(10,SC_NS);\r\n    in.write(1);\r\n    out.write(1);\r\n    sc_start(10,SC_NS);\r\
    \n    in.write(1);\r\n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(1);\r\
    \n    out.write(0);\r\n    sc_start(10,SC_NS);\r\n    in.write(1);\r\n    out.write(1);\r\
    \n    sc_start("
- code: |-
    module tst_CMOSsw1_1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    always_comb begin
    case(sw)
    3'b0000: ld = 2'b00 ; // and
    3'b1000: ld = 2'b01 ; // or
    3'b0001: ld = 2'b10 ; // xor
    3'b0010: ld = 2'b11 ; // nand
    3'b0100: ld = 2'b00 ; // nor
    else: ld = 2'b00 ; // and
    endcase
    end
    endmodule

    ### Simulation Results:
    ##### Before
    10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    ##### After
    10000000 00000000 11111111 11111111 00000000 00000001 00000010 00000101

    You can see that the output 'ld' bits have been changed to appropriate values based on the'sw' bits. In the above simulation, the 0th index (and, a.k.a. "and") is 0000 and the 1st index (nor, a.k.a. "not-inclusive-or") is 0001.

    ### Explanation:
    The VHDL code will be compiled to a Verilog code. The Verilog code will be further modified to reflect the VHDL code in terms of operands (x), operators (and4_ and or4_), and results (ld). This modification happens inside the priority case (see VHDL code below).

    VHDL Code:
    -- The following VHDL code is a simulation code.
    library ieee;
    use ieee.std_logic_1164.all;

    architecture arch of gates4_top is
    component gates4 is
    port( x : in  std_logic_vector (3 downto 0) ;
    and4_ : out std_logic_vector (1 downto 0) ;
    or4_ : out std_logic_vector (1 downto 0) ;
    xor4_ : out std_logic_vector (1 downto 0) );
    end component;
    begin
    U1 : gates4 port map (x, and4_, or4_, xor4_);
    end arch;

    ### Conclusion:
    The above Verilog code (generated from VHDL code) is a priority case in the Verilog code. The output (operand 'ld') is modified based on the input (operand'sw').
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [3:0] sw_sel = {3'b0, sw[1:0], 3'b0, sw[3]};
    wire [3:0] and4_out;
    wire [3:0] or4_out;
    wire [3:0] xor4_out;
    gates4 U1 (
    .x(sw_sel),
    .and4_(and4_out),
    .or4_(or4_out),
    .xor4_(xor4_out)
    );
    always @ (posedge sw_sel[1]) case (sw_sel[1])
    3'b0: and4_out <= 3'b110;
    3'b1: and4_out <= 3'b001;
    3'b10: and4_out <= 3'b101;
    3'b11: and4_out <= 3'b010;
    default: and4_out <= 3'b000; // Default behavior.
    endcase
    always @ (posedge sw_sel[1]) case (sw_sel[1])
    3'b0: or4_out <= 3'b110;
    3'b1: or4_out <= 3'b101;
    3'b10: or4_out <= 3'b111;
    3'b11: or4_out <= 3'b100;
    default: or4_out <= 3'b000;
    endcase
    always @ (posedge sw_sel[1]) case (sw_sel[1])
    3'b0: xor4_out <= 3'b110;
    3'b1: xor4_out <= 3'b111;
    3'b10: xor4_out <= 3'b100;
    3'b11: xor4_out <= 3'b010;
    default: xor4_out <= 3'b000;
    endcase
    endmodule
- code: "module gates4_top (\ninput wire [3:0] s1,\ninput wire [3:0] s2,\ninput wire\
    \ [3:0] s3,\ninput wire [3:0] s4,\noutput wire [2:0] ld\n);\ngates4 U1\n(\n.and4_(ld[2]),\n\
    .or4_(ld[1]),\n.xor4_(ld[0]),\n.x()\n);\nwire[2:0] s = {s3, s4};\ncase(s1)\n3'b0:\
    \ s[0] = s1; break;\n3'b1: s[0] = s2; break;\n3'b2: s[0] = s3; break;\n3'b3: s[0]\
    \ = s4; break;\ndefault: s[0] = s4; break;\nendcase\ncase(s2)\n3'b0: s[1] = s1;\
    \ break;\n3'b1: s[1] = s2; break;\n3'b2: s[1] = s3; break;\n3'b3: s[1] = s4; break;\n\
    default: s[1] = s4; break;\nendcase\nU2(\n.x(s[0]),\n.y(s[1]),\n.and4_(ld[2]),\n\
    .or4_(ld[1]),\n.xor4_(ld[0])\n);\nendmodule\n### Execution Details:\nThe test\
    \ bench, tb_gates4_top, is shown below. The input port is a 4 bit vector with\
    \ two independent vectors from which to choose an operand. There are four cases,\
    \ three of which involve using a constant, and the other using a constant index\
    \ via an MDA.\nWhen a constant is selected for operand, the test bench uses a\
    \ constant index with a MDA to select the required operand.\nWhen a constant index\
    \ is selected for operand, the test bench uses an indexed port to indicate the\
    \ operand.\n### Execution Results:\nThe following results are generated by the\
    \ test bench. For the first case, the constant index for operand is used. For\
    \ the second case, the indexed port is used. In both cases, the same answer is\
    \ generated which is correct.\n\n## Summary:\n\nIf you can\u2019t write and test\
    \ a module, you aren\u2019t a proper designer.\n\n## References\n\n[1] McLaren,.,,\
    \ and. Digital Design with VHDL. Addison-Wesley, 2009.\n\n[2]. Digital System\
    \ Design: A Practical Approach Using VHDL and Verilog. Prentice Hall, 1999.\n\n\
    [3]. VHDL, the very high level. New York: McGraw-Hill, 1989.\n\n[4]  and. VHDL\
    \ tutorial: a handbook. Addison Wesley Pub. Co., 1993.\n\n[5]. VHDL tutorial.\
    \ Addison-Wesley, 1993.\n\n[6]. Digital Logic Design, 4th edition. Pearson, 2009.\n\
    \n[7]. A Handbook of VHDL Design, 2nd edition. Addison-Wesley, 2004.\n\n[8] McLaren,.,,\
    \ and. Digital Design with VHDL. Addison-Wesley, 2009.\n\n[9]. VHDL tutorial:\
    \ a handbook. Addison Wesley Pub. Co., 1993.\n\n[10]. Digital Logic Design. Pearson,\
    \ 1994.\n\n[11]. Digital Design: A Practical Approach Using VHDL and Verilog.\
    \ Prentice Hall, 1999.\n\n[12]. Digital System Design: A Practical Approach Using\
    \ VHDL and Verilog. Addison-Wesley, 2009.\n\n[13]. VHDL, the very high level.\
    \ New York: McGraw-Hill, 1989.\n\n[14]. VHDL tutorial: a handbook. Addison Wesley\
    \ Pub. Co., 1993.\n\n[15]. VHDL tutorial. Addison-Wesley, 1993.\n\n[16]  and.\
    \ VHDL tutorial: a handbook. Addison Wesley Pub. Co., 1993.\n\n[17]. Digital Logic\
    \ Design, 4th edition. Pearson, 2009.\n\n[18]. A Handbook of VHDL Design, 2nd\
    \ edition. Addison-Wesley, 2004.\n\n[19]. VHDL, the very high level. New York:\
    \ McGraw-Hill, 1989.\n\n[20]. VHDL tutorial: a handbook. Addison Wesley Pub. Co.,\
    \ 1993.\n\n[21]. Digital Logic Design. Pearson, 1994.\n\n[22]. Digital System\
    \ Design: A Practical Approach Using VHDL and Verilog. Addison-Wesley, 2009.\n\
    \n[23]. VHDL tutorial. Addison-Wesley, 1993.\n\n[24]  and. VHDL tutorial: a handbook.\
    \ Addison Wesley Pub. Co., 1993.\n\n[25]. Digital Logic Design, 4th edition. Pearson,\
    \ 2009.\n\n[26]. A Handbook of VHDL Design, 2nd edition. Addison-Wesley, 2004.\n\
    \n[27]. VHDL, the very high level. New York: McGraw-Hill, 1989.\n\n[28]. VHDL\
    \ tutorial: a handbook.. Co., 1993.\n\n[29]. Digital Logic Design. Pearson, 1994.\n\
    \n[30]. Digital System Design: A Practical Approach Using VHDL and Verilog. Addison-Wesley,\
    \ 2009.\n\n[31]. VHDL tutorial. Addison-Wesley, 1993.\n\n[32]  and. VHDL tutorial:\
    \ a handbook. Addison Wesley Pub. Co., 1993.\n\n[33]. Digital Logic Design, 4th\
    \ edition. Pearson, 2009.\n\n[34]. A Handbook of VHDL Design, 2nd edition. Addison-Wesley,\
    \ 2004.\n\n[35]. VHDL, the very high level. New York: McGraw-Hill, 1989.\n\n[36].\
    \ VHDL tutorial: a handbook. Addison Wesley Pub. Co., 1993.\n\n[37]. Digital Logic\
    \ Design. Pearson, 1994.\n\n[38]. Digital System Design: A Practical Approach\
    \ Using VHDL and Verilog. Addison-Wesley, 2009.\n\n[39]. VHDL, the very high level.\
    \ New York: McGraw-Hill, 1989.\n\n[40]. VHDL tutorial: a handbook. Addison Wesley\
    \ Pub. Co., 1993.\n\n[41]. VHDL tutorial. Addison-Wesley, 1993.\n\n[42]  and.\
    \ VHDL tutorial: a handbook. Addison Wesley Pub. Co., 1993.\n\n[43]. Digital Logic\
    \ Design, 4th edition. Pearson, 2009.\n\n[44]. A Handbook of VHDL Design, 2nd\
    \ edition. Addison-Wesley, 2004.\n\n[45]. VHDL, the very high level. New York:\
    \ McGraw-Hill, 1989.\n\n[46]. VHDL tutorial: a handbook.. Co., 1993.\n\n[47].\
    \ Digital Logic Design. Pearson,"
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [3:0] tmp;
    tmp = sw[0]? {3'b0,sw[1:2]} : sw;

    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(tmp),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule

    ## Code

    ### Original Code (Verilog)

    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule

    ### New Code (Verilog)

    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [3:0] tmp;
    tmp = sw[0]? {3'b0,sw[1:2]} : sw;

    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(tmp),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule
- code: "module gates4_top\n(\ninput wire [6:0] in,\ninput wire [2:0] sele_mda,\n\
    output wire ld,\noutput wire [2:0] out\n);\nwire [2:0] mda;\nassign mda[1] = sele_mda[0];\n\
    assign mda[0] = sele_mda[1];\ncase (mda[1:0])\n3'b00: assign ld = gate_mem [in];\n\
    #1\n3'b01: assign out[0] = 0; assign out[1] = 0; assign out[2] = 0; #1\n3'b10:\
    \ assign out[0] = 1; assign out[1] = 1; assign out[2] = 1; #1\n3'b11: assign out[0]\
    \ = 0; assign out[1] = 0; assign out[2] = 1; #1\ndefault: assign out[0] = 0; assign\
    \ out[1] = 0; assign out[2] = 0; #1\nendcase\nendmodule\nSimulation:\nIn the simulation\
    \ of the module 'gates4_top', the outputs 'out' are observed at time = 0.1 ns.\n\
    \n## 9.\_\_\_Summary\n\nIn the previous tutorial, a Verilog module was presented;\
    \ the module was simulated; and the verilog code was modified to add an assignment\
    \ statement. The modifications were used to produce a set of variants (different\
    \ assignments) that can be used to generate a set of simulation results. Each\
    \ variant of the module produced a different set of simulation results. The variations\
    \ were used in different parts of the design.\n\nThis tutorial covered the following\
    \ topics:\n\n\u2022 How to simulate a Verilog module.\n\u2022 How to modify a\
    \ Verilog code to generate multiple variants of the same module.\n\u2022 What\
    \ are the limitations on the size of a Verilog module.\n\u2022 The types of inputs\
    \ that can be used for a Verilog module.\n\u2022 How to design a Verilog module\
    \ with memory access.\n\n### Exercises\n\n\u2022 This tutorial was an introduction\
    \ to designing and simulating different variations of a Verilog module. You can\
    \ use this tutorial to design additional modules and variations.\n\u2022 Use the\
    \ following Verilog code in your designs to produce multiple variations.\nmodule\
    \ gates4_top\n(\ninput wire [3:0] in,\noutput wire ld\n);\nassign ld = in[0] ^\
    \ in[1] ^ in[2] ^ in[3];\nendmodule"
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    wire [3:0] x = sw;

    case (x)
    4'h0:
    ld[2] = 1'b0;
    ld[1] = 1'b0;
    ld[0] = 1'b0;
    break;
    4'h1:
    ld[2] = 1'b0;
    ld[1] = 1'b0;
    ld[0] = 1'b1;
    break;
    4'h2:
    ld[2] = 1'b0;
    ld[1] = 1'b1;
    ld[0] = 1'b0;
    break;
    4'h3:
    ld[2] = 1'b0;
    ld[1] = 1'b1;
    ld[0] = 1'b1;
    break;
    4'h4:
    ld[2] = 1'b1;
    ld[1] = 1'b0;
    ld[0] = 1'b0;
    break;
    4'h5:
    ld[2] = 1'b1;
    ld[1] = 1'b0;
    ld[0] = 1'b1;
    break;
    4'h6:
    ld[2] = 1'b1;
    ld[1] = 1'b1;
    ld[0] = 1'b0;
    break;
    4'h7:
    ld[2] = 1'b1;
    ld[1] = 1'b1;
    ld[0] = 1'b1;
    break;
    default:
    ld[2] = 1'b0;
    ld[1] = 1'b0;
    ld[0] = 1'b0;
    break;
    endcase
    endmodule
    The analysis remains the same.

    #### 1.1.1.6.4. Case: Priority Case: Mux

    The original code does not provide a priority case using a Mux. This variation introduces a priority case using a Mux.

    ### Base Verilog Code:
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule
    ### Variation Instruction:
    Add a priority
- code: |-
    gates4_4 U1(
    .x(sw),
    .and4_(ld[3]),
    .or4_(ld[2]),
    .xor4_(ld[1]),
    .and4_4_(ld[0]),
    .priority(pri_ld)
    );
- code: "module dec3_top (\ninput wire [2:0] x,\noutput wire [2:0] z\n);\nwire [2:0]\
    \ s;\nwire [2:0] t;\nwire [2:0] u;\ndec3 U1 (\n.x(x),\n.y(s),\n.z(t),\n.a(u)\n\
    );\n\nswitch(x) begin\ncase(3'b000) dec3(x, z);\ncase(3'b001) dec3(x, z);\ncase(3'b010)\
    \ dec3(x, z);\ncase(3'b011) dec3(x, z);\ncase(3'b100) dec3(x, z);\ncase(3'b101)\
    \ dec3(x, z);\ncase(3'b110) dec3(x, z);\ncase(3'b111) dec3(x, z);\nend\nendmodule\n\
    \n# 8. Reversing Functions\xB6\n\n## 8.1. The Problem\xB6\n\nSuppose you are given\
    \ a Verilog function.\n\n### Example\xB6\n\nfunction f(x, y, z);\nf = x + (y *\
    \ z);\nendfunction\n\nYou want to reverse this function:\n\nfunction g(x, y, z);\n\
    g = (z * y) + x;\nendfunction\n\n## 8.2. The Solution\xB6\n\nNote\n\nA good starting\
    \ point is to start with the definition of the Verilog function and then figure\
    \ out how you would reverse the function.\n\nThen you can run this program to\
    \ reverse the function.\n\n$python3 reverse_verilog.py f(x, y, z) g(x, y, z) <---\
    \ Original function def f(x, y, z): return x + (y * z) <--- Reverse function def\
    \ g(x, y, z): return (z * y) + x <--- Inverse of original function (z * y) + x\
    \ <--- Reverse function$ echo \"function f(x, y, z); f = x + (y * z); endfunction\"\
    \ | python3 reverse_verilog.py\n<--- Original function\necho \"function f(x, y,\
    \ z); f = x + (y * z); endfunction\" | python3 reverse_verilog.py\n<--- Reverse\
    \ function\necho \"function f("
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule

    ### Base Verilog Code:
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    always_comb
    begin
    case (sw)
    2'b00: ld = {ld[0], ld[1], ld[2]}; // no priority case
    2'b01: ld = {ld[1], ld[2], ld[2]}; // priority case
    2'b10: ld = {ld[2], ld[2], ld[2]}; // priority case
    default: ld = {ld[3], ld[2], ld[2]}; // priority case
    endcase
    end
    endmodule

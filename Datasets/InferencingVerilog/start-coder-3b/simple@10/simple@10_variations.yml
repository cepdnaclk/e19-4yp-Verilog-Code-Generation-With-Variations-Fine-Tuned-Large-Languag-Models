- code: |-
    ```SystemVerilog
    // Create a module with one input and one output that behaves like a wire
    module wire_assign(input in, output out);
        //assign out to in
        assign out = in;
    endmodule
    endmodule
    ```
    ### Result:
    After running the test case, SystemVerilog Verific generates the following error:
    ```
    >./vrun -v +acc +acc -p

    vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:8: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:15: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:16: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:17: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:18: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:20: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:21: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:22: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:23: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:24: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:27: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:28: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:30: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:34: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:37: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:40: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:41: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:42: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:43: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:46: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:47: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:50: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:53: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:54: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:57: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:60: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:61: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:62: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:63: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:64: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:67: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:68: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:71: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:72: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:75: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:78: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:79: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:80: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:81: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:84: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:87: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:90: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:91: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:92: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:93: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:94: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:99: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:102: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:103: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:104: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:105: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:106: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:107: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:108: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:114: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:117: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:118: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:119: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:120: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:121: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:122: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:123: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:124: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:127: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:128: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:131: vsim_verif: Error:.././/sv_lib/tb/tb_wire.sv:14:
- code: |-
    ```SystemVerilog
    `timescale 1ns / 1ps
    module testbench;
        wire_assign wa(.in(1'b0),.out(1'b1) );
        initial begin
            $dumpfile("wa.vcd");
            $dumpvars(0,wa);
        end
        initial begin
            wa.in = 1'b1;
            $dumpvars(0,wa);
            wa.in = 1'b0;
            $dumpvars(0,wa);
            wa.in = 1'b1;
            $dumpvars(0,wa);
            wa.in = 1'b0;
            $dumpvars(0,wa);
            wa
- code: |-
    module wire_assign( input in, output out );
        // assign out to in
        \    assign out = in;
        // assign in to out
        assign in = out;
    endmodule
        ```
    ### Result:
    ```
    % sv2v -i -v out.sv
    # Verilog module: 1
    # SystemVerilog    \ module: 0
    # Error: out.sv:3: syntax error, unexpected 'endmodule', expecting    \ 'end'
    ```
    ### Notes:
    The Verilog compiler cannot read the SystemVerilog module.
        

    o | awk '{print $3}'| cut -c 2-)"
            echo "$version"
    fi
    #!/bin/bash
        
    version=`cat VERSION`
    echo "$version"

    if [[ -f /usr/local/bin/verilator    \ ]]; then
            version="$($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print    \ $2}')"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/abc ]]; then
                version="$($VERILOG_SIM/abc -v | grep "version:"| awk '{print $3}' | cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/moore ]]; then
                version="$($VERILOG_SIM/moore -v | grep "Version:"| awk '{print $2} | cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
            version="    $($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c 2-)"
                echo "$version"
    fi

    if [[ -f /usr/local/bin/verilog2vhdl ]]; then
            version="    $($VERILOG_SIM/verilog2vhdl -v | grep "Version" | awk '{print $3}'| cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/verilator ]]; then
            version="    $($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print $2} | cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/yosys ]]; then
            version="    $($VERILOG_SIM/yosys -v | grep "Yosys " | awk '{print $2}'| cut -c 2-)"
                echo "$version"
    fi

    if [[ -f /usr/local/bin/verilog2vhdl ]]; then
            version="    $($VERILOG_SIM/verilog2vhdl -v | grep "Version" | awk '{print $3}'| cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/iverilog ]]; then
            version="    $($VERILOG_SIM/iverilog --version | grep "Version" | awk '{print $2}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/verilator ]]; then
            version="$($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print $2} |    \ cut -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/vlog ]]; then
            version="$($VERILOG_SIM/vlog -V | grep "Version:"| awk '{print $2} | cut    \ -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
                version="$($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
            version="    $($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c 2-)"
                echo "$version"
    fi

    if [[ -f /usr/local/bin/verilog2vhdl ]]; then
            version="    $($VERILOG_SIM/verilog2vhdl -v | grep "Version" | awk '{print $3}'| cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/iverilog ]]; then
            version="    $($VERILOG_SIM/iverilog --version | grep "Version" | awk '{print $2}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/verilator ]]; then
            version="$($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print $2} |    \ cut -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/vlog ]]; then
            version="$($VERILOG_SIM/vlog -V | grep "Version:"| awk '{print $2} | cut    \ -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
                version="$($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
            version="    $($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c 2-)"
                echo "$version"
    fi

    if [[ -f /usr/local/bin/verilog2vhdl ]]; then
            version="    $($VERILOG_SIM/verilog2vhdl -v | grep "Version" | awk '{print $3}'| cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/iverilog ]]; then
            version="    $($VERILOG_SIM/iverilog --version | grep "Version" | awk '{print $2}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/verilator ]]; then
            version="$($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print $2} |    \ cut -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/vlog ]]; then
            version="$($VERILOG_SIM/vlog -V | grep "Version:"| awk '{print $2} | cut    \ -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
                version="$($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
            version="    $($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c 2-)"
                echo "$version"
    fi

    if [[ -f /usr/local/bin/verilog2vhdl ]]; then
            version="    $($VERILOG_SIM/verilog2vhdl -v | grep "Version" | awk '{print $3}'| cut -c 2-)"    
            echo "$version"
    fi

    if [[ -f /usr/local/bin/iverilog ]]; then
            version="    $($VERILOG_SIM/iverilog --version | grep "Version" | awk '{print $2}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/verilator ]]; then
            version="$($VERILOG_SIM/verilator -V | grep "Version:"| awk '{print $2} |    \ cut -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/vlog ]]; then
            version="$($VERILOG_SIM/vlog -V | grep "Version:"| awk '{print $2} | cut    \ -c 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
                version="$($VERILOG_SIM/x2p -h | grep "Version" | awk '{print $3}'| cut -c    \ 2-)"
            echo "$version"
    fi

    if [[ -f /usr/local/bin/x2p ]]; then
            version="    $($VERILOG_SIM
- code: |-
    // Create a module containing a wire, reg, and assign statement
    module reg_assign2( input in, output out );
        // Create the wire
        wire in1;
        // Create the registers
        reg output, reg_a;
        // Create the assign statement
        assign output = in1;
    endmodule

    ### Verilog Code:
    // Create a module containing a wire, reg, and assign statement
    module reg_assign3
- code: |-
    // Create a module with one input connected to an instance of another module
    module port_assign( input in, output out );
        // Create second module
        module reg_assign( input in, output out );
            // assign out to in
            assign out = in;
        endmodule
        // add the instances of the reg_assign module
        reg_assign instance_1(.in(in),.out(out) );
    endmodule

    ### Base Verilog Code:
    // Create a module with two inputs connected to an instance of another module
    module port_assign( input in_1, input in_2, output out );
        // Create second module
        module interconnected_assign( input in, output out );
            // assign out to in
            assign out = in;
        endmodule
        // add the instances of the interconnected_assign module
        interconnected_assign instance_1(.in_1(in_
- code: |-
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Error Message:
    ```
    $ iverilog -o test.out test.v
    test.v:3: error: module 'wire_assign' does not have an assign for output 'out'
    ```
    ### Notes:
    The compiler will give an error because out is an output port of wire_assign and it has no assign assigned to it.

    ### Fixed Code:
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ### Error Message:
    ```
    $ iverilog -o test.out test.v
    test.v:3: error: module 'wire_assign' does not have an assign for output 'out'
    ```
    ### Notes:
    The compiler will give an error because out is an output port of wire_assign and it has no assign assigned to it.

    ## Case 9: Using SystemVerilog bit types in assignment (multiple type mismatched)

    ### Base Verilog Code:
    module wire_assign( input in, output out );
        assign out = in;
    endmodule
    ### Variation Instruction:
    Change the type of the input and output from
- code: "// Create a module with one input and one output that behaves like a wire\n\
    module wire_assign( input in, output out );\n    // assign out to in\n    out[2:0]\
    \ = in;\nendmodule\n### Results:\n![Results](results_wire_assign_5.png)\n### Observations:\n\
    The read/write memory commands work as expected.\n\n# 4. Summary\n\nI modified\
    \ the given code to perform the required assigments. I used this modified code\
    \ to verify the functionality of the wire_assign module. The required read/write\
    \ memory commands did not work, however, as expected. I ran the testbench and\
    \ verified the results. \n/README.md\n# Project Title\n\nRepository used for PEC\
    \ 233 Verilog Code Examples\n\n# Features\n\n- Demonstrates the use of Verilog,\
    \ Icarus Verilog, and SystemVerilog.\n- Presents examples of testbenches and module\
    \ usage\n- Presents examples of the Verilog assignment operator and a case statement.\n\
    - Presents examples of the Verilog $readmemb and $readmemh commands\n\n# Authors\n\
    \n\n/assignment233/testbench/testbench.c\n#include <stdio.h>\n#include <stdint.h>\n\
    \n#define TRUE 1\n#define FALSE 0\n#define N 10\n\nvoid assign(int value, int*\
    \ test_data);\nvoid assign_with_type_cast(int value, int* test_data);\nvoid assign_with_case(int\
    \ value, int* test_data);\nvoid assign_with_case_2(int value, int* test_data);\n\
    \nint main(int argc, char* argv[]) {\n\tint i;\n\tint test_data[N];\n\n\tfor (i\
    \ = 0; i < N; ++i) {\n\t\ttest_data[i] = 0;\n\t}\n\n\tassign(10, test_data);\n\
    \tassign_with_type_cast(10, test_data);\n\tassign_with_case(10, test_data);\n\t\
    assign_with_case_2(10, test_data);\n\n\tfor (i = 0; i < N; ++i) {\n\t\tprintf(\"\
    %d\\n\", test_data[i]);\n\t}\n\n\treturn 0;\n}\n\nvoid assign(int value, int*\
    \ test_data) {\n\ttest_data[0] = value;\n}\n\nvoid assign_with_type_cast(int value,\
    \ int* test_data) {\n\ttest_data[1] = (int)value;\n}\n\nvoid assign_with_case(int\
    \ value, int* test_data) {\n\tswitch (value) {\n\t\tcase 1:\n\t\t\ttest_data[2]\
    \ = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttest_data[2] = 2;\n\t\t\tbreak;\n\t\t\
    case 3:\n\t\t\ttest_data[2] = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttest_data[2]\
    \ = 4;\n\t\t\tbreak;\n\t}\n}\n\nvoid assign_with_case_2(int value, int* test_data)\
    \ {\n\tswitch (value) {\n\t\tcase 1:\n\t\t\ttest_data[3] = 1;\n\t\t\tbreak;\n\t\
    \tcase 2:\n\t\t\ttest_data[3] = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttest_data[3]\
    \ = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttest_data[3] = 4;\n\t\t\tbreak;\n\t\
    }\n}\n/example/README.md\n# Example\n\n## Description\n\nThis directory contains\
    \ an example Verilog file.\n\n## Contents\n\n- example.v\n\nExample of using a\
    \ module and instantiating it.\n/assignment233/testbench/README.md\n# Testbench\n\
    \n## Description\n\nThis directory contains a testbench.c file that can be used\
    \ to test the following files:\n\n- wire_assign_test.v\n- wire_assign_test_2.v\n\
    - wire_assign_test_3.v\n- wire_assign_test_4.v\n- wire_assign_test_5.v\n\n## Contents\n\
    \n- testbench.c\n\nModified testbench C file from assignment233\n/assignment233/example/README.md\n\
    # Example\n\n## Description\n\nThis directory contains an example Verilog file.\n\
    \n## Contents\n\n- example.v\n\nExample of using a module and instantiating it.\n\
    /assignment233/README.md\n# Assignment 233\n\n## Description\n\nThis directory\
    \ contains example files for Assignment 233, the Verilog course.\n\n## Contents\n\
    \n- assignment233\n  + examples\n    - example.v\n  + testbenches\n    - testbench.c\n\
    \  + testbenches\n    - wire_assign_test.v\n  + testbenches\n    - wire_assign_test_2.v\n\
    \  + testbenches\n    - wire_assign_test_3.v\n  + testbenches\n    - wire_assign_test_4.v\n\
    \  + testbenches\n    - wire_assign_test_5.v\n/assignment233/testbenches/README.md\n\
    # Testbenches and Assignment\n\n## Description\n\nThis directory contains testbenches\
    \ and assignment files for Assignment 233, the Verilog course.\n\n## Contents\n\
    \n- testbenches\n  + testbench.c\n- assignment233\n  + examples\n    - example.v\n\
    \  + testbenches\n    - wire_assign_test.v\n  + testbenches\n    - wire_assign_test_2.v\n\
    \  + testbenches\n    - wire_assign_test_3.v\n  + testbenches\n    - wire_assign_test_4.v\n\
    \  + testbenches\n    - wire_assign_test_5.v\n/assignment"
- code: "// Create a module with one input and one output that behaves like a wire\n\
    module wire_assign( input in, output bit out );\n    assign out = in;\nendmodule\n\
    ### Test:\n// Create a net of bit type with 1 bit, read it out\nbit net_bit;\n\
    wire_assign #(.out(net_bit)) wire_mod(.in(1'b1));\n### Test Result:\nnet_bit =\
    \ 1'b1\n/examples/examples/wiring/mux_2to1_2aout_2_var.c\n// Name: Multiplexer\
    \ 2:1 2A:2 Out 2 Var\n// Description: This example shows how to make a 2:1 mux\
    \ with 2 inputs and 2 outputs\n//              and how to use the mux as a 2nd\
    \ order variable\n// Author: \n// Date: 7/1/2017\n\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <math.h>\n\n// This defines a struct to hold all the 2nd\
    \ order var information\ntypedef struct var_2nd\n{\n    const char* name;\n  \
    \  void* address;\n    double value;\n    double derivative;\n    double integral;\n\
    \    double error;\n    double last_error;\n    double out;\n    double threshold_low;\n\
    \    double threshold_high;\n    // This is a pointer to a function that is called\
    \ whenever the value of the var changes\n    void(*callback1)(void);\n    void(*callback2)(void);\n\
    \n} struct_2nd;\n\n// Global variables\nstruct_2nd my_var1;\nstruct_2nd my_var2;\n\
    struct_2nd my_var3;\nstruct_2nd my_var4;\n\n\n// This function gets called when\
    \ the value of my_var1 changes\nvoid var_change1()\n{\n    //printf(\"my_var1:\
    \ %lf\\n\", my_var1.value);\n}\n\n// This function gets called when the value\
    \ of my_var2 changes\nvoid var_change2()\n{\n    //printf(\"my_var2: %lf\\n\"\
    , my_var2.value);\n}\n\n\n// This function gets called when the value of my_var3\
    \ changes\nvoid var_change3()\n{\n    //printf(\"my_var3: %lf\\n\", my_var3.value);\n\
    }\n\n// This function gets called when the value of my_var4 changes\nvoid var_change4()\n\
    {\n    //printf(\"my_var4: %lf\\n\", my_var4.value);\n}\n\n\n\n// This is the\
    \ 2:1 mux module\nvoid mux_2to1_2aout_2_var(double* a1, double* a2, double* out1,\
    \ double* out2)\n{\n    double a = *a1;\n    double b = *a2;\n    *out1 = a;\n\
    \    *out2 = b;\n}\n\n// Main function\nint main()\n{\n    // Initialize the variables\n\
    \    my_var1.address = &a1;\n    my_var1.value = 100;\n    my_var1.name = \"a1\"\
    ;\n    my_var1.callback1 = var_change1;\n\n    my_var2.address = &a2;\n    my_var2.value\
    \ = 100;\n    my_var2.name = \"a2\";\n    my_var2.callback2 = var_change2;\n\n\
    \    my_var3.address = &a3;\n    my_var3.value = 100;\n    my_var3.name = \"a3\"\
    ;\n    my_var3.callback3 = var_change3;\n\n    my_var4.address = &a4;\n    my_var4.value\
    \ = 100;\n    my_var4.name = \"a4\";\n    my_var4.callback4 = var_change4;\n\n\
    \    // Main loop\n    while(1)\n    {\n        // Read in the values\n      \
    \  double a1 = *(double*)my_var1.address;\n        double a2 = *(double*)my_var2.address;\n\
    \        double a3 = *(double*)my_var3.address;\n        double a4 = *(double*)my_var4.address;\n\
    \n        // Get out1 and out2 from the mux\n        double out1;\n        double\
    \ out2;\n        mux_2to1_2aout_2_var(&a1, &a2, &out1, &out2);\n\n        // Output\
    \ the values\n        printf(\"a1: %lf\\n\", a1);\n        printf(\"a2: %lf\\\
    n\", a2);\n        printf(\"a3: %lf\\n\", a3);\n        printf(\"a4: %lf\\n\"\
    , a4);\n        printf(\"out1: %lf\\n\", out1);\n        printf(\"out2: %lf\\\
    n\", out2);\n\n        // Wait 1 second\n        sleep(1);\n    }\n}\n/examples/examples/wiring/mux_2to1_2bout_2_var.c\n\
    // Name: Multiplexer 2:1 2B:2 Out 2 Var\n// Description: This example shows how\
    \ to make a 2:1 mux with 2 inputs and 2 outputs\n//              and how to use\
    \ the mux as a 2nd order variable\n// Author: \n// Date: 7/1/2017\n\n#include\
    \ <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// This defines a struct\
    \ to hold all the 2nd order var information\ntypedef struct var_2nd\n{\n    const\
    \ char* name;\n    void* address;\n    double value;\n    double derivative;\n\
    \    double integral;\n    double error;\n    double last_error;\n    double out;\n\
    \    double threshold_low;\n    double threshold_high;\n    // This is a pointer\
    \ to a function that is called whenever the value of the var changes\n    void(*callback1)(void);\n\
    \    void(*callback2)(void);\n\n} struct_2nd;\n\n// Global variables\nstruct_2nd\
    \ my_var1;\nstruct_2nd my_var2;\nstruct_2nd my_var3;\nstruct_2nd my_var4;\n\n\n\
    // This function gets called when the value of my_var1 changes\nvoid var_change1()\n\
    {\n    //printf(\"my_var1: %lf\\n\", my_var1.value);\n}\n\n// This function gets\
    \ called when the value of my_var2 changes\nvoid var_change2()\n{\n    //printf(\"\
    my_var2: %lf\\n\", my_var2.value);\n}\n\n\n// This function gets called when the\
    \ value of my_var3 changes\nvoid var_change3()\n{\n    //printf(\"my_var3: %lf\\\
    n\", my_var3.value);\n}\n\n// This function gets called when the value of my_var4\
    \ changes\nvoid var_change4()\n{\n    //printf(\"my_var4: %lf\\n\", my_var4.value);\n\
    }\n\n\n\n// This is the 2:1 mux module\nvoid mux_2to1_2bout_2_var(double* b1,\
    \ double* b2, double* out1, double* out2)\n{\n    double b = *b1;\n    double\
    \ c = *b2;\n    *out1 = b;\n    *out2 = c;\n}\n\n// Main function\nint main()\n\
    {\n    // Initialize the variables\n    my_var1.address = &b1;\n    my_var1.value\
    \ = 100;\n    my_var1.name = \"b1\";\n    my_var1.callback1 = var_change1;\n\n\
    \    my_var2.address = &b2;\n    my_var2.value = 100;\n    my_var2.name = \"b2\"\
    ;\n    my_var2.callback2 = var_change2;\n\n    my_var3.address = &b3;\n    my_var3.value\
    \ = 100;\n    my_var3.name = \"b3\";\n    my_var3.callback3 = var_change3;\n\n\
    \    my_var4.address = &b4;\n    my_var4.value = 100;\n    my_var4.name = \"b4\"\
    ;\n    my_var4.callback4 = var_change4;\n\n    // Main loop\n    while(1)\n  \
    \  {"
- code: module add
- code: "```SystemVerilog\nmodule wire_array_output_input_3( input wire [4:0] in[4:0],\
    \ output wire [6:0] out[6:0] );\n    assign out[0:1] = in[0:1];\nendmodule\n\n\
    ```\n/Project 3/code/main.c\n/* File: main.c\n * Description: \n *      Main function\
    \ for program.\n *      Reads the command line arguments and calls corresponding\
    \ functions.\n * Parameters:\n *      argc: argument count\n *      argv: argument\
    \ vector\n * Return:\n *      EXIT_SUCCESS: success\n *      EXIT_FAILURE: failure\n\
    \ */\n\n#include \"mystring.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include\
    \ <time.h>\n#include <string.h>\n#include \"bstree.h\"\n\n\nint main( int argc,\
    \ char* argv[] )\n{\n    // check to see if user entered correct number of arguments\n\
    \    if( argc!= 2 )\n    {\n        printf( \"Usage:./main input_file_name\\n\"\
    \ );\n        return EXIT_FAILURE;\n    }\n\n    // set the seed\n    srand( time(\
    \ NULL ) );\n\n    // declare variables\n    FILE* inputFile;\n    char inputFileName[100];\n\
    \    char command;\n    char* commandInput;\n    long long commandNumber;\n  \
    \  FILE* outputFile;\n    char outputFileName[100];\n\n    // open the input file\n\
    \    strcpy( inputFileName, argv[1] );\n    inputFile = fopen( inputFileName,\
    \ \"r\" );\n\n    // if the input file does not open, display error message to\
    \ user\n    if( inputFile == NULL )\n    {\n        printf( \"Cannot open file:\
    \ %s\\n\", inputFileName );\n        return EXIT_FAILURE;\n    }\n\n    // get\
    \ the output file name from user\n    printf( \"Please enter the name of the output\
    \ file:\\n\" );\n    scanf( \" %s\", outputFileName );\n\n    // open the output\
    \ file\n    outputFile = fopen( outputFileName, \"w\" );\n\n    // check if the\
    \ output file can be opened\n    if( outputFile == NULL )\n    {\n        printf(\
    \ \"Cannot open file: %s\\n\", outputFileName );\n        return EXIT_FAILURE;\n\
    \    }\n\n    // parse the commands in the input file\n    while( fscanf( inputFile,\
    \ \" %c %lld\", &command, &commandNumber )!= EOF )\n    {\n        // call parse_command\
    \ function\n        parse_command( command, commandNumber, outputFile );\n   \
    \ }\n\n    // close all of the files\n    fclose( inputFile );\n    fclose( outputFile\
    \ );\n\n    // return success\n    return EXIT_SUCCESS;\n}\n\n/* Function: parse_command\n\
    \ * Description: \n *      Reads and parses the command from the input file.\n\
    \ * Parameters:\n *      command: the command that is to be parsed\n *      commandNumber:\
    \ the number associated with the command\n *      outputFile: the output file\n\
    \ * Return:\n *      void\n */\nvoid parse_command( char command, long long commandNumber,\
    \ FILE* outputFile )\n{\n    // switch statement determines which function to\
    \ call\n    switch( command )\n    {\n        // case to create a new tree\n \
    \       case 'C':\n            // create new tree\n            create_tree( commandNumber,\
    \ outputFile );\n            break;\n\n        // case to insert a new node into\
    \ the tree\n        case 'I':\n            // insert a new node into the tree\n\
    \            insert_node( commandNumber, outputFile );\n            break;\n\n\
    \        // case to search for a node in the tree\n        case 'S':\n       \
    \     // search for a node in the tree\n            search_tree( commandNumber,\
    \ outputFile );\n            break;\n\n        // case to delete a node from the\
    \ tree\n        case 'D':\n            // delete a node from the tree\n      \
    \      delete_node( commandNumber, outputFile );\n            break;\n\n     \
    \   // case to destroy the tree\n        case 'K':\n            // destroy the\
    \ tree\n            destroy_tree( commandNumber );\n            break;\n\n   \
    \     // default\n        default:\n            // return a failure response\n\
    \            fprintf( outputFile, \"Please enter a valid command.\\n\" );\n  \
    \          break;\n    }\n}\n\n/* Function: create_tree\n * Description: \n *\
    \      Creates a new binary search tree and sets min and max to the given number.\n\
    \ * Parameters:\n *      commandNumber: the number that is to be used for min/max\n\
    \ *      outputFile: the output file\n * Return:\n *      void\n */\nvoid create_tree(\
    \ long long commandNumber, FILE* outputFile )\n{\n    // create a new tree\n \
    \   root = new_bstree( commandNumber );\n\n    // set min and max to the given\
    \ number\n    min = commandNumber;\n    max = commandNumber;\n\n    // return\
    \ a success response\n    fprintf( outputFile, \"New tree created.\\n\" );\n}\n\
    \n/* Function"
- code: |-
    use vcs_sopc.cpp
    module XOR_Gate(
        input logic [1:0] A [0:3], B,
        output logic Y
    );
        assign Y = A ^ B;
    endmodule
    ### Simulation Results:
    ![image](https://user-images.githubusercontent.com/75221133/129497250-c2e40e8c-c63c-4323-8127-7c6762e0c181.png)
    ### Verilog Code:
    // Verilog code for Problem 4
    module XOR_Gate(
        input A, B,
        output Y
    );
        assign Y = A ^ B;
    endmodule
    ### Variation Instruction
- code: "// Verilog code for Problem 4\nmodule XOR_Gate_Wildcard(\n    input [1:0]\
    \ A [*], B [*],\n    output [1:0] Y [*]\n);\n    assign Y = A ^ B;\nendmodule\n\
    \"\"\"\n\nfrom sys import maxsize\n\nclass Variation:\n    def __init__(self,\
    \ code_line):\n        self.code_line = code_line\n        self.code_id = self.code_line.split(\"\
    \ \")[2]\n        self.code_variation_type = self.code_line.split(\"  \")[1].replace(\"\
    ,\", \" \").strip()\n        self.code_explanation = self.code_line.split(\" \
    \ \")[2].strip()\n        self.code_modified_code = self.code_line.split(\"  \"\
    )[3].strip()\n        self.variable_name = self.code_line.split(\"  \")[4].strip()\n\
    \        self.variable_range = self.code_line.split(\"  \")[5].strip()\n     \
    \   self.variable_range_range = self.code_line.split(\"  \")[6].strip()\n    \
    \    if(len(self.code_line.split(\" \")) > 7):\n            self.variable_range_range_range\
    \ = self.code_line.split(\"  \")[7].strip()\n        else:\n            self.variable_range_range_range\
    \ = \"None\"\n\n    def __str__(self):\n        return \"id: \" + self.code_id\
    \ + \"\\nVariation Type: \" + self.code_variation_type + \"\\nExplanation: \"\
    \ + self.code_explanation + \"\\nModified Code: \" + self.code_modified_code +\
    \ \"\\nVariable Name: \" + self.variable_name + \"\\nVariable Range: \" + self.variable_range\
    \ + \"\\nVariable Range Range: \" + self.variable_range_range + \"\\nVariable\
    \ Range Range Range: \" + self.variable_range_range_range + \"\\n\\n\"\n\nif __name__\
    \ == \"__main__\":\n    variations = []\n    for line in open(\"verilog.txt\"\
    ):\n        if line!= \"\\n\":\n            variations.append(Variation(line))\n\
    \n    num_variations = len(variations)\n\n    max_id = 0\n    max_id_index = 0\n\
    \    for i in range(num_variations):\n        if variations[i].code_id > max_id:\n\
    \            max_id = variations[i].code_id\n            max_id_index = i\n\n\
    \    min_id = maxsize\n    min_id_index = 0\n    for i in range(num_variations):\n\
    \        if variations[i].code_id < min_id:\n            min_id = variations[i].code_id\n\
    \            min_id_index = i\n\n    print(\"Max ID: \" + str(max_id) + \" at\
    \ Index: \" + str(max_id_index) + \" Variation: \" + variations[max_id_index].code_variation_type)\n\
    \    print(\"Min ID: \" + str(min_id) + \" at Index: \" + str(min_id_index) +\
    \ \" Variation: \" + variations[min_id_index].code_variation_type)\n\n    for\
    \ variation in variations:\n        print(variation)\n\n    \n/src/main.rs\nuse\
    \ std::env;\nuse std::fs::File;\nuse std::io::Read;\n\nmod problem1;\nmod problem2;\n\
    mod problem3;\nmod problem4;\n\nfn main() -> std::io::Result<()> {\n    let args:\
    \ Vec<String> = env::args().collect();\n    \n    let file_name = &args[1];\n\
    \    let file = File::open(file_name)?;\n\n    let mut file_contents = String::new();\n\
    \    file.read_to_string(&mut file_contents)?;\n\n    let problem_type = match\
    \ file_name {\n        \"Problem01\" => \"Problem1\",\n        \"Problem02\" =>\
    \ \"Problem2\",\n        \"Problem03\" => \"Problem3\",\n        \"Problem04\"\
    \ => \"Problem4\",\n        _ => \"None\",\n    };\n\n    if problem_type!= \"\
    None\" {\n        let problem_func = match problem_type {\n            \"Problem1\"\
    \ => problem1::problem1,\n            \"Problem2\" => problem2::problem2,\n  \
    \          \"Problem3\" => problem3::problem3,\n            \"Problem4\" => problem4::problem4,\n\
    \            _ => \"None\",\n        };\n\n        let file_content_lines = file_contents.lines().collect::<Vec<&str>>();\n\
    \        for i in 0..file_content_lines.len() {\n            let file_line = file_content_lines.get(i).unwrap();\n\
    \            if file_line.to_string().starts_with(\"### Base Verilog Code:\")\
    \ {\n                match problem_func(&file_contents.replace(file_line, \"\"\
    ), &file_name, i) {\n                    Ok(_) => {}\n                    Err(_)\
    \ => {}\n                };\n            } else if file_line.to_string().starts_with(\"\
    ### Variation Instruction:\") {\n                match problem_func(&file_contents.replace(file_line,\
    \ \"\"), &file_name, i) {\n                    Ok(_) => {}\n                 \
    \   Err(_) => {}\n                };\n            }\n        }\n    }\n\n    Ok(())\n\
    }\n\n/*\n// Verilog code for Problem 1\nmodule Problem1(\ninput A0_0, A0_1, A0_2,\
    \ A0_3, A1_0, A1_1, A1_2, A1_3, A2_0, A2_1, A2_2, A2_3, A3_0, A3_1, A3_2, A3_3,\
    \ B0_0, B0_1, B0_2, B0_3, B1_0, B1_1, B1_2, B1_3, B2_0, B2_1, B2_2, B2_3, B3_0,\
    \ B3_1, B3_2, B3_3,\noutput C0_0, C0_1, C0_2, C0_3, C1_0, C1_1, C1_2, C1_3, C2_0,\
    \ C2_1, C2_2, C2_3, C3_0, C3_1, C3_2, C3_3\n);\nalways_comb begin\nC0_0 = A0_0&\
    \ (~A1_0);\nC0_1 = A0_1& (~A1_1);\nC0_2 = A0_2& (~A1_2);\nC0_3 = A0_3& (~A1_3);\n\
    C1_0 = A1_0& (~A0_0);\nC1_1 = A1_1& (~A0_1);\nC1_2 = A1_2& (~A0_2);\nC1_3 = A1_3&\
    \ (~A0_3);\nC2_0 = A2_0& (~A3_0);\nC2_1 = A2_1& (~A3_1);\nC2_2 = A2_2& (~A3_2);\n\
    C2_3 = A2_3& (~A3_3);\nC3_0 = A3_0& (~A2_0);\nC3_1 = A3_1& (~A2_1);\nC3_2 = A3_2&\
    \ (~A2_2);\nC3_3 = A3_3& (~A2_3);\nend\nendmodule\n// Problem 2\nmodule Problem2(\n\
    input A0_0, A0_1, A0_2, A0_3, A1_0, A1_1, A1_2, A1_3, A2_0, A2_1, A2_2, A2_3,\
    \ A3_0, A3_1, A3_2, A3_3, B0_0, B0_1, B0_2, B0_3, B1_0, B1_1, B1_2, B1_3, B2_0,\
    \ B2_1, B2_2, B2_3, B3_0, B3_1, B3_2, B3_3,\noutput Y\n);\nassign Y = ~A0_0& (~A0_1&\
    \ (~A0_2& (~A0_3))) & (~A1_0& (~A1_1& (~A1_2& (~A"
- code: Verilog code for
- code: |-
    // Verilog code for Problems 5
    // modified to use a
- code: |-
    // Verilog code for Problem 3
    module Not_Gate(
        input A [0:3],
        output Y
    );
        assign Y = ~A[0:3];
    endmodule
    ### Verilog Testbench:
    // Verilog testbench code for Problem 3
    module Not_tb;
        logic A [0:3];
        assign A = {A[1:0]};
        Not_Gate not_gate(A);
        initial begin
            forever A = {A[1:0]};
            #10;
        end
    endmodule
    ### Result:
    // Problem 3: Verilog Testbench Result
    ![alt text](../results/Not_tb.png "Not tb")
    ### Comments:
    The above test bench shows that the output Y is the NOT of the input A.
- code: |-
    // Verilog code for Problem 1
    module Four_to_One_Multiplexer(
        input [1:0] I,
        output Y
    );
        wire temp;
        assign temp = I[1] || I[0];
        assign Y = temp;
    endmodule/Lab_3/MultiPlexer_Problem_4_1D.c
    // Verilog code for Problem 4 (1D)
    // Modified to use a 5-input OR gate instad of a 5-bit variable
    module MultiPlexer(
        input [4:0] I, S,
        output Y
    );
        wire temp, output;
        // Generate temp
        temp = I[S];
        // Generate output
        assign output = temp;
        assign Y = output;
    endmodule/README.md
    # ENGR_202_Lab_Design
    This repository contains the lab designs for ENGR 202 Fall 2020 at Cal Poly Pomona.
- code: |-
    // Verilog code for Problem 17
    module XNOR_Gate(
        input logic [1:0] A, B,
        output logic Y
    );
        assign Y = ~(A ^ B);
    endmodule
    ###
- code: "-module AND_Gate(\n-   input A, B,\n-    output Y\n-);\n-    logic [1:0]\
    \ A [0:3];\n-    assign Y = A[0] & A[1] & A[2] & A[3];\n-endmodule\n+\n+module\
    \ AND_Gate(\n+    input A, B,\n+    output Y\n+);\n+    logic [1:0] A [0:3];\n\
    +    assign Y = A[0] & A[1] & A[2] & A[3];\n+endmodule\n \n module OR_Gate(\n\
    \     input A, B,\n     output Y\n );\n-    logic [1:0] A [0:3];\n-    assign\
    \ Y = A[0] & A[1] & A[2] & A[3];\n+    logic [1:0] A [0:3];\n+    assign Y = A[0]\
    \ | A[1] | A[2] | A[3];\n endmodule\n \n module NOT_Gate(\n     input A,\n   \
    \  output Y\n );\n-    logic [1:0] A [0:3];\n-    assign Y = A[0] & A[1] & A[2]\
    \ & A[3];\n+    logic [1:"
- code: "// Verilog code for Problem 5\nmodule XOR_8_Gate(\n    input logic [3:0]\
    \ A [0:3],\n    logic [7:0] B,\n    output logic [3:0] Y [0:3]\n);\n\nparameter\
    \ SIZE = 4;\n\ninitial begin\n    for(int i = 0; i < SIZE; i++)\n        Y[i]\
    \ = (A[i] ^ B[i]);\nendmodule\n### Test for 3-bit inputs:\n\n```verilog\nXOR_8_Gate\
    \ a(\n\t.A(4'b0000),\n\t.B(4'b0000),\n\t.Y(4'b0000)\n);\n\nXOR_8_Gate b(\n\t.A(4'b0011),\n\
    \t.B(4'b0011),\n\t.Y(4'b0000)\n);\n\nXOR_8_Gate c(\n\t.A(4'b0110),\n\t.B(4'b0101),\n\
    \t.Y(4'b1011)\n);\n\n\nXOR_8_Gate d(\n\t.A(4'b0101),\n\t.B(4'b0110),\n\t.Y(4'b1011)\n\
    );\n```\n/Lectures/04_Verilog_I/02_Verilog_07/ex_module_1/ex_module_1.md\n# Verilog\
    \ Modules\n\n## Problem 1\n### Base Verilog Code:\n\n// Verilog code for ex_module_1\n\
    module ex_module_1(\n    input logic A, \n    input logic B,\n    output logic\
    \ Y\n);\n\t// Module body\nendmodule\n\n### Variation Instruction:\nModify the\
    \ parameters of the module. What happens when you change parameter values for\
    \ different module instantiations?\n\n### Modified Code:  \n// Verilog code for\
    \ ex_module_1\nmodule ex_module_1(\n    input logic A, \n    input logic B,\n\
    \    output logic Y,\n    parameter PARAM1,\n    parameter PARAM2\n);\n\t// Module\
    \ body\nendmodule\n### Test:\n```verilog\nex_module_1 a(.PARAM1(2'b11),.PARAM2(2'b11));\n\
    ex_module_1 b(.PARAM1(2'b00),.PARAM2(2'b00));\nex_module_1 c(.PARAM1(2'b10),.PARAM2(2'b10));\n\
    ex_module_1 d(.PARAM1(2'b11),.PARAM2(2'b01));\n```\n\n## Problem 2\n### Base Verilog\
    \ Code:\n\n// Verilog code for ex_module_1\nmodule ex_module_1(\n    input logic\
    \ A, \n    input logic B,\n    output logic Y\n);\n\t// Module body\nendmodule\n\
    \n### Variation Instruction:\nModify the parameters of the module. What happens\
    \ when you change parameter values for different module instantiations?\n\n###\
    \ Modified Code:  \n// Verilog code for ex_module_1\nmodule ex_module_1(\n   \
    \ input logic A, \n    input logic B,\n    output logic Y,\n    parameter PARAM_A,\n\
    \    parameter PARAM_B,\n    parameter PARAM_Y\n);\n\t// Module body\nendmodule\n\
    ### Test:\n```verilog\nex_module_1 a(.PARAM_A(2'b11),.PARAM_B(2'b11),.PARAM_Y(2'b11));\n\
    ex_module_1 b(.PARAM_A(2'b00),.PARAM_B(2'b00),.PARAM_Y(2'b00));\nex_module_1 c(.PARAM_A(2'b10),.PARAM_B(2'b10),.PARAM_Y(2'b10));\n\
    ex_module_1 d(.PARAM_A(2'b11),.PARAM_B(2'b01),.PARAM_Y(2'b01));\n```\n\n## Problem\
    \ 3\n### Base Verilog Code:\n\n// Verilog code for ex_module_1\nmodule ex_module_1(\n\
    \    input logic A, \n    input logic B,\n    output logic Y\n);\n\t// Module\
    \ body\nendmodule\n\n### Variation Instruction:\nModify the parameters of the\
    \ module. What happens when you change parameter values for different module instantiations?\n\
    \n### Modified Code:  \n// Verilog code for ex_module_1\nmodule ex_module_1(\n\
    \    input logic A, \n    input logic B,\n    output logic Y,\n    parameter PARAM_A\
    \ = 'X,\n    parameter PARAM_B = 'X,\n    parameter PARAM_Y = 'X\n);\n\t// Module\
    \ body\nendmodule\n### Test:\n```verilog\nex_module_1 a(.PARAM_A(2'b11),.PARAM_B(2'b11),.PARAM_Y(2'b11));\n\
    ex_module_1 b(.PARAM_A(2'b00),.PARAM_B(2'b00),.PARAM_Y(2'b00));\nex_module_1 c(.PARAM_A(2'b10),.PARAM_B(2'b10),.PARAM_Y(2'b10));\n\
    ex_module_1 d(.PARAM_A(2'b11),.PARAM_B(2'b01),.PARAM_Y(2'b01));\n```\n\n## Problem\
    \ 4\n### Base Verilog Code:\n\n// Verilog code for ex_module_1\nmodule ex_module_1(\n\
    \    input logic A, \n    input logic B,\n    output logic Y\n);\n\t// Module\
    \ body\nendmodule\n### Variation Instruction:\nModify the parameters of the module.\
    \ What happens when you change parameter values for different module instantiations?\n\
    \n### Modified Code:  \n// Verilog code for ex_module_1\nmodule ex_module_1(\n\
    \    input logic A, \n    input logic B,\n    output logic Y,\n    parameter PARAM_A\
    \ = 'X,\n    parameter PARAM_B = 'X,\n    parameter PARAM_Y = 'X,\n    parameter\
    \ PARAM_SIZE = 1\n);\n\t// Module body\nendmodule\n### Test:\n```verilog\nex_module_1\
    \ a(.PARAM_A(2'b11),.PARAM_B(2'b11),.PARAM_Y(2'b11));\nex_module_1 b(.PARAM_A(2'b00),.PARAM_B(2'b00),.PARAM_Y(2'b00));\n\
    ex_module_1 c(.PARAM_A(2'b10),.PARAM_B(2'b10),.PARAM_Y(2'b10));\nex_module_1 d(.PARAM_A(2"
- code: |-
    // Verilog code for Problem 4
    // module XOR_Gate_Array(
    //     input A, B,
    //     output Y
    // );
    //     logic [3]A ; // Packing 4 bits for A
    //     logic [3]B ; // Packing 4 bits for B
    //     logic [3]Y ; // Packing 4 bits for Y
    //     assign Y = A ^ B;
    // endmodule

    module XOR_Gate_Array_1D(
        input [1:0]A, B,
        output Y
    );
        assign Y = A ^ B;
    endmodule

    module XOR_Gate_Array_2D(
        input [1:0]A, [1:0]B,
        output Y
    );
        assign Y = A ^ B;
    endmodule

    module XOR_Gate_Array_3D(
        input [1:0]A, [1:0]B, [1:0]C,
        output Y
    );
        assign Y = A ^ B ^ C;
    endmodule

    module XOR_Gate_Array_4D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D,
        output Y
    );
        assign Y = A ^ B ^ C ^ D;
    endmodule

    module XOR_Gate_Array_5D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E;
    endmodule

    module XOR_Gate_Array_6D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F;
    endmodule

    module XOR_Gate_Array_7D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G;
    endmodule

    module XOR_Gate_Array_8D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H;
    endmodule

    module XOR_Gate_Array_9D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I;
    endmodule

    module XOR_Gate_Array_10D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J;
    endmodule

    module XOR_Gate_Array_11D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K;
    endmodule

    module XOR_Gate_Array_12D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L;
    endmodule

    module XOR_Gate_Array_13D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L, [1:0]M,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L ^ M;
    endmodule

    module XOR_Gate_Array_14D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L, [1:0]M, [1:0]N,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L ^ M ^ N;
    endmodule

    module XOR_Gate_Array_15D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L, [1:0]M, [1:0]N, [1:0]O,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L ^ M ^ N ^ O;
    endmodule

    module XOR_Gate_Array_16D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L, [1:0]M, [1:0]N, [1:0]O, [1:0]P,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L ^ M ^ N ^ O ^ P;
    endmodule

    module XOR_Gate_Array_17D(
        input [1:0]A, [1:0]B, [1:0]C, [1:0]D, [1:0]E, [1:0]F, [1:0]G, [1:0]H, [1:0]I, [1:0]J, [1:0]K, [1:0]L, [1:0]M, [1:0]N, [1:0]O, [1:0]P, [1:0]Q,
        output Y
    );
        assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H ^ I ^ J ^ K ^ L ^ M ^ N ^ O ^ P ^ Q;
    endmodule

    module XOR_Gate_Array_1
- code: |-
    module test;

    packed my_struct;
    reg x, y, z;
    my_struct my_struct_packed;

    assign my_struct_packed.x = x;
    assign my_struct_packed.y = y;
    assign my_struct_packed.z = z;

    always begin
        x = my_struct_packed.x;
        y = my_struct_packed.y;
        z = my_struct_packed.z;
    end
    endmodule


    ## References

    https://stackoverflow.com/questions/25534700/verilog-pack-unpack-module
    https://hackaday.com/2013/05/23/struct-packing-in-vhdl/
    https://stackoverflow.com/questions/63420878/how-to-define-a-packed-structure-in-verilog
    https://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_1/ug476-verilog-ps.pdf

    ### Additional Resources

    https://www.edaplayground.com/x/Q2a

    ## Summary
    /Lab4/lab4.md
    # Lab 4

    ## Introduction

    This lab covers the basics of signal processing in Verilog by looking at the use of D flip flops and combinatorial logic to control it. It will be explored in detail the use of a clock and its effect on the simulation of Verilog based on the input waveforms provided.

    ## Materials

    You will need:

    * 1x Bread Board
    * 1x Hspice software with sample input waveforms from project

    ## Setup

    1. Use the sample input waveforms from the project to load into Hspice.
    2. Select simulation in Project Manager

    ## Task

    - Explain the operation of the D flipflop and its different modes of behavior.

    For D flip-flop, there are 5 modes of behavior.

    - 00: T0 = 0; T1 = 0
    - 01: T0 = 0; T1 = 1
    - 10: T0 = 1; T1 = 0
    - 11: T0 = 1; T1 = 1
    - Z:   Always 0

    - Explain the operation of the D flipflop and its different modes of behavior.

    - Explain the operation of the D flipflop and its different modes of behavior.

    - Explain the operation of the D flipflop and its different modes of behavior.

    ## Resources

    https://www.edaplayground.com/x/J3P

    ## Summary

    This lab covers the basics of signal processing in Verilog by looking at the use of D flip flops and combinatorial logic to control it. It will be explored in detail the use of a clock and its effect on the simulation of Verilog based on the input waveforms provided.
    /Lab2/Lab2.md
    # Lab 2:

    ## Introduction

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.

    ## Materials

    You will need:

    * 1x Bread Board
    * 1x Hspice software with sample input waveforms from project

    ## Setup

    1. Use the sample input waveforms from the project to load into Hspice.
    2. Select simulation in Project Manager

    ## Task

    For all parts, use the simulator to verify your results.

    1. Create a module called "test" werived from the value of variable "a" at the time it is evaluated.

    (c)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (d)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (e)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (f)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (g)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (h)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    ## Resources

    [VHDL to Verilog Converter](https://www.edaplayground.com/x/K5r)

    ## Summary

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.
    ith a single wire output and input. Use a combination of combinatorial logic operators to implement the following logic function (use the truth-table):

    ![](https://assets.digitalocean.com/articles/vhdl_to_verilog/table1.JPG)

    - Write the test module in Verilog.
    - Verify in Hspice that:
      - The output is 1 whenever the inputs a & b are 1
      - The output is 0 whenever the inputs a & b are 0

    (a)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (b)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (c)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (d)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (e)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (f)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (g)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    (h)

    The value of this variable will change every time the clock rises. The integer value is incremented by one every time a 1 is detected.

    ## Resources

    ## Summary

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.

    ## Introduction

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.

    ## Materials

    You will need:

    * 1x Bread Board
    * 1x Hspice software with sample input waveforms from project

    ## Setup

    1. Use the sample input waveforms from the project to load into Hspice.
    2. Select simulation in Project Manager

    ## Task

    For all parts, use the simulator to verify your results.

    1. Create a module called "test" with a single wire output and input. Use a combination of combinatorial logic operators to implement the following logic function (use the truth-table):

    ![](https://assets.digitalocean.com/articles/vhdl_to_verilog/table1.JPG)

    - Write the test module in Verilog.
    - Verify in Hspice that:
      - The output is 1 whenever the inputs a & b are 1
      - The output is 0 whenever the inputs a & b are 0

    ## Resources

    ## Summary

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.

    ## Introduction

    This lab covers the basics of Verilog by looking at the fundamental building blocks of the hardware language. It will be explored in detail the use of variable declarations, integer arithmetic, arithmetic operators, conditionals, and loops.

    ## Materials

    You will need:

    * 1x Bread Board
    * 1x Hspice software with sample input waveforms from project

    ## Setup

    1. Use the sample input waveforms from the project to load into Hspice.
- code: "module test;\npacked mystruct;\nreg [7:0] a;\nassign #25 a = 1;\nassign #10\
    \ b = 1;\nalways begin\n    mystruct.a = #10 a;\nend\nendmodule\n\"\"\"\n\n\n\
    /README.md\n# VerilogVerse\n\nVerilogVerse is a tool developed to automatically\
    \ generate different variations of Verilog code files. The tool is implemented\
    \ using Python and relies on the SPARK (Systematic Parametric Verification) framework.\
    \ The tool has been tested on Linux.\n\n## Dependencies\n\n* SPARK\n    * SPARK\
    \ Tools\n* Python 3.6.6\n    * argparse\n    * xml (included in Python 3.6.6)\n\
    \    * importlib\n\n## Usage\n\n```\nusage: run.py [-h] [-b BASE] [-d DVAR] [-n\
    \ NUM] [-p PROTOCOL] [-o OUTPUT]\n\noptional arguments:\n  -h, --help        \
    \    show this help message and exit\n  -b BASE, --base BASE  Input file with\
    \ base Verilog code.\n  -d DVAR, --dvar DVAR  Input file with different variable\
    \ values.\n  -n NUM, --num NUM     Number of variations to be generated.\n  -p\
    \ PROTOCOL, --protocol PROTOCOL\n                        Input file with protocol\
    \ values.\n  -o OUTPUT, --output OUTPUT\n                        Output file with\
    \ generated variations.\n```\n\n## Example\n\n```\n$./run.py -b base.v -d dvar.v\
    \ -n 10 -p protocol.v -o output.v\n```\n\n## Code Generation\n\n* VerilogVerse\
    \ can generate variations of different components.\n* Two main components that\
    \ can be generated with VerilogVerse are:\n  * Wires\n  * Registers\n* Wires are\
    \ modified using packed structure.\n* Registers are modified using packed structure\
    \ along with modifying assignments.\n/scripts/generate_base_component.py\n#!/usr/bin/python3\n\
    \nimport argparse\nimport re\n\nparser = argparse.ArgumentParser(description='Verilog\
    \ Verse')\nparser.add_argument('-b', '--base', help='Input file with base Verilog\
    \ code.')\nparser.add_argument('-d', '--dvar', help='Input file with different\
    \ variable values.')\nparser.add_argument('-n', '--num', type=int, help='Number\
    \ of variations to be generated.')\nparser.add_argument('-p', '--protocol', help='Input\
    \ file with protocol values.')\nparser.add_argument('-o', '--output', help='Output\
    \ file with generated variations.')\n\nargs = parser.parse_args()\n\ncomponents\
    \ = ['wire','reg']\n\n# Read base code\nwith open(args.base, 'r') as base:\n\t\
    base_contents = base.readlines()\n\n# Read different variable values\ndvar_contents\
    \ = None\nwith open(args.dvar, 'r') as dvar:\n\tdvar_contents = dvar.readlines()\n\
    \n# Read protocol values\nprotocol_contents = None\nwith open(args.protocol, 'r')\
    \ as protocol:\n\tprotocol_contents = protocol.readlines()\n\n# Generate component\
    \ variations\nfor component in components:\n\tvariations = []\n\tcount = 0\n\n\
    \t# Get variations\n\tfor dvar_content in dvar_contents:\n\t\tdvar_"
- code: "module test;\nstruct data;\nreg a;\nregister data r1, r2, r3;\nassign #25\
    \ a = 1;\nassign r1.x = #10 a;\nassign r2.y = #10 r1.x;\nassign r3.z = #10 r2.y;\n\
    endmodule\n\nstruct data;\ninput x;\ninput [3:0] y;\ninput [4:0] z;\nendstruct\n\
    ### Resulting Verilog:\nmodule test;\nwire a;\nreg a;\nstruct data;\nregister\
    \ data r1, r2, r3;\nassign #25 a = 1;\nassign r1.x = #10 a;\nassign r2.y = #10\
    \ r1.x;\nassign r3.z = #10 r2.y;\nendmodule\n\nstruct data;\ninput x;\ninput [3:0]\
    \ y;\ninput [4:0] z;\nendstruct\n\nThe above code should result in the following\
    \ netlist:\n\n## Schematic Syntax\xB6\n\nThe following are the syntaxes for the\
    \ schematic languages.\n\n### XESS:\n\n##\n##         __  __  __     _       _\
    \     _   _       _\n##        |  \\/  |/ /    | |     (_)   | | (_)     | |\n\
    ##        | \\  / | |     | |      _ _ __| | _  __ _| |\n##        | |\\/| | |\
    \     | |     | | |__ | || / _| | |\n##        | |  | | |     | |     | | |  _||\
    \ || (_| | |\n##        |_|  |_| \\_____|_|     |_|_| |_|__(_)__,_|\\__|\n##\n\
    ##  Version 2.0 Copyright (c) XESS Corporation, 2016\n##  Author: \n##  XESS is\
    \ an open source hardware platform for digital logic synthesis.\n##  See http://www.xess.com\
    \ for more information.\n##\n##  This program is free software; you can redistribute\
    \ it and/or modify\n##  it under the terms of the GNU General Public License as\
    \ published by\n##  the Free Software Foundation; either version 2 of the License,\
    \ or\n##  (at your option) any later version.\n##\n##  This program is distributed\
    \ in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY; without even\
    \ the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\
    \  See the\n##  GNU General Public License for more details.\n##\n##  You should\
    \ have received a copy of the GNU General Public License\n##  along with this\
    \ program; if not, write to the Free Software\n##  Foundation, Inc., 59 Temple\
    \ Place, Suite 330,\n##  Boston, MA  02111-1307  USA\n##  ___________________________________________________________\n\
    ##  |                      XESS HDL                          |\n##  |  Copyright\
    \ (C) 2010 XESS Corporation, All Rights Reserved|\n##  |________________________________________________________|\n\
    ##\n\n##\n## XESS HDL 1.0\n##\n## This is a simple testbench.\n##\n##\nmodule\
    \ test;\nsignal a, b, c;\n\n##\n## Simple test to test some of the basics\n##\n\
    module test1;\ninput [15:0] a;\ninput [3:0] b;\ninput [5:0] c;\noutput reg [15:0]\
    \ d;\n\nmodule test2;\ninput [15:0] a;\ninput [3:0] b;\ninput [5:0] c;\noutput\
    \ reg [15:0] d;\n\nmodule test3;\n#10 a = 1;\n#20 b = 2;\n#30 c = 3;\noutput reg\
    \ [15:0] d;\n\nmodule test4;\n#10 a = 1;\n#20 b = 2;\n#30 c = 3;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test5;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test6;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test7;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test8;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test9;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test10;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test11;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test12;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test13;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test14;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test15;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test16;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test17;\noutput reg [15:0]\
    \ d;\n\n## Test of constants in the top level\nmodule test18;\noutput reg [15:0]\
    \ d;\n\nendmodule\n\nendmodule\n\n##\n## This is a test of the compiler.\n##\n\
    module test;\ninput a, b, c;\n\n##\n## The testbench\n##\nmodule test2;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test3;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test4;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test5;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test6;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test7;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test8;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test9;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test10;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test11;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test12;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test13;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test14;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test15;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test16;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test17;\ninput\
    \ a, b, c;\n\n##\n## This is a test of the compiler.\n##\nmodule test18;\ninput\
    \ a, b, c;\n\nendmodule\n\n##\n## The testbench\n##\nmodule test2;\ninput a, b,\
    \ c;\n\n##\n## The testbench\n##\nmodule test3;\ninput a, b, c;\n\n##\n## The\
    \ testbench\n##\nmodule test4;\ninput a, b, c;\n\n##\n## The testbench\n##\nmodule\
    \ test5;\ninput a, b, c;\n\n##\n## The testbench\n##\nmodule test6;\ninput a,\
    \ b, c;\n\n##\n## The testbench\n##\nmodule test7;\ninput a, b, c;\n\n##\n## The\
    \ testbench\n##\nmodule test8;\ninput a, b, c;\n\n##\n## The testbench\n##\nmodule\
    \ test9;\ninput a, b, c;\n\n##\n## The testbench\n##\nmodule test10;\ninput a,\
    \ b, c;\n\n##"
- code: |-
    ```
    module test(a, b);
    reg [1:0] a, b;
    wire c, d, e;
    always_ff : a_always
        c = a + b;
    end
    endmodule
- code: "```Verilog\nmodule test;\nwire a;\nreg y;\ninitial begin\n    #30 y, a =\
    \ 1;\nend\nendmodule\n```\n\n/Chapter1/README.md\n# Ch1. Synchronous Signal Flow/Chapter14/README.md\n\
    # Ch14. Blocking and Nonblocking Assignments/Chapter23/README.md\n# Ch23. 7 and\
    \ 8-bit Logic Comparisons/README.md\n# Verilog Design Examples\n\nExample Verilog\
    \ designs from the book: *Verilog HDL: A Practical Guide for Designers, Engineers,\
    \ and Architects* by **\n/Chapter15/README.md\n# Ch15. Comparison and Arithmetic\
    \ Operators/Chapter20/README.md\n# Ch20. Conditional and Blocking Assignment/Chapter4/README.md\n\
    # Ch4. Logic and Truth Values/Chapter20/ex_20_8.v\n\n// Verilog Code:\n// a 20-bit\
    \ unsigned integer is being multiplied with a 1-bit unsigned \n//   integer. The\
    \ result is being assigned to a 40-bit unsigned integer. \n//   Show the truth\
    \ table of the multiplied and assign statement.\nmodule test(a, b, c);\ninput\
    \ [19:0] a;\ninput b;\noutput [39:0] c;\nassign c = (a * b);\nendmodule\n\n/Chapter17/README.md\n\
    # Ch17. 2-Bit 1-Wire Shift Register/Chapter18/ex_18_7.v\n\n// Verilog Code:\n\
    // Write a verilog module that accepts two input signals, m and n, \n// and emits\
    \ a single output signal, out, that is 1 when the inputs \n// are equal, and 0\
    \ if the inputs differ.\nmodule test(m,n,out);\ninput m,n;\noutput out;\nassign\
    \ out = (m == n)? 1 : 0;\nendmodule\n\n/Chapter3/README.md\n# Ch3. Wire and Register\
    \ Declarations/Chapter19/README.md\n# Ch19. 3-Bit Arithmetic/Chapter16/README.md\n\
    # Ch16. 3-Bit Comparator/Chapter10/ex_10_5.v\n\n// Verilog Code:\n// Use the Verilog\
    \ conditional operator, the ternary operator,\n// or the built-in function, $min($value(v),\
    \ $value(w)) to find\n// the"
- code: |-
    module test;
    wire a;
    packed {
        reg x, y, z;
    } packed_signals;
    assign #25 a = 1;
    always begin
        packed_signals = pack(x, y, z);
    end
    endmodule
    ### Verilog-to-C:
    #include <stdio.h>

    #include <veriopt.h>

    #include <vpi_user.h>

    #include <vpi_vpi_user.h>

    #include <vpi_system.h>

    #define DEBUG_VPI 1

    void vpi_register_cb() {
        s_vpi_systf_data tf_data;
    #ifdef DEBUG_VPI
        printf("Registering callbacks...\n");
    #endif
    }

    int main() {
        int i, size, status;
        s_vpi_vlog_info *info;
        s_vpi_time tm;
        s_vpi_value value;
        s_vpi_value return_value;
        s_vpi_variable v;

        s_vpi_time *curr_time;
        s_vpi_time *start_time;
    #ifdef DEBUG_VPI
        printf("Starting callback testing...\n");
    #endif
        /*
         * Get the current time.
         */
        curr_time = vpi_cycle_delay();
    #ifdef DEBUG_VPI
        printf("Current time: %ld\n", curr_time->fs);
    #endif
        /*
         * Construct a time structure.
         */
        start_time = vpi_malloc(sizeof(s_vpi_time));
        start_time->type = vpiSysTime;
        start_time->fs = 1000;
    #ifdef DEBUG_VPI
        printf("Starting time (fs): %ld\n", start_time->fs);
    #endif
        /*
         * Set the current time to 1 second.
         */
        tm.type = vpiTime;
        tm.high = 0;
        tm.low = 1000;
    #ifdef DEBUG_VPI
        printf("Current time (fs): %ld\n", curr_time->fs);
    #endif
        status = vpi_set_value(vpi_handle, &tm);
        if (status!= 0) {
            printf("Error setting value\n");
        } else {
            printf("Set value to 1 second\n");
        }
        /*
         * Get the value of a variable "a" in the "test" module.
         */
        v = vpi_scan_id("a", vpi_handle);
        if (v == NULL) {
            printf("Cannot find variable a\n");
        } else {
            printf("Found variable %s\n", v->name);
        }
        value.format = vpiIntVal;
        value.value.integer = 1;
        vpi_put_value(v, &value, NULL, vpiNoDelay);
        return_value = vpi_get_value(v);
        if (vpi_get(v, &value)!= 0) {
            printf("Could not get value\n");
        } else {
            printf("Value (int): %d\n", value.value.integer);
        }
        /*
         * Get the current time.
         */
        status = vpi_get_time(vpi_handle, curr_time);

        value.format = vpiIntVal;

        for (i = 0; i < 3; i++) {
            printf("Time in cycle 100000000ns: %ld\n", curr_time->fs);

            /*
             * Get the value of a variable "a" in the "test" module.
             */
            v = vpi_scan_id("a", vpi_handle);
            if (v == NULL) {
                printf("Cannot find variable a\n");
            } else {
                printf("Found variable %s\n", v->name);
            }
            value.format = vpiIntVal;
            value.value.integer = 1;
            vpi_put_value(v, &value, NULL, vpiNoDelay);
            return_value = vpi_get_value(v);
            if (vpi_get(v, &value)!= 0) {
                printf("Could not get value\n");
            } else {
                printf("Value (int): %d\n", value.value.integer);
            }

    #ifdef DEBUG_VPI
            printf("Current time (fs): %ld\n", curr_time->fs);
    #endif
            /*
             * Get the value of a variable "a" in the "test" module.
             */
            v = vpi_scan_id("a", vpi_handle);
            if (v == NULL) {
                printf("Cannot find variable a\n");
            } else {
                printf("Found variable %s\n", v->name);
            }
            value.format = vpiIntVal;
            value.value.integer = 2;
            vpi_put_value(v, &value, NULL, vpiNoDelay);
            return_value = vpi_get_value(v);
            if (vpi_get(v, &value)!= 0) {
                printf("Could not get value\n");
            } else {
                printf("Value (int): %d\n", value.value.integer);
            }
            /*
             * Get the current time.
             */
            status = vpi_get_time(vpi_handle, curr_time);
    #ifdef DEBUG_VPI
            printf("Current time (fs): %ld\n", curr_time->fs);
    #endif
            value.format = vpiIntVal;
            value.value.integer = i;
            vpi_put_value(v, &value, NULL, vpiNoDelay);
            return_value = vpi_get_value(v);
            if (vpi_get(v, &value)!= 0) {
                printf("Could not get value\n");
            } else {
                printf("Value (int): %d\n", value.value.integer);
            }
        }
    #ifdef DEBUG_VPI
        printf("Finished callback testing...\n");
    #endif
    }/tests/c_compiler/verilog/test.c

    int main() {
      int a = 10;
      int b = 20;
      printf("sum is: %d\n", a+b);
      return 0;
    }
    (s_vpi_time*)vpi_malloc (sizeof(s_vpi_time));
      if (!time){
        return NULL;
      }

      time->type = vpiSysTime;
      time->fs = curr_time->fs + time_incr;
      return time;
    }
    /src/utils/sysc.c
    /*
     * Copyright 2013-2016 Odroid.in, Inc.
     *  <>
     */

    #include <stdlib.h>
    #include <stdio.h>
    #include <veriopt.h>
    #include <string.h>
    #include <vpi_user.h>
    #include <vpi_vpi_user.h>
    #include <vpi_system.h>
    #include <vpi_systypes.h>
    #include <sysc.h>

    s_vpi_time* curr_time(void) {
      static s_vpi_time* time;
      static int first_time = 1;

      if (first_time){
        first_time = 0;
        time = (s_vpi_time*)vpi_malloc (sizeof(s_vpi_time));
        if (!time){
          return NULL;
        }

        time->type = vpiSysTime;
        time->fs = 1;
      }
      return time;
    }

    s_vpi_time* delay_time(s_vpi_time* curr_time, int time_incr) {
      static s_vpi_time* time;
      if (!curr_time){
        return NULL;
      }

      time = (s_vpi_time*)vpi_malloc (sizeof(s_vpi_time));
      if (!time){
        return NULL;
      }

      time->type = vpiSysTime;
      time->fs = curr_time->fs + time_incr;
      return time;
    }

    s_vpi_time* delay_time_ns(s_vpi_time* curr_time, int time_incr) {
      static s_vpi_time* time;
      if (!curr_time){
        return NULL;
      }

      time = /src/verilog/verilog_main.c
    /*
     * Copyright 2013-2015 Odroid.in, Inc.
     *  <>
     */
    #include <stdlib.h>
    #include <veriopt.h>
    #include <vpi_user.h>
    #include <string.h>
    #include <vpi_vpi_user.h>
- code: |-
    module test;
    pack mypack;
    reg mypack.x
- code: "module test;\npacked struct pack struct\n    {\n    wire a;\n    reg x;\n\
    \    reg y;\n    reg z;\n    }\n    pack_inst;\nreg packed pack_struct;\n\nassign\
    \ #25 (pack_inst.a) = 1;\nalways begin\n    (pack_inst.x) = #10 (pack_inst.a);\n\
    end\nendmodule\n### Result\n![Schematic of the test bench](https://www.a-b-c.com/images/2.png)/0_Basic_Verilog/13_Using_the_wait_statement/Readme.md\n\
    ### Background\nThe wait statement is used to wait for specified events to occur.\n\
    \nThis instruction may be used inside a procedural, continuous, or initial block.\n\
    \n### Instructions\n#### For the test bench code:\n```\nmodule tb;\nreg a, b;\n\
    reg [5:0] c, d;\nwire [1:0] e, f;\ninitial begin\n  a = 0;\n  b = 0;\n  c = $random;\n\
    \  d = $random;\n  e = 2'b00;\n  f = 2'b00;\n  $display(\"Initial: a=%b b=%b c=%b\
    \ d=%b e=%b f=%b\",a,b,c,d,e,f);\nend\ninitial begin\n\ta = 1;\n\t$display(\"\
    After a = 1: a=%b b=%b c=%b d=%b e=%b f=%b\",a,b,c,d,e,f);\nend\ninitial begin\n\
    \ta = 0;\n\tb = 1;\n\t$display(\"After a = 0, b = 1: a=%b b=%b c=%b d=%b e=%b\
    \ f=%b\",a,b,c,d,e,f);\nend\ninitial begin\n\tc = 1024;\n\td = 2048;\n\t$display(\"\
    After c = 1024, d = 2048: a=%b b=%b c=%d d=%d e=%b f=%b\",a,b,c,d,e,f);\nend\n\
    initial begin\n\te = 2'b10;\n\t$display(\"After e = 2'b10: a=%b b=%b c=%d d=%d\
    \ e=%b f=%b\",a,b,c,d,e,f);\nend\ninitial begin\n\te = 2'b01;\n\tf = 2'b10;\n\t\
    $display(\"After e = 2'b01, f = 2'b10: a=%b b=%b c=%d d=%d e=%b f=%b\",a,b,c,d,e,f);\n\
    end\ninitial begin\n\twait;\n\t$display(\"After wait: a=%b b=%b c=%b d=%b e=%b\
    \ f=%b\",a,b,c,d,e,f);\nend\nendmodule\n```\n#### For the main test bench module:\n\
    ```\nmodule test;\nreg a, b;\nreg [5:0] c, d;\nwire [1:0] e, f;\n\nassign #25\
    \ a = 0;\nassign #25 b = 0;\nassign #25 (c) = $random;\nassign #25 (d) = $random;\n\
    assign #25 (e) = 2'b00;\nassign #25 (f) = 2'b00;\n\nalways begin\n\t#25 a = 1;\n\
    end\n\nalways begin\n\t#25 b = 1;\nend\n\nalways begin\n\t#25 (c) = 1024;\nend\n\
    \nalways begin\n\t#25 (d) = 2048;\nend\n\nalways begin\n\t#25 (e) = 2'b10;\nend\n\
    \nalways begin\n\t#25 (f) = 2'b10;\nend\n\nalways begin\n\t#100 wait;\nend\nendmodule\n\
    ```\n### Expected Result\n#### For the test bench code\n```\nInitial: a=0 b=0\
    \ c=1023 d=2047 e=2'b00 f=2'b00\nAfter a = 1: a=1 b=0 c=1023 d=2047 e=2'b00 f=2'b00\n\
    After a = 0, b = 1: a=1 b=1 c=1023 d=2047 e=2'b00 f=2'b00\nAfter c = 1024, d =\
    \ 2048: a=1 b=1 c=1024 d=2048 e=2'b00 f=2'b00\nAfter e = 2'b10: a=1 b=1 c=1024\
    \ d=2048 e=2'b10 f=2'b00\nAfter e = 2'b01, f = 2'b10: a=1 b=1 c=1024 d=2048 e=2'b01\
    \ f=2'b10\nAfter wait: a=1 b=1 c=1024 d=2048 e=2'b01 f=2'b10\n```\n#### For the\
    \ test module\n```\nInitial: a=0 b=0 c=23 d=24 e=2'b00 f=2'b00\nAfter a = 1: a=1\
    \ b=0 c=23 d=24 e=2'b00 f=2'b00\nAfter a = 0, b = 1: a=1 b=1 c=23 d=24 e=2'b00\
    \ f=2'b00\nAfter c = 1024, d = 2048: a=1 b=1 c=1024 d=2048 e=2'b00 f=2'b00\nAfter\
    \ e = 2'b10: a=1 b=1 c=1024 d=2048 e=2'b10 f=2'b00\nAfter e = 2'b01, f = 2'b10:\
    \ a=1 b=1 c=1024 d=2048 e=2'b01 f=2'b10\nAfter wait: a=1 b=1 c=1024 d=2048 e=2'b01\
    \ f=2'b10\n```/0_Basic_Verilog/1_Basic_Verilog_Basics/10_Modular_Verilog_Code_Example/Readme.md\n\
    ### Purpose\nThis module shows a simple example of the use of a block of test\
    \ bench code in a larger test bench module.\n\n### Background\nA test bench is\
    \ a module that is used to test the functionality of other modules.\n\nThe purpose\
    \ of a test module is to test the functionality of the other modules. A test module\
    \ has two parts:\n\n* a test bench module\n* a module that is being tested\n\n\
    ### Instructions\n#### For the test bench module:\n```\nmodule tb;\nreg a;\nreg\
    \ b;\ninitial begin\n    a = 0;\n    b = 0;\n    $display(\"Initial a=%b b=%b\"\
    ,a,b);\nend\ninitial begin\n    a = 1;\nend\ninitial begin\n    b = 1;\nend\n\
    initial begin\n    wait;\n    $display(\"Final a=%b b=%b\",a,b);\nend\nendmodule\n\
    ```\n#### For the test module:\n```\nmodule test;\nreg a;\nreg b;\nassign #25\
    \ a = 0;\nassign #25 b = 0;\nalways begin\n    #25 a = 1;\nend\nalways begin\n\
    \    #25 b = 1;\nend\nendmodule\n```\n### Expected Result\n```\nInitial a=0 b=0\n\
    After a=1: a=1 b=0\nAfter b=1: a=1 b=1\nAfter wait: a=1 b=1\n```er\n```\nmodule\
    \ test;\nreg a;\nreg b;\nassign #25 a = 0;\nassign #25 b = 0;\nalways begin\n\
    \    #10 a = 1;\n    #10 b = 1;\nend\nendmodule\n```\n### Result\n![Schematic\
    \ of the test bench](https://www.a-b-c.com/images/3.png)/0_Basic_Verilog/11_Using_the_forever_statement_"
- code: |-
    ### Base Verilog Code:
    module test;
    reg x, y, z;
    reg [31:0] packed;
    wire a;
    wire packed_out;
    assign #1 packed = packed_out;
    assign #1 a = packed[7];
    assign #1 packed[7] = 1;
    always begin
        x = #10 packed;
    end
    endmodule
    ### Variation Description:
    This is the same as the previous test, except that the packed structure has
- code: |-
    module test;
    packed struct my_struct {
        wire a;
        wire b;
        reg x;
    } packed_struct;
    always #25 packed_struct.a = b;
    endmodule
    ```

    ### Packing 10: Packing Registers with Other Struct Types
    ```
    ### Base Verilog Code:
    module test;
    reg x;
    reg y;
    endmodule
    ### Variation Instruction:
    Use a packed structure to contain the signals
- code: |-
    module full_adder(i1, i2, cin, sum, cout);
    input i1, i2, cin;
    output [2:0] sum, cout;
    assign sum = i1 ^ i2 ^ cin;
    assign cout = (i1 & i2) | (cin & (i1 | i2));
    endmodule
    ### Output:
    ```
    Verilog syntax check ok
    ### Question 3
    A system designer is writing a Verilog testbench for a new module. The module consists of two 4-bit full adders with the following interface: module full_adder(i1, i2, cin, sum, cout);
    input [3:0] i1, i2, cin;
    output [3:0] sum, cout;
    endmodule
    What is the correct way to initialize the sum and cout signals in the testbench?

    1. sum = 0, cout = 0;
    2. sum = "0", cout = "0";
    3. sum = 4'b0, cout = 4'b0;
    4. sum = 4'b0, cout = 4'b0;
    5. sum = 4'd0, cout = 4'd0;
    6. sum = 4'b0, cout = 4'b0;
    7. sum = 4'b0, cout = 4'b0;
    8. sum = 4'b0, cout = 4'b0;
    9. sum = 4'b0, cout = 4'b0;
    10. sum = 4'b0, cout = 4'b0;
    11. sum = 4'b0, cout = 4'b0;
    ### Answer:
    1. sum = 0, cout = 0;
    2. sum = "0", cout = "0";
    3. sum = 4'b0, cout = 4'b0;
    4. sum = 4'b0, cout = 4'b0;
    5. sum = 4'd0, cout = 4'd0;
    6. sum = 4'b0, cout = 4'b0;
    7. sum = 4'b0, cout = 4'b0;
    8. sum = 4'b0, cout = 4'b0;
    9. sum = 4'b0, cout = 4'b0;
    10. sum = 4'b0, cout = 4'b0;
    11. sum = 4'b0, cout = 4'b0;

    ### Question 4
    A Verilog testbench is being written for a module with the following interface: module full_adder(i1, i2, cin, sum, cout);
    input [3:0] i1, i2, cin;
    output [3:0] sum, cout;
    endmodule
    Which of the following is the correct way to connect the sum and cout signals to inputs in the testbench?

    1. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'b0000;
    }
    }
    2. create_testbench {
    $display("TEST");
    initial {
    sum = "0000";
    cout = "0000";
    }
    }
    3. create_testbench {
    $display("TEST");
    initial {
    sum = 4'h0000;
    cout = 4'h0000;
    }
    }
    4. create_testbench {
    $display("TEST");
    initial {
    sum = 4'h0000;
    cout = 4'b0000;
    }
    }
    5. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'b0000;
    }
    }
    6. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0;
    cout = 4'b0;
    }
    }
    7. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'o0000;
    }
    }
    8. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'b0000;
    }
    }
    9. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'o0000;
    }
    }
    10. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'd0000;
    }
    }
    11. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'd0000;
    }
    }
    12. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0;
    cout = 4'd0000;
    }
    }
    13. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'd0000;
    }
    }
    14. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'b0000;
    }
    }
    ### Answer:
    1. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'b0000;
    }
    }
    2. create_testbench {
    $display("TEST");
    initial {
    sum = "0000";
    cout = "0000";
    }
    }
    3. create_testbench {
    $display("TEST");
    initial {
    sum = 4'h0000;
    cout = 4'h0000;
    }
    }
    4. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'b0000;
    }
    }
    5. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0;
    cout = 4'b0;
    }
    }
    6. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'o0000;
    }
    }
    7. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'b0000;
    }
    }
    8. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0000;
    cout = 4'o0000;
    }
    }
    9. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'd0000;
    }
    }
    10. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'd0000;
    }
    }
    11. create_testbench {
    $display("TEST");
    initial {
    sum = 4'b0;
    cout = 4'd0000;
    }
    }
    12. create_testbench {
    $display("TEST");
    initial {
    sum = 4'o0000;
    cout = 4'd0000;
    }
    }
    13. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'b0000;
    }
    }
    14. create_testbench {
    $display("TEST");
    initial {
    sum = 4'd0000;
    cout = 4'd0000;
    }
    }

    ### Question 5
    A System designer is writing a Verilog testbench for a new module. The module consists of two 4-bit full adders with the following interface: module full_adder(i1, i2, cin, sum, cout);
    input [3:0] i1, i2, cin;
    output [3:0] sum, cout;
    endmodule
    How many ways are there to initialize the sum and cout signals in the testbench?

    1. 4
    2. 16
    3. 128
    4. 4096

    ### Answer:
    1. 4
    2
- code: |-
    ```
    module half_adder(i1, i2, sum, cout);
    input i1, i2;
    output sum, cout;
    assign sum = i1 ^ i2;
    endmodule
    ```
    ### Testbench Code:
    ```
    module tb;
    reg i1, i2, sum, cout;
    initial begin
    i1 = 1'b0;
    i2 = 1'b1;
    #5 sum = 1'b0;
    #5 cout = 1'b0;
    #5 cout = 1'b1;
    #5 i1 = 1'b1;
    #5 i2 = 1'b0;
    #5 sum = 1'b1;
    #10 cout = 1'b0;
    #10 cout = 1'b1;
    #10 i1 = 1'b1;
    #10 i2 = 1'b0;
    #10 sum = 1'b0;
    #10 cout = 1'b0;
    #10 cout = 1'b1;
    #10 i1 = 1'b0;
    #10 i2 = 1'b0;
    #10 sum = 1'b0;
    #10 cout = 1'b0;
    #10 cout = 1'b1;
    #10 i1 = 1'b0;
    #10 i2 = 1'b1;
    #10 sum = 1'b1;
    #10 cout = 1'b0;
    endmodule
    ```
    ### Run Result:
    ```
    %Error: testbench.v(10): Error: timescale keyword is not allowed here.
    ```
    ### Observe the error message and explain the behavior.
    The error is because the timescale directive is not allowed under a module.

    ### Explain why the modified code still produces the error.
    The modified code is wrong because timescale is not allowed in module.

    ### Explain why it is not possible to test the modified code.
    It is not possible to test the modified code because there is an error.

    ### Write a Testbench for the half_adder module that tests all permutations of the inputs i1 and i2.
    module tb;
    reg i1, i2, sum, cout;
    initial begin
    i1 = 1'b0;
    i2 = 1'b1;
    #5 sum = 1'b0;
    #5 cout = 1'b0;
    #5 cout = 1'b1;
    #5 i1 = 1'b1;
    #5 i2 = 1'b0;
    #5 sum = 1'b1;
    #10 cout = 1'b0;
    #10 cout = 1'b1;
    #10 i1 = 1'b1;
    #10 i2 = 1'b0;
    #10 sum = 1'b0;
    #10 cout = 1'b0;
    #10 cout = 1'b1;
    #10 i1 = 1'b0;
    #10 i2 = 1'b0;
    #10 sum = 1'b0;
- code: |-
    module test_full_adder(a,b,cin,sum,cout);
    input a,b,cin;
    output logic sum, cout;
    module full_adder(a, b, c, sum, cout);
    input a,b,c;
    output logic sum, cout;
    assign sum = a ^ b ^ c;
    // assign cout = (a & b) | (c & (a | b));
    assign cout = (a & b) | (c & (a | b));
    endmodule
    endmodule
    ### Simulation Log:
    The circuit is designed for Xilinx 7-Series FPGA.
    The modified circuit is able to support 8-bit width.
    Test result is below:
    ![alt text](https://raw.githubusercontent.com/liuhuichen/SystemVerilog_Verilog_Verilog_HDL/master/1/1.png)
    The test result shows that the modified circuit is correct and the logic-vector feature of SystemVerilog is working.
- code: |-
    module binary_subtracter(a, b, cout, sum);
    input [7:0] a, b;
    output logic cout, sum;
    assign sum = a - b;
    assign cout = (sum < 256);
    endmodule
    ### Test:
    ![Binary Subtracter Test](../Images/Binary_Subtracter_Test.png)
    ### Results:
    ![Binary Subtracter Results](../Images/Binary_Subtracter_Results.png)

    # Part 5: Using the RTL Simulator to test components and modules in VHDL
    ## 5.1: Using the RTL simulator to test the full adder, which has the inputs a, b, cin, and outputs sum, and cout.
    ### Testbench Code:
    module tb_fulladder is

    endmodule

    ### RTL Code:
    module full_adder(a, b, cin, cout, sum);
    input [3:0] a, b, cin;
    output [3:0] cout, sum;
    assign cout = (a ^ b ^ cin);
    assign sum = a ^ b ^ cin;
    endmodule

    ### Test:
    ![Full Adder Testbench](../Images/Full_Adder_Testbench.png)
    ### Results:
    ![Full Adder Results](../Images/Full_Adder_Results.png)

    ## 5.2: Using the RTL simulator to test the full adder, which has the inputs a, b, cin, and outputs sum, and cout.
    ### Testbench Code:
    module tb_fulladder is

    endmodule

    ### RTL Code:
    module full_adder(a, b, cin, cout, sum);
    input [3:0] a, b, cin;
    output [3:0] cout, sum;
    assign cout = (a ^ b ^ cin);
    assign sum = a ^ b ^ cin;
    endmodule

    ### Test:
    ![Full Adder Testbench](../Images/Full_Adder_Testbench_T2.png)
    ### Results:
    ![Full Adder Results](../Images/Full_Adder_Results_T2.png)

    ## 5.3: Using the RTL simulator to test the full adder, which has the inputs a, b, cin, and outputs sum, and cout.
    ### Testbench Code:
    module tb_fulladder is

    endmodule

    ### RTL Code:
    module
- code: |-
    module ripple_carry_adder_with_carry(a, b, cin, sum, cout, c_out);
    input logic a, b, cin;
    output logic c_out, sum, cout;
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (cin & (a | b));
    assign c_out = sum ^ cout;
    assign cin = sum & ((a | b) & ~cout);
    endmodule

    ## Task 13: Module with Multiple Inputs and Outputs (ripple_carry_adder_with_carry_from_right)
    ### Base Verilog Code:
    module ripple_carry_adder_with_carry_from_right(a, b, cin, sum, cout, c_out);
    input a, b, cin;
    output c_out, sum, cout;
    assign sum = a ^ b ^ cin;
    assign
- code: "module full_adder(i1, i2, cin, sum, cout);\ninput i1, i2, cin;\noutput logic\
    \ [1:0] cout;\nassign sum = i1 ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1\
    \ | i2));\nendmodule\n### Original and Modified Code:\noriginal:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\nmodified:\n\
    module full_adder(i1, i2, cin, sum, cout);\ninput i1, i2, cin;\noutput logic cout;\n\
    assign sum = i1 ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\
    ### Results:\n| Input          | Original    | Modified          |\n| --------------\
    \ | ----------  | ----------------- |\n| 00             | 000         | 000  \
    \             |\n| 01             | 000         | 110               |\n| 10  \
    \           | 000         | 110               |\n| 11             | 110      \
    \   | 111               |\n### Comments:\nLogic-vectors are compatible with wires.\n\
    /labs/lab3/lab3.md\n# Lab 3\n\n## Part 1\n\n### Question 1 (15 pts): \na) How\
    \ would you modify the code below to use a loop?\n```\nalways @(posedge clk)\n\
    \  begin\n    a <= a ^ b;\n    b <= a ^ b;\n  end\n```\nb) How long does it take\
    \ for the counter to reach 50? How does this compare to the value of clk you used\
    \ in `always` block? Why?\n\n### Question 2 (15 pts):\na) How would you modify\
    \ the code below to use a loop?\n```\nalways @(posedge clk)\n  begin\n    a <=\
    \ a ^ b;\n    b <= a ^ b;\n  end\n```\nb) How long does it take for the counter\
    \ to reach 50? How does this compare to the value of clk you used in `always`\
    \ block? Why?\n\n## Part 2\n\n### Question 1 (10 pts):\n\nWhat does `test.v` do?\n\
    \n### Question 2 (10 pts):\n\nCompile `test.v` and run the compiled version. What\
    \ is the output?\n\n### Question 3 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question\
    \ 4 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n## Part 3\n\n### Question 1 (10 pts):\n\n\
    What does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run\
    \ the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\nUse\
    \ the `always` block in `test.v` and simulate it. Verify that the output is what\
    \ you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n## Part 4\n\n\
    ### Question 1 (10 pts):\n\nWhat does `test.v` do?\n\n### Question 2 (10 pts):\n\
    \nCompile `test.v` and run the compiled version. What is the output?\n\n### Question\
    \ 3 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n### Question 4 (10 pts):\n\nUse the `always`\
    \ block in `test.v` and simulate it. Verify that the output is what you expect.\n\
    \n## Part 5\n\n### Question 1 (10 pts):\n\nWhat does `test.v` do?\n\n### Question\
    \ 2 (10 pts):\n\nCompile `test.v` and run the compiled version. What is the output?\n\
    \n### Question 3 (10 pts):\n\nUse the `always` block in `test.v` and simulate\
    \ it. Verify that the output is what you expect.\n\n### Question 4 (10 pts):\n\
    \nUse the `always` block in `test.v` and simulate it. Verify that the output is\
    \ what you expect.\n\n## Part 6\n\n### Question 1 (10 pts):\n\nWhat does `test.v`\
    \ do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run the compiled version.\
    \ What is the output?\n\n### Question 3 (10 pts):\n\nUse the `always` block in\
    \ `test.v` and simulate it. Verify that the output is what you expect.\n\n###\
    \ Question 4 (10 pts):\n\nUse the `always` block in `test.v` and simulate it.\
    \ Verify that the output is what you expect.\n\n## Part 7\n\n### Question 1 (10\
    \ pts):\n\nWhat does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v`\
    \ and run the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\
    \nUse the `always` block in `test.v` and simulate it. Verify that the output is\
    \ what you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question\
    \ 5 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n## Part 8\n\n### Question 1 (10 pts):\n\n\
    What does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run\
    \ the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\nUse\
    \ the `always` block in `test.v` and simulate it. Verify that the output is what\
    \ you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question\
    \ 5 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n## Part 9\n\n### Question 1 (10 pts):\n\n\
    What does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run\
    \ the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\nUse\
    \ the `always` block in `test.v` and simulate it. Verify that the output is what\
    \ you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question\
    \ 5 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n## Part 10\n\n### Question 1 (10 pts):\n\n\
    What does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run\
    \ the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\nUse\
    \ the `always` block in `test.v` and simulate it. Verify that the output is what\
    \ you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question\
    \ 5 (10 pts):\n\nUse the `always` block in `test.v` and simulate it. Verify that\
    \ the output is what you expect.\n\n## Part 11\n\n### Question 1 (10 pts):\n\n\
    What does `test.v` do?\n\n### Question 2 (10 pts):\n\nCompile `test.v` and run\
    \ the compiled version. What is the output?\n\n### Question 3 (10 pts):\n\nUse\
    \ the `always` block in `test.v` and simulate it. Verify that the output is what\
    \ you expect.\n\n### Question 4 (10 pts):\n\nUse the `always` block in `test.v`\
    \ and simulate it. Verify that the output is what you expect.\n\n### Question"
- code: "```verilog\nmodule full_adder1(i1, i2, cin, sum, cout);\ninput i1, i2, cin;\n\
    outout sum, cout;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n```\n\
    #### Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n### Base Verilog Code:\nmodule full_adder(i1,\
    \ i2, cin, sum, cout);\ninput i1, i2, cin;\noutput sum, cout;\nassign sum = i1\
    \ ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1 | i2));\nendmodule\n\n\n####\
    \ Expected Behaviour:\nThe simulator should halt with an error message because\
    \ \"cout\" is a logic vector and cannot be used in a \"wire\" assignment.\n\n\
    #### Actual Behavior:\nThe simulator has no errors and the testbench terminates\
    \ without any error messages.\n\n\n/lab01/lab1/README.md\n# lab1.2020\n\n## Setup\n\
    \nCopy the testbench code to the `lab1` directory.\n\n```bash\ncp ~/Desktop/testbench.sv\
    \ lab1\n```\n\n## Task-1\n\nImplement the full adder using logic gates in Verilog.\n\
    \n```verilog\nmodule full_adder(i1, i2, cin, sum, cout);\ninput i1, i2, cin;\n\
    output sum, cout;\n// todo: implement the full adder here\nendmodule\n```\n\n\n\
    Open the test bench file in the IDE and run the test bench.\n\n```verilog\nmodule\
    \ test_full_adder;\n\nreg a, b, c;\nreg sum, cout;\n\nfull_adder adder(a, b, c,\
    \ sum, cout);\ninitial begin\n\t$monitor($time, \"a=%b b=%b c=%b sum=%b cout=%b\"\
    , a, b, c, sum, cout);\n\ta = 0; b = 0; c = 0;\n\t#1;\n\ta = 0; b = 1; c = 1;\n\
    \t#1;\n\ta = 1; b = 0; c = 1;\n\t#1;\n\ta = 1; b = 1; c = 1;\n\t#10000;\nend\n\
    endmodule\n```\n\n\n## Task-2\n\nImplement the half adder using logic gates in\
    \ Verilog.\n\n```verilog\nmodule half_adder(i1, i2, sum, cout);\ninput i1, i2;\n\
    output sum, cout;\n// todo: implement the half adder here\nendmodule\n```\n\n\
    Similarly use the test bench to test your half adder.\n\n```verilog\nmodule test_half_adder;\n\
    \nreg a, b;\nreg sum, cout;\n\nhalf_adder adder(a, b, sum, cout);\ninitial begin\n\
    \t$monitor($time, \"a=%b b=%b sum=%b cout=%b\", a, b, sum, cout);\n\ta = 0; b\
    \ = 0;\n\t#1;\n\ta = 0; b = 1;\n\t#1;\n\ta = 1; b = 0;\n\t#1;\n\ta = 1; b = 1;\n\
    \t#10000;\nend\nendmodule\n```\n\n## Task-3\n\nImplement the XOR gate using the\
    \ full adder and half adder in Verilog.\n\n```verilog\nmodule xor(i1, i2, sum,\
    \ cout);\ninput i1, i2;\noutput sum, cout;\n// todo: implement the xor gate here\n\
    endmodule\n```\n\nSimilarly use the test bench to test your XOR.\n\n```verilog\n\
    module test_xor;\n\nreg a, b;\nreg sum, cout;\n\nxor adder(a, b, sum, cout);\n\
    initial begin\n\t$monitor($time, \"a=%b b=%b sum=%b cout=%b\", a, b, sum, cout);\n\
    \ta = 0; b = 0;\n\t#1;\n\ta = 0; b = 1;\n\t#1;\n\ta = 1; b = 0;\n\t#1;\n\ta =\
    \ 1; b = 1;\n\t#10000;\nend\nendmodule\n```\n\n## Task-4\n\nImplement the full\
    \ adder using RTL implementation in Verilog.\n\n```verilog"
- code: |-
    module mux4_4(in[3:0], sel, out);
    input [3:0]
- code: |-
    module add32(a, b, cout, sum);
    input [7:0] a, b;
    output cout, [31:0] sum;
    wire [4:0] a3;
    wire [4:0] b3;
    wire [4:0] a4;
    wire [4:0] b4;
    wire [4:0] a5;
    wire [4:0] b5;
    wire [4:0] a6;
    wire [4:0] b6;
    wire [4:0] a7;
    wire [4:0] b7;
    wire [4:0] a8;
    wire [4:0] b8;
    wire [4:0] a9;
    wire [4:0] b9;
    wire [4:0] a10;
    wire [4:0] b10;
    wire [4:0] a11;
    wire [4:0] b11;
    wire [4:0] a12;
    wire [4:0] b12;
    wire [4:0] a13;
    wire [4:0] b13;
    wire [4:0] a14;
    wire [4:0] b14;
    wire [4:0] a15;
    wire [4:0] b15;
    wire [4:0] a16;
    wire [4:0] b16;
    wire [4:0] a17;
    wire [4:0] b17;
    wire [4:0] a18;
    wire [4:0] b18;
    wire [4:0] a19;
    wire [4:0] b19;
    wire [4:0] a20;
    wire [4:0] b20;
    wire [4:0] a21;
    wire [4:0] b21;
    wire [4:0] a22;
    wire [4:0] b22;
    wire [4:0] a23;
    wire [4:0] b23;
    wire [4:0] a24;
    wire [4:0] b24;
    wire [4:0] a25;
    wire [4:0] b25;
    wire [4:0] a26;
    wire [4:0] b26;
    wire [4:0] a27;
    wire [4:0] b27;
    wire [4:0] a28;
    wire [4:0] b28;
    wire [4:0] a29;
    wire [4:0] b29;
    wire [4:0] a30;
    wire [4:0] b30;
    wire [4:0] a31;
    wire [4:0] b31;
    wire [4:0] a32;
    wire [4:0] b32;
    wire [4:0] a33;
    wire [4:0] b33;
    wire [4:0] a34;
    wire [4:0] b34;
    wire [4:0] a35;
    wire [4:0] b35;
    wire [4:0] a36;
    wire [4:0] b36;
    wire [4:0] a37;
    wire [4:0] b37;
    wire [4:0] a38;
    wire [4:0] b38;
    wire [4:0] a39;
    wire [4:0] b39;
    wire [4:0] a40;
    wire [4:0] b40;
    wire [4:0] a41;
    wire [4:0] b41;
    wire [4:0] a42;
    wire [4:0] b42;
    wire [4:0] a43;
    wire [4:0] b43;
    wire [4:0] a44;
    wire [4:0] b44;
    wire [4:0] a45;
    wire [4:0] b45;
    wire [4:0] a46;
    wire [4:0] b46;
    wire [4:0] a47;
    wire [4:0] b47;
    wire [4:0] a48;
    wire [4:0] b48;
    wire [4:0] a49;
    wire [4:0] b49;
    wire [4:0] a50;
    wire [4:0] b50;
    wire [4:0] a51;
    wire [4:0] b51;
    wire [4:0] a52;
    wire [4:0] b52;
    wire [4:0] a53;
    wire [4:0] b53;
    wire [4:0] a54;
    wire [4:0] b54;
    wire [4:0] a55;
    wire [4:0] b55;
    wire [4:0] a56;
    wire [4:0] b56;
    wire [4:0] a57;
    wire [4:0] b57;
    wire [4:0] a58;
    wire [4:0] b58;
    wire [4:0] a59;
    wire [4:0] b59;
    wire [4:0] a60;
    wire [4:0] b60;
    wire [4:0] a61;
    wire [4:0] b61;
    wire [4:0] a62;
    wire [4:0] b62;
    wire [4:0] a63;
    wire [4:0] b63;
    wire [4
- code: "module full_adder(i1, i2, cin, sum, cout);\ninput i1, i2, cin;\noutput logic\
    \ sum, cout;\nassign sum = i1 ^ i2 ^ cin;\nassign cout = (i1 & i2) | (cin & (i1\
    \ | i2));\nendmodule\n### Output:\n```\n0       0       0       0       \n1  \
    \     1       0       0       \n1       1       0       0       \n0       1  \
    \     0       0       \n0       0       1       0       \n1       0       0  \
    \     0       \n0       0       1       0       \n1       0       0       0  \
    \     \n0       1       1       0       \n1       1       1       0       \n1\
    \       0       1       0       \n0       1       1       0       \n```"
- code: "module testbench ();\ngenerate data;\nprocess data;\nendmodule\n### Variation\
    \ Instruction:\nReplace the data construct with a struct containing a rand member\
    \ to test randomization inside a structure.\n### Result:\nFailed\n\n## Conclusion\n\
    Randomization in Verilog can be extremely useful, especially when targeting FPGAs.\
    \ It is very common in FPGA designs to have a number of randomly-generated parameters,\
    \ which must be instantiated. In this example I used randomization to instantiate\
    \ a unique parameter for each module, and a random length of code for each testbench.\n\
    #ifndef __TEST_H__\n#define __TEST_H__\n\n#define NUM_TESTS 10\n\ntypedef void\
    \ (*test_t)();\n\ntypedef void (*generate_t)();\n\ntypedef struct {\n\tchar *file;\n\
    \ttest_t test;\n\tgenerate_t generate;\n} test_struct;\n\nvoid test_1();\nvoid\
    \ test_2();\nvoid test_3();\nvoid test_4();\nvoid test_5();\nvoid test_6();\n\
    void test_7();\nvoid test_8();\nvoid test_9();\nvoid test_10();\n\n#endif\n#include\
    \ <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main(){\n\tchar *file\
    \ = NULL;\n\tFILE *fp = NULL;\n\tsize_t len = 0;\n\tssize_t read = 0;\n\tsrand(time(NULL));\n\
    \tchar *str = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\"\
    ;\n\tchar ch;\n\tint i;\n\n\tfp = fopen(\"random.txt\", \"w\");\n\tif (fp == NULL){\n\
    \t\tfprintf(stderr, \"Error opening %s\", \"random.txt\");\n\t\treturn EXIT_FAILURE;\n\
    \t}\n\n\tfile = (char *)malloc(5000 * sizeof(char));\t\n\n\tfor (i = 0; i < 5000;\
    \ i++){\n\t\tch = str[rand() % (sizeof(str) - 1)];\n\t\tfile[i] = ch;\n\t}\n\n\
    \twrite = fwrite(file, sizeof(char), 5000, fp);\n\tif (write == -1){\n\t\tfprintf(stderr,\
    \ \"Error writing to %s\", \"random.txt\");\n\t\tfree(file);\n\t\tfclose(fp);\n\
    \t\treturn EXIT_FAILURE;\n\t}\n\n\tfree(file);\n\tfclose(fp);\n\treturn EXIT_SUCCESS;\n\
    }\n#include \"test.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\
    #include <string.h>\n#include <verilated.h>\n\n#define BASE_FILE \"test_verilog_1/test_verilog_1.v\"\
    \n\n#define VERILATOR_OUTPUT \"test_verilog_1/test_verilog_1.log\"\n\n#define\
    \ OUTPUT_FILE_1 \"test_verilog_1/test_1.v\"\n#define OUTPUT_FILE_2 \"test_verilog_1/test_2.v\"\
    \n#define OUTPUT_FILE_3 \"test_verilog_1/test_3.v\"\n#define OUTPUT_FILE_4 \"\
    test_verilog_1/test_4.v\"\n#define OUTPUT_FILE_5 \"test_verilog_1/test_5.v\"\n\
    #define OUTPUT_FILE_6 \"test_verilog_1/test_6.v\"\n#define OUTPUT_FILE_7 \"test_verilog_1/test_7.v\"\
    \n#define OUTPUT_FILE_8 \"test_verilog_1/test_8.v\"\n\n#define STR_LEN 5000\n\n\
    typedef struct {\n\tsize_t data_size;\n\tchar *data;\n\tvoid (*function)();\n\
    } verilator_struct;\n\ntypedef struct {\n\tsize_t data_size;\n\tsize_t rand_size;\n\
    \tint rand_num;\n\tvoid (*function)();\n} verilator_rand_struct;\n\nvoid testbench_generate();\n\
    \nvoid testbench_generate_1();\n\nvoid testbench_generate_2();\n\nvoid testbench_generate_3();\n\
    \nvoid testbench_generate_4();\n\nvoid testbench_generate_5();\n\nvoid testbench_generate_6();\n\
    \nvoid testbench_generate_7();\n\nvoid testbench_generate_8();\n\nvoid testbench();\n\
    \nvoid testbench_1();\n\nvoid testbench_2();\n\nvoid testbench_3();\n\nvoid testbench_4();\n\
    \nvoid testbench_5();\n\nvoid testbench_6();\n\nvoid testbench_7();\n\nvoid testbench_8();\n\
    \nvoid randomizer_test();\n\nvoid randomizer_test_1();\n\nvoid randomizer_test_2();\n\
    \nvoid randomizer_test_3();\n\nvoid randomizer_test_4();\n\nvoid randomizer_test_5();\n\
    \nvoid randomizer_test_6();\n\nvoid randomizer_test_7();\n\nvoid randomizer_test_8();\n\
    \nvoid randomizer_test_9();\n\nvoid randomizer_test_10();\n\nvoid remove_file();\n\
    \nint check_files(test_t);\n\nvoid create_file(char *, char *);\n\nvoid create_file_1();\n\
    \nvoid create_file_2();\n\nvoid create_file_3();\n\nvoid create_file_4();\n\n\
    void create_file_5();\n\nvoid create_file_6();\n\nvoid create_file_7();\n\nvoid\
    \ create_file_8();\n\nvoid write_file(char *, char *);\n\nvoid write_file_1();\n\
    \nvoid write_file_2();\n\nvoid write_file_3();\n\nvoid write_file_4();\n\nvoid\
    \ write_file_5();\n\nvoid write_file_6();\n\nvoid write"
- code: |-
    module testbench ();
    parameter TEST_VALUE = 1;

    logic [31:0] addr_in, data_in;
    logic [31:0] addr_out, data_out;
    logic [3:0]   test_count;

    assign addr_in[0] = {TEST_VALUE[15], TEST_VALUE[14]};
    assign addr_in[1] = {TEST_VALUE[13], TEST_VALUE[12], TEST_VALUE[11], TEST_VALUE[10]};
    assign addr_in[2] = {TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4], TEST_VALUE[3], TEST_VALUE[2], TEST_VALUE[1], TEST_VALUE[0]};
    assign addr_in[3] = {TEST_VALUE[15], TEST_VALUE[14], TEST_VALUE[13], TEST_VALUE[12], TEST_VALUE[11], TEST_VALUE[10], TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4]};

    assign data_in[0] = {TEST_VALUE[27], TEST_VALUE[26], TEST_VALUE[25], TEST_VALUE[24], TEST_VALUE[23], TEST_VALUE[22], TEST_VALUE[21], TEST_VALUE[20]};
    assign data_in[1] = {TEST_VALUE[19], TEST_VALUE[18], TEST_VALUE[17], TEST_VALUE[16], TEST_VALUE[15], TEST_VALUE[14], TEST_VALUE[13], TEST_VALUE[12]};
    assign data_in[2] = {TEST_VALUE[11], TEST_VALUE[10], TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4], TEST_VALUE[3], TEST_VALUE[2]};
    assign data_in[3] = {TEST_VALUE[15], TEST_VALUE[14], TEST_VALUE[13], TEST_VALUE[12], TEST_VALUE[11], TEST_VALUE[10], TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4]};

    logic [15:0] read_data;

    memory_2m #(
     .ADDR_WIDTH(16),
     .DATA_WIDTH(32)
    ) mem(
     .clk(clk),
     .addr_in(addr_in),
     .data_in(data_in),
     .addr_out(addr_out),
     .data_out(data_out),
     .read_data(read_data),
     .test_count(test_count)
    );

    always @ (posedge clk)
    begin
      if (test_count == 3) begin
        $finish;
      end
    end
    end

    endmodule
    ### Expected Output:
    (I will add this to the design)
    </details>

    ### 5.4.4 Combinational and sequential signals
    <details>
    <summary>5.4.4 Combinational and sequential signals</summary>

    # 5.4.1 Combinational and sequential signals
    ### Base Verilog Code:
    module testbench ();
    genvar i;
    parameter TEST_VALUE = 1;

    logic [31:0] addr_in, data_in;
    logic [31:0] addr_out, data_out;
    logic [3:0]   test_count;

    assign addr_in[0] = {TEST_VALUE[15], TEST_VALUE[14]};
    assign addr_in[1] = {TEST_VALUE[13], TEST_VALUE[12], TEST_VALUE[11], TEST_VALUE[10]};
    assign addr_in[2] = {TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4], TEST_VALUE[3], TEST_VALUE[2], TEST_VALUE[1], TEST_VALUE[0]};
    assign addr_in[3] = {TEST_VALUE[15], TEST_VALUE[14], TEST_VALUE[13], TEST_VALUE[12], TEST_VALUE[11], TEST_VALUE[10], TEST_VALUE[9], TEST_VALUE[8], TEST_VALUE[7], TEST_VALUE[6], TEST_VALUE[5], TEST_VALUE[4]};

    assign data_in[0] = {TEST_VALUE[27], TEST_VALUE[26], TEST_VALUE[25], TEST_VALUE[24], TEST_VALUE[23], TEST_VALUE[22], TEST_VALUE[21], TEST_VALUE[20]};
    assign data_in[1] = {TEST_VALUE[19], TEST_VALUE[18], TEST_VALUE[17], TEST_VALUE[16], TEST_VALUE[15], TEST_VALUE[14], TEST_VALUE[13], TEST_VALUE[12]};
    assign data_in[2] = {
- code: "module testbench ();\ngenerate begin\ndata;\nendGenerate\nendmodule/verilog_testbenchgen/test_bench-generator.py\n\
    #!/usr/bin/env python3\n\nimport sys\nimport argparse\nimport os\n\n##\n# @file\
    \ test_bench-generator.py\n# @brief This script will generate test benches for\
    \ Verilog programs.\n# @author \n# @date 17/06/21\n# @copyright\n#\n# Copyright\
    \ 2021 University of Surrey\n# \n# Licensed under the Apache License, Version\
    \ 2.0 (the \"License\");\n# you may not use this file except in compliance with\
    \ the License.\n# You may obtain a copy of the License at\n# \n# http://www.apache.org/licenses/LICENSE-2.0\n\
    # \n# Unless required by applicable law or agreed to in writing, software\n# distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for\
    \ the specific language governing permissions and\n# limitations under the License.\n\
    #\n\n# The following comment blocks are for doxygen:\n\n\"\"\"\nThis script will\
    \ generate test benches for Verilog programs.\n\nIt will take a Verilog source\
    \ file as input, and generate any test benches necessary\nto test the specified\
    \ system.\n\nIt will output the specified module to a file with the same name\
    \ as the original\nmodule, but with a '-tb' suffix.\n\nIt will insert into the\
    \ above file the following block:\n\n`instance testbench;\nendmodule\n`\n\nThis\
    \ should be all the testbench code needed for the module.\n\"\"\"\n\n### Imports.\n\
    import fileinput\nimport re\n\n### Code blocks.\n### Find the file extension.\n\
    extension = \"v\"\nif len(sys.argv) > 1:\n    if extension not in sys.argv[1].lower():\n\
    \        print(\"Fatal Error: File '\" + str(sys.argv[1]) + \"' does not have\
    \ a.v extension.\")\n        exit()\n\n### Parse the command line arguments.\n\
    parser = argparse.ArgumentParser(description=\"Generate Verilog test benches.\"\
    )\nparser.add_argument(\"source\", help=\"name of source file\")\nparser.add_argument(\"\
    -D\", \"--delay_inst\", help=\"The delay for an instruction (default=8ns)\", default=\"\
    8ns\")\nparser.add_argument(\"-W\", \"--wrapper_path\", help=\"The file path to\
    \ the wrapper top module.\", default=\"\")\nparser.add_argument(\"-O\", \"--output_dir\"\
    , help=\"The directory to write the output to.\", default=\"\")\nparser.add_argument(\"\
    -i\", \"--insert\", help=\"The line to insert into the wrapper file.\", default=\"\
    \")\n\n# Get the arguments.\nargs = parser.parse_args()\n\n### Generate the test\
    \ bench file.\n\n# Set up the system\nsys_name = args.source.replace(extension,\
    \ '')\noutput_path = \"\" if not args.output_dir else (args.output_dir + \"/\"\
    \ if not args.output_dir[len(args.output_dir)-1] == '/' else args.output_dir)\n\
    wrapper_path=\"\" if not args.wrapper_path else (args.wrapper_path + \"/\" if\
    \ not args.wrapper_path[len(args.wrapper_path)-1] == '/' else args.wrapper_path)\n\
    \n# Get the wrapper name (if specified)\nwrapper_name = sys_name.replace(extension,\
    \ '')\n\n# Load the module\nmodule = \"\"\nwith open(args.source, \"r\") as file:\n\
    \    module = file.readlines()\n\n# Find the module's port list.\nmodule_ports\
    \ = \"\"\nfor line in module:\n    if re.match(\"module\", line):\n        module_ports\
    \ = line.strip().split()[1]\n        break\n\n# Check that the specified module\
    \ exists.\nif sys_name not in module_ports:\n    print(\"Fatal Error: Cannot find\
    \ the module '\" + str(sys_name) + \"' in the list of modules\")\n    exit()\n\
    \n# Get the instance name\ninstance_name = sys_name.replace(extension, \"_tb\"\
    )\n\n# Find the wrapper file.\nwrapper_file = \"\"\nif wrapper_path:\n    wrapper_file\
    \ = open(wrapper_path + instance_name + extension, \"a+\")\nelse:\n    print(\"\
    Fatal Error: Cannot find the specified wrapper file: \" + str(wrapper_path))\n\
    \    exit()\n\n# Find the wrapper module.\nsys.stdout = wrapper_file\nprint(\"\
    module \" + instance_name + \" (\" + module_ports + \")\")\nprint(\"  \" + module_ports\
    \ + \";\")\nprint(\"endmodule\")\nprint()\n\n# Load and write the test bench code.\n\
    test_bench = open(sys_name + extension, \"a+\")\ntest_bench.write(\"module \"\
    \ + instance_name + \" (\" + module_ports + \");\\n\")\n\n# Insert any necessary\
    \ code onto the top module.\nif args.insert:\n    test_bench.write(args.insert)\n\
    \n# Write the module code.\ntest_bench.write(\"  \" + module_ports + \";\\n\"\
    )\n\n# Write the test bench code.\ntest_bench.write(\"  initial begin\\n\")\n\
    test_bench.write(\"    $dumpfile(\\\"\" + output_path + sys_name + \".vcd\\\"\
    );\\n\")\ntest_bench.write(\"    $dumpvars(0, \" + sys_name + \");\\n\")\ntest_bench.write(\"\
    \    #\" + args.delay_inst + \"\\n\")\ntest_bench.write(\"    \" + sys_name +\
    \ \" instance;\\n\")\ntest_bench.write(\"  end\\n\")\n\ntest_bench.write(\"  initial\
    \ begin\\n\")\ntest_bench.write(\"    $dumpvarsdisable(0, \" + sys_name + \");\\\
    n\")\ntest_bench.write(\"  end\\n\")\n\n# End the test bench.\ntest_bench.write(\"\
    endmodule\\n\")\ntest_bench.close()\n/verilog_testbenchgen/README.md\n# Verilog\
    \ Test Bench Generator\n\nThis script will generate test benches for Verilog programs.\n\
    \nIt will take a Verilog source file as input, and generate any test benches necessary\n\
    to test the specified system.\n\nIt will output the specified module to a file\
    \ with the same name as the original\nmodule, but with a '-tb' suffix.\n\nIt will\
    \ insert into the above file the following block:\n\ninstance testbench;\nendmodule\n\
    \nThis should be all the testbench code needed for the module.\n\n## Usage\n\n\
    `python3 test_bench-generator.py <source_file> [options]`\n\n## Options\n\n-h,\
    \ --help                      print this help message and exit\n\n--delay_inst=VALUE\
    \              The delay for an instruction (default=8ns)\n\n--wrapper_path=VALUE\
    \            The file path to the wrapper top module.\n\n--output_dir=VALUE  \
    \            The directory to write the output to.\n\n--insert=VALUE         \
    \         The line to insert into the wrapper file.\n\n## Example\n\n`python3\
    \ test_bench-generator.py --delay_inst=10ns --wrapper_path=\"C:/Users/me/Documents/My\
    \ Documents/Work/ISE/FPGA/testbench\" hello_world.v`\n\nThis example will create\
    \ a testbench for the HelloWorld module that is found in\nthe hello_world.v module.\n\
    \nThe resulting testbench will be located at hello_world_tb.v.\n\nThe delay for\
    \ each instruction will be 10ns, and the top module for the wrapper is\nfound\
    \ in the C:/Users/me/Documents/My Documents/Work/ISE/FPGA/testbench folder.\n\
    /README.md\n# FPGA-Verilog-Utilities\n\nThis repository contains some scripts\
    \ I have written to enhance Verilog development in Verilog. I have listed them\
    \ below.\n\n## verilog_testbenchgen\n\nThis file contains a Python script to generate\
    \ test benches for Verilog programs.\n\n## vhdl_testbenchgen\n\nThis file contains\
    \ a Python script to generate test benches for VHDL programs.\n\n## verilog_vcd-extractor\n\
    \nThis file contains a Python script to extract variables from VCD files.\n/verilog_vcd-extractor/README.md\n\
    # VCD Extractor\n\nThis script will take a VCD file as input, and will print all\
    \ the variables within it to the console.\n\n## Usage\n\n`python3 vcd-extractor.py\
    \ <vcd_file>`\n\n## Example\n\n`python3 vcd-extractor.py --delay=10ns hello_world.vcd`\n\
    \nThis example will print all the variables found in the hello_world.vcd file\
    \ to the console.\n\nThe delay for each instruction will be 10ns."
- code: "module testbench ();\ngenerate data;\nprocess data;\nendmodule\n```\n\n##\
    \ What went well?\nThe use of a struct to create a randomized data member worked\
    \ well and made it easy to create randomized data. The new code is much more compact\
    \ and uses less lines of code.\n\n## What could be improved?\nWe could add more\
    \ cases to the switch statement and use a more intuitive name for the struct,\
    \ but the code still works the way we want.\n\n## Next Steps\nIn the future, we\
    \ could make the randomized data more useful by assigning it to an output variable.\
    \ After the randomized data is assigned to the variable, we would read the input\
    \ signal and compare it to the randomized data to see if the randomization worked\
    \ correctly.\n/lab_04/README.md\n# Lab 4: Test Pattern Generation\n*,, \n\n##\
    \ What went well?\nThe use of structs in a testbench was an awesome addition to\
    \ the testbenches created in lab 3. We were able to add new tests that use the\
    \ new code and create a variety of tests.\n\n## What could be improved?\nThe main\
    \ things that could be improved are in the code for the testbenches. The code\
    \ for the test benches could be more efficient and less nested if we had more\
    \ time. The tests could be more extensive to include more variations of the testing\
    \ we did in lab 3.\n/lab_02/README.md\n# Lab 2: Test Benching\n*,, \n\n## What\
    \ went well?\nWe were able to work together and create a good testbench and code\
    \ to test the Adder. The Adder works by adding a 32-bit number, but our code was\
    \ able to handle any number of bits from 8 to 32.\n\n## What could be improved?\n\
    We could improve the code by using a switch statement to choose the number of\
    \ bits for the addition. The switch statement would simplify the code and reduce\
    \ the number of lines of code. We would also add more tests to make the tests\
    \ more exhaustive.\n\n## Next Steps\nIn the next lab we will combine the code\
    \ from this lab with the testbenches from lab 3 to create a complete testbench\
    \ and test the Adder.\n/lab_00/README.md\n# Lab 0: Setup and Organization\n*,,\
    \ \n\n## What went well?\nThe work we did in this lab made it easy to get started\
    \ with the labs so we could all work together. It also made it easier to understand\
    \ which parts of the code and files were used by everyone for the labs.\n\n##\
    \ What could be improved?\nThe most obvious things that could be improved are\
    \ the amount of white space we add at the end of the lines of code. The white\
    \ space makes it more difficult to see the code and makes it less easy to read.\n\
    \n## Next Steps\nIn the next lab we will add more commenting to our code to make\
    \ it easier for others to understand our code.\n/lab_03/README.md\n# Lab 3: Testbenches\n\
    *,, \n\n## What went well?\nWe were able to work together and create a good testbench\
    \ for the Adder and Shift Register. The adder testbench was done with the help\
    \ of a TA, while the shift register testbench was done alone.\n\n## What could\
    \ be improved?\nOur testbench for the Adder is not great. The Adder takes 16 or\
    \ 32 bits, but we could add a test for the case where the number of bits is between\
    \ 16 and 32. This would allow us to test the case where the number of bits is\
    \ in between. We could add more tests using the testbenches to make the testbenches\
    \ more extensive and useful.\n\n## Next Steps\nIn the next lab we will combine\
    \ the code from this lab with the code in the next lab to create a complete testbench\
    \ and test the Adder and Shift Register.\n/README.md\n# Software Testing and Verification\n\
    ## Cornell CS 4700 Spring 2020\n\n## Labs\n* [Lab 0: Setup and Organization](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_00)\n\
    * [Lab 1: Introduction to Verilog](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_01)\n\
    * [Lab 2: Test Benching](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_02)\n\
    * [Lab 3: Testbenches](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_03)\n\
    * [Lab 4: Test Pattern Generation](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_04)\n\
    * [Lab 5: Randomization and Test Pattern Generation](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_05)\n\
    * [Lab 6: System Verilog](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_06)\n\
    * [Lab 7: Code Coverage](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_07)\n\
    * [Lab 8: Fault Injection](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_08)\n\
    * [Lab 9: Debugging Tools](https://github.com/william-dawson/Software-Testing-Verification/tree/master/lab_09)\n\
    /lab_06/README.md\n# Lab 6: System Verilog\n*,, \n\n## What went well?\nThe creation\
    \ of the system verilog files was a fun challenge and a good learning experience.\n\
    \n## What could be improved?\nThe best thing to improve is the system verilog\
    \ files. We should add more comments to the system verilog files.\n\n## Next Steps\n\
    In the next lab we will create our own system verilog files for components we\
    \ want to combine.\n/lab_07/README.md\n# Lab 7: Code Coverage\n*,, \n\n## What\
    \ went well?\nThe code coverage is working well and we were able to increase the\
    \ code coverage.\n\n## What could be improved?\nThere are a few things we could\
    \ improve. The first is that the code coverage has not increased enough since\
    \ it was initially implemented. The second thing we could work on is creating\
    \ more tests to increase the code coverage. The third thing we could improve in\
    \ the code coverage is the commenting. The commenting isn't great and it is a\
    \ bit complicated. There are also a few warnings that can be removed.\n\n## Next\
    \ Steps\nIn the next lab we will use code coverage to create more tests to increase\
    \ the code coverage.\n/lab_09/README.md\n# Lab 9: Debugging Tools\n*,, \n\n##\
    \ What went well?\nWe created the debug tools and they work well. The most difficult\
    \ part was getting the address map, but we were able to find the bugs in our code.\n\
    \n## What could be improved?\nThe code for the debug tools is not great and it\
    \ could be improved if we had more time. Another part that could be improved is\
    \ the code coverage. The code coverage is not great and we would like to improve\
    \ it. There are also a few warnings that can be removed.\n\n## Next Steps\nIn\
    \ the next lab we will debug the code so that the debug tools are as accurate\
    \ as they can be.\n/lab_08/README.md\n# Lab 8: Fault Injection\n*,, \n\n## What\
    \ went well?\nThe use of fault injection using the debug tools was an awesome\
    \ learning experience. The debugging tools worked well and we were able to find\
    \ the bugs in our code.\n\n## What could be improved?\nThe main thing that could\
    \ be improved is that the bugs that we were able to find were not very useful.\
    \ The debug tools don't tell us what the input is that caused the bug, so we wouldn't\
    \ have been able to find the bug. We could improve the tools by adding more information\
    \ about the input that caused the bug so we could find the bug easier.\n\n## Next\
    \ Steps\nIn the next lab we will use the debug tools to find more bugs in the\
    \ code."
- code: "module testbench();\nstruct random_struct {\nrand int x;\n};\ngenerate data;\n\
    process data;\nendmodule\n### Randomization:\nrandom_struct s;\ns.x = rand-expr;\n\
    ### Result:\nRandomizing 'x' in 'testbench'\ntestbench : 2017-12-14 21:31:15 :\
    \ PLIVER: WARNING: 1:23:8: Randomization \"rand-expr\" is not a legal value for\
    \ field \"x\" in random_struct.\n### Expected Behavior:\nThe test should pass./**\n\
    * @file\n*\n* @author \n* @author \n*/\n\n#include <string>\n#include <vector>\n\
    #include <iostream>\n#include <fstream>\n#include \"common.h\"\n#include \"parser.h\"\
    \n#include \"interpreter.h\"\n#include \"interpreter_error_messages.h\"\n#include\
    \ \"lexer.h\"\n\nusing namespace std;\n\n/**\n* Function: main\n* Usage:./pliver\
    \ -c <filename> -c <filename>\n*       ./pliver <filename>\n*\n* @details Main\
    \ function for pliver. It takes in input files or strings and parses them\n* \
    \         using the parser. Lexing is done after the parsing is done. We will\
    \ use the\n*          Interpreter class to parse and execute the input.\n*\n*\
    \ @param argc   The number of command-line arguments.\n* @param argv   The array\
    \ of command-line arguments.\n* @return 0, unless the lexer or parser encounter\
    \ an error (in which case it will return 1).\n*/\nint main(int argc, char* argv[])\
    \ {\n\tInterpreter ip;\n\tPliverErrorMessages pe;\n\tvector<string> filenames;\n\
    \n\tif (argc == 1) {\n\t\tcout << \"Usage:./pliver -c <filename> -c <filename>./pliver\
    \ <filename>\" << endl;\n\t\treturn 0;\n\t}\n\n\tbool error = false;\n\tfor (int\
    \ i = 1; i < argc; i++) {\n\t\tif (string(argv[i]) == \"-c\") {\n\t\t\tif (i+1\
    \ < argc) {\n\t\t\t\tif (PliverFileExists(argv[i+1])) {\n\t\t\t\t\tfilenames.push_back(argv[i+1]);\n\
    \t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"File does not exist: \"\
    \ << argv[i+1] << \"\\n\" << endl;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else\
    \ {\n\t\t\t\terror = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (PliverFileExists(argv[i]))\
    \ {\n\t\t\t\tfilenames.push_back(argv[i]);\n\t\t\t} else {\n\t\t\t\tcout << \"\
    File does not exist: \" << argv[i] << \"\\n\" << endl;\n\t\t\t\treturn 1;\n\t\t\
    \t}\n\t\t}\n\t}\n\n\tif (error) {\n\t\tcout << \"Usage:./pliver -c <filename>\
    \ -c <filename>./pliver <filename>\" << endl;\n\t\treturn 1;\n\t}\n\n\tfor (string\
    \ filename: filenames) {\n\t\tifstream file(filename);\n\t\tstring line;\n\t\t\
    while (getline(file, line)) {\n\t\t\tif (line.empty()) continue;\n\t\t\tvector<PliverToken>\
    \ tokens = Lexer::getTokens(line);\n\t\t\tif (tokens.empty()) continue;\n\t\t\t\
    Parser parser;\n\t\t\tif (parser.error) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\
    Node node = parser.parse(tokens);\n\t\t\tif (node.type == \"error\") {\n\t\t\t\
    \tstring msg = node.message + \"\\n\";\n\t\t\t\tcout << msg;\n\t\t\t\treturn 1;\n\
    \t\t\t}\n\t\t\ttry {\n\t\t\t\tip.execute(node, filename);\n\t\t\t} catch(InterpreterException\
    \ &ex) {\n\t\t\t\tcout << ex.what() << endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn 0;\n}/**\n* @file\n*\n* @author \n* @author \n*/\n\n#include\
    \ <string>\n#include <vector>\n#include <iostream>\n#include <fstream>\n\n#include\
    \ \"node.h\"\n#include \"interpreter.h\"\n#include \"interpreter_error_messages.h\"\
    \n\nusing namespace std;\n\n/** @brief Executes the given node.\n *\n *  @param\
    \ node The node to execute.\n *\n *  @details Executes the given node. Depending\
    \ on the type of node,\n *  the function will be one of:\n *  - execute() will\
    \ be called on each of the children of the node.\n *  - execute() will be called\
    \ on the statement in the declaration.\n *  - execute() will be called on each\
    \ of the children of the node.\n */\nvoid Interpreter::execute(Node& node, string\
    \ fileName) {\n\tif (node.type == \"error\") {\n\t\treturn;\n\t}\n\telse if (node.type\
    \ == \"module_declaration\") {\n\t\texecute(node.statement, fileName);\n\t}\n\t\
    else if (node.type == \"declaration\") {\n\t\texecute(node.statement, fileName);\n\
    \t}\n\telse if (node.type == \"instance_declaration\") {\n\t\texecute(node.statement,\
    \ fileName);\n\t}\n\telse if (node.type == \"module_instantiation\") {\n\t\texecute(node.statement,\
    \ fileName);\n\t}\n\telse if (node.type == \"instance_instantiation\") {\n\t\t\
    execute(node.statement, fileName);\n\t}\n\telse if (node.type == \"assign_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"if_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"if_else_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"while_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"generate_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"generate_case_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"process\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"task\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"process_declaration\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"task_declaration\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"while_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"for_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"case_statement\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"rand\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"randc\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"randomize\"\
    ) {\n\t\texecute(node.statement, fileName);\n\t}\n\telse if (node.type == \"module_declaration_block\"\
    ) {\n\t\tfor (Node n : node.children) {\n\t\t\texecute(n, fileName);\n\t\t}\n\t\
    }\n\telse if (node.type == \"declaration_block\") {\n\t\tfor (Node n : node.children)\
    \ {\n\t\t\texecute(n, fileName);\n\t\t}\n\t}\n\telse if (node.type == \"statement_block\"\
    ) {\n\t\tfor (Node n : node.children) {\n\t\t\texecute(n, fileName);\n\t\t}\n\t\
    }\n\telse if (node.type == \"statement\") {\n\n\t}\n\telse if (node.children.size()\
    \ == 0) {\n\t\tif (node.type == \"assign_statement\") {\n\t\t\tstring lhs = node.l_expression.token;\n\
    \t\t\tstring rhs = node.r_expression.token;\n\n\t\t\t// Make sure the lhs of an\
    \ assignment is a variable.\n\t\t\tif (lhs!= \"$\") {\n\t\t\t\tif (!isVariable(lhs))\
    \ {\n\t\t\t\t\tthrow InterpreterException(PliverErrorMessages::NOT_A_VARIABLE);\n\
    \t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the rhs variable is not a variable, we cannot\
    \ execute the assignment statement\n\t\t\t// to assign a value to it.\n\t\t\t\
    if (!isVariable(rhs) &&!isRandom(rhs)) {\n\t\t\t\tthrow InterpreterException(Pliver"
- code: "```\nstruct randval {\n int rand;\n};\n\nmodule testbench ();\ngenerate data;\n\
    process data;\nendmodule\n### Output:\n\n```\n== Testbench ==\nProcess ID (PID):\
    \ 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 6\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 0 ns\nDescription: \n== Testbench ==\nProcess ID (PID): 15168\nThread ID\
    \ (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\nLine:\
    \ 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\nTime:\
    \ 0 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 0 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 0 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 15168\nThread ID (TID): 15168\nFile: /home/yousef/Desktop/Veri-Random/src/testbench.v\n\
    Line: 7\nName: TESTBENCH_TOP\nModule: testbench\nClock: 500000\nState: Running\n\
    Time: 1 ns\nDescription: Generate statement: for (i=0; i<10; i=i+1)\n== Testbench\
    \ ==\nProcess ID (PID): 151"
- code: "module testbench ();\ngenerate data;\nprocess data;\nendmodule\n### Proposed\
    \ Solution:\nTo solve this issue, the data should be put in a struct with a rand\
    \ member. \n### Relevant Files:\n1. [data_struct.txt](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/data_struct.txt)\n\
    2. [testbench_with_data_struct.txt](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/testbench_with_data_struct.txt)\n\
    /Advanced_Topics_in_Verilog/Advanced_Topics_in_Verilog_11/Advanced_Topics_in_Verilog_11.md\n\
    # Advanced Topics in Verilog: 11 - Verilog for Computer Architectures and Performance\
    \ Analysis\n\n## Overview\n\n* The course content includes a presentation and\
    \ a set of assignments. The presentation gives an introduction to Verilog and\
    \ covers some of the concepts discussed in the lecture; the assignments provide\
    \ practice with Verilog.\n\n* The course has been split into 2 parts.\n\n  Part\
    \ 1 covers the Vivado HLS tool and performance analysis using the DSE flow.\n\n\
    \  Part 2 covers FPGAs, and gives an introduction to synthesis, mapping, and a\
    \ brief introduction to Vitis.\n\n* In the first part, you will use Vivado HLS\
    \ to port a C program to the x86 FPGA platform, and then use the DSE flow to generate\
    \ RTL for the program.\n\n* In the second part, you will synthesize the RTL to\
    \ an FPGA and then perform a mapping and timing analysis.\n\n* The assignments\
    \ included in Part 1 have been divided into 5 sections, and each section is marked\
    \ with a code snippet at the top of the file. The name of the section corresponds\
    \ to the Vivado HLS tool command used to execute the command. Each section contains\
    \ a Verilog code snippet, and there is a set of assignments to complete. The files\
    \ with the assignment names are listed in the table below. \n\n|  Section ID |\
    \ Section Name        | Code Snippet         | File           |\n| -----------\
    \ | ------------------- | ------------------- | -------------- |\n| 1        \
    \   | 1_add               | \"add\"                | \"adder.v\"      |\n| 2 \
    \          | 1_sub               | \"sub\"                | \"sub.v\"        |\n\
    | 3           | 2_add_sub           | \"add_sub\"            | \"add_sub.v\" \
    \   |\n| 4           | 3_add_sub_multiply  | \"add_sub_multiply\"  | \"add_sub_mult.v\"\
    \ |\n| 5           | 4_mult_div          | \"mult_div\"           | \"mult_div.v\"\
    \   |\n\n## Assignment 1\n\nIn this assignment, you will use the Vivado HLS tool\
    \ to port a simple C program to the x86 FPGA platform. The C program performs\
    \ simple arithmetic operations, and generates a 32 bit fixed point result. The\
    \ fixed point result is stored in a 32 bit integer. The fixed point format is\
    \ 15 bits integer and 16 bits fractional. The program also prints out the result\
    \ of the computation in text format. The program source can be found in the file\
    \ [adder.c](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/adder.c).\n\
    \nPort the program to the x86 FPGA platform. You will need to add a file to the\
    \ folder [hls](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/tree/main/Advanced_Topics_in_Verilog_11/hls).\
    \ This file will be the C source file to port to x86.\n\n```bash\nsudo hls -f./adder.c\
    \ -s add -o./hls -D x86_sim\n```\n\nTo generate the RTL for the adder, you will\
    \ use the Vivado HLS tool. In the command below, you will need to replace the\
    \ <ADD_SUB_MUL_MULT_DIV> with the name of the folder where your generated files\
    \ will be placed. The <ADDER.H> file will also need to be replaced with the name\
    \ of the header file for the generated code.\n\n```bash\nsudo vivado_hls -f <ADD_SUB_MUL_MULT_DIV>.tcl\n\
    ```\n\nThe tcl file will be placed in the [hls/syn](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/tree/main/Advanced_Topics_in_Verilog_11/hls/syn).\
    \ The file is called [adder.tcl](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/adder.tcl).\n\
    \nYou should now have the following files in the [hls/syn/verilog](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/tree/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog).\
    \ The files are: [adder.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder.v),\
    \ [multiplier.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/multiplier.v),\
    \ [adder.h](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder.h),\
    \ [adder_tb.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder_tb.v),\
    \ and a [project.runs](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder_tb.v).\n\
    \nIn the file [adder.h](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder.h),\
    \ you can see the function prototype for the function add.\n\n```verilog\nint\
    \ add(int, int);\n```\n\nYou can see the function call to the add function in\
    \ [adder_tb.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder_tb.v).\n\
    \n```verilog\ninitial begin\n    $dumpfile(\"adder_tb.vcd\");\n    $dumpvars(0,adder_tb,#0);\n\
    \    main_add_sub_mul_mult_div();\n    $finish;\nend\n```\n\nThe function main_add_sub_mul_mult_div()\
    \ can be found in [adder_tb.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder_tb.v).\n\
    \n```verilog\nvoid main_add_sub_mul_mult_div()\n{\n    int a = 1;\n    int b =\
    \ 2;\n    int result = add(a, b);\n    print_result(a, b, result);\n}\n```\n\n\
    The function print_result() can be found in [adder_tb.v](https://github.com/Vitis-Tutorials/Advanced_Topics_in_Verilog/blob/main/Advanced_Topics_in_Verilog_11/hls/syn/verilog/adder_tb.v).\n\
    \n```verilog\nvoid print_result(int a, int b, int result)\n{\n    $display(\"\
    %d + %d = %d\", $signed(a), $signed(b), $signed(result));\n    $display(\"\\n\"\
    );\n}\n```\n\n## Assignment 2\n\nIn this assignment, you will use the Vivado HLS\
    \ tool to port a simple C program to the x86 FPGA platform. The C program performs\
    \ simple arithmetic operations, and generates a 32 bit fixed point result. The\
    \ fixed point result is stored in a 32 bit integer. The fixed point format is\
    \ 15 bits integer and 16 bits fractional. The program also prints out the result\
    \ of the computation in text format. The program source can be found in"
- code: |-
    ```
    ```
    ### Description of Changes:
    ```
    ```

    # 05/22/2018 Bugs Fixed
    ## Test Case 1: Testcase1.v
    ### Base Verilog Code:
    module testbench ();
    generate data;
    process data;
    endmodule
    ### Variation Instruction:
    Add a paramter to the rand module that is used as an input to an internal module inside
- code: |-
    <img src="https://raw.githubusercontent.com/ShubhamGupta01/Randomization/master/img/proc.PNG" alt="Randomization" width="500">
    ### Results:
    <img src="https://raw.githubusercontent.com/ShubhamGupta01/Randomization/master/img/proc%20Result.PNG" alt="Results" width="500">### Base Verilog Code:
    module testbench ();
    generate data;
    process data;
    endmodule
    ### Variation Instruction:
    Replace the data construct with an alternativ
- code: |-
    module testbench ();
    input wire a0;
    output wire a1,a2,a3,a4;
    always @(posedge a0
- code: |-
    module tst_dff_pbeh();
      logic di,clk; logic do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    /code/verilog/basic_wave_gen/README.md
    # Basic Wave Generator
    This code is a basic wave generator which is based on the Verilog 'generate' statement. The basic wave generator can generate a waveform of bits, of any length, but with a fixed frequency. This means that every 1/frequency cycles the signal changes state. This is useful for basic tests where you want to know when an operation completes or if your design has an error. The code uses a 'for' loop to create the wave.
    ## How to Run
    After downloading the code, navigate to this folder in a terminal and run:

    `gtkwave gen_wave.vcd gen_wave.gtkw`

    This will open the resulting.vcd file in gtkwave.
- code: |-
    module tst_dff_pbeh();
      logic di,clk; logic [1:0] do;
      dff_p_logic d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ***
    */

    #include "Vdff_p_logic.h"
    #include "verilated.h"
    #include <iostream>

    // Define a macro to allow the use of SystemVerilog types in Verilator
    //#define USE_SYSTEM_VERILOG

    // Define a macro to allow the use of SystemVerilog types in gcc
    //#define USE_GCC_SYSTEM_VERILOG

    // Define a macro to allow the use of SystemVerilog types in gcc
    //#define USE_GCC_SYSTEM_VERILOG_C_API

    // Define a macro to allow the use of SystemVerilog types in gcc
    //#define USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99

    // Define a macro to allow the use of SystemVerilog types in gcc
    //#define USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99_LEGACY

    struct Vdff_p_logic__Syms;

    /////////////////////////////////////////////////////////////////////////
    ///      top-level module instantiation
    /////////////////////////////////////////////////////////////////////////

    Vdff_p_logic* Vdff_p_logic_factory_pbeh()
    {
      Vdff_p_logic* top = new Vdff_p_logic;
      return top;
    }

    void Vdff_p_logic_delete(Vdff_p_logic* top)
    {
      if (!top) return;
      delete top;
    }

    /////////////////////////////////////////////////////////////////////////
    ///    top-level module functions
    /////////////////////////////////////////////////////////////////////////

    Vdff_p_logic::Vdff_p_logic()
    : // Module setup
      name2id_(), id2name_(), clock(0), reset(0)
    {
      // Module instantiation
    //  Vdff_p_logic__Syms* __restrict vlSymsp = get_SimConfig()->symsp.get();
      Vdff_p_logic__Syms* __restrict vlSymsp = (Vdff_p_logic__Syms*)(new Vdff_p_logic__Syms(this, name()) );
      Vdff_p_logic*                __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;
      // Initialize Verilog module
      // Internals; generally not touched by application code
      begin();
    }

    Vdff_p_logic::~Vdff_p_logic()
    {
      // Module destruction
      // Deinitialize
      end();
    }

    void Vdff_p_logic::begin()
    {
      VL_DEBUG_IF(VL_DBG_MSGF("+Vdff_p_logic::begin\n"); );
      // INITIAL
      // Initials
      // Initial begin
      // Channel setup
      // Channel initials
    //  Vdff_p_logic__Syms* __restrict vlSymsp = get_SimConfig()->symsp.get();
      Vdff_p_logic__Syms* __restrict vlSymsp = (Vdff_p_logic__Syms*)(new Vdff_p_logic__Syms(this, name()) );
      Vdff_p_logic*                __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;
      // Body
      {
        // INTERNAL.name_map(12)
        // Tracing: _name_map
        // BEHAVIOUR WHEN BLOCK IS ENTERED
        VL_DEBUG_IF(VL_DBG_MSGF("+    Vdff_p_logic::_name_map(12)\n"); );
      }
      // Final
      _final();
      VL_DEBUG_IF(VL_DBG_MSGF("+Vdff_p_logic::end\n"); );
    }

    void Vdff_p_logic::end()
    {
    }

    void Vdff_p_logic::set_SimConfig(VerilatedConfig* cfg)
    {
      if (!cfg) return;
      // USE_SYSTEM_VERILOG
      define_sym2id(cfg->lookup_str("USE_SYSTEM_VERILOG"), 1, __Vm_sym2id);
      // USE_GCC_SYSTEM_VERILOG
      define_sym2id(cfg->lookup_str("USE_GCC_SYSTEM_VERILOG"), 1, __Vm_sym2id);
      // USE_GCC_SYSTEM_VERILOG_C_API
      define_sym2id(cfg->lookup_str("USE_GCC_SYSTEM_VERILOG_C_API"), 1, __Vm_sym2id);
      // USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99
      define_sym2id(cfg->lookup_str("USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99"), 1, __Vm_sym2id);
      // USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99_LEGACY
      define_sym2id(cfg->lookup_str("USE_GCC_SYSTEM_VERILOG_C_API_COMPAT_C99_LEGACY"), 1, __Vm_sym2id);
    }

    void Vdff_p_logic::define_sym2id(const char* name, int id, SymTab& sym2id)
    {
      sym2id.add(name, id, id);
    }

    void Vdff_p_logic::eval_step()
    {
    #ifdef TRACE
      if (Verilated::traceActivated())
        trace(dt, 1024);
    #endif //TRACE
    // Setup time_stamp
    // Evaluate reset
    // Evaluate clock
    // Initialize
    // Evaluate set (previous values, as saved by last eval_step()) of clock
        if (0 && (get_SimConfig()->top__Syms->syms->clk_port)) {
            // Evaluate clock(s)
            {
                const bool old = clk;
                if (get_SimConfig()->top__Syms->rst_inv && reset) { clk = old; }
                else if (get_SimConfig()->top__Syms->reset_i) { clk =!old; }
                else { clk =!old; }
                // Evaluate reset
                    clock = clk;
            }
        } else {
            // Evaluate clock(s)
            {
                const bool old = clk;
                if (get_SimConfig()->top__Syms->rst_inv && reset) { clk = old; }
                else if (get_SimConfig()->top__Syms->reset_i) { clk =!old; }
                else { clk =!old; }
                // Evaluate reset
                    clock = clk;
            }
        }
    }

    void Vdff_p_logic::eval_reset()
    {
    // Setup time_stamp
    // Reset time_stamp
    // Initialize
    // Evaluate reset
        reset = 0;
        {
            const bool old = clk;
            const bool old2 = reset;
            if (get_SimConfig()->top__Syms->rst_inv && reset_i) { clk = old; }
            else if (get_SimConfig()->top__Syms->reset_i) { clk =!old; }
            else { clk =!old; }
            reset =!old2;
        }
        // Evaluate clock(s)
            clock = clk;
    }


    // Verilated::debugDump
    void Vdff_p_logic
    ::_eval_debug_trace_init()
    {
      VL_DEBUG_IF(VL_DBG_MSGF("+Vdff_p_logic::_eval_debug_trace_init\n"); );
      // Variables
        Vdff_p_logic__Syms* __restrict vlSymsp = (Vdff_p_logic__Syms*)(this->__VlSymsp);
        Vdff_p_logic*              __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;
    }

    void Vdff_p_logic
    ::_eval_debug_trace_dump(VerilatedVcd* vcdp, uint32_t code)
    {
      VL_DEBUG_IF(VL_DBG_MSGF("+Vdff_p_logic::_eval_debug_trace_dump\n"); );
      // Variables
        Vdff_p_logic__Syms* __restrict vlSymsp = (Vdff_p_logic__Syms*)(this->__VlSymsp);
        Vdff_p_logic*              __restrict vlTOPp VL_ATTR_UNUSED = vlSymsp->TOPp;
    }

    void Vdff_p_logic
    ::_eval_initial_loop()
    {
      VL_DEBUG_IF(VL_DBG_MSGF("+Vdff_p_logic::_eval_initial_loop\n"); );

    }

    void Vdff_p_logic
- code: "module tst_dff_pbeh();\n  logic [3:0] di,clk; logic [3:0] do;\n  dff_p d1(do,di,clk);\
    \ // Instantiate DFF with path delay\n  initial begin clk=0; di=1'b0; #35 $stop;\
    \ end // Initialize & stop\n  always #3 clk=~clk; // Generate clock (negedges\
    \ at 6, 12, 18...)\n  always #5 di=~di; // Toggle data\n  initial $monitor($time,\"\
    clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n/src/main/java/edu/udel/cse/util/ClockedProcess.java\n\
    package edu.udel.cse.util;\n\nimport com.github.cambridgehackers.squirrel.core.exprs.Expr;\n\
    import com.github.cambridgehackers.squirrel.core.nodes.Block;\nimport com.github.cambridgehackers.squirrel.core.nodes.Statement;\n\
    import com.github.cambridgehackers.squirrel.core.nodes.Statement.StatementContext;\n\
    import com.github.cambridgehackers.squirrel.core.nodes.StatementImpl;\nimport\
    \ com.github.cambridgehackers.squirrel.core.nodes.Stmt;\nimport com.github.cambridgehackers.squirrel.core.nodes.Stmt.StmtContext;\n\
    import com.github.cambridgehackers.squirrel.core.nodes.Stmt.StmtContext.StmtContextImpl;\n\
    \n/**\n * A {@link com.github.cambridgehackers.squirrel.core.nodes.Statement}\
    \ that\n * creates a clocked process.\n */\npublic class ClockedProcess extends\
    \ StatementImpl {\n    private Expr clk;\n    private Stmt stmts;\n    private\
    \ Statement stmt;\n\n    /**\n     * Constructs a new {@code ClockedProcess}.\n\
    \     *\n     * @param context\n     *            {@link StatementContext} object.\n\
    \     * @param clk\n     *            A {@link com.github.cambridgehackers.squirrel.core.exprs.Expr}\n\
    \     *            object.\n     * @param body\n     *            A {@link com.github.cambridgehackers.squirrel.core.nodes.Block}\n\
    \     *            object.\n     */\n    public ClockedProcess(StmtContext context,\
    \ Expr clk, Block body) {\n        super(context);\n        this.clk = clk;\n\
    \        this.stmts = body;\n        this.stmt = new StmtContextImpl(context,\
    \ clk);\n        setStmts(stmts);\n    }\n\n    /**\n     * The statement that\
    \ will be part of the clocked process.\n     *\n     * @return A {@link Statemnt}.\n\
    \     */\n    public Statement getStmt() {\n        return this.stmt;\n    }\n\
    \n    /**\n     * An {@link Statement} that contains a single statement with the\
    \ clocked\n     * process body.\n     *\n     * @return An {@link Statement}.\n\
    \     */\n    @Override\n    public Statement getStmts() {\n        return this.stmt;\n\
    \    }\n\n    /**\n     * A {@link Stmt} that contains the clocked process body.\n\
    \     *\n     * @param stmts\n     *            A {@link Stmt}.\n     */\n   \
    \ @Override\n    public void setStmts(Stmt stmts) {\n        this.stmts = stmts;\n\
    \        this.stmt.setStmts(stmts);\n    }\n\n    /**\n     * Returns a {@link\
    \ Expr} that represents the clock.\n     *\n     * @return A {@link Expr}.\n \
    \    */\n    public Expr getClk() {\n        return this.clk;\n    }\n\n    /**\n\
    \     * Sets a new {@link Expr} for the clock.\n     *\n     * @param clk\n  \
    \   *            A {@link Expr}.\n     */\n    public void setClk(Expr clk) {\n\
    \        this.clk = clk;\n    }\n\n    /**\n     * Returns a {@link Block} that\
    \ represents the body of the clocked process.\n     *\n     * @return A {@link\
    \ Block}.\n     */\n    public Block getBody() {\n        return this.stmts.getBody();\n\
    \    }\n\n    /**\n     * Sets a new {@link Block} for the body of the clocked\
    \ process.\n     *\n     * @param body\n     *            A {@link Block}.\n \
    \    */\n    public void setBody(Block body) {\n        this.stmts.setBody(body);\n\
    \    }\n\n}\n/src/main/java/edu/udel/cse/util/ClockedProcessBuilder.java\npackage\
    \ edu.udel.cse.util;\n\nimport com.github.cambridgehackers.squirrel.core.exprs.Expr;\n\
    import com.github.cambridgehackers.squirrel.core.nodes.Block;\n\n/**\n * Class\
    \ that is used to build a clocked process.\n */\npublic class ClockedProcessBuilder\
    \ {\n    private Expr clk;\n    private Block body;\n\n    /**\n     * Constructs\
    \ a new {@code ClockedProcessBuilder}.\n     *\n     * @param clk\n     *    \
    \        A {@link Expr}.\n     * @param body\n     *            A {@link Block}.\n\
    \     */\n    public ClockedProcessBuilder(Expr clk, Block body) {\n        this.clk\
    \ = clk;\n        this.body = body;\n    }\n\n    /**\n     * Sets the {@code\
    \ clkExpr} for the clocked process.\n     *\n     * @param clk\n     *       \
    \     A {@link Expr}.\n     * @return A {@code ClockedProcessBuilder}.\n     */\n\
    \    public ClockedProcessBuilder withClk(Expr clk) {\n        this.clk = clk;\n\
    \        return this;\n    }\n\n    /**\n     * Sets the {@code body} of the clocked\
    \ process.\n     *\n     * @param body\n     *            A {@link Block}.\n \
    \    * @return A {@code ClockedProcessBuilder}.\n     */\n    public ClockedProcessBuilder\
    \ withBody(Block body) {\n        this.body = body;\n        return this;\n  \
    \  }\n\n    /**\n     * Returns a {@link ClockedProcess} that represents the clocked\
    \ process.\n     *\n     * @return A {@link ClockedProcess}.\n     */\n    public\
    \ ClockedProcess build() {\n        return new ClockedProcess(null, clk, body);\n\
    \    }\n}\n/README.md\n# Squirrel Extension\n\n[![Build Status](https://github.com/cambridgehackers/squirrel-extension/workflows/CI/badge.svg)](https://github.com/cambridgehackers/squirrel-extension/actions?query=workflow%3ACI)\n\
    \nThis extension contains macros and utilities for [Squirrel](https://squirrel-lang.github.io/).\n\
    \n## Using This Extension\n\nTo use this extension, add this extension to the\
    \ root of your Squirrel project's dependencies:\n```\n{\n\t\"dependencies\": [\n\
    \t\t{\n\t\t\t\"name\": \"squirrel-extension\",\n\t\t\t\"url\": \"https://github.com/cambridgehackers/squirrel-extension.git\"\
    \n\t\t}\n\t]\n}\n```\n\nThe following macros are provided by this extension:\n\
    \n### `clocked_process`\n```\nclocked_process(clk, body)\n```\nThis macro takes\
    \ two arguments:\n* A clock signal\n* A block of statements to be processed by\
    \ a clocked process\n\nExample:\n```verilog\nclocked_process(clk, [\n\treg a,\
    \ b, c;\n\n\talways @(posedge clk) begin\n\t\ta <= b + c;\n\tend\n]);\n```\n\n\
    ### `with_clock`\n```\nwith_clock(clk, body)\n```\nThis macro provides a block\
    \ of statements with a clock signal.\n\nExample:\n```verilog\nwith_clock(clk,\
    \ [\n\treg a, b, c;\n\n\talways @(posedge clk) begin\n\t\ta <= b + c;\n\tend\n\
    ]);\n```\n\n### `test`\n```\ntest(testName, test)\n```\nThis macro takes a test\
    \ name and an expression.\n\nExample:\n```verilog\ntest(\"Test name\", 1 == 1);\n\
    ```\n\n## Related Projects\n\n* [Squirrel](https://docs.squirrel-lang.org/) -\
    \ A new programming language for embedded systems.\n* [Squirrel Syntax Hierarchy](https://github.com/cambridgehackers/squirrel-syntax-hierarchy)\
    \ - A graphical representation of the syntax tree of Squirrel.\n* [Squirrel Syntax\
    \ Highlighters](https://github.com/cambridgehackers/squirrel-syntax-highlighters)\
    \ - Syntax highlighters for various editors using Squirrel.\n* [Squirrel Extension\
    \ for Atom](https://github.com/cambridgehackers/squirrel-extension-atom) - An\
    \ Squirrel Atom extension.\n/CHANGELOG.md\n# Changelog\nAll notable changes to\
    \ this project will be documented in this file.\n\nThe format is based on [Keep\
    \ a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres\
    \ to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\
    ### Added\n- `test` function"
- code: "#### Base Verilog Code:\nmodule tst_dff_pbeh();\n  logic [1:0] di,clk; logic\
    \ do;\n  dff_p d1(do,di,clk); // Instantiate DFF with path delay\n  initial begin\
    \ clk=0; di=1'b0; #35 $stop; end // Initialize & stop\n  always #3 clk=~clk; //\
    \ Generate clock (negedges at 6, 12, 18...)\n  always #5 di=~di; // Toggle data\n\
    \  initial $monitor($time,\"clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n####\
    \ Additional Verilog Code:\nThe following code was added to the end of the base\
    \ Verilog code:\n`logic [2:0] dff_p_types;`\n#### SystemVerilog Code:\nThe following\
    \ code was added to the end of the SystemVerilog code:\n`logic [2:0] dff_p_types;`\n\
    /src/main/resources/static/src/index.js\nimport Vue from 'vue'\nimport App from\
    \ './App.vue'\nimport Home from './Home.vue'\nimport Login from './Login.vue'\n\
    import Register from './Register.vue'\nimport VueRouter from 'vue-router'\nimport\
    \ VueSession from 'vue-session'\nimport VueSessionUi from 'vue-session-ui'\nimport\
    \ VueSessionStorage from 'vue-sessionstorage'\n\nimport 'bootstrap/dist/css/bootstrap.css'\n\
    import 'bootstrap/dist/css/bootstrap-theme.css'\nimport 'bootstrap-social/bootstrap-social.css'\n\
    import 'roboto-fontface/css/roboto/roboto.css'\nimport 'font-awesome/css/font-awesome.css'\n\
    \nVue.use(VueRouter)\nVue.use(VueSessionStorage)\nVue.use(VueSessionUi)\nVue.use(VueSession,\
    \ {\n  persist: true,\n  expires: 60 * 60 * 1000,\n  key: 'vue-session',\n  maxAge:\
    \ 60 * 60 * 1000,\n})\n\nconst routes = [\n  { path: '/register', component: Register\
    \ },\n  { path: '/login', component: Login },\n  { path: '/home', component: Home\
    \ },\n  { path: '/', component: Login },\n]\n\nconst router = new VueRouter({\n\
    \  routes, // short for `routes: routes`\n})\n\n// Set the default font for Vue\
    \ to Roboto\nVue.config.font = 'Roboto'\n\nVue.component('app', App)\nVue.component('home',\
    \ Home)\nVue.component('login', Login)\nVue.component('register', Register)\n\n\
    const app = new Vue({\n  el: '#app',\n  router,\n  template: '<app/>',\n})\n/src/main/resources/static/scripts/gen_verilator.sh\n\
    #!/bin/bash\n\n# Script that runs verilog simulation and generates a trace file\n\
    # Usage:\n#./gen_verilator.sh <module_name>\n# <module_name>: Name of the module\
    \ in the testbench to be compiled\n\n# Import the generated Verilog file to the\
    \ Vivado project\n# Import the generated VHDL file to the Vivado project\n\nmodule_name=$1\n\
    sim_name=${module_name}_tb\n# Generate the simulation result for top-level module\n\
    echo \"Compiling RTL simulation testbench for ${module_name}...\"\ncd ${sim_name}\n\
    verilator \\\n--cc -Wno-fatal \\\n--exe -Wno-fatal -CFLAGS \"-g\" \\\n--top-module\
    \ ${module_name} \\\n--Mdir obj_${module_name} \\\n--public \\\n--trace \\\n${sim_name}.v\
    \ \\\n--Mdir obj_${module_name} \\\n-f./sim.mk\n# Run the simulation\necho \"\
    Running RTL simulation for ${module_name}...\"\nmake -C obj_${module_name} -j\n\
    # Generate trace file\necho \"Generating trace file for ${module_name}...\"\n\
    ./obj_${module_name}/V${module_name} \\\n2>&1 | tee -a../${module_name}_trace.log\
    \ \n# Clear the Vivado project\necho \"Cleaning Vivado project for ${module_name}...\"\
    \nrm -rf./obj_${module_name}\n# Clean the simulation directory\necho \"Cleaning\
    \ simulation directory for ${module_name}...\"\ncd..\nrm -rf./${sim_name}\n/src/main/java/com/github/vasek17/verilog/service/impl/ProjectServiceImpl.java\n\
    package com.github.vasek17.verilog.service.impl;\n\nimport com.github.vasek17.verilog.constant.ProjectStatusCode;\n\
    import com.github.vasek17.verilog.dao.ProjectDao;\nimport com.github.vasek17.verilog.dao.UserRepository;\n\
    import com.github.vasek17.verilog.model.Project;\nimport com.github.vasek17.verilog.model.User;\n\
    import com.github.vasek17.verilog.service.ProjectService;\nimport org.springframework.beans.factory.annotation.Autowired;\n\
    import org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\n\
    public class ProjectServiceImpl implements ProjectService {\n\n    private ProjectDao\
    \ projectDao;\n    private UserRepository userRepository;\n\n    @Autowired\n\
    \    public ProjectServiceImpl(ProjectDao projectDao, UserRepository userRepository)\
    \ {\n        this.projectDao = projectDao;\n        this.userRepository = userRepository;\n\
    \    }\n\n    @Override\n    public List<Project> findAllByAuthor(User author)\
    \ {\n        return projectDao.findAllByAuthor(author);\n    }\n\n    @Override\n\
    \    public Project findById(Long id) {\n        return projectDao.findById(id).orElse(null);\n\
    \    }\n\n    @Override\n    public Project create(Project project) {\n      \
    \  project.setStatusCode(ProjectStatusCode.SAVED);\n        return projectDao.save(project);\n\
    \    }\n\n    @Override\n    public void delete(Long id) {\n        Project project\
    \ = findById(id);\n        if(project!= null) {\n            project.setStatusCode(ProjectStatusCode.DELETED);\n\
    \            projectDao.save(project);\n        }\n    }\n\n    @Override\n  \
    \  public Project assign(Long projectId, Long assignedToId) {\n        Project\
    \ project = findById(projectId);\n        User user = userRepository.findById(assignedToId).orElse(null);\n\
    \        if(project!= null && user!= null) {\n            project.setAssignedTo(user);\n\
    \            return projectDao.save(project);\n        }\n        return null;\n\
    \    }\n\n}\n/src/main/java/com/github/vasek17/verilog/dao/ProjectDao.java\npackage\
    \ com.github.vasek17.verilog.dao;\n\nimport com.github.vasek17.verilog.model.Project;\n\
    import com.github.vasek17.verilog.model.User;\nimport org.springframework.data.repository.CrudRepository;\n\
    import org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n\
    @Repository\npublic interface ProjectDao extends CrudRepository<Project, Long>\
    \ {\n\n    List<Project> findAllByAuthor(User author);\n\n}\n/src/main/java/com/github/vasek17/verilog/dao/UserRepository.java\n\
    package com.github.vasek17.verilog.dao;\n\nimport com.github.vasek17.verilog.model.User;\n\
    import com.github.vasek17.verilog.model.Verification;\nimport org.springframework.data.repository.CrudRepository;\n\
    import org.springframework.stereotype.Repository;\n\n@Repository\npublic interface\
    \ UserRepository extends CrudRepository<User, Long> {\n\n    User findByEmail(String\
    \ email);\n\n}\n/src/main/resources/static/scripts/gen_vivado.sh\n#!/bin/bash\n\
    \n# Script that runs synthesizable file, FPGA implementation, and FPGA bitstream\
    \ generation\n# Usage:\n#./gen_vivado.sh <module_name> <project_directory>\n#\
    \ <module_name>: Name of the module in the testbench to be compiled\n# <project_directory>:\
    \ Directory path of the Vivado project\n\nmodule_name=$1\nproj_dir=$2\n# Import\
    \ the generated Verilog file to the Vivado project\necho \"Importing generated\
    \ Verilog file to Vivado project...\"\ncp./${proj_dir}/${module_name}_tb/src/${module_name}.v./${proj_dir}/${module_name}/\n\
    # Import the generated VHDL file to the Vivado project\n# Generate the synthesizable\
    \ file for top-level module\necho \"Generating synthesizable file for top-level\
    \ module...\"\n./scripts/gen_synth.sh ${module_name}\n# Generate the"
- code: "module tst_dff_pbeh();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk); //\
    \ Instantiate DFF with path delay\n  initial begin\n    clk=0; di=1'b0; #35 $stop;\
    \ end // Initialize & stop\n  always #3 clk=~clk; // Generate clock (negedges\
    \ at 6, 12, 18...)\n  always #5 di=~di; // Toggle data\n  initial $monitor($time,\"\
    clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n\n### Test Result:\n\nThe data\
    \ is still valid, it just no longer has the path delay requirement on the path\
    \ to the DFF.\n\n## \tModule Instantiation with Multiple Timing Constraints\n\n\
    ### Base Verilog Code:\nmodule tst_dff_pbeh();\n  reg di,clk; wire do;\n  dff_p\
    \ d1(do,di"
- code: |-
    module tst_dff_pbeh();
      bit di,clk; bit [1:0] do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule

    # Code Verification

    The original code in this tutorial can be found here.
- code: |-
    module dff_pbeh(logic do, logic di, logic clk);
      logic [1:0] do, di, clk;
      always_ff @ (posedge clk) do <= di;
    endmodule

    ### Base Verilog Code:
    module dff_pbeh(output do, input di, input clk);
      reg [1:0] do, di, clk;
      always @ (posedge clk) do <= di;
    endmodule
    ### Variation Instruction:
    Change the clk declaration to
- code: |-
    module tst_dff_pbeh();
      logic di,clk, do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ```

    #### 2.3.2.5.2. SystemVerilog
    ```SystemVerilog
    ### Base Verilog Code:
    module tst_dff_pbeh();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate DFF with path delay
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock (negedges at 6, 12, 18...)
      always #5 di=~di; // Toggle data
      initial $monitor($time,"clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ### Variation Instruction:
    Change the reg declarations for di and clk to logic to test compatibility
- code: "module dff_p(output logic do, input logic di, input logic clk);\n  logic\
    \ [0:0] dout;\n  initial do=0;\n  always @(posedge clk) begin\n    if(di) begin\n\
    \      dout <= 1'b1;\n    end else begin\n      dout <= 0;\n    end\n  end\n \
    \ assign do = dout;\nendmodule\n```\n## How to use\n### Prerequisites\n- The file\
    \ `test_bench.sv` must be in the working directory and the path to this file must\
    \ be added to the `TOP_LEVEL_SOURCES` field of the Makefile.\n\n### Running\n\
    - Run `make` to generate the executable `test_bench`\n- Run `make sim` to run\
    \ the simulation. The result will be written to the file results.txt./p4.py\n\
    # \nimport sys\nfrom pyparsing import *\n\n# A function that takes in a variable\
    \ name and converts it to lowercase and underscore-separated\n# Returns the converted\
    \ name\ndef convert_varname(name):\n    return name.lower().replace(' ', '_')\n\
    \n# A function that takes in a module name and converts it to lowercase, underscore-separated,\
    \ and an extension of sv\n# Returns the converted name\ndef convert_module_name(name):\n\
    \    return name.lower().replace(' ', '_') + '.sv'\n\n# a function that takes\
    \ in a module name and converts it to lowercase, underscore-separated, and an\
    \ extension of v\n# Returns the converted name\ndef convert_module_name_vhdl(name):\n\
    \    return name.lower().replace(' ', '_') + '.v'\n\n# A function that takes in\
    \ a list of tokens and returns a dictionary of the tokens as key, and their converted\
    \ names as value\n# Returns a dictionary containing tokens and their converted\
    \ names\ndef convert_token_list(token_list):\n    return dict(map(lambda x : (convert_varname(x[0]),\
    \ convert_varname(x[1])), token_list))\n\n# A function that converts a module\
    \ name to a module declaration\n# Returns a string containing the module declaration\
    \ \ndef convert_module_declaration(module_name):\n    return'module'+ convert_module_name(module_name)\
    \ + '(clk_in);'\n\n# A function that takes in an input name and converts it to\
    \ lowercase and underscore-separated\n# Returns the converted name\ndef convert_input_name(name):\n\
    \    return name.lower().replace(' ', '_')\n\n# A function that takes in an output\
    \ name and converts it to lowercase and underscore-separated\n# Returns the converted\
    \ name\ndef convert_output_name(name):\n    return name.lower().replace(' ', '_')\n\
    \n# A function that takes in an internal name and converts it to lowercase and\
    \ underscore-separated\n# Returns the converted name\ndef convert_internal_name(name):\n\
    \    return name.lower().replace(' ', '_')\n\n# A function that takes in an input\
    \ declaration and converts it to a converted input name\n# Returns the converted\
    \ input name\ndef convert_input_declaration(input_name):\n    return convert_input_name(input_name)\n\
    \n# A function that takes in an output declaration and converts it to a converted\
    \ output name\n# Returns the converted output name\ndef convert_output_declaration(output_name):\n\
    \    return convert_output_name(output_name)\n\n# A function that takes in an\
    \ internal declaration and converts it to a converted internal name\n# Returns\
    \ the converted internal name\ndef convert_internal_declaration(internal_name):\n\
    \    return convert_internal_name(internal_name)\n\n# A function that takes in\
    \ an input declaration and converts it to an input declaration with a converted\
    \ name\n# Returns an input declaration with a converted name\ndef convert_input_declarations(input_declaration):\n\
    \    return convert_input_name(input_declaration) +'inout'\n\n# A function that\
    \ takes in an output declaration and converts it to an output declaration with\
    \ a converted name\n# Returns an output declaration with a converted name\ndef\
    \ convert_output_declarations(output_declaration):\n    return convert_output_name(output_declaration)\
    \ +'inout'\n\n# A function that takes in an internal declaration and converts\
    \ it to an internal declaration with a converted name\n# Returns an internal declaration\
    \ with a converted name\ndef convert_internal_declarations(internal_declaration):\n\
    \    return convert_internal_name(internal_declaration) +'out'\n\n# A function\
    \ that takes in a clock declaration and converts it to a converted clock name\n\
    # Returns a clock declaration with a converted name\ndef convert_clock(clock):\n\
    \    return convert_input_name(clock)\n\n# A function that takes in a state variable\
    \ name and converts it to lowercase and underscore-separated\n# Returns the converted\
    \ name\ndef convert_state_var_name(name):\n    return name.lower().replace(' ',\
    \ '_')\n\n# A function that takes in a state declaration with a state variable\
    \ name and converts it to an output declaration with a converted name\n# Returns\
    \ a state declaration with the converted output name\ndef convert_state_var_declaration(state_var_declaration):\n\
    \    return convert_output_declaration(state_var_declaration)\n\n# A function\
    \ that takes in a state declaration with a state variable name and converts it\
    \ to an output declaration with a converted name\n# Returns a state declaration\
    \ with the converted output name\ndef convert_state_var_declarations(state_var_declarations):\n\
    \    return convert_output_declarations(state_var_declarations)\n\n# A function\
    \ that takes in an input declaration and converts it to a converted input name\n\
    # Returns a converted input name\ndef convert_input_declaration_only(input_declaration):\n\
    \    return convert_input_name(input_declaration)\n\n# A function that takes in\
    \ an output declaration and converts it to a converted output name\n# Returns\
    \ a converted output name\ndef convert_output_declaration_only(output_declaration):\n\
    \    return convert_output_name(output_declaration)\n\n# A function that takes\
    \ in an internal declaration and converts it to a converted internal name\n# Returns\
    \ a converted internal name\ndef convert_internal_declaration_only(internal_declaration):\n\
    \    return convert_internal_name(internal_declaration)\n\n# A function that takes\
    \ in a state declaration with a state variable name and converts it to an output\
    \ declaration with a converted name\n# Returns a state declaration with the converted\
    \ output name\ndef convert_state_var_declaration_only(state_var_declaration):\n\
    \    return convert_state_var_name(state_var_declaration)\n\n# a function that\
    \ takes in a list of tokens and returns a dictionary of the tokens as key, and\
    \ their converted names as value\n# Returns a dictionary containing tokens and\
    \ their converted names\ndef convert_token_list_vhdl(token_list):\n    return\
    \ dict(map(lambda x : (convert_varname_vhdl(x[0]), convert_varname_vhdl(x[1])),\
    \ token_list))\n\n# A function that takes in a variable name and converts it to\
    \ lowercase, underscore-separated, and an extension of vhdl\n# Returns the converted\
    \ name\ndef convert_varname_vhdl(name):\n    return name.lower().replace('-',\
    \ '_').replace(' ', '_')\n\n# A function that takes in a module name and converts\
    \ it to lowercase, underscore-separated, and an extension of vhdl\n# Returns the\
    \ converted name\ndef convert_module_name_vhdl(name):\n    return name.lower().replace('\
    \ ', '_') + '.vhd'\n\n# A function that takes in an input name and converts it\
    \ to lowercase and underscore-separated\n# Returns the converted name\ndef convert_input_name_vhdl(name):\n\
    \    return name.lower().replace(' ', '_')\n\n# A function that takes in an output\
    \ name and converts it to lowercase and underscore-separated\n# Returns the converted\
    \ name\ndef convert_output_name_vhdl(name):\n    return name.lower().replace('\
    \ ', '_')\n\n# A function that takes in an internal name and converts it to lowercase\
    \ and underscore-separated\n# Returns the converted name\ndef convert_internal_name_vhdl"
- code: "module tst_dff_pbeh();\n  logic di,clk; logic [1:0] do;\n  dff_p d1(do,di,clk);\
    \ // Instantiate DFF with path delay\n  initial begin clk=0; di=1'b0; #35 $stop;\
    \ end // Initialize & stop\n  always #3 clk=~clk; // Generate clock (negedges\
    \ at 6, 12, 18...)\n  always #5 di=~di; // Toggle data\n  initial $monitor($time,\"\
    clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n\n/README.md\n# vta\n\nVeriTIGER:\
    \ Test-Driven Integration of GDS-Compatible IPs for Verilog/SystemVerilog\n\n\
    [![DOI](https://zenodo.org/badge/68825652.svg)](https://zenodo.org/badge/latestdoi/68825652)\n\
    \n\n## Overview\n\nThe VeriTIGER package is an implementation of a test-driven\
    \ methodology for integrating GDS-compatible IPs to larger testbenches. In particular,\
    \ it allows users to integrate a library of GDS-compatible IPs into a testbench\
    \ where the input/output interfaces of the IPs are specified. The purpose of the\
    \ test-driven methodology is to increase the efficiency of the testbenches by\
    \ lowering the number of unique testbenches needed to test the IPs under each\
    \ of the different test cases.\n\n## Installation\nTo install, make sure you have\
    \ a Python3 environment.\n```bash\npip install -r requirements.txt\n```\n\n##\
    \ Run\nTo run, go to a test directory and run the following command.\n\n```bash\n\
    python vta_cmd.py --inputs verilog\n```\n\n/testbenches/dff/Makefile\n# Makefile\
    \ for VeriTIGER\n\nSIM = vvp\n\nrun: test_dff_pbeh\n\t./test_dff_pbeh\n\nclean:\n\
    \trm -f *.vcd *.vlog\n\ntest_dff_pbeh: test_dff_pbeh.v\n\tiverilog -o test_dff_pbeh\
    \ -I../../../libs/pbeh_library/pbeh_tb -s test_dff_pbeh test_dff_pbeh.v\n\t$(SIM)\
    \ test_dff_pbeh\n/libs/pbeh_library/README.md\n# pbeh_library\n\nThe pbeh_library\
    \ is a library of Verilog HDL testbenches that can be used as a starting point\
    \ to help with integration.\n\nThe pbeh_library is a work in progress, and will\
    \ be expanded in the future to include additional testbenches.\n\n## Installation\n\
    To install, make sure you have a Python3 environment.\n```bash\npip install -r\
    \ requirements.txt\n```\n\n## Run\nTo run, go to a test directory and run the\
    \ following command.\n\n```bash\npython vta_cmd.py --inputs verilog --testbench\
    \ pbeh\n```\n\n## Testbenches\n\nThe pbeh_library includes the following testbenches:\n\
    * dff_p_tb: Testbench for a synchronous D-flip-flop with path delay.\n* dff_pbeh:\
    \ Testbench using the Path-Based Event Handling (PBEH) tool. \n* tst_dff_pbeh:\
    \ Companion test case for dff_pbeh."
- code: |-
    always @(a or b or c or d)
    if (a && b &&!c && d) output_pulse <= 1'b1;
    endmodule

    ### Verilog Code:
    always @(a or b or c or d)
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0;
    else if (switch) switch_bounce_delay <= 1'b1;
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0 after 10 us;
    else if (switch) switch_bounce_delay <= 1'b1 after 10 us;
    ### Variation Instruction:
    Remove all of the logic surrounding the switch_bounce_delay signal as it is just being used to debounce the switch signal and replace it with the following line of code.
    delay(10);

    ### Verilog Code:
    always @(a or b or c1 or c2)
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0 after 10 us;
    else if (switch) switch_bounce_delay <= 1'b1 after 10 us;
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0;
    else if (switch) switch_bounce_delay <= 1'b1;
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0 after 10 us;
    else if (switch) switch_bounce_delay <= 1'b1 after 10 us;
    ### Variation Instruction:
    Remove the logic surrounding the switch_bounce_delay signal and replace it with the following single line of code.
    delay(10);

    ### Verilog Code:
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0;
    else if (switch) switch_bounce_delay <= 1'b1;
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0 after 10 us;
    else if (switch) switch_bounce_delay <= 1'b1 after 10 us;
    ### Variation Instruction:
    Remove all of the debouncing logic from the first two if blocks and replace this code with the following single line of code.
    delay(10);

    ### Verilog Code:
    output_pulse <= 1'b0;
    delay(10);
    output_pulse <= 1'b1;
    delay(10);
    ### Variation Instruction:
    Replace all of the code with a single line of code.
    delay(10);

    ### Verilog Code:
    always @(a or b or c1 or c2)
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0;
    else if (switch) switch_bounce_delay <= 1'b1;
    // Debouncing switch with a 10 ms delay after each debouncing cycle
    if (!switch) switch_bounce_delay <= 1'b0 after 10 us;
    else if (switch) switch_bounce_delay <= 1'b1 after 10 us;
    ### Variation Instruction:
    Remove all of the delay logic from the code and replace the entire code block with the following single line of code.
    delay(10);
- code: |-
    module MemoryReadWrite ( input [31:0] address, input [31:0] data,
    output logic ready,
    output logic [31:0] read_data,
    input mem_reg_out,
    output logic rd_reg );

    ## The Memory Read Write Module: Module Declaration

    The memory read write module is a Verilog module with three inputs, the address from the Instruction Fetch module and the address from the Latch module. The memory read write module has three outputs, ready and the data from memory. Each data input is a logic signal for Verilog.

    ### Base Verilog Code:

    module MemoryReadWrite ( input [31:0] address,
    input [31:0] data,
    output reg ready,
    output reg [31:0] read_data );
    endmodule

    ### Variation
- code: |-
    logic [7:0] a, b;
    input pass, add;
    logic [7:0] alu_out;

    always @(a or b or pass or add)
    if (pass) alu_out = a;       // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0;           // Default output is 0

    ### Result:

    I can simulate the new code without any errors.

    # 3. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in Verilog.

    # 4. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL.

    # 5. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL.

    # 6. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL.

    # 7. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL.

    # 8. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL.

    # 9. ALU (VHDL)

    This example shows how to write the ALU using VHDL for the FPGA in VHDL
- code: "module ALU ( input [7:0] a, b, input pass, add,\noutput logic [7:0] alu_out\
    \ );\n// Simple combinational ALU\nalways @(a or b or pass or add)\nif (pass)\
    \ alu_out = a;       // Pass input 'a'\nelse if (add) alu_out = a + b; // Add\
    \ inputs 'a' and 'b'\nelse alu_out = 0;           // Default output is 0\nendmodule\n\
    \n## How to test?\n\n### Compile and run the Verilog code:\nThe code is tested\
    \ for synthesis and simulation. Verilog source files are included in src/alu directory.\
    \ To generate a.vcd file, execute the following command:\n\n> iverilog -o alu_tb\
    \ -g2012 -Isrc -I/home/student/fpgasim/src/sv/ -Wall -DSIM=1 alu_tb.v alu.v\n\n\
    > vvp alu_tb -n 25\n\n>./gen_trace.py --vcd alu_tb.vcd\n\n### Verify Verilog code:\n\
    \u2022 Open the simulation waveform (.vcd) file in gtkwave and review the simulation\
    \ results\n\n\u2022 Open the synthesis log file (alu_tb.map) in an editor. The\
    \ synthesis results are aligned with the Verilog code.\n\n## How to synthesize\
    \ to a gate-level netlist:\n\n### Compile and run the Verilog code:\nThe code\
    \ is compiled for synthesis and not for simulation. Execute the following command:\n\
    \n> iverilog -o alu_tb -g2012 -Isrc -I/home/student/fpgasim/src/sv/ -Wall -DSIM=0\
    \ alu_tb.v alu.v\n\nThe following command generates synthesis reports:\n\n>./synth_alu.py\
    \ alu.v\n\nThe following command converts the generated report to JSON format:\n\
    \n>./report2json.py -f alu_tb.rpt -o alu_tb.json\n\n## References\n\n\u2022 Verilog\
    \ HDL Language Specification\n\n\u2022 A Guide to Verilog: The Definitive Guide,\
    \ 4th Edition"
- code: "module ALU ( input [7:0] a, b, input pass, add,\noutput logic [7:0] alu_out\
    \ );\n// Simple combinational ALU\nalways @(a or b or pass or add)\nif (pass)\
    \ alu_out = a;       // Pass input 'a'\nelse if (add) alu_out = a + b; // Add\
    \ inputs 'a' and 'b'\nelse alu_out = 0;           // Default output is 0\nendmodule\n\
    \n### Summary\n\nIn a previous section, we saw how to declare a simple combinational\
    \ signal (a register), assign it a value, and read it in a basic Verilog testbench.\n\
    \nIn this section, we will extend our knowledge by implementing a simple arithmetic\_\
    logic unit (ALU) in combination hardware. The ALU takes two 8-bit inputs, and\
    \ an add/pass indicator, as well as outputting a 8-bit result.\n\nThe ALU is a\
    \ hardware component that performs basic arithmetic on a set of inputs. Most ALUs\
    \ will also output a carry if the output results in a non-zero value. The Verilog\
    \ code below is a simple implementation of an 8-bit ALU.\n\n    module ALU ( input\
    \ [7:0] a, b, input pass, add,\noutput reg [7:0] alu_out );\n\n// Simple combinational\
    \ ALU\nalways @(a or b or pass or add)\nif (pass) alu_out = a;       // Pass input\
    \ 'a'\nelse if (add) alu_out = a + b; // Add inputs 'a' and 'b'\nelse alu_out\
    \ = 0;           // Default output is 0\nendmodule\n\nThe Verilog code above is\
    \ the most basic version of an 8-bit ALU. You will now be tasked with modifying\
    \ the code above to make the following features of a modern 8-bit ALU work.\n\n\
    \u2022 The ALU outputs the result of its computation (and only the result of its\
    \ computation)\n\u2022 The ALU can support carry-out\n\nThe first two requirements\
    \ above are trivial to meet. The last requirement will require the introduction\
    \ of a new component to our chip, which is the register file.\n\nThe register\
    \ file is a collection of 8-bit registers that are accessible via an address select.\
    \ The register file will be responsible for holding the intermediate values of\
    \ the ALU.\n\nThe Verilog code below is a register file (with 8 8-bit registers).\
    \ The inputs to the register file are a set of 8-bit data, a set of 2-bit address,\
    \ a set of 2-bit write enable (we will use this to enable writing to registers),\
    \ and a set of 1-bit write (we will use this to write to the registers).\n\n \
    \   module RegFile(input [7:0] data, input [1:0] a_addr, input [1:0] w_addr, input\
    \ write,\noutput reg [7:0] reg_out);\n\n// The first part of the module is the\
    \ register file itself\nreg [7:0] reg [7:0];\n\n// The second part is the write\
    \ logic\nalways @(posedge write)\nif (w_addr[1]) reg[a_addr[1]] <= reg[a_addr[0]]\
    \ + data;          // Add a_addr[0] to data\nelse if (w_addr[0]) reg[a_addr[0]]\
    \ <= data;                       // Copy data to a_addr[0]\nelse reg_out = reg[a_addr[0]];\
    \                                     // Read from a_addr[0]\n\nendmodule\n\n\
    The Verilog code above is a basic register file implementation. There are two\
    \ parts to the implementation. The first part is the register file itself. The\
    \ signal data is copied from the ALU output to the input to the register file\
    \ when the write enable is 1. The second part is the write logic. The write logic\
    \ is responsible for writing to the registers. The write logic first checks to\
    \ see if the write enable signal is enabled for the second address. If it is,\
    \ then it adds the value at the first address to the data input. If the write\
    \ enable signal is enabled for the first address, then it copies the data value\
    \ to the first address. If no write enable is enabled, then the register output\
    \ is simply the value stored at the first address.\n\nThe above code is a basic\
    \ implementation of a register file with 8 registers. If additional registers\
    \ are required, you only need to add more registers to the RegFile module by adding\
    \ more reg [7:0] reg [7:0]; lines. Additionally, you only need to add more address\
    \ lines to the register file by adding more input [1:0] w_addr, input [1:0] a_addr,\
    \ to the RegFile module.\n\n## Modifying the ALU to support a modern 8-bit ALU\n\
    \nIn the previous section, you learned how to implement a simple 8-bit ALU in\
    \ Verilog. We will now modify the ALU implementation we created in the previous\
    \ subsection to meet the requirements of modern hardware."
- code: "library IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity ALU is\n\nport (\n\
    a: in  std_logic_vector(7 downto 0);\nb: in  std_logic_vector(7 downto 0);\npass:\
    \ in  std_logic;\nadd: in  std_logic;\nalu_out: out std_logic_vector(7 downto\
    \ 0)\n);\n\nend ALU;\n\n## VHDL to VHDL Conversion\n\n\u2022 VHDL is a hardware\
    \ description language.\n\u2022 VHDL is a superset of Verilog.\n\u2022 VHDL can\
    \ be used to describe the whole circuit.\n\u2022 VHDL is mostly used to define\
    \ the interface between the hardware and the software.\n\u2022 VHDL is used to\
    \ simulate the hardware.\n\u2022 VHDL is a formal language.\n\n## VHDL Description\
    \ Languages\n\n### VHDL Description Languages\n\n\u2022 VHDL Description Languages\
    \ help to declare the various signal types.\n\u2022 VHDL Description Languages\
    \ help to define the functions.\n\u2022 VHDL Description Languages helps to describe\
    \ the hardware.\n\u2022 VHDL Description Languages help to describe the interfaces.\n\
    \n### Keywords and Types in VHDL\n\n\u2022 Keywords have a pre-defined meaning\
    \ in VHDL.\n\u2022 Keywords are reserved in VHDL.\n\u2022 Keywords are case sensitive.\n\
    \u2022 Keywords are used to declare various types.\n\u2022 Keywords are used to\
    \ define various functions.\n\u2022 Keywords are used to describe the hardware.\n\
    \u2022 Keywords are used to describe the interfaces.\n\u2022 Keywords are used\
    \ to describe the various types of signals.\n\n### VHDL Description Languages\
    \ Keywords\n\n\u2022 library\n\u2022 package\n\u2022 interface\n\u2022 entity\n\
    \u2022 generate\n\u2022 procedure\n\u2022 function\n\u2022 architecture\n\u2022\
    \ primitive\n\u2022 constant\n\u2022 signal\n\u2022 signal\n\u2022 std_logic\n\
    \u2022 std_logic_vector\n\u2022 std_logic_vector\n\u2022 std_logic\n\u2022 std_logic_vector\n\
    \n## VHDL Description Languages Keywords:\n\n\u2022 Library keywords can be used\
    \ to specify a library name.\n\u2022 Package keywords can be used to specify a\
    \ package name.\n\u2022 Interface keywords can be used to specify an interface\
    \ name.\n\u2022 Entity keywords can be used to specify an entity name.\n\u2022\
    \ Generate keywords can be used to specify a generate name.\n\u2022 Procedure\
    \ keywords can be used to specify a procedure name.\n\u2022 Function keywords\
    \ can be used to specify a function name.\n\u2022 Architecture keywords can be\
    \ used to specify an architecture name.\n\u2022 Primitive keywords can be used\
    \ to specify a primitive name.\n\u2022 Constant keywords can be used to specify\
    \ a constant name.\n\u2022 Signal keywords can be used to specify a signal name.\n\
    \u2022 Std_logic keywords can be used to specify a std_logic name.\n\u2022 Std_logic_vector\
    \ keywords can be used to specify a std_logic_vector name.\n\u2022 Std_logic_vector\
    \ keywords can be used to specify a std_logic_vector name.\n\n### Keywords:\n\n\
    \u2022 Library keywords can be used to specify a library name.\n\u2022 Package\
    \ keywords can be used to specify a package name.\n\u2022 Interface keywords can\
    \ be used to specify an interface name.\n\u2022 Entity keywords can be used to\
    \ specify an entity name.\n\u2022 Generate keywords can be used to specify a generate\
    \ name.\n\u2022 Procedure keywords can be used to specify a procedure name.\n\u2022\
    \ Function keywords can be used to specify a function name.\n\u2022 Architecture\
    \ keywords can be used to specify an architecture name.\n\u2022 Primitive keywords\
    \ can be used to specify a primitive name.\n\u2022 Constant keywords can be used\
    \ to specify a constant name.\n\u2022 Signal keywords"
- code: "module ALU ( input   [7:0] a, b, input pass, add,\noutput  logic [15:0] alu_out\
    \ );\n// Simple combinational ALU\nalways @(a or b or pass or add)\nif (pass)\
    \ alu_out = a;       // Pass input 'a'\nelse if (add) alu_out = a + b; // Add\
    \ inputs 'a' and 'b'\nelse alu_out = 0;           // Default output is 0\nendmodule\n\
    ### The Compiler\u2019s View of the Code:\n* Note the logic [15:0] modifier that\
    \ is now used to declare an output.\n* The compiler no longer complains that the\
    \ output type is \u201Cunsigned\u201D and not \u201Clogic\u201D.\n* The output\
    \ type is now \u201Clogic\u201D.\n* The output type is now \u201Cunsigned\u201D\
    , but this is OK.\n\n## 15.19 Unsigned Data and Virtuoso\n\n### Base Verilog Code:\n\
    module ALU ( input [7:0] a, b, input pass, add,\noutput reg [7:0] alu_out );\n\
    // Simple combinational ALU\nalways @(a or b or pass or add)\nif (pass) alu_out\
    \ = a;       // Pass input 'a'\nelse if (add) alu_out ="
- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out ); // Changed the output type
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a; // Pass input 'a'
    else if (add) alu_out = a + b; // Add inputs 'a' and 'b'
    else alu_out = 0; // Default output is 0
    endmodule
    ### Altering the verilog code
    It is not necessary to alter the code to make the module work correctly.
    Now we have created the ALU module. Let us connect it to the CPU module via the connections.
    19
    The CPU Control Module
    Module Name Signal Type Module Input Output a, b, pass, add Control A
    a_reg[7:0], b_reg[7:0],
    pass, add,
    cpu.alu.a_reg[7:0], cpu.alu.b_reg[7:0], cpu.alu.pass, cpu.alu.add ALU,
    alu_out cpu.alu.alu_out[7:0],
    cpu_alu_out[7:0]
    ### Altering the Verilog Code:
    module CPU ( input [15:0] a, b, input pass, add,
    output logic [15:0] cpu_alu_out );
    // Control input to the ALU
    input [7:0] a_reg, b_reg;
    input [7:0] pass, add;
    // The ALU
    ALU cpu_alu (.a_reg(a_reg),.b_reg(b_reg),.pass(pass),.add(add));
    always @*
    cpu_alu_out = cpu_alu.alu_out; // Forward the ALU output
    endmodule
    We use a control register to create the ALU module.
    We do not need to modify the CPU module.
    The control registers are always active low.
    They do not need to be updated at any time.
    ### Altering the code:
    // Control input to the ALU
    input [7:0] a_reg, b_reg;
    input [7:0] pass, add;
    // The ALU
    ALU cpu_alu (.a_reg(a_reg),.b_reg(b_reg),.pass(~pass), // Changed the output from active low to active high.
    .add(~add));
    always @*
    cpu_alu_out = cpu_alu.alu_out; // Forward the ALU output
    endmodule
    100
    The CPU Control Module
    8.4.3.4 The Branch Module:
    Branch Module:
    Input
    Control a, b, add, pass
    Output
    cpu_br_out
    ### Base Verilog Code:
    module Branch ( input [7:0] a, b, input pass, add,
    output reg cpu_br_out );
    // Branching module
    // Always keep track of the PC
    integer pc;
    assign pc = a;
    // If branches are enabled,
    // execute branching logic
    if (pass)
    always @(a or b)
    if (add)
    pc = pc + 4;
    cpu_br_out = 1; // Indicate a branch
    else cpu_br_out = 0; // Indicate no branch
    endmodule
    ### Altered Verilog Code:
    module Branch ( input [7:0] a, b, input pass, add,
    output logic cpu_br_out );
    // Branching module
    // Always keep track of the PC
    integer pc;
    assign pc = a;
    // If branches are enabled,
    // execute branching logic
    if (pass)
    always @(a or b) // Changed the pass signal logic
    if (add)
    pc = pc + 4;
    cpu_br_out = 1; // Indicate a branch
    else cpu_br_out = 0; // Indicate no branch
    endmodule
    ### Altered CPU Module Code:
    module CPU ( input [15:0] a, b, input pass, add,
    output logic [15:0] cpu_alu_out,
    output logic cpu_br_out );
    // Control input to the ALU
    input [7:0] a_reg, b_reg;
    input [7:0] pass, add;
    // The ALU
    ALU cpu_alu (.a_reg(a_reg),.b_reg(b_reg),
    .pass(~pass), // Changed the output from active low to active high.
    .add(~add));
    Branch cpu_branch ( // The branch module
    .a(a_reg),.b(b_reg),
    .pass(~pass),.add(~add));
    assign cpu_alu_out = cpu_alu.alu_out; // Forward the ALU output
    assign cpu_br_out = cpu_branch.cpu_br_out; // Forward the branch output
    endmodule
    Next we will look at the complete CPU module. You can use this module for all future CPU designs in this book.
    101
    The CPU Control Module
    9. Summary:
    In this chapter we have designed the CPU control module.
    The CPU module was modified to include 2 control signals (pass, add) instead of one (add). The output of the CPU is now the ALU output and the branch output.
    102
    Chapter 10: The CPU Bus Interface
    The CPU bus provides the system with access to the peripherals it needs.
    The peripheral buses provide the CPU with information on how to access the peripherals.
    The CPU bus must have different buses for each peripheral because the peripherals may be different.
    103
    The CPU Bus Interface
    10.1.1.1 The Verilog Code:
    module bus_interface (
    input [31:0] addr,
    input [31:0] data_in,
    output [31:0] data_out,
    input r_w,
    input clk,
    input we,
    output done,
    output [31:0] rdata,
    output we_n,
    output clk_n,
    output strobe,
    output [4:0] addr_bus,
    output [2:0] rw_bus );
    // I/O interface to CPU
    // Input
    input [31:0] addr,
    input [31:0] data_in,
    input [31:0] data_out,
    input clk;
    // Control bits
    input [3:0] addr_cmd,
    input [2:0] r_w,
    // Output
    output [31:0] data_out,
    output [31:0] rdata,
    // Control outputs
    output done,
    output we,
    output [7:0] we_n,
    output [7:0] clk_n,
    output strobe,
    output [4:0] addr_bus,
    output [2:0] rw_bus );
    // CPU address bus
    output [31:0] addr_out;
    // I/O address
    output [31:0] data_out;
    // CPU data bus
    output [4:0] addr_bus;
    // CPU address bus
    output [2:0] rw_bus; // Read/Write bit
    // I/O port
    output we;
    output we_n;
    output clk;
    output clk_n;
    output strobe;
    // Data read
    assign rdata = data_in;
    // Data write
    assign data_out = data_in;
    // Control signals
    assign done = 1'b0;
    assign clk = 0;
    assign clk_n = 0;
    assign strobe = 0;
    // Address bus
    assign addr_bus = addr;
    assign addr_out = addr;
    assign rw_bus = r_w; // Read/Write bit
    always @(posedge clk)
    begin
    we <= r_w;
    clk <= clk_n;
    clk_n <= clk;
    endmodule
    104
    The CPU Bus Interface
    10.1.2.2 The Altera Image:
    The CPU bus is not part of the Altera image.
    It is not necessary to create a bus interface for the Altera image. The Altera image already has the correct I/O ports to provide access to the peripherals.
    105
    The CPU Bus Interface
    10.1.2.3 The Intel Image:
    The Intel image has separate I/O ports for each peripheral.
    In this case, the CPU bus interface is also necessary, as it provides access to the peripherals.
    106
    Chapter 10: The CPU Bus Interface
    10.2.1.1 The Verilog Code:
    module bus_interface (
    input [31:0] addr,
    input [31:0] data_in,
    output [31:0] data_out,
    input r_w,
    input clk,
    input we,
    output [31:0] rdata,
- code: |-
    module ALU ( input [7:0] a, b, input pass, add,
    output logic [7:0] alu_out );
    // Simple combinational ALU
    always @(a or b or pass or add)
    if (pass) alu_out = a;
- code: |-
    module FSM(
    input [3:0] counter_in,
    output logic [3:0] counter_out,
    input enable,
    input clock);

    reg [3:0] counter_out;

    always @(posedge clock or negedge enable)
    if (enable == 1)
    counter_out <= counter_in;
    else
    counter_out <= counter_in + 1;

    endmodule

    ## FSM_4BIT

    This example shows how to define a Finite State Machine component that can operate as a 4-bit counter.

    ### Base Verilog Code:
    module FSM_4BIT(
    input [3:0] counter_in,
    output reg [3:0] counter_out,
    input enable_counter);

    reg [3:0] next_state;
    reg counter_init;

    always @(posedge clock or negedge reset)
    if (reset)
    counter_init <= 0;
    else
- code: |-
    module AndOr (output X, Y, input A, B, C);
    logic [1:0] X, Y;
    assign #10 X = A << 3;
    assign #1
- code: "module AndOr (output X, Y, input A, B, C);\nassign #10 X = A & B;\nassign\
    \ #10 Y = B | C;\nendmodule\n### Expected Results:\nX should be 4'b0010 and Y\
    \ should be 4'b1110.\n### Comments or rationale:\nThe constant was changed to\
    \ 4'b1100.\n/lab6/code/src/test/vunit/TestAndOr.c\n// TestAndOr.c\n//\n// Programmer:\
    \ \n// Created: 2020-09-09\n// Last Modified: 2021-01-28\n//\n// TestAndOr.c provides\
    \ C-based unit testing of the AndOr module in test/vunit/\n//\n\n#include <stdlib.h>\n\
    #include \"svdpi.h\"\n#include \"Tester.h\"\n\n// Test and verify that the AndOr\
    \ module produces the correct output\nvoid testAndOr() {\n    // Module parameters\n\
    \    char *outputNames[3] = {\"X\", \"Y\", NULL};\n    int outputNums[2] = {1,\
    \ 2};\n    char *inputNames[2] = {\"A\", \"B\"};\n    int inputNums[3] = {4, 4,\
    \ 4};\n    int outputTypes[6] = {SV_BIT, SV_BIT, SV_LOGIC, SV_LOGIC, SV_LOGIC,\
    \ SV_LOGIC};\n    int inputTypes[6] = {SV_BIT, SV_BIT, SV_BIT, SV_LOGIC, SV_LOGIC,\
    \ SV_LOGIC};\n    int clockValue = 1;\n    int resetValue = 1;\n\n    // Create\
    \ test object\n    Tester test;\n    test.create(\"AndOr\", outputNames, outputNums,\
    \ inputNames, inputNums, outputTypes, inputTypes, 1, clockValue, resetValue);\n\
    \n    // Test with constant values\n    test.setConstantInputValues(4);\n    test.setInputValues(1,\
    \ 1, 1, 1, 1, 1);\n    test.runTest();\n\n    // Generate waveform\n    test.generateWaveforms();\n\
    \n    // Set the verilog testbench name and run the simulation\n    test.setVerilogTestbenchName(\"\
    AndOrTB\");\n    test.runSimulation();\n\n    // Read the output values from the\
    \ waveform\n    test.readOutputValues();\n\n    // Compare the values read with\
    \ expected values\n    test.compareOutputValues(4, 2, 4, 4, 4, 4, 4, 4, 4, 4);\n\
    \n    // Clean up\n    test.destroy();\n}\n\n// Test and verify that the AndOr\
    \ module produces the correct output with a 2-bit inputs\nvoid testAndOr_2bit()\
    \ {\n    // Module parameters\n    char *outputNames[3] = {\"X\", \"Y\", NULL};\n\
    \    int outputNums[2] = {1, 2};\n    char *inputNames[2] = {\"A\", \"B\"};\n\
    \    int inputNums[3] = {2, 2, 2};\n    int outputTypes[6] = {SV_BIT, SV_BIT,\
    \ SV_LOGIC, SV_LOGIC, SV_LOGIC, SV_LOGIC};\n    int inputTypes[6] = {SV_BIT, SV_BIT,\
    \ SV_BIT, SV_LOGIC, SV_LOGIC, SV_LOGIC};\n    int clockValue = 1;\n    int resetValue\
    \ = 1;\n\n    // Create test object\n    Tester test;\n    test.create(\"AndOr_2bit\"\
    , outputNames, outputNums, inputNames, inputNums, outputTypes, inputTypes, 1,\
    \ clockValue, resetValue);\n\n    // Test with constant values\n    test.setConstantInputValues(3);\n\
    \    test.setInputValues(0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1);\n  \
    \  test.runTest();\n\n    // Generate waveform\n    test.generateWaveforms();\n\
    \n    // Set the verilog testbench name and run the simulation\n    test.setVerilogTestbenchName(\"\
    AndOrTB_2bit\");\n    test.runSimulation();\n\n    // Read the output values from\
    \ the waveform\n    test.readOutputValues();\n\n    // Compare the values read\
    \ with expected values\n    test.compareOutputValues(4, 2, 4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4);\n\n    // Clean up\n    test.destroy();\n}\n\n// Test\
    \ and verify that the AndOr module produces the correct output with a 4-bit inputs\n\
    void testAndOr_4bit() {\n    // Module parameters\n    char *outputNames[3] =\
    \ {\"X\", \"Y\", NULL};\n    int outputNums[2] = {1, 2};\n    char *inputNames[2]\
    \ = {\"A\", \"B\"};\n    int inputNums[3] = {4, 4, 4};\n    int outputTypes[6]\
    \ = {SV_BIT, SV_BIT, SV_LOGIC, SV_LOGIC, SV_LOGIC, SV_LOGIC};\n    int inputTypes[6]\
    \ = {SV_BIT, SV_BIT, SV_BIT, SV_LOGIC, SV_LOGIC, SV_LOGIC};\n    int clockValue\
    \ = 1;\n    int resetValue = 1;\n\n    // Create test object\n    Tester test;\n\
    \    test.create(\"AndOr_4bit\", outputNames, outputNums, inputNames, inputNums,\
    \ outputTypes, inputTypes, 1, clockValue, resetValue);\n\n    // Test with constant\
    \ values\n    test.setConstantInputValues(4);\n    test.setInputValues(0, 1, 0,\
    \ 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1);\n    test.runTest();\n\n    // Generate\
    \ waveform\n    test.generateWaveforms();\n\n    // Set the verilog testbench\
    \ name and run the simulation\n    test.setVerilogTestbenchName(\"A.readOutputValues();\n\
    \n    // Compare the values read with expected values\n    test.compareOutputValues(4,\
    \ 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4);\n\n    // Clean up\n    test.destroy();\n\
    }\n\n// Test and verify that the AndOr module produces the correct output with\
    \ 3-input logic value\nvoid testAndOr_3logic() {\n    // Module parameters\n \
    \   char *outputNames[3] = {\"X\", \"Y\", NULL};\n    int outputNums[2] = {1,\
    \ 2};\n    char *inputNames[2] = {\"A\", \"B\"};\n    int inputNums"
- code: "module AndOr (output X, Y, input A, B, C);\nassign #10 X = A & B;\nassign\
    \ #10 Y = B | C;\nendmodule\n### Result:\n#### Testbench Code:\nmodule AndOrTB();\n\
    \n### Testbench:\nmodule AndOrTB();\n\n### Output:\n\n### Output:\n\n\n---\nlayout:\
    \ post\nauthor: \ntitle: Using SystemVerilog Bit-Selects for SystemVerilog-2012\
    \ Ports\n---\n<hr>\n<h2>SystemVerilog 2012 Ports</h2>\n<hr>\n### Background:\n\
    The SystemVerilog standard, version 2012, includes a capability to declare Ports\
    \ in a similar way to how signals are declared. Here is the syntax for declaring\
    \ a port:\n\n<h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3,\
    \ in output port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input\
    \ port_1, output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5,\
    \ output port_6)</h3>\n\nPorts can be declared as a vector of a variable number\
    \ of ports by using a type of port that is a vector. Here is the syntax for declaring\
    \ a vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n\
    <h3>output [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in\
    \ inout [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input port_1,\
    \ output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5, output\
    \ port_6)</h3>\n\nPorts can be declared as a vector of a variable number of ports\
    \ by using a type of port that is a vector. Here is the syntax for declaring a\
    \ vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n<h3>output\
    \ [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in inout\
    \ [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input port_1,\
    \ output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5, output\
    \ port_6)</h3>\n\nPorts can be declared as a vector of a variable number of ports\
    \ by using a type of port that is a vector. Here is the syntax for declaring a\
    \ vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n<h3>output\
    \ [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in inout\
    \ [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input port_1,\
    \ output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5, output\
    \ port_6)</h3>\n\nPorts can be declared as a vector of a variable number of ports\
    \ by using a type of port that is a vector. Here is the syntax for declaring a\
    \ vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n<h3>output\
    \ [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in inout\
    \ [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input port_1,\
    \ output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5, output\
    \ port_6)</h3>\n\nPorts can be declared as a vector of a variable number of ports\
    \ by using a type of port that is a vector. Here is the syntax for declaring a\
    \ vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n<h3>output\
    \ [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in inout\
    \ [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port_6);</h3>\n\n<h3>(</h3>\n<h3>input port_1,\
    \ output port_2, inout port_3,</h3>\n<h3>in output port_4, in inout port_5, output\
    \ port_6)</h3>\n\nPorts can be declared as a vector of a variable number of ports\
    \ by using a type of port that is a vector. Here is the syntax for declaring a\
    \ vector of a variable number of ports:\n\n<h3>(input [N_1:0] port_1,</h3>\n<h3>output\
    \ [N_2:0] port_2, inout [N_3:0] port_3, in [N_4:0] port_4,</h3>\n<h3>in inout\
    \ [N_5:0] port_5, output [N_6:0] port_6);</h3>\n\n### Background:\nThe SystemVerilog\
    \ standard, version 2012, includes a capability to declare Ports in a similar\
    \ way to how signals are declared. Here is the syntax for declaring a port:\n\n\
    <h3>module_name</h3>\n<h3> (input port_1, output port_2, inout port_3, in output\
    \ port_4, in inout port_5, output port"
- code: |-
    module AndOr (output X, Y, input A, B, C);
    bit [1:0] C_bit;
    always @* begin
    C_bit = C & [1:0];
    end
    assign #10 X = A & B;
    assign #10 Y = B | C_bit;
    endmodule
    ### Expected behavior:
    1. The Vivado tool should be able to compile the modified code.
    2. The synthesis results should be verified with expected value.
    ### Actual Behavior:
    1. The Vivado tool is able to compile the modified module but the synthesis results seems to differ from the expected value.
    ### Steps to reproduce the behavior:
    1. Run Synplify under Xilinx project and get the expected value.
    2. Run the modified module and check the synthesis result.

    ## Other information

    ### Versions
    Vivado 2019.2

    ### Additional information
    None

    ### Environment

    Additionally, the modified module is used in a system containing other modules, the following steps are required:

    1. Copy the modified module to another directory.
    2. Add the path to the copy to SystemVerilog work path.
    3. Include the modified module in top level (or any module).

    This also seems to work in SystemVerilo if the module is not copied to another directory.

    ### Checklist

    ###### Is the issue an expected behavior?

    [ ] Yes
    [X] No

    ###### Did you check Vivado Log?

    [ ] Yes
    [X] No

    ###### Did you check Xilinx Log?

    [ ] Yes
    [X] No

    ###### Did you check SystemVerilog Log?

    [ ] Yes
    [X] No

    ###### Did you check Report?

    [ ] Yes
    [X] No

    ###### Is the issue a regression?

    [ ] Yes
    [X] No

    ###### Did you check the user guide?

    [ ] Yes
    [X] No

    ###### Did you check FAQ?

    [ ] Yes
    [X] No

    ###### Did you check Issue List?

    [ ] Yes
    [X] No

    ###### Did you check on other tools?

    [ ] Yes
    [X] No

    ###### Did you check other people's bugs?

    [ ] Yes
    [X] No
- code: |-
    module AndOr (output X, Y, input A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B | C;
    endmodule
    ### Testbench:
    module test_bench;
    `timescale 1 ns / 10 ps
    reg a, b, c;
    wire x, y;
    AndOr andOr(a, b, c);
    initial begin
    a = 1'b0;
    b = 1'b0;
    c = 1'b0;
    #1000 b = 1'b1;
    #1000 a = 1'b1;
    #1000 c = 1'b1;
    end
    always @(a, b, c) begin
    $display("X value = %b, Y value = %b", x, y);
    end
    endmodule
    # 2021-02-25 13:23:13 -0500

    X value = 0, Y value = 0
    X value = 1, Y value = 0
    X value = 1, Y value = 0
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    X value = 1, Y value = 1
    # 2021-02-25 13:23:13 -0500

    X value = 1, Y value = 1
    X value = 1, Y value
- code: "module AndOr (output X, Y, input A, B, C);\nassign #10 X = A & B;\nassign\
    \ #10 Y = B | C;\nendmodule\n/Homework 3/Homework 3.md\n# Homework 3\n## Group\
    \ 13,,, \n\n### Problem 1\n#### a.\n![Alt text](p1a1.png)\n\n#### b.\n![Alt text](p1b1.png)\n\
    \n#### c.\n![Alt text](p1c1.png)\n\n### Problem 2\n#### a.\n![Alt text](p2a1.png)\n\
    \n#### b.\n![Alt text](p2b1.png)\n\n#### c.\n![Alt text](p2c1.png)\n\n### Problem\
    \ 3\n#### a.\n![Alt text](p3a1.png)\n\n#### b.\n![Alt text](p3b1.png)\n\n####\
    \ c.\n![Alt text](p3c1.png)\n/Homework 7/question3.md\n## 3. Design a 32-bit divider\
    \ with a 3-bit control signal that uses the following table for signal assignment:\n\
    \n| Control     | dividend      | divisor      | result      |\n|-------------|---------------|--------------|-------------|\n\
    | 000         | 00000000000000| 000000       | 000000000000 |\n| 001         |\
    \ 00000000000000| 000000       | 000000000000 |\n| 010         | 00000000000000|\
    \ 000000       | 000000000000 |\n| 011         | 00000000000000| 000000      \
    \ | 000000000000 |\n| 100         | 00000000000000| 000000       | 000000000000\
    \ |\n| 101         | 00000000000000| 000000       | 000000000000 |\n| 110    \
    \     | 00000000000000| 000000       | 000000000000 |\n| 111         | 00000000000000|\
    \ 000000       | 000000000000 |\n\n### Verilog Code\n\n#### Divider\n```verilog\n\
    //Divider module\nmodule divider_core(\n\tinput [31:0] dividend,\n\tinput [2:0]\
    \ control,\n\tinput [2:0] divisor,\n\toutput [31:0] result\n);\n\nalways @ (posedge\
    \ control)\n\tif (control == 0)\n\t\tresult <= 0;\n\telse\n\t\tresult <= {divisor,\
    \ dividend[31:0]};\nend\n\nendmodule\n```\n/Homework 3/question2.md\n## 2. Design\
    \ a two-stage pipelined multiplier that uses the following table for signal assignment:\n\
    \n| Control     | A             | B             | Product      |\n|-------------|---------------|---------------|--------------|\n\
    | 000         | 0             | 0             | 0            |\n| 001        \
    \ | 0             | 0             | 0            |\n| 010         | 0        \
    \     | 0             | 0            |\n| 011         | A[19:0]       | B[19:0]\
    \       | A[19:0] x B[19:0] |\n| 100         | A[31:20]      | B[31:20]      |\
    \ A[31:20] x B[31:20] |\n| 101         | A[31:0]       | B[31:0]       | A[31:0]\
    \ x B[31:0] |\n| 110         | A[31:20]      | B[19:0]       | A[31:20] x B[19:0]\
    \ |\n| 111         | A[31:0]       | B[31:20]      | A[31:0] x B[31:20] |\n\n\
    ### Verilog Code\n#### Multiplier\n```verilog\n// Multiplier module\nmodule multiplier_core(\n\
    \tinput [31:0] A,\n\tinput [31:0] B,\n\tinput [2:0] control,\n\toutput [63:0]\
    \ product\n);\n\nalways @ (posedge control)\n\tif (control == 0)\n\t\tproduct\
    \ <= {A, B};\n\telse if (control == 1)\n\t\tproduct <= {A[31:20], B[19:0]};\n\t\
    else if (control == 2)\n\t\tproduct <= {A[31:0], B[31:0]};\n\telse if (control\
    \ == 3)\n\t\tproduct <= {A[31:20], B[19:0]};\n\telse if (control == 4)\n\t\tproduct\
    \ <= {A[31:0], B[31:20]};\n\telse if (control == 5)\n\t\tproduct <= {A[31:0],\
    \ B[31:0]};\n\telse if (control == 6)\n\t\tproduct <= {A[31:20], B[31:20]};\n\t\
    else if (control == 7)\n\t\tproduct <= {A[31:0], B[31:20]};\nend\n\nendmodule\n\
    ```\n#### Two-Stage Pipeline\n```verilog\n// Two-Stage Pipeline module\nmodule\
    \ mul_2stg(\n\tinput [31:0] A,\n\tinput [31:0] B,\n\tinput [2:0] control,\n\t\
    output [63:0] product\n);\n\nreg [63:0] A_buffer = {A, 0};\nreg [63:0] B_buffer\
    \ = {B, 0};\nreg [2:0] control_buffer = 0;\n\nassign control_buffer = control;\n\
    \nassign product = {A_buffer[31:20], B_buffer[31:20]};\nalways @ (posedge control)\n\
    \tif (control == 0)\n\t\tproduct <= {A_buffer[31:0], B_buffer[31:0]};\n\telse\
    \ if (control == 1)\n\t\tB_buffer <= {A_buffer[31:0], B[31:20]};\n\telse if (control\
    \ == 2)\n\t\tA_buffer <= {A[31:0], B[31:0]};\n\telse if (control == 3)\n\t\tB_buffer\
    \ <= {A[31:0], B[31:20]};\n\telse if (control == 4)\n\t\tA_buffer <= {A[31:0],\
    \ B[31:0]};\n\telse if (control == 5)\n\t\tB_buffer <= {A[31:20], B[31:0]};\n\t\
    else if (control == 6)\n\t\tproduct <= {A[31:20], B[19:0]};\n\telse if (control\
    \ == 7)\n\t\tproduct <= {A[31:0], B[31:20]};\nend\n\nendmodule\n```\n#### Combinatorial\
    \ Architecture\n```verilog\nmodule multiplier(\n\tinput [31:0] A,\n\tinput [31:0]\
    \ B,\n\tinput [2:0] control,\n\toutput [63:0] product\n);\n\nmul_2stg mul_inst\n\
    \t(\n\t\t.A(A),\n\t\t.B(B),\n\t\t.control(control),\n\t\t.product(product)\n\t\
    );\n\nendmodule\n```\n#### Testbench\n```verilog\nmodule multiplier_test\n(\n\
    \    input [31:0] A,\n    input [31:0] B,\n    input [2:0] control,\n    output\
    \ [63:0] product\n);\n\nreg ["
- code: |-
    ![image](https://user-images.githubusercontent.com/35247784/110959543-1e246f80-8315-11eb-9705-939a224d8160.png)
    #### Verilog Code for modified code:
    ```verilog
    module AndOr (output X, Y, input A, B, C);
    assign #10 X = A & B;
    assign #10 Y = B & A;
    assign #10 C = X | Y | C;
    endmodule
    ```
    ## 3.7 Test Result (SystemVerilog)
    ### Base SystemVerilog Code:
    ![image](https://user-images.githubusercontent.com/35247784/110960594-06112f00-8316-11eb-88a8-c1108d558208.png)
    ### Modified SystemVerilog Code:
    ![image](https://user-images.githubusercontent.com
- code: |-
    module AndOr (output X, Y, input A, B, C);
    assign #10 X = A & B; //Note the & symbol for bitwise AND
    assign #10 Y = B | C; //Note the | symbol for bitwise OR
    endmodule

    ## How to use the code:
    ### Method 1:
    Run the code using the command:
    ### `make`
    ### Method 2:
    Alternatively, the code can be compiled and linked using the command:
    ### `vlog -sv <input_filename.v>`
- code: |-
    module AndOr (output X, Y, input A, B, C);
    assign #(0) X = A & B;
    assign #(0) Y = B | C;
    endmodule
    ### Resulting Behavior:

    ### Notes:
    This issue was resolved as part of https://github.com/SymbiFlow/sv-tests/pull/143/files.
- code: |-
    ```
    module Test (output tri X, in1);
    always @* begin
    X = in1;
    end
    endmodule

    module Test_1 (output tri X, in1);
    always @* begin
    X = in1;
    end
    endmodule
    ```

    ### Result:
    This code compiles successfully, the circuit is simulated successfully and the output is tri-state.

    ## Question 2
    ### Base Verilog
- code: |-
    module IR ( input logic [1:0] A, input [7:0] B, input load,
    clk, output reg [7:0] data_out );
    // Modify the 1D elements of array A to be packed into the 4D array A
    // packed[1][2][3][4] = {A[0],A[1],A[2],A[3]} packed[1][2][3][4] = {A[0],A[1],A[2],A[3]}
    }
    ### Modified Testbench:
    module _tb ( input logic [1:0] A, input [7:0] B,
    input load,
    input clk,
    output reg [7:0] data_out );
    wire [1:0] A_in;
    wire [1:0] B_in;
    wire load_in;
    wire clk_in;
    wire [7:0] data_out_in;
    IR ir (.A ( A_in ),.B ( B_in ),.load ( load_in ),
    .clk ( clk_in ),
    .data_out ( data_out_in ) );
    initial begin
    clk_in = 1; A_in = 2'b00; B_in = 8'd25; load_in = 1'b1;
    #5.0 clk_in = 0; #5.0;
    #5.0 clk_in = 1; A_in = 2'b01; B_in = 8'd53; load_in = 1'b1;
    #5.0 clk_in = 0; #5.0;
    #5.0 clk_in = 1; A_in = 2'b10; B_in = 8'd77; load_in = 1'b1;
    #5.0 clk_in = 0;
    end
    initial begin
    $monitor($time, "\tA_in = %s\tB_in = %h\tload_in = %b\tclk_in = %b\tdata_out_in = %h", A_in, B_in, load_in, clk_in, data_out_in); end endmodule
- code: |-
    module IR ( input [7:0] data_in[3:0], input load, clk, output reg [1:0] data_out[1:0] );
    // Multi-dimensional indexed write
    always @( posedge clk )
    if ( load ) data_out <= {data_in[1:0]};
    endmodule

    ### 4.1.5 Multiple Array Reads

    The next step is to create a multiple array read. The module will take five inputs, a 3D packed array, a 2D packed array, and a 2D packed array. The 2D packed logic-vector arrays are expected to be the indices into the 3D packed logic-vector array. The module will read two elements of the 3D array based on the element in the 2D packed array that is indexed into the 3D packed array. The module will then read one element of the 3D array based on the element in the 2D packed array that is indexed into the 3D packed array.

    The following is a test bench that reads two elements of the data_in array at the index of data_index[0] and reads the element of the data_in array at the index of data_index[0] and data_index[1
- code: "module IR ( input [7:0] data_in, input load, clk,\noutput reg [7:0] data_out\
    \ );\n// Simple register (Instruction Register) loaded on posedge clk when load\
    \ is high\nalways @( posedge clk )\nif ( load )\ndata_out <= data_in[0:1][0:3][0:7][0:8];\n\
    endmodule\n### Final Code Output:\n\n## 2.4.2.4.1. Handling Arrays of Arrays\xB6\
    \n\nLet\u2019s consider a simple 2-D array of"
- code: |-
    module IR ( input [7:0] data_in, input load,
    input [1:0] A [0:3], input [1:0] B [0:3],
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule
    ### Variation Instruction:
    Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use
- code: |-
    module IR ( input [0:1] A [0:3], input [0:1] B [0:3], input load, clk,
    output reg [0:1] add_out, output reg [0:1] mult_out );
    // Simple
- code: |-
    module IR ( input [1:0] B [0:3], input [1:0] A [0:3], input load, clk, output reg [1:0] data_out );
    always @( posedge clk )
    if ( load )
    data_out <= A [B];
    endmodule
    ### Output:
    00000000
    00000001
    00000010
    00000011
    00000100
    00000101
    00000110
    00000111
    00001000
    00001001
    00001010
    00001011
    00001100
    00001101
    00001110
    00001111
    00010000
    00010001
    00010010
    00010011
    00010100
    00010101
    00010110
    00010111
    00011000
    00011001
    00011010
    00011011
    00011100
    00011101
    00011110
    00011111
    00100000
    00100001
    00100010
    00100011
    00100100
    00100101
    00100110
    00100111
    00101000
    00101001
    00101010
    00101011
    00101100
    00101101
    00101110
    00101111
    00110000
    00110001
    00110010
    00110011
    00110100
    00110101
    00110110
    00110111
    00111000
    00111001
    00111010
    00111011
    00111100
    00111101
    00111110
    00111111
    01000000
    01000001
    01000010
    01000011
    01000100
    01000101
    01000110
    01000111
    01001000
    01001001
    01001010
    01001011
    01001100
    01001101
    01001110
    01001111
    01010000
    01010001
    01010010
    01010011
    01010100
    01010101
    01010110
    01010111
    01011000
    01011001
    01011010
    01011011
    01011100
    01011101
    01011110
    01011111
    01100000
    01100001
    01100010
    01100011
    01100100
    01100101
    01100110
    01100111
    01101000
    01101001
    01101010
    01101011
    01101100
    01101101
    01101110
    01101111
    01110000
    01110001
    01110010
    01110011
    01110100
    01110101
    01110110
    01110111
    01111000
    01111001
    01111010
    01111011
    01111100
    01111101
    01111110
    01111111
    10000000
    10000001
    10000010
    10000011
    10000100
    10000101
    10000110
    10000111
    10001000
    10001001
    10001010
    10001011
    10001100
    10001101
    10001110
    10001111
    10010000
    10010001
    10010010
    10010011
    10010100
    10010101
    10010110
    10010111
    10011000
    10011001
    10011010
    10011011
    10011100
    10011101
    10011110
    10011111
    10100000
    10100001
    10100010
    10100011
    10100100
    10100101
    10100110
    10100111
    10101000
    10101001
    10101010
    10101011
    10101100
    10101101
    10101110
    10101111
    10110000
    10110001
    10110010
    10110011
    10110100
    10110101
    10110110
    10110111
    10111000
    10111001
    10111010
    10111011
    10111100
    10111101
    10111110
    10111111
    11000000
    11000001
    11000010
    11000011
    11000100
    11000101
    11000110
    11000111
    11001000
    11001001
    11001010
    11001011
    11001100
    11001101
    11001110
    11001111
    11010000
    11010001
    11010010
    11010011
    11010100
    11010101
    11010110
    11010111
    11011000
    11011001
    11011010
    1101
- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );

    logic [7:0] A [0:3];

    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= A[data_in[7:4]] >> 4;
    endmodule
- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule

    ## Sample Test Cases

    Each of the variations of each instruction type has a corresponding test case that is provided in the verilog file (e.g., ADD_test.v). Note that all variations are implemented for all instruction types.
- code: "module IR ( input [1:0] A [0:3][0:3][0:3][0:3], input [1:0] B [0:3][0:3][0:3],\
    \ input [1:0] C [0:3][0:3], input [1:0] D [0:3], input load, clk,\noutput reg\
    \ [1:0] E [0:3] );\n// Simple register (Instruction Register) loaded on posedge\
    \ clk when load is high\nalways @( posedge clk )\nif ( load ) E[D] <= B[B][B][B];\n\
    endmodule\n\n## 4.3.8. Packing Unpacking\xB6\n\nIn Verilog, it is sometimes useful\
    \ to pack values into a single-bit or multi-bit data type, or to unpack a value\
    \ from a single-bit or multi-bit data type into multiple values. The following\
    \ example demonstrates such code:\n\nmodule PackUnpack (\ninput [7:0] A, B, C,\
    \ D, E,\noutput reg [1:0] A1, B1, C1, D1, E1\n);\nlogic [7:0] A3, B3, C3, D3,\
    \ E3;\nassign A3 = {A[7:4], A[3:0]};\nassign B3 = {B[7:4], B[3:0]};\nassign C3\
    \ = {C[7:4], C[3:0]};\nassign D3 = {D[7:4], D[3:0]};\nassign E3 = {E[7:4], E[3:0]};\n\
    assign A1 = {A3[7:4], A3[3:0]};\nassign B1 = {B3[7:4], B3[3:0]};\nassign C1 =\
    \ {C3[7:4], C3[3:0]};\nassign D1 = {D3[7:4], D3[3:0]};\nassign E1 = {E3[7:4],\
    \ E3[3:0]};\nendmodule\n\n### A note about the example above:\xB6\n\nIn this example,\
    \ multiple output register assignments are made within the one module instantiation.\
    \ This is possible because the A3, B3, C3, D3, and E3 signal assignments are generated\
    \ by the assign statements, and because the output register assignments are contained\
    \ within the module instance. The syntax to make multiple output register assignments\
    \ within one module instance is\n\nassign output1, output2,..., outputN = {value1,\
    \ value2,..., valueN};\n\n## 4.3.9. Demonstrating Sensitivity List\xB6\n\nThe\
    \ sensitivity list (i.e., the list of signals which are sensitive to) for an always\
    \ statement should consist of the signals that change most often, followed by\
    \ common intermediate signals, followed by signals that are less likely to change.\n\
    \nThe following example demonstrates such code:\n\nmodule IR ( input clk,\ninput\
    \ [7:0] data_in, input load,\noutput reg [7:0] data_out );\n// Simple register\
    \ (Instruction Register) loaded on posedge clk when load is high\nalways @( posedge\
    \ clk )\nif ( load )\ndata_out = data_in;\nendmodule\n\n\nThis will result in\
    \ a synthesis warning. The warning will advise us that the output signal data_out\
    \ is sensitive to the input signal data_in, which is most often changing. This\
    \ is correct, but we also want to make sure that data_out is sensitive to load,\
    \ which will be frequently changing. This is the only part of the always statement\
    \ that changes most often. Therefore, to correct the sensitivity of data_out to\
    \ load, we must place it at the end of the sensitivity list.\n\n### Modified Code:\xB6\
    \n\nmodule IR ( input clk,\ninput [7:0] data_in, input load,\noutput reg [7:0]\
    \ data_out );\n// Simple register (Instruction Register) loaded on posedge clk\
    \ when load is high\nalways @( clk, load )\nif ( load )\ndata_out = data_in;\n\
    endmodule\n\n## 4.3.10. Demonstrating Combinational Loops\xB6\n\nIn a combinational\
    \ loop, there is no storage element involved. Therefore, it is a purely functional\
    \ construct. It can only be used within a module body or within a package declaration.\
    \ The following code example illustrates a combinational loop within a module\
    \ declaration.\n\nmodule DFB ( input [3:0] A, input [3:0] B,\noutput reg [3:0]\
    \ C\n);\n// Combinational Loops\nalways @*\nC = A & B;\nendmodule\n\n\n## 4.3.11.\
    \ Demonstrating Sequential Loops\xB6\n\nIn a sequential loop, there is some storage\
    \ that is used. Therefore, it can be used within a module body or within a package\
    \ declaration. The following code example illustrates a sequential loop within\
    \ a module declaration.\n\nmodule DFF ( input clk, input [3:0] D,\noutput reg\
    \ [3:"
- code: |-
    module IR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Simple register (Instruction Register) loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in;
    endmodule
    ## ArrayIR

    module ArrayIR ( input [7:0] data_in, input load, clk,
    output reg [7:0] data_out );
    // Multi-dimensional IR loaded on posedge clk when load is high
    always @( posedge clk )
    if ( load ) data_out <= data_in[0:3];
    endmodule

    ## IR

    module IR ( input [7:0] data_in, input load, clk, output reg [7:0] data_out );

    ### Introduction

    The IR (Instruction Register) is a simple register-like structure (e.g., a 32-bit register) that is loaded with an input value (e.g., data_in) on a posedge of the clk input. The data_in is then sampled on a posedge of the clk and written to data_out.

    ### Example Verilog Code:

    module IR ( input [7:0] data_in, input load, clk, output reg [7:0] data_out );

    ### Variation:

    Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.

    ### Example Verilog Code:

    module IR ( input [7:0] data_in, input load, clk, output reg [7:0] data_out );

    ### Variation:

    Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.

    ### Example Verilog Code:

    module IR ( input [7:0] data_in, input load, clk, output reg [7:0] data_out );

    ### Variation:

    Modify the inputs A and B to be elements of a packed 1D logic-vector array (e.g., logic [1:0] A [0:3]) and use an inside operator with a fixed 4D range to test multi-dimensional array handling.
- code: |-
    ```
    module Problem20(input [3:0] a, input [3:0] b, output [3:0] c);
      assign c = a | (b & ~c);
      assign c = 8'b111111111;
      assign c = a | (b & ~c);
      assign c = 8'b111111111;
      assign c = a | (b & ~c);
      assign c = 8'b111111111;
      assign c = a | (b & ~c);
      assign c = 8'b111111111;
      assign c = a | (b & ~c);
      assign c = 8'b111111111;
      assign c = a | (b & ~
- code: "```\n> vcs -full64 -notice Problem10.v \n> vcs Problem10.v\n> vsim -c -do\
    \ sim.do\n(OK) Loading work library: work\n(OK) Saving results into directory:\
    \ /home/kristina/verilog/test/Problem10/obj_dir\n(OK) Executing vlogan (VCS)\n\
    (OK) Found {Problem10.v}\n(OK)   and {Problem10.v}\n(OK) Executing vlogan -full64\
    \ (VCS)\n(OK) vlogan execution completed\n(OK) Executing vhdlan (VCS)\n(OK) vhdlan\
    \ execution completed\n(OK) Executing compile_system (VCS)\n(OK) compile_system\
    \ execution completed\n(OK) Executing link (VCS)\n(OK) link execution completed\n\
    Simulation time: 0 ps\n>\n```\n## Problem 11\n### Base Verilog Code:\nmodule Problem11(input\
    \ [9:3] in, output [3:0] out);\n\treg [3:0]"
- code: "module Problem5_tb;\n  reg [3:0] a, b;\n  reg [3:0] diff;\n  \n  initial\
    \ begin\n    a = 4'b0010;\n    b = 4'b0100;\n    \n    #100;\n    $dumpfile(\"\
    Problem5_tb.vcd\");\n    $dumpvars;\n  end\n  \n  initial begin\n    #100000;\n\
    \  end\nendmodule\n\nModule Problem5_tb\n\n// Generated by Verilator 3.9.6\n//\
    \ Verilator is free software; you can redistribute it and/or modify it under the\
    \ terms of the GNU General Public License as published by the Free Software Foundation;\
    \ either version 2 of the License, or (at your option) any later version.\n//\
    \ Verilator requires maximum redistribution limitations under both the Verilator\
    \ Public License and the GNU General Public License.  See the files COPYING.VL\
    \ and COPYING.GPL for details.\n// There is NO WARRANTY, to the extent permitted\
    \ by law.  Type \"verilator --help\" for more information.\n// Date: Mon Nov \
    \ 2 10:59:47 MST 2020\n// Compiler flags:  +0\n// Module name    : Problem5_tb\n\
    \n// Include any architecture specific header files you need here.\n// e.g. #include\
    \ <VYourModule.h>\n#include \"VProblem5_tb.h\"\n#include <verilated_vcd_c.h>\n\
    \n#include <iostream>\n\n// Define the verilated module name.\nVL_MODULE(Problem5_tb)\
    \ {\n  // Define the top level instance.\n  VProblem5_tb* top = new VProblem5_tb;\n\
    \n#ifndef VL_DPI_IN_COMPILE\n  // Set up tracing.\n  Verilated::traceEverOn(true);\n\
    \  VerilatedVcdC* Tfp = new VerilatedVcdC;\n  top->trace(Tfp, 99);\n  Tfp->open(\"\
    Problem5_tb.vcd\");\n#endif\n\n  // Do any other initializations.\n#ifdef VL_DPI_IN_COMPILE\n\
    \  printf(\"running init_dpi\\n\");\n#endif\n\n#ifdef VL_DPI_IN_COMPILE\n  //\
    \ Set up the DPI function from C++.\n  // Call the C++ function \"do_dpi\" exported\
    \ from the DPI library.\n  // This function does not take arguments and does not\
    \ return a value.\n  void (*do_dpi)() = (void (*)())dpi_import_symbol(\"do_dpi\"\
    );\n  do_dpi();\n#endif\n\n  // Generate an initial value for the DPI function\
    \ from C++.\n  // Call the C++ function \"get_dpi\" exported from the DPI library.\n\
    \  // This function returns a string value and takes a pointer to a char buffer.\n\
    \  char buf[1024];\n  void (*get_dpi)(char*) = (void (*)(char*))dpi_import_symbol(\"\
    get_dpi\");\n  get_dpi(buf);\n\n  // Execute the simulation for duration ns.\n\
    \  // Do this by reading all of the time units.\n  while (Verilated::gotFinish()\
    \ == false) {\n    top->eval();\n  }\n\n  // Close the VCD trace file and, if\
    \ present, dump the trace to a file.\n  Tfp->close();\n  if (Verilated::gotFinish())\
    \ exit(1);\n}\n\n// main"
- code: |-
    ```verilog
    module Problem4(input [3:0] a, b, output [3:0] diff);
      reg [3:0] x, y, z;
      assign diff = a - b;
    endmodule
    ```
    ## Problem 5
    ### Base Verilog Code:
    ```
- code: "```python\nmodule Problem16(input [3:0] a, b, output [3:0] prod, accum);\n\
    \  typedef struct packed{ \n    \tsigned [3:0] x;\n    \tsigned [3:0] y;\n   \
    \ \tsigned [3:0] z;\n  } packedstruct;\n  packedstruct packedarray[4];\n  reg\
    \ [3:0] product;\n  reg [3:0] accumulation;\n  assign product = a * b;\n  assign\
    \ accumulation = accumulation + product;\nendmodule\n```\n## Problem 17 - Packed\
    \ Structures and Dynamic Arrays with Unpacked Structures as Elements\n### Base\
    \ Verilog Code:\nmodule Problem17"
- code: |-
    module Problem8(input [3:0] a, b, output [3:0] diff);
      logic [3:0] x, y, z;
      assign x = a;
      assign y = b;
      assign z = x + y;

      assign diff = z - a;
    endmodule/Assignment4/Problem8/Problem8.py
    import sys

    from Problem7 import Problem7


    class Problem8(Problem7):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 2:
                    if line[0] == "module" and line[1][0] == "P":
                        print(f"Problem #{i + 1}: Pack and unpacking")
                    elif line[0] == "module":
                        print(f"Line #{i + 1}             elif line[1][0] == "P":
                        print(f"Line #{i + 1}: Problem {line[1][1]}")

                    self.fileLines[i] = f"\t// Replace the reg declarations with a packed structure that includes the signals x, y, and z, and modify the assignments accordingly to test packed structure handling."
    : Problem {line[1]}")
       /Assignment4/Problem5/Problem5.py
    import sys

    from Problem4 import Problem4


    class Problem5(Problem4):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 3 and line[1] == "assign":
        print(f"Line #{i + 1}: Problem {line[1]}")

                    self.fileLines[i] = f"\t// Remove the reg declarations and replace the reg assignments with wire assignments."
                   if line[0][0] == "P":
                        print(f"Problem #{i + 1}: Pack and unpacking")
                 /Assignment2/Problem6/Problem6.py
    import sys

    from Problem5 import Problem5


    class Problem6(Problem5):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 2:
                    if line[0] == "module" and line[1][0] == "P":
                        print(f"\nProblem #{i + 1}: Packing")
                    elif line[0] == "module":
                        print(f"Line #{i + 1}: Problem {line[1]}")

        def replaceLine(self, i):
            if self.fileLines[i].startswith("module"):
                index = self.fileLines[i].find("(")
                self.fileLines[i] = self.fileLines[i][:index] + "[3:0]" + self.fileLines[i][index:]
         self.fileLines[i] = f"\tassign x[{j} +: a[{j} +: b[{j} +: x[{j} +: y[{j} +: z[{j} +: z[{j} +: 4]]]]] = x[{j} +: a[{j} +: y[{j} +: z[{j} +: 4]]];"
    /Assignment4/Problem3/Problem3.py
    import sys

    from Problem2 import Problem2


    class Problem3(Problem2):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 2 and (line[0] == "assign" or line[0] == "assigns" or line[0] == "assign#"):
                    if line[1][0] == "P":
                        print(f"Problem #{i + 1}: Problem 3")
                    elif line[1][0] == "x" and line[1][1:].isdigit():
                        j = int(line[1][1:])
                   /Assignment4/Problem10/Problem10.py
    import sys

    from Problem9 import Problem9


    class Problem10(Problem9):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 3 and line[1] == "assign":
                    if line[0][0] == "P":
                        print(f"Problem #{i + 1}: Pack and unpacking")
                    elif line[0][0] == "x" and line[0][1:].isdigit() and line[0][1]!= "1" and line[0][1]!= "2":
                        print(f"Line #{i + 1}: Problem {line[0][1]}")

                    self.fileLines[i] = f"\tassign x[{line[0][1]} +: a[{line[0][1]} +: b[{line[0][1]} +: x[{line[0][1]} +: y[{line[0][1]} +: z[{line[0][1]} +: z[{line[0][1]} +: 4]]]]] = x[{line[0][1]} +: a[{line[0][1]} +: y[{line[0][1]} +: z[{line[0][1]} +: 4]]];"
    /Assignment4/Problem7/Problem7.py
    import sys

    from Problem6 import Proble   def replaceLine(self, i):
            if self.fileLines[i].startswith("module"):
                index = self.fileLines[i].find("(")
                self.fileLines[i] = self.fileLines[i][:index] + "[3:0]" + self.fileLines[i][index:]
    m6


    class Problem7(Problem6):
        def __init__(self, fileName):
            super().__init__(fileName)

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if len(line) == 3 and (line[0] == "assign" or line[0] == "assigns" or line[0] == "assign#"):
                    if line[1][0] == "P":
                        print(f"Problem #{i + 1}: Pack and unpacking")
        #             elif line[1][0] == "x" and line[1][1:].isdigit():
        #                 j = int(line[1][1:])
                    elif line[1][0] == "x" and line[1][1:].isdigit():
                        j = int(line[1][1:]) - 1
                    elif line[1][0] == "x" and line[1][1] == "1":
                        j = 0
                    elif line[1][0] == "x" and line[1][1] == "2":
                        j = 1

                    self.fileLines[i] = f"\tassign x[{j} +: a[{j} +: b[{j} +: x[{j} +: y[{j} +: z[{j} +: z[{j} +: 4]]]]] = x[{j} +: a[{j} +: y[{j} +: z[{j} +: 4]]];"

     /Assignment1/Problem5/Problem5.py
    import sys

    from Problem4 import Problem4


    class Problem5(Problem4):
        def __init__(self, fileName):
            super().__init__(fileName)

            self.registerNames = {
                "add": "a",
                "sub": "b",
                "mult": "x",
                "div": "y",
                "left": "z",
                "right": "w"
            }

        def execute(self):
            super().execute()

            for i, line in enumerate(self.fileLines):
                line = line.split()
                if line[0] == "#":
                    self.replaceLine(i)

        def replaceLine(self, i):
            if self.fileLines[i].startswith("module"):
                index = self.fileLines[i].find("(")
                self.fileLines[i] = self.fileLines[i][:index] + "[3:0]" + self.fileLines[i][index:]

                for k in range(len(self.fileLines)):
                    if self.fileLines[k].startswith("wire") or self.fileLines[k].startswith("reg"):
                        self.fileLines[k] = self.fileLines[k][:3] + "reg[" + self.registerNames[self.fileLines[k][3:]] + "]" + self
- code: |-
    ```
    module Problem8(input [3:0] a, b, output [3:0] diff);
      wire [3:0] temp, temp2;
      reg [3:0] y, z;
      assign temp = a - b;
      assign temp2 = b - a;
      assign diff[0] = a[0]^temp[0];
      assign diff[1] = a[1]^temp[1];
      assign diff[2] = a[2]^temp[2];
      assign diff[3] = b[3]^temp[3];
      assign diff[4] = b[4]^temp[4];
      assign diff[5] = b[5]^temp[5];
      assign diff[6] = b[6]^temp[6];
      assign diff[7] = b[7]^temp[7];
      assign y = diff[3:0];
      assign z = diff[7:4];
      assign diff[3:0] = y^z;
      assign diff[7:4] = y^z;
    endmodule
    ```
    ### Output:
    ```
    module Problem8(input [3:0] a, b, output [3:0] diff);
      wire [3:0] temp, temp2;
      reg [3:0] y, z;
      assign temp = a - b;
      assign temp2 = b - a;
      assign diff[0] = a[0]^temp[0];
      assign diff[1] = a[1]^temp[1];
      assign diff[2] = a[2]^temp[2];
      assign diff[3] = b[3]^temp[3];
      assign diff[4] = b[4]^temp[4];
      assign diff[5] = b[5]^temp[5];
      assign diff[6] = b[6]^temp
- code: "module Problem10(input [10:0] x, input [9:0] y, output [3:0] z);\n  wire\
    \ d10, d9, d6[4];\n  assign d10 = x[10];\n  assign d9 = y[9];\n  assign d6[4]\
    \ = x[6:0];\n  assign d6[0] = d6[1] & d6[2] & d6[3];\n  assign z[0] = d10;\n \
    \ assign z[1] = d9;\n  assign z[2] = d6[3];\n  assign z[3] = d6[0];\nendmodule\n\
    # \n# 9/10/2018\n# CS 465: Computer Organization and Architecture\n# HW2: Sampling\
    \ and Arithmetic\n\nimport math\nimport numpy as np\nimport random\nimport matplotlib.pyplot\
    \ as plt \n\ndef generateData(N):\n    return np.random.uniform(0,1,N)\n\ndef\
    \ plotData(y):\n    plt.hist(y)\n    plt.show()\n\ndef filterData(x, p):\n   \
    \ y = np.zeros(len(x))\n    for i in range(len(y)):\n        if i - 2 > 0:\n \
    \           y[i] = p * x[i] + (1 - p) * y[i-1]\n        else:\n            y[i]\
    \ = x[i]\n    return y\n\ndef filterData2(x, p):\n    y = np.zeros(len(x))\n \
    \   for i in range(len(y)):\n        if i - 2 > 0:\n            y[i] = p * x[i]\
    \ + (1 - p) * y[i-1]\n        else:\n            y[i] = x[i]\n    return y\n\n\
    N = 10000\nfor p in [0.1, 0.3, 0.5, 0.7, 0.9]:\n    x = generateData(N)\n    y\
    \ = filterData(x, p)\n    plotData(y)\n\nN = 10000\nfor p in [0.1, 0.3, 0.5, 0.7,\
    \ 0.9]:\n    x = generateData(N)\n    y = filterData2(x, p)\n    plotData(y)\n\
    \nN = 10000\nfor p in [0.1, 0.3, 0.5, 0.7, 0.9]:\n    x = generateData(N)\n  \
    \  y = filterData2(x, p)\n    plotData(y)\n# \n# 9/10/2018\n# CS 465: Computer\
    \ Organization and Architecture\n# HW2: Sampling and Arithmetic\n\nimport math\n\
    import numpy as np\nimport random\nimport matplotlib.pyplot as plt\n\nN = 10000\n\
    x = np.zeros(N)\ny = np.zeros(N)\nfor i in range(N):\n    x[i] = random.random()\n\
    \    y[i] = np.random.poisson(x[i])\n\nplt.hist(y)\nplt.show()\nn-1):\n    x[i]\
    \ = i\n\nn = 10\np = 0.35\ny = np.zeros(n)\nfor i in range(n):\n    y[i] = x[i]\
    \ * p + (1 - p) * y[i-1]\n\nfor i in range(n):\n    print(\"x[{}] = {}\".format(i,\
    \ x[i]))\n    print(\"y[{}] = {}\".format(i, y[i]))\n\nprint(\"\")\n\nprint(\"\
    Original Signal:\")\nplt.plot(x)\nplt.show()\n\nprint(\"\")\n\nprint(\"Filtered\
    \ Signal:\")\nplt.plot(y)\nplt.show()\n# \n# 9/10/2018\n# CS 465: Computer Organization\
    \ and Architecture\n# HW2: Sampling and Arithmetic\n\nimport math\nimport numpy\
    \ as np\nimport random\nimport matplotlib.pyplot as plt\n\nn = 100\nx = np.zeros(n)\n\
    for i in range(# \n# 9/10/2018\n# CS 465: Computer Organization and Architecture\n\
    # HW2: Sampling and Arithmetic\n\n\nN = 10000\nx = [1,2,3,4,5,6,7,8,9,10]\ny =\
    \ [0.0] * N\nfor i in range(N):\n    y[i] = x[i]\n    if i > 2:\n        y[i]\
    \ = y[i] + y[] * p + (1 - p) * y[i-1]\n\nfor i in range(N):\n    print(\"x[{}]\
    \ = {}\".format(i, x[i]))\n    print(\"y[{}] = {}\".format(i, y[i]))\ni-1] + y[i-2]\n\
    \nn = 10\np = 0.35\ny = [0.0] * n\nfor i in range(n):\n    y[i] = x[i  x_s[i]\
    \ = x[i] * s[i] + (1 - s[i]) * y[i-1]\n\nfor i in range(N):\n    print(\"x[{}]\
    \ = {}\".format(i, x[i]))\n    print(\"y[{}] = {}\".format(i, y[i]))\n    print(\"\
    s[{}] = {}\".format(i, s[i]))\n    print(\"x_s[{}] = {}\".format(i, x_s[i]))\n\
    \nprint(\"\")\n\nprint(\"Original Signal:\")\nplt.plot(x)\nplt.show()\n\nprint(\"\
    \")\n\nprint(\"Sampled Signal:\")\nplt.plot(s)\nplt.show()\n\nprint(\"\")\n\n\
    print(\"Filtered Signal:\")\nplt.plot(y)\nplt.show()\n\nprint(\"\")\n\nprint(\"\
    Sampled and Filtered Signal:\")\nplt.plot(x_s)\nplt.show()\n# \n# 9/10/2018\n\
    # CS 465: Computer Organization and Architecture\n# HW"
- code: "module Problem15(input [3:0] a, b, c, [3:0] y, [3:0] x, output [3:0] d);\n\
    \  reg [3:0] q;\n  reg [3:0] r;\n  reg [3:0] s;\n  reg [3:0] t;\n  \n  initial\
    \ begin\n    q = 0;\n    r = 0;\n    s = 0;\n    t = 0;\n  end\n  \n  always @(posedge\
    \ clock) begin\n    q <= 0;\n    r <= q;\n    s <= r;\n    t <= r;\n  end\n  \n\
    \  always @* begin\n    y <= 0;\n  end\n  \n  assign d[3] = t;\nendmodule\n###\
    \ Output:\n0\n0\n0\n0"
- code: "module Problem8(input  [3:0] a, b, output [3:0] diff);\n  packed struct {\n\
    \    reg [3:0] x, y, z;\n  } diff;\nendmodule\n#include <stdlib.h>\n#include <stdio.h>\n\
    #include <string.h>\n#include <stdint.h>\n\n#include \"y86.h\"\n\nuint32_t execute_call(uint32_t\
    \ *registers, code_t *code, uint32_t address, int32_t offset) {\n  uint32_t ip;\
    \   // instruction pointer\n  uint32_t sp;   // stack pointer\n  uint32_t ret;\
    \  // return address\n  uint32_t size; // size of the function we call\n\n  /*\
    \ Check if the stack pointer is valid: it must be less than the stack top\n  \
    \   This test is not required for the full solution */\n\n  /* Check if the address\
    \ of the call is in the same segment the call is\n     being made in.  Make sure\
    \ that the offset is within the segment. */\n\n  /* Make sure that there is room\
    \ to put the return address on the stack */\n\n  /* Store the return address onto\
    \ the stack, and save the return address */\n\n  /* Set the instruction pointer\
    \ to the address field of the instruction\n     that called this function */\n\
    \n  /* Update the stack pointer */\n\n  /* Modify the flags in the EFLAGS register\
    \ to reflect the result of the\n     function being called */\n\n  /* Return the\
    \ value calculated by the function being called */\n}\n\nint main(void) {\n  int32_t\
    \ offset[3];\n  int32_t offset2;\n  uint32_t stacktop = 0x00403000;\n  uint32_t\
    \ registers[NUM_REGISTERS];\n  code_t code;\n  uint32_t *segments;\n  segment_t\
    \ segment;\n  uint32_t i;\n  uint32_t address;\n  uint32_t result;\n  uint32_t\
    \ return_address;\n\n  /* Initialize the values of the array of code segments\
    \ */\n\n  segment.num_bytes = 0x004000c8;\n  segment.bytes     = (uint8_t*)malloc(sizeof(uint8_t)\
    \ * segment.num_bytes); \n  memcpy(segment.bytes, code_bin, segment.num_bytes);\n\
    \  segments = (uint32_t*)malloc(sizeof(uint32_t) * NUM_CODE_SEGMENTS);\n  segments[0]\
    \ = (uint32_t)segment.bytes;\n  segments[1] = (uint32_t)segment.bytes + segment.num_bytes;\n\
    \  segments[2] = (uint32_t)segment.bytes + 2*segment.num_bytes;\n  segments[3]\
    \ = (uint32_t)segment.bytes + 3*segment.num_bytes;\n  segments[4] = (uint32_t)segment.bytes\
    \ + 4*segment.num_bytes;\n\n  /* Set the segment register to point to the 0th\
    \ segment */\n\n  /* Set the instruction pointer to point to code segment 0's\
    \ program counter */\n\n  /* Call the function to execute the first instruction\
    \ */\n\n  /* Check for a branch */\n\n  /* If the branch was taken, set the program\
    \ counter to the target\n     address, otherwise set it to the next instruction.\
    \ */\n\n  /* Check for a function call */\n\n  /* If a function call was made,\
    \ execute the call and then skip the next\n     instruction. Otherwise, skip the\
    \ next instruction. */\n\n  /* If we've finished all the instructions in this\
    \ code segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if the stack pointer is\
    \ valid: it must be less than the stack\n     top */\n\n  /* Update the instruction\
    \ pointer to the address saved in the stack */\n\n  /* Restore the stack pointer\
    \ */\n\n\n  /* Call the function to execute the second instruction */\n\n  /*\
    \ Check for a branch */\n\n  /* If the branch was taken, set the program counter\
    \ to the target\n     address, otherwise set it to the next instruction. */\n\n\
    \  /* Check for a function call */\n\n  /* If a function call was made, execute\
    \ the call and then skip the next\n     instruction. Otherwise, skip the next\
    \ instruction. */\n\n  /* If we've finished all the instructions in this code\
    \ segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if the stack pointer is\
    \ valid: it must be less than the stack\n     top */\n\n  /* Update the instruction\
    \ pointer to the address saved in the stack */\n\n  /* Restore the stack pointer\
    \ */\n\n\n  /* Call the function to execute the second instruction */\n\n  /*\
    \ Check for a branch */\n\n  /* If the branch was taken, set the program counter\
    \ to the target\n     address, otherwise set it to the next instruction. */\n\n\
    \  /* Check for a function call */\n\n  /* If a function call was made, execute\
    \ the call and then skip the next\n     instruction. Otherwise, skip the next\
    \ instruction. */\n\n  /* If we've finished all the instructions in this code\
    \ segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if the stack pointer is\
    \ valid: it must be less than the stack\n     top */\n\n  /* Update the instruction\
    \ pointer to the address saved in the stack */\n\n  /* Restore the stack pointer\
    \ */\n\n\n  /* Call the function to execute the third instruction */\n\n  /* Check\
    \ for a branch */\n\n  /* If the branch was taken, set the program counter to\
    \ the target\n     address, otherwise set it to the next instruction. */\n\n \
    \ /* Check for a function call */\n\n  /* If a function call was made, execute\
    \ the call and then skip the next\n     instruction. Otherwise, skip the next\
    \ instruction. */\n\n  /* If we've finished all the instructions in this code\
    \ segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if the stack pointer is\
    \ valid: it must be less than the stack\n     top */\n\n  /* Update the instruction\
    \ pointer to the address saved in the stack */\n\n  /* Restore the stack pointer\
    \ */\n\n\n  /* Call the function to execute the third instruction */\n\n  /* Check\
    \ for a branch */\n\n  /* If the branch was taken, set the program counter to\
    \ the target\n     address, otherwise set it to the next instruction. */\n\n \
    \ /* Check for a function call */\n\n  /* If a function call was made, execute\
    \ the call and then skip the next\n     instruction. Otherwise, skip the next\
    \ instruction. */\n\n  /* If we've finished all the instructions in this code\
    \ segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if the stack pointer is\
    \ valid: it must be less than the stack\n     top */\n\n  /* Update the instruction\
    \ pointer to the address saved in the stack */\n\n  /* Restore the stack pointer\
    \ */\n\n\n  /* Call the function to execute the fourth instruction */\n\n  /*\
    \ Check for a branch */\n\n  /* If the branch was taken, set the program counter\
    \ to the target\n     address, otherwise set it to the next instruction. */\n\n\
    \  /* Check for a function call */\n\n  /* If a function call was made, execute\
    \ the call and then skip the next\n     instruction. Otherwise, skip the next\
    \ instruction. */\n\n  /* If we've finished all the instructions in this code\
    \ segment, return\n     back to the caller (the code that called this function).\
    \ */\n\n  /* Update the flags to reflect the function's result if a function\n\
    \     call was made */\n\n  /* Check for a value in the EFLAGS register.  If it\
    \ is 1, set the EFLAGS\n     register back to 0, otherwise leave it the same.\
    \ */\n\n  /* Save the return address on the stack and update the stack pointer\
    \ */\n\n  /* Return from the function */\n\n  /* Check if"
- code: "```verilog\nmodule tst_alu4();\n  reg [3:0]a,b; reg[1:0] f; logic cci; logic[3:0]d;\
    \ logic co;\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\n  initial begin cci=1'b0;\
    \ f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\n  always begin\
    \ // Apply stimulus with #3 delay\n  end\n  initial $monitor($time, \" cci = %b,\
    \ a= %h,b = %h,f = %b,d =%b,co= %b \",cci,a,b,f,d,co); // Use %h\nendmodule\n\
    ```\n\n### Output:\n\n```console\n$./sim\n cci = 0, a= 0,b = 0,f = 00,d =0,co=\
    \ 0 \nTime: 30.000, cci = 0, a= 0,b = 0,f = 00,d =0,co= 1\n```"
- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; wire co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Output:
    ```
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
    cci = 0, a= 0,b = 0,f = 00,d =0,co= 0
- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; logic [1:0] cci; wire [1:0] d; wire co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Result:
    ![image](https://user-images.githubusercontent.com/83641209/117053571-75899e00-ad0b-11eb-982e-852813bc1f6c.png)

    The result shows that the d output is logic type and has no conflict with the signal type of d.

    ## 8. ALU with the input co=4'h1
    ### Base Verilog Code:
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus with #3 delay
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_
- code: "module tst_alu4();\n  reg [3:0]a,b; reg[1:0] f; logic [1:0] cci; wire[3:0]d;\
    \ wire co;\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\n  initial begin cci=1'b0;\
    \ f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\n  always begin\
    \ // Apply stimulus with #3 delay\n  end\n  initial $monitor($time, \" cci = %b,\
    \ a= %h,b = %h,f = %b,d =%h,co= %b \",cci,a,b,f,d,co); // Use %h\nendmodule\n\
    ### Output:\ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d =0,co= 0 \ncci = 0, a= 0,b = 0,f = 00,d\
    \ =0,co= 0 \ncc"
- code: |-
    ```
    module alu_4(d, co, a, b, f, cci);
      logic [3:0] d;
      logic co;
      logic [1:0] f;
      logic [3:0] a;
      logic [3:0] b;
      wire [3:0] sel;
      reg [3:0] d_reg;
      reg co_reg;
      reg [3:0] d_alu;
      assign d = d_alu;
      alu aluinst(d_alu, co_reg, sel);
      assign co = co_reg;
      assign d_reg = d_alu;
      always @(posedge cci) begin
        case(f)
          2'b00: sel = a;
          2'b01: sel = b;
          2'b10: sel = 0;
          2'b11: sel = 1'b1;
          default : sel = 0;
        endcase
      end
    endmodule

    module alu(d, co, sel);
      logic [3:0] d;
      logic co;
      logic [3:0] sel;
      reg [3:0] d_reg;
      reg co_reg;
      reg [3:0] d_alu;
      assign d = d_alu;
      assign co = co_reg;
      assign d_reg = d_alu;

      always @(sel) begin
        case(sel)
          4'h0: d_alu = 4'b0000;
          4'h1: d_alu = 4'b0001;
          4'h2: d_alu = 4'b0010;
          4'h3: d_alu = 4'b0011;
          4'h4: d_alu = 4'b0100;
          4'h5: d_alu = 4'b0101;
          4'h6: d_alu = 4'b0110;
          4'h7: d_alu = 4'b0111;
          4'h8: d_alu = 4'b1000;
          4'h9: d_alu = 4'b1001;
          4'ha: d_alu = 4'b1010;
          4'hb: d_alu = 4'b1011;
          4'hc: d_alu = 4'b1100;
          4'hd: d_alu = 4'b1101;
          4'he: d_alu = 4'b1110;
          4'hf: d_alu = 4'b1111;
          default: d_alu = sel;
        endcase
      end

      always @(sel) begin
        case(sel)
          4'h0: co_reg = 1'b1;
          4'h1: co_reg = 1'b1;
          4'h2: co_reg = 1'b1;
          4'h3: co_reg = 1'b1;
          4'h4: co_reg = 1'b1;
          4'h5: co_reg = 1'b1;
          4'h6: co_reg = 1'b1;
          4'h7: co_reg = 1'b1;
          4'h8: co_reg = 1'b1;
          4'h9: co_reg = 1'b1;
          4'ha: co_reg = 1'b1;
          4'hb: co_reg = 1'b1;
          4'hc: co_reg = 1'b1;
          4'hd: co_reg = 1'b1;
          4'he: co_reg = 1'b1;
          4'hf: co_reg = 1'b1;
          default
- code: "module tst_alu4();\n  reg [3:0]a,b; reg[1:0] f; reg cci; logic[3:0]d; logic\
    \ co;\n  alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU\n  initial begin cci=1'b0;\
    \ f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop\n  always begin\
    \ // Apply stimulus with #3 delay\n  end\n  initial $monitor($time, \" cci = %b,\
    \ a= %h,b = %h,f = %b,d =%h,co= %b \",cci,a,b,f,d,co); // Use %h\nendmodule\n\
    #include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n\
    #include <cstring>\nusing namespace std;\n\nint main()\n{\n\tstring s;\n\tstring\
    \ line;\n\tstring line_new;\n\tifstream file1(\"testbench.txt\");\n\tofstream\
    \ file2;\n\tfile2.open(\"testbench_new.txt\", ios::out | ios::trunc);\n\tif (file1.is_open())\n\
    \t{\n\t\twhile (getline(file1, line))\n\t\t{\n\t\t\tline_new += line[0];\n\t\t\
    \tfor (int i = 1; i < line.size(); i++)\n\t\t\t{\n\t\t\t\tif (line[i] =='' &&\
    \ line[i - 1]!='')\n\t\t\t\t{\n\t\t\t\t\tline_new += line[i];\n\t\t\t\t}\n\t\t\
    \t\telse\n\t\t\t\t\tline_new += line[i];\n\t\t\t}\n\t\t\tline_new += '\\n';\n\t\
    \t}\n\t\t\n\t\tfile2 << line_new;\n\t\tfile1.close();\n\t\tfile2.close();\n\t\
    }\n\telse cout << \"Unable to open file\";\n\treturn 0;\n}"
- code: |-
    module tst_alu4();
      reg [3:0]a,b; reg[1:0] f; logic cci; wire[3:0]d; logic co;
      alu_4 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin c
- code: |-
    module alu(out,o_sum,o_co,o_ci);
    input [3:0]i;
    input [3:0]j;
    input [1:0]f;
    input ci;
    output [1:0]co;
    output [3:0]sum;

    reg [1:0] c_in;
    reg [3:0] s_in;
    reg [3:0] i_in;
    reg [3:0] j_in;

    always@(*)(ci == 1'b1) begin
    c_in <= 3'b1;
    end

    always@(*)(ci == 1'b0) begin
    c_in <= 3'b0;
    end

    always@(*)(f == 3'b000) begin
    s_in <= i_in + j_in + c_in;
    end

    always@(*)(f == 3'b001) begin
    s_in <= i_in + j_in;
    end

    always@(*)(f == 3'b010) begin
    s_in <= i_in - j_in;
    end

    always@(*)(f == 3'b011) begin
    s_in <= i_in - j_in + c_in;
    end

    always@(*)(f == 3'b100) begin
    s_in <= i_in * j_in;
    end

    always@(*)(f == 3'b101) begin
    s_in <= i_in * j_in + c_in;
    end

    always@(*)(f == 3'b110) begin
    s_in <= i_in / j_in;
    end

    always@(*)(f == 3'b111) begin
    s_in <= i_in / j_in + c_in;
    end

    assign o_co = c_in;
    assign o_sum = s_in;
    endmodule

    ### Simulation Output:

    ![alu](https://user-images.githubusercontent.com/79090949/118186105-5a866300-b408-11eb-8576-286742286ee2.PNG)

    > **Notice:**
    > No error reported.
    > Functionality tested correctly.

    ## 1.5 : rom

    **Q:** Implement a 4-bit ALU with the following inputs and outputs:

    ![rom](https://user-images.githubusercontent.com/79090949/118186508-c953bd00-b408-11eb-9707-5579477e3d2b.PNG)

    **Ans:**
    ### Base Verilog Code:
    module rom(out, ci, f);
    input [3:0] f;
    output ci;
    output [3:0] out;

    reg [3:0] rom_table [0:15];
    wire [1:0] rom_ci;

    always@(*) begin
    case (f)
    3'b000: rom_ci = 2'b00;
    3'b001: rom_ci = 2'b01;
    3'b010: rom_ci = 2'b10;
    3'b011: rom_ci = 2'b11;
    3'b100: rom_ci = 2'b10;
    3'b101: rom_ci = 2'b11;
    3'b110: rom_ci = 2'b01;
    3'b111: rom_ci = 2'b00;
    default: rom_ci = 2'bxx;
    endcase
    end
    assign rom_ci = 2'b10;
    assign out = rom_table[f];

    reg [3:0] r_f;
    always@(*) begin
    r_f = f;
    end

    always@(*) begin
    if (r_f == 3'b000) begin rom_table[3'b000] = 4'h0; end
    if (r_f == 3'b001) begin rom_table[3'b001] = 4'h1; end
    if (r_f == 3'b010) begin rom_table[3'b010] = 4'h2; end
    if (r_f == 3'b011) begin rom_table[3'b011] = 4'h3; end
    if (r_f == 3'b100) begin rom_table[3'b100] = 4'h4; end
    if (r_f == 3'b101) begin rom_table[3'b101] = 4'h5; end
    if (r_f == 3'b110) begin rom_table[3'b110] = 4'h6; end
    if (r_f == 3'b111) begin rom_table[3'b111] = 4'h7; end
    endmodule

    ### Variation Instruction:
    To test the ROM
- code: |-
    * Change the type of co from reg to reg.
    ```
    // Copyright 2019-2020 Cadence Design Systems, Inc.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //     http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    // implied.
    //
    // See the License for the specific language governing permissions and
    // limitations under the License.

    using System;
    using System.Collections.Generic;

    using Microsoft.Extensions.Logging;

    using BACnetApplication.Logging;
    using BACnetApplication.BACnet;
    using BACnetApplication.Configuration;
    using BACnetApplication.Devices;
    using BACnetApplication.Services.Data;
    using BACnetApplication.Services.Device;
    using BACnetApplication.Services.Network;
    using BACnetApplication.Services.Object;
    using BACnetApplication.Services.Property;
    using BACnetApplication.Services.Services;
    using BACnetApplication.Services.Services.Device;
    using BACnetApplication.Services.Services.Object;
    using BACnetApplication.Services.Services.Property;
    using BACnetApplication.Services.Services.Value;
    using BACnetApplication.Services.Services.Value.Actions;
    using BACnetApplication.Services.Services.Value.Data;
    using BACnetApplication.Services.Services.Value.Events;
    using BACnetApplication.Services.Services.Value.Objects;
    using BACnetApplication.Services.Services.Value.Points;
    using BACnetApplication.Services.Services.Value.Properties;
    using BACnetApplication.Services.Services.Value.Services;
    using BACnetApplication.Services.Services.Value.Types;
    using BACnetApplication.Services.Services.Value.Values;
    using BACnetApplication.Services.Services.Value.Variables;
    using BACnetApplication.Services.Services.Value.Variables.Analog;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Data;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Events;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Objects;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Properties;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Services;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Types;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Values;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Actions;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Data;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Events;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Objects;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Properties;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Services;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Types;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Values;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Actions;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Data;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Events;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Objects;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Properties;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Services;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Types;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Values;
    using BACnetApplication.Services.Services.Value.Variables.Analog.Variables.Variables.Variables;
    using BACnetApplication.Services.Services.Value.Variables.Binary;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Data;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Events;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Objects;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Properties;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Services;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Types;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Values;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables.Actions;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables.Data;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables.Events;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables.Objects;
    using BACnetApplication.Services.Services.Value.Variables.Binary.Variables.Properties;
    using BACnetApplication.Services.Services.Value
- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;

    struct d_data {
    rand unsigned [7:0] DataOut;
    };

    d_data d
- code: "```\n`include \"test_bench_top.sv\"\n\nmodule TestDataComponent;\n\nparameter\
    \ integer NUM_TESTS = 1000000;\nparameter integer NUM_ITERATIONS = 10;\n\nlocalparam\
    \ TestWidth = 8;\nlocalparam BitWidth = TestWidth + 7;\n\nlocalparam integer BitMask\
    \ = (1 << BitWidth) - 1;\n\nreg [TestWidth-1:0] DataIn;\n\nreg [BitWidth-1:0]\
    \ Rand;\nreg [BitWidth-1:0] DataOut;\nreg ControlSignals;\n\nDataComponent DUT(\n\
    .DataIn(DataIn),\n.DataOut(DataOut),\n.ControlSignals(ControlSignals)\n);\n\n\
    initial begin\n$dumpfile(\"DataComponent.vcd\");\n$dumpvars(0, TestDataComponent);\n\
    \nfor (integer i = 0; i < NUM_TESTS; i ++) begin\nDataIn = (Rand & BitMask);\n\
    ControlSignals = 1;\n\nfor (integer j = 0; j < NUM_ITERATIONS; j++) begin\n# 1;\n\
    end\n\n$display(\"%08d, %02x, %03x, %d\", i, DataIn, DataOut, ControlSignals);\n\
    end\n\nend\nendmodule\n```\n   // Test cases\n        // First one is not a duplicate\n\
    \        for (int i = 1; i < 100; i++) {\n            array.add(i);\n        }\n\
    \        System.out.println(\"Should be false: \" + array.contains(1));\n    \
    \    System.out.println(\"Should be true: \" + array.contains(98));\n        System.out.println(\"\
    Should be false: \" + array.contains(99));\n    }\n}\n/HW4/src/ArrayIntList.java\n\
    /**\n * @author \n * @version 1.0\n * @since 05/27/2018\n */\npublic class ArrayIntList\
    \ implements IntList {\n\n    private int[] list;\n    private int count;\n\n\
    \    public ArrayIntList(int size) {\n        list = new int[size];\n        count\
    \ = 0;\n    }\n\n    @Override\n    public int size() {\n        return count;\n\
    \    }\n\n    @Override\n    public boolean contains(int value) {\n        for\
    \ (int i = 0; i < count; i++) {\n            if (list[i] == value) {\n       \
    \         return true;\n            }\n        }\n        return false;\n    }\n\
    \n    @Override\n    public void insert(int index, int value) {\n        if (index\
    \ <= count && index >= 0) {\n            if (count == list.length) {\n       \
    \         int[] temp = new int[list.length * 2];\n                for (int i =\
    \ 0; i < list.length; i++) {\n                    temp[i] = list[i];\n       \
    \         }\n                list = temp;\n            }\n            for (int\
    \ i = count; i >= index; i--) {\n                list[i] = list[i - 1];\n    \
    \        }\n            list[index] = value;\n            count++;\n        }\
    \ else {\n            throw new IndexOutOfBoundsException(\"Index: \" + index\
    \ + \", Size: \" + count);\n        }\n    }\n\n    @Override\n    public int\
    \ remove(int index) {\n        if (index <= count && index >= 0) {\n         \
    \   int removed = list[index];\n            for (int i = index; i < count - 1;\
    \ i++) {\n                list[i] = list[i + 1];\n            }\n            count--;\n\
    \            return removed;\n        } else {\n            throw new IndexOutOfBoundsException(\"\
    Index: \" + index + \", Size: \" + count);\n        }\n    }\n\n    @Override\n\
    \    public int get(int index) {\n        if (index < count && index >= 0) {\n\
    \            return list[index];\n        } else {\n            throw new IndexOutOfBoundsException(\"\
    Index: \" + index + \", Size: \" + count);\n        }\n    }\n\n    public int\
    \ set(int index, int value) {\n        if (index < count && index >= 0) {\n  \
    \          int temp = list[index];\n            list[index] = value;\n       \
    \     return temp;\n        } else {\n            throw new IndexOutOfBoundsException(\"\
    Index: \" + index + \", Size: \" + count);\n        }\n    }\n\n    public void\
    \ main() {\n        // Preexisting lists\n        ArrayIntList array = new ArrayIntList(100);\n\
    \n        // Tests empty list\n        System.out.println(\"Should be 0: \" +\
    \ array.size());\n        System.out.println(\"Should be false: \" + array.contains(0));\n\
    \n        // Test cases with a bunch of 9s in them\n        for (int i = 0; i\
    \ < 10; i++) {\n            array.add(9);\n        }\n\n        System.out.println(\"\
    Should be true: \" + array.contains(9));\n        System.out.println(\"Should\
    \ be true: \" + array.contains(8));\n        System.out.println(\"Should be true:\
    \ \" + array.contains(7));\n        System.out.println(\"Should be true: \" +\
    \ array.contains(6));\n\n        System.out.println(\"Should be 10: \" + array.size());\n\
    \n        // Test negative index\n        try {\n            array.remove(-1);\n\
    \        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"\
    Caught expected exception: \" + e.getMessage());\n        }\n\n        // Test\
    \ out of bounds index\n        try {\n            array.remove(10);\n        }\
    \ catch (IndexOutOfBoundsException e) {\n            System.out.println(\"Caught\
    \ expected exception: \" + e.getMessage());\n        }\n\n        // Add to index\
    \ 0\n        array.insert(0, 0);\n\n        System.out.println(\"Should be true:\
    \ \" + array.contains(0));\n        System.out.println(\"Should be 11: \" + array.size());\n\
    \n        // Add to index 11\n        array.insert(11, 11);\n\n        System.out.println(\"\
    Should be true: \" + array.contains(11));\n        System.out.println(\"Should\
    \ be 12: \" + array.size());\n\n        // Test get\n        System.out.println(\"\
    Should be 9: \" + array.get(0));\n\n        // Test set\n        System.out.println(\"\
    Should be 3: \" + array.set(5, 3));\n        System.out.println(\"Should be 3:\
    \ \" + array.get(5));\n\n        // Test negative index\n        try {\n     \
    \       System.out.println(\"Should be \" + array.set(-1, 11));\n        } catch\
    \ (IndexOutOfBoundsException e) {\n            System.out.println(\"Caught expected\
    \ exception: \" + e.getMessage());\n        }\n\n        // Test out of bounds\
    \ index\n        try {\n            System.out.println(\"Should be \" + array.set(10,\
    \ 11));\n        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"\
    Caught expected exception: \" + e.getMessage());\n        }\n\n        // Testing\
    \ remove\n        System.out.println(\"Should be true: \" + array.contains(3));\n\
    \n        System.out.println(\"Should be 3: \" + array.remove(5));\n\n       \
    \ System.out.println(\"Should be false: \" + array.contains(3));\n        System.out.println(\"\
    Should be true: \" + array.contains(0));\n        System.out.println(\"Should\
    \ be true: \" + array.contains(9));\n        System.out.println(\"Should be 10:\
    \ \" + array.size());\n\n        // Test first index\n        System.out.println(\"\
    Should be 0: \" + array.remove(0));\n        System.out.println(\"Should be false:\
    \ \" + array.contains(0));\n        System.out.println(\"Should be true: \" +\
    \ array.contains(9));\n        System.out.println(\"Should be 9: \" + array.size());\n\
    \n        System.out.println(\"Should be 9: \" + array.remove(8));\n        System.out.println(\"\
    Should be false: \" + array.contains(9));\n        System.out.println(\"Should\
    \ be true: \" + array.contains(8));\n        System.out.println(\"Should be 8:\
    \ \" + array.size());\n\n        // Test for removal\n        System.out.println(\"\
    Should be 8: \" + array.remove(7));\n        System.out.println(\"Should be false:\
    \ \" + array.contains(8));\n        System.out.println(\"Should be true: \" +\
    \ array.contains(7));\n        System.out.println(\"Should be 7: \" + array.size());\n\
    \n        // Test for removal\n        System.out.println(\"Should be 7: \" +\
    \ array.remove(6));\n        System.out.println(\"Should be false: \" + array.contains(8));\n\
    \        System.out.println(\"Should be false: \" + array.contains(7));\n    \
    \    System.out.println(\"Should be 6: \" + array.size());\n\n        // Test\
    \ for removal\n        System.out.println(\"Should be 6: \" + array.remove(5));\n\
    \        System.out.println(\"Should be false: \" + array.contains(6));\n    \
    \    System.out.println(\"Should be true: \""
- code: |-
    module my_module();
    reg a;

    always @* begin
    a = ~a;
    end

    initial begin
    a = 1'b1;
    end

    endmodule

    ## 4.9.1.6
    ### Base Verilog Code:
    module my_module();
    reg a;

    always @* begin
    a = ~a;
    end

    always @ (posedge clk or negedge clk) begin
    a
- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    struct data_struct {
    logic [7:0] data;
    logic rand;
    };

    struct data_struct data;
    data.data = DataIn;
    data.rand = rand;
    endmodule
- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule
    ### Expected Output:
    ```
    Verilog Code:

    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    endmodule

    Modified Code:

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    Expected Output:

    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand2;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand3;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand4;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand4;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand4;
    } structData;
    structData Data;
    endmodule

    module DataComponent (DataIn, DataOut, ControlSignals);
    typedef struct structData {
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    rand integer rand4;
    } structData;
    structData Data;
    endmodule
- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    reg [7:0] DataOut;
    endmodule
    ### Modification Output:
    The following code contains all the changes made during this part.
    diff --git a/data_component.v b/data_component.v
    index 8e389c2..f1078f6 100644
    --- a/data_component.v
    +++ b/data_component.v
    @@ -1,5 +1,10 @@
    -module DataComponent (DataIn, DataOut, ControlSignals);
    +module DataComponent (DataIn, DataOut, ControlSignals,
    +                       DataOut_init,
    +                       DataOut_rand_zero,
    +                       DataOut_rand_one,
    +                       DataOut_rand_other);
    +
     input [7:0] DataIn;
     output [7:0] DataOut;
     input ControlSignals;
    @@ -7,4 +12,19 @@ endmodule

    -// TODO: DataComponent
    +// TODO: DataComponent
    +
    +reg [7:0] DataOut;
    +
    +// TODO: Initial Value
    +// TODO: Random Value
    +reg DataOut_init = 0x0;
    +reg DataOut_rand_zero = 0x0;
    +reg DataOut_rand_one = 0x1;
    +reg DataOut_rand_other = 0x2;
    +
    +// TODO: Randomization
    +
    +// TODO: Randomization
    +
    +// TODO: Randomization

    ### Comments:
    The changes needed to achieve this goal can be seen in the added lines.
    The added lines define the data signal, the initial signal, the random zero signal, the random one signal, and the random other signal.
    +
    +@davejones1990
- code: module DataComponent (Data
- code: |-
    module Nand3 (A, B, C, D);
    input A;
    input B;
    input C;
    output D;

    Nand2 NAND_A1 (.X1(A),.X2(D));
    Nand2 NAND_A2 (.X1(B),.X2(D));
    Nand2 NAND_A3 (.X1(C),.X2(D));

    Nand2 NAND_A4 (.X1(A),.X2(B),.
- code: "```\nstruct data_component_struct{\n  always_comb begin\n    DataOut = DataIn;\n\
    \  end\n  rand begin\n    int<8> randData;\n    randData = rand? randData:rand.next;\n\
    \  end\n};\n/doc/verilog_style.md\n## Verilog style guide\n\n### General style\n\
    \n- Use tabs for indentation (never spaces), although spaces are still allowed\
    \ in certain locations.\n- Line wrapping is only necessary when the code would\
    \ otherwise exceed the 80 character limit, and in those cases the maximum line\
    \ length is 100 characters.\n- Line length should be determined by the number\
    \ of characters that can fit into the 80-character limit. Longer lines are usually\
    \ harder to read.\n\n### Code blocks\n\n- All code should be contained within\
    \ parentheses, unless they are not necessary to indicate a block.\n- Use a single,\
    \ blank line before a new block begins. Make sure that this is the only line and\
    \ is not mixed up with a different block.\n- If a code block spans multiple lines,\
    \ indent it to 2 or more tabs.\n- If a code block is empty, add a comment to explain\
    \ why it is empty.\n\n### File names\n\n- All filenames should be lower case and\
    \ have the extension \"v\".\n- If there are multiple files in the same directory,\
    \ they should be ordered alphabetically.\n\n### Comments\n\n- Start every comment\
    \ block with a line starting with '//' and a single space.\n- Start every comment\
    \ within a block with two slashes, and comment text should be indented one space\
    \ from the line starting with '//'.\n- If a line begins with a comment, it should\
    \ not be indented to be parallel with the line starting with '//'.\n\n### Naming\
    \ conventions\n\n- Verilog uses the same naming conventions as C++ and Java.\n\
    - Module names must be all uppercase.\n- Local variable names and parameter names\
    \ must be all lowercase.\n- Variables and signals must be named with 2 or more\
    \ lowercase letters.\n\n```\ninput a0;\ninput [1:0] a1;\ninput  a2, a3;\ninput\
    \   a4, a5;\ninput  a6,  a7, a8;\ninput  a9;\ninput   x_a10,    x_a11, x_a12;\n\
    input  x_a13;\ninput   x_x_x_a14;  x_x_x_    a15;\ninput  x_x_x_        x_x_x_x_a16;\n\
    input   b0, b1, b2;\ninput   [0:0]   b3;\ninput   [1:0]   b4;\ninput   [0]   \
    \  b5;\ninput   [1]     b6;\ninput   [2]     b7;\ninput  [3]     b8;\ninput  \
    \ [3:0]   b9;\ninput   [7]     b10;\ninput   [7:0]   b11;\ninput   [3:0]   [0:0]\
    \   b12;\ninput  [3:0]   [1:0]   b13;\ninput   [1:0]   [1:0]   b14;\ninput  [1:0]\
    \   [3:0]   b15;\ninput   [1:0]   [3:0]   [0:0]   b16;\ninput  [1:0]   [3:0] \
    \  [1:0]   b17;\ninput   x_x_x_    x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_b18;\ninput\
    \  x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_b19;\ninput   x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_b20;\n\
    input  x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_b21;\n\
    ```\n\nYou will notice that the variable names are in alphabetical order. This\
    \ is not technically necessary, but it is very important to have consistent naming.\
    \ The \"x\" variable names are used as placeholders for long variable names.\n\
    \n**The exception to all of the above is the testbench file, which should be named\
    \ \"testbench.v\".**\n\n### Testbench file\n\n- The file should contain a \"module\
    \ main\" with a single input \"clock\" and a single output \"done\".\n- The file\
    \ should contain a \"module test\" to contain all of the test buses.\n- The file\
    \ should contain a \"module testbench\" to contain all the verilog code that is\
    \ necessary to run the tests.\n\n### Module names\n\n- Module names that are less\
    \ than 10 characters long should use snake-case. This includes any instance of\
    \ a module within another module.\n- Module names that are longer than 10 characters\
    \ long should use camel case.\n\n### Schematic symbols\n\n- Use the following\
    \ schematic symbols:\n\n```\ninput:  I \noutput: O \ninout:  IO \nreg:    R \n\
    wire:   W \nlogic:  L\n```\n\n- The input/output schematic symbol should only\
    \ be used when it is clear that the input/output is a signal or variable being\
    \ used by the module.\n- If the input/output is being used to pass data to/from\
    \ a register, then the input/output schematic symbol should be in the opposite\
    \ direction of the actual signal or variable being used.\n\n### Module I/O and\
    \ Wire\n\n- All of the wires, including inputs and outputs, should be declared\
    \ in the module header.\n- The use of wires should be limited. If a variable is\
    \ declared as a wire, it should be assigned a value within the module's always\
    \ block.\n- Wires that are not assigned should not be declared.\n\n### Module\
    \ headers\n\n- The signal declarations should be listed for each module in the\
    \ same order as they are declared in the module code.\n- The always/initial block(s)\
    \ should be listed at the end of the header.\n- The parameters/localparam block(s)\
    \ should be listed before the always/initial block(s).\n- The always/initial block(s)\
    \ should be indented by one tab.\n- The always/initial block(s) within a module\
    \ should be listed in the same order as they are declared.\n- Each module should\
    \ be declared in the same order within a module file as they are included.\n\n\
    ### Verilog code blocks\n\n- All of the Verilog code blocks should match the following\
    \ guidelines:\n\n```\nalways_ff:\nalways_comb:\nalways_latch:\ninit:\nalways:\n\
    if:\ncase:\ncasex:\ncasez:\nfor:\nbegin:\nend\n```\n\n- The use of the always_ff\
    \ keyword should be limited. Always_ff is only used for synchronous FFs that are\
    \ clocked.\n- The always_latch keyword should only be used for latch registers.\
    \ The always keyword should be used for everything else.\n- In general, the use\
    \ of the always_comb and always_latch keywords should be limited.\n- In general,\
    \ the use of the case, casex, and casez keywords should be limited.\n- The begin\
    \ and end keywords should be used correctly.\n\n### Verilog code indentation\n\
    \n- The level of indentation for code blocks should be consistent throughout the\
    \ module.\n- Code within the same block should be indented by one tab.\n- Code\
    \ within the same line should be indented by two tabs.\n- The use of spaces within\
    \ code blocks should be limited.\n\n### Verilog code comments\n\n- All lines that\
    \ start with '//' are comments.\n- The '//' should be on the same line as the\
    \ comment text.\n\n### Verilog code spacing\n\n- Spaces should be added between\
    \ tokens:\n\n```\nmodule a (a, b, c, d, e);\noutput a, b, c, d, e;\nreg a, b,\
    \ c, d, e;\ninput a, b, c, d, e;\nwire a, b, c, d, e;\n```\n\n- Spaces between\
    \ tokens should be used for consistency.\n- Spaces should not be added between\
    \ the tokens"
- code: |-
    module DataComponent (DataIn, DataOut, ControlSignals);
    input [7:0] DataIn;
    output [7:0] DataOut;
    input ControlSignals;
    reg [7:0] DataIn;
    reg [7:0] DataOut;

    struct rand_struct {
    rand rand;
    };
    rand_struct rand_array [16];

    always_comb #0 DataOut = DataIn;

    if (ControlSignals) begin
    rand_array [rand_gen_random_number] = rand_structrandom_number;
    endendmodule

    #### Verilog Unit Test:

    module DataComponentTest;

    wire [7:0] DataIn;
    wire [7:0] DataOut;
    wire ControlSignals;

    DataComponent DUT (DataIn, DataOut, ControlSignals);

    initial begin
    $dumpfile("out.v
- code: |-
    module Problem11(input [3:0] a, b, output [3:0] sum);
      logic [3:0] di;
      logic clk;
      initial begin
        di = 'b0;
      end
      always @(posedge clk) begin
        di <= ~di;
      end
      assign sum = a + b + ~di;
    endmodule
    ### Result:
    <img src="Images/Problem11.png" alt="Problem 11"width="200"/>

    #### Problem 12
    ### Base Verilog Code:
    module Problem12(input [3:0] a, b, output [3:0] sum);
      assign sum = a + b;
    endmodule
    ### Variation Instruction:
    Change the reg declarations for di and clk to logic to
- code: |-
    ```verilog
    module Problem1(input [3:0] a, b, output [3:0] sum);
      assign sum = a + b;
    endmodule
    ```
    ### Variation Results:
    [Problem1.v](https://github.com/fredl900/SystemVerilogExperiments/blob/master/Experiment3/Problem1.v)
    ```
    Testbench successfully compiled.
    Running Verilator output file simulation.
    Loading system verilog module.

    Simulation complete.

    Verilator output reports the following warnings:
    ```
    /Experiment2/Problem1.c
    #include <systemc.h>

    SC_MODULE (Problem1)
    {
        sc_in<sc_uint<4>> a;
        sc_in<sc_uint<4>> b;
        sc_out<sc_uint<4>> sum;
        SC_CTOR (Problem1)
        {
            SC_METHOD (adder);
            sensitive << a << b;
        }
        void adder()
        {
            sum.write(a.read() + b.read());
        }
    };

    int sc_main (int argc, char* argv[])
    {
        Problem1 problem("problem");
        sc_trace_file* tf = sc_create_vcd_trace_file("testbench");

        tf->set_time_unit(1, SC_PS);

        sc_signal<sc_uint<4>> a, b, sum;

        problem.a(a);
        problem.b(b);
        problem.sum(sum);

        sc_start(1000, SC_PS);
        a = 5;
        b = 2;
        sc_start(1000, SC_PS);
        tf->dump(0);

        sc_start(1000, SC_PS);
        a = 3;
        b = 1;
        sc_start(1000, SC_PS);
        tf->dump(0);

        sc_start(1000, SC_PS);
        a = 8;
        b = 9;
        sc_start(1000, SC_PS);
        tf->dump(0);

        sc_start(1000, SC_PS);
        a = 9;
        b = 9;
        sc_start(1000, SC_PS);
        tf->dump(0);

        sc_start(1000, SC_PS);
        tf->dump(1);
        tf->write_trace();

        sc_destroy_vcd_trace_file(tf);

        sc_close_vcd_trace_file(tf);

        return 0;
    }
- code: |-
    ```
    module Test(input [1:0] a, b, c, output [1:0] d);
      assign c = d | a;
      assign d = b & ~c;
    endmodule
    ```
- code: |-
    module Problem2(input [3:0] a, b, output [3:0] sum);
      reg[3:0] di, clk;
      reg[3:0] sum;

      always @ (posedge clk)
        sum <= a + b;

      always @ (posedge clk)
        di <= a + b;
    endmodule

    ### Results:

    1. Test bench is a new file (Problem2_tb.sv) in the test directory.
    2. The test bench is able to run on both models (Verilog and SystemVerilog).
    3. The waveform shows 2 different clocks which is expected for registers declared as reg types.
    4. In the waveform, clk is 0 for the first set and 1 for the second set.
    5. In the waveform, di is 0 for the first set and 1 for the second set.
    6. In the waveform, sum is 0 for the first set and 1 for the second set.

    ### Discussion:
    In SystemVerilog, registers are declared with the logic type, so Verilog registers are converted into SystemVerilog registers by SystemVerilog compiler. The result is that Verilog simulation works fine while SystemVerilog simulation fails.   while($row = $result->fetch_assoc()){
                echo $row["name"]. " ". $row["email"];
                echo "<br>";
            }
            $conn->close();
          ?>
        </body>
    </html><html>
        <head>
            <title>
                MySQL
            </title>
        </head>
        <body>
            <?php
            // create connection
            $servername = "localhost";
            $username = "root";
            $password = "";
            $dbname = "myDB";
            $conn = new mysqli($servername, $username, $password, $dbname);
            //check connection
            if ($conn->connect_error){
                die("Connection failed: ". $conn->connect_error);
            }
            $sql = "SELECT name, email FROM students";
            $result = $conn->query($sql);
         n.
    3. No error is found.

    ## Problem 3

    ### Testbench code:

    ```verilog
    module Test(input clock, input reset, input [1:0] a, input [1:0] b, output [1:0] out);
      logic [1:0] a_new, b_new;
      logic [1:0] a_new_1, b_new_1;

      assign a_new_1 = ~a_new;
      assign b_new_1 = ~b_new;

      always @ (posedge clock) begin
        a_new <= a;
        b_new <= b;
      end

      initial begin
        #700 reset = 1'b1;
        #700 reset = 1'b0;
        #1000 reset = 1'b1;
        #1000 reset = 1'b0;
        a = 2'b11;
        b = 2'b11;
      end

      always@(posedge clock) begin
        if (!reset) begin
          out <= ~a_new;
          out <= ~b_new;
        end else begin
          out <= b_new;
        end
      end
    endmodule
    ```

    ### Results:

    1. Test bench is a new file (Problem3_tb.sv) in the test directory.
    2. The test bench is able to run on both models (Verilog and SystemVerilog).
    3. The waveform shows 2 different clocks which is expected for registers declared as wire type.
    4. In the waveform, clk is 0 for the first set and 1 for the second set.
    5. In the waveform, reset is 0 for the first set and 1 for the second set.
    6. In the waveform, a is 2'b11 for the first set and 2'b00 for the second set.
    7. In the waveform, b is 2'b11 for the first set and 2'b00 for the second set.
    8. In the waveform, out is 2'b11 for the first set and 2'b00 for the second set.

    ### Discussion:

    In SystemVerilog, registers are declared with the logic type, so Verilog registers are converted into SystemVerilog registers by SystemVerilog compiler. The result is that Verilog simulation works fine while SystemVerilog simulation fails.# Problems 1-3

    1. There are no problems found in the code.
    2. No error is found.
    3. No error is found.

    ## Problem 2

    ### Testbench code:

    ```verilog
    module Test(input clock, input reset, input [1:0] a, input [1:0] b, output [1:0] out);
      logic [1:0] a_new, b_new;
      logic [1:0] a_new_1, b_new_1;

      assign a_new_1 = ~a_new;
      assign b_new_1 = ~b_new;

      always @ (posedge clock) begin
        a_new <= a;
        b_new <= b;
      end

      initial begin
        #700 reset = 1'b1;
        #700 reset = 1'b0;
        #1000 reset = 1'b1;
        #1000 reset = 1'b0;
        a = 2'b11;
        b = 2'b11;
      end

      always@(posedge clock) begin
        if (!reset) begin
          out <= ~a;
          out <= ~b;
        end else begin
          out <= a;
        end
      end
    endmodule
    ```

    ### Results:

    1. Test bench is a new file (Problem2_tb.sv) in the test directory.
    2. The test bench is able to run on both models (Verilog and SystemVerilog).
    3. The waveform shows 2
- code: |-
    ```
    module Problem6(input [3:0] a, b, output reg [3:0] sum);
      reg clk, rst, d;

      always_ff @(posedge clk) begin
        if (rst) begin
          sum <= 4'b0000;
        end
        else if (d) begin
          sum <= a + b;
        end
      end

      initial begin
        clk = 0;
        rst = 0;
        d = 1;
        #2 d = 1;
        #2 clk = 1;
      end
    endmodule
    ```
    /Lab 15/README.md
    # Lab 15

    ## Problems

    ### Problem 1

    - [Problem 1](./Problem1.png)
    - [Trace](./traces/1.txt)

    ### Problem 2

    - [Problem 2](./Problem2.png)
    - [Trace](./traces/2.txt)

    ### Problem 3

    - [Problem 3](./Problem3.png)
    - [Trace](./traces/3.txt)
    /Lab 8/README.md
    # Lab 8 - System Verilog

    ## Problems

    ### Problem 1

    - [Problem 1](./Problem1.png)
    - [Trace](./traces/1.txt)

    ### Problem 2

    - [Problem 2](./Problem2.png)
    - [Trace](./traces/2.txt)

    ### Problem 3

    - [Problem 3](./Problem3.png)
    - [Trace](./traces/3.txt)

    ### Problem 4

    - [Problem 4](./Problem4.png)
    - [Trace](./traces/4.txt)

    ### Problem 5

    - [Problem 5](./Problem5.png)
    - [Trace](./traces/5.txt)

    ### Problem 6

    - [Problem 6](./Problem6.png)
    - [Trace](./traces/6.txt)

    ### Problem 7

    - [Problem 7](./Problem7.png)
    - [Trace](./traces/7.txt)

    ### Problem 8

    - [Problem 8](./Problem8.png)
    - [Trace](./traces/8.txt)
    /Lab 12/README.md
    # Lab 12 - System Verilog

    ## Problems

    ### Problem 1

    - [Problem 1](./Problem1.png)
    - [Trace](./traces/1.txt)

    ### Problem 2

    - [Problem 2](./Problem2.png)
    - [Trace](./traces/2.txt)

    ### Problem 3

    - [Problem 3](./Problem3.png)
    - [Trace](./traces/3.txt)

    ### Problem 4

    - [Problem 4](./Problem4.png)
    - [Trace](./traces/4.txt)

    ### Problem 5

    - [Problem 5](./Problem5.png)
    - [Trace](./traces/5.txt)

    ### Problem 6

    - [Problem 6](./Problem6.png)
    - [Trace](./traces/6.txt)
    /Lab 14/README.md
    # Lab 14 - System Verilog

    ## Problems

    ### Problem 1

    - [Problem 1](./Problem1.png)
    - [Trace](./traces/1.txt)

    ### Problem 2

    - [Problem 2](./Problem2.png)
    - [Trace](./traces/2.txt)

    ### Problem 3

    - [Problem 3](./Problem3.png)
    - [Trace](./traces/3.txt)
    /Lab 11/Problem6.py
    #  - 21801123

    # Problem 6

    import math

    s = [3, 1, 4, 1, 5, 9, 2, 6, 5]

    # Problem 6

    while True:
        # Get the input
        num = input("Please enter a number in the range 1 to 10: ")

        # Check if the input is one
        if num == "1":
            # Get the value k
            k = input("Please enter a value: ")
            k = int(k)

            # Get the value q
            q = input("Please enter a value: ")
            q = int(q)

            # Get the value r
            r = input("Please enter a value: ")
            r = int(r)

            # Check if they are in range
            if k <= q and k <= r:
                break

        # The input is invalid
        else:
            print("Please enter a valid value")

    # Get the value x from the user
    x = input("Please enter a value: ")
    x = int(x)

    # Print the output
    print(
        f"The output is {"{" if q == 1 else "{" if r == 1 else "["}x+5, x+10, x+15}."
    )

    # Print the output
    print(
        f"The output is {"{" if q == 2 else "{" if r == 2 else "["}x+5, x+10, x+15}."
    )

    # Print the output
    print(
        f"The output is {"{" if q == 3 else "{" if r == 3 else "["}x+5, x+10, x+15}."
    )

    # Print the output
    print(
        f"The output is {"{" if q == 4 else "{" if r == 4 else "["}x+5, x+10, x+15}."
    )
- code: |-
    module Problem2(input [3:0] a, b);
    endmodule
    module Problem
- code: |-
    module Problem1(input [3:0] a, b, output [3:0] sum);
      logic [3:0] di;
      logic clk;
      always @(posedge clk, posedge reset)
        begin
          if (reset == 1'b1)
            di = 8'b10;
          else
            di = a + b;
        end
      assign sum = di;
    endmodule
    #include <iostream>
    using namespace std;

    void print_array(int *array, int size)
    {
        for (int i = 0; i < size; i++)
        {
            cout << array[i] << " ";
        }
        cout << endl;
    }

    void print_matrix(int **matrix, int row, int col)
    {
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                cout << matrix[i][j] << " ";
            }
            cout << endl;
        }
    }

    int main()
    {
        int a[] = {1, 2, 3, 4, 5, 6};
        print_array(a, 6);

        int **m = new int *[5];
        m[0] = new int[5];
        m[1] = new int[5];
        m[2] = new int[5];
        m[3] = new int[5];
        m[4] = new int[5];

        m[0][0] = 0;
        m[0][1] = 1;
        m[0][2] = 2;
        m[0][3] = 3;
        m[0][4] = 4;
        m[1][0] = 0;
        m[1][1] = 1;
        m[1][2] = 2;
        m[1][3] = 3;
        m[1][4] = 4;
        m[2][0] = 0;
        m[2][1] = 1;
        m[2][2] = 2;
        m[2][3] = 3;
        m[2][4] = 4;
        m[3][0] = 0;
        m[3][1] = 1;
        m[3][2] = 2;
        m[3][3] = 3;
        m[3][4] = 4;
        m[4][0] = 0;
        m[4][1] = 1;
        m[4][2] = 2;
        m[4][3] = 3;
        m[4][4] = 4;

        print_matrix(m, 5, 5);

        delete[] m[0];
        delete[] m[1];
        delete[] m[2];
        delete[] m[3];
        delete[] m[4];
        delete[] m;

        return 0;
    }#include <iostream>
    using namespace std;

    int main()
    {
        int a[3][3];
        int b[3][3];

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cin >> a[i][j];
            }
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cin >> b[i][j];
            }
        }

        cout << "a:" << endl;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cout << a[i][j] << " ";
            }
            cout << endl;
        }

        cout << "b:" << endl;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cout << b[i][j] << " ";
            }
            cout << endl;
        }

        int c[3][3];

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                c[i][j] = a[i][j] * b[i][j];
            }
        }

        cout << "c:" << endl;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cout << c[i][j] << " ";
            }
            cout << endl;
        }
    }// The following is the base file
    #ifndef MAIN_
    #define MAIN_

    #include <iostream>
    using namespace std;

    void print_array(int *array, int size)
    {
        for (int i = 0; i < size; i++)
        {
            cout << array[i] << " ";
        }
        cout << endl;
    }

    void print_matrix(int **matrix, int row, int col)
    {
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                cout << matrix[i][j] << " ";
            }
            cout << endl;
        }
    }

    // The following is the code that you will modify
    void print_matrix_int(int **matrix, int row, int col)
    {
        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                cout << matrix[i][j] << " ";
            }
            cout << endl;
        }
    }

    #endif#include <iostream>
    #include <cmath>
    using namespace std;

    int main()
    {
        int n;
        cin >> n;

        int *a = new int[n];

        for (int i = 0; i < n; i++)
        {
            cin >> a[i];
        }

        int *b = new int[n];

        for (int i = 0; i < n; i++)
        {
            b[i] = a[i];
        }

        delete[] a;

        int *c = new int[n];
        int *d = new int[n];

        for (int i = 0; i < n; i++)
        {
            c[i] = b[i] + d[i];
        }

        delete[] b;
        delete[] d;

        for (int i = 0; i < n; i++)
        {
            cout << c[i] << endl;
        }
        delete[] c;

        return 0;
    }#include <iostream>
    #include <cmath>
    using namespace std;

    float f1(int n)
    {
        float sum = 0.0;
        for (int i = 1; i <= n; i++)
        {
            sum += 1.0 / (float)i;
        }
        return sum;
    }

    float f2(int n)
    {
        float sum = 0.0;
        for (int i = 1; i <= n; i++)
        {
            sum += (float)(i % 2) / (float)i;
        }
        return sum;
    }

    int main()
    {
        int n;
        cin >> n;

        float e1, e2;
        e1 = f1(n);
        e2 = f2(n);

        cout << "e1: " << e1 << endl;
        cout << "e2: " << e2 << endl;

        return 0;
    }#include <iostream>
    using namespace std;

    int main()
    {
        int a[3][3];
        int b[3][3];

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cin >> a[i][j];
            }
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cin >> b[i][j];
            }
        }

        int c[3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                c[i][j] = a[i][j] * b[i][j];
            }
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                cout << c[i][j] << " ";
            }
            cout << endl;
        }
    }#include <iostream>
    using namespace std;

    void print_array(int *array, int size)
    {
        for (int i =
- code: |-
    ```
    module
- code: "--- a/3.31/example1.sv\n+++ b/3.31/example1.sv\n@@ -5,7 +5,7 @@\n   logic\
    \ [3:0] sum;\n   always_ff @(posedge clk) begin\n     if (di) begin\n-      reg\
    \ [3:0] a, b;\n+      logic [3:0] a, b;\n       a = b;\n     end\n   end\n@@ -15,7\
    \ +15,7 @@\n   assign sum = a + b;\n endmodule\n \n-module Testbench(input clk,\
    \ input [3:0] di, output [3:0] sum);\n+module Testbench(input clk, input [3:0]\
    \ di, output [3:0] sum);\n   reg [3:0] a, b, c;\n   initial begin\n     a = 1'b1;\n\
    @@ -28,7 +28,7 @@\n     #9;\n   end\n   initial #10;\n-  logic [3:0] d;\n+  logic\
    \ [3:0] d;\n   always_ff @(posedge clk) begin\n     if (di) begin\n       d <=\
    \ #1 a + b + c;\n\n### Expected Behavior:\nSystemVerilog compatibility is not\
    \ enforced.\n### Actual Behavior:\nIn this case, the code fails to compile because\
    \ it uses reg instead of logic.\n### SystemVerilog Code:\n--- a/3.31/example1.sv\n\
    +++ b/3.31/example1.sv\n@@ -5,7 +5,7 @@\n   logic [3:0] sum;\n   always_ff @(posedge\
    \ clk) begin\n     if (di) begin\n-      reg [3:0] a, b;\n+      logic [3:0] a,\
    \ b;\n       a = b;\n     end\n   end\n@@ -15,7 +15,7 @@\n   assign sum = a +\
    \ b;\n endmodule\n \n-module Testbench(input clk, input [3:0] di, output [3:0]\
    \ sum);\n+module Testbench(input clk, input [3:0] di, output [3:0] sum);\n   reg\
    \ [3:0] a, b, c;\n   initial begin\n     a = 1'b1;\n\n\n### Steps to Reproduce\
    \ the Problem:\nRun the included testbench.\n### Expected Result:\nProgram should\
    \ compile.\n### Actual Result:\nProgram fails to compile.\n\n### Extra Information\
    \ & Screenshots:\nThis is a valid test case.  It is possible to run this code\
    \ in SystemVerilog and Verilog, as shown below.\n\nNote:  I am currently working\
    \ on other test cases.\n/3.31/example2.c\n#include <stdio.h>\n#include <string.h>\n\
    #include <stdlib.h>\n#include <stdint.h>\n\nint main() {\n  char *s = \"Hello\"\
    ;\n  char *t = \"World\";\n  char *u = malloc(strlen(s) + strlen(t) + 1);\n  strcpy(u,\
    \ s);\n  strcat(u, t);\n  printf(\"%s\\n\", u);\n\n  return 0;\n}\nr.\n\nIf you\
    \ are using a Windows machine with Mingw-w64/MSYS2, there is a script file for\
    \ getting everything working.\n```\n/cygdrive/c/Users/YourUser/Documents/tools/Mingw-w64/MSYS2/msys2_shell.cmd\n\
    ```\n\n## Compiling\nTo compile a C source file, use the following:\n```\ngcc\
    \ -O3 -o your-program-name.exe your-source-file.c\n```\n\n## Sample Program\n\
    ```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  char *s = \"Hello\"\
    ;\n  char *t = \"World\";\n  char *u = malloc(strlen(s) + strlen(t) + 1);\n  strcpy(u,\
    \ s);\n  strcat(u, t);\n  printf(\"%s\\n\", u);\n\n  return 0;\n}\n```\n\n## Running\n\
    ```\n./your-program-name.exe\n```\n\n### Results\n```\nHello World\n```\n\n##\
    \ Issues\n* You may need to change the include paths.\n/README.md\n# SystemVerilog\
    \ vs C\n\nHere I will be compiling and running C code in SystemVerilog and comparing\
    \ the results.\n\n## Pre-Requisites\n\nMake sure you have:\n* [Verilator](https://www.veripool.org/wiki/verilator)\n\
    * [GTKWave](https://github.com/gtkwave/gtkwave)\n* [Mingw-w64/MSYS2](https://www.msys2.org/)\n\
    * [Icarus Verilog](https://gitlab.com/icarus-verilog/icarus-verilog)\n\n### Getting\
    \ Started\n\nStart by cloning the repo:\n```\ngit clone https://github.com/briancwelch/systemverilog-vs-c.git\n\
    ```\n\n#### Mingw-w64/MSYS2\n\nI prefer to use MSYS2 for Windows.  In this directory\
    \ is a script file for getting everything working.  If you would like to use a\
    \ different C compiler, you will need to change the path to gcc in the script.\
    \  The script also includes a link to the Verilator installation folde/3.31/example3.c\n\
    #include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  int *x = malloc(sizeof(int));\n\
    \  *x = 5;\n  int *y = malloc(sizeof(int));\n  *y = 3;\n  int *z = malloc(sizeof(int));\n\
    \  *z = *x * *y;\n  printf(\"%d\\n\", *z);\n  return 0;\n}"
- code: |-
    module Problem5(input [3:0] a, b, output [3:0] s, output [3:0] r);
      assign s = b & a;
      assign r = a - 1;
    endmodule
    ```
- code: "// Verilog code for Problem 11\nmodule MSI(\n    input clock, reset,\n  \
    \  input [8:0] A, B,\n    output logic [7:0] S,\n    output logic C\n);\n    Full_Subtractor_with_Borrow\
    \ FSB1(.A(B),.B(A),.Cin(C),.Sum(S),.Carry(Cout)); // Instantiate the full-subtractor\
    \ module\n    Full_Adder FA3(.A(A),.B(S),.Cin(Cout),.Sum(C),.Cout(Cout)); // Instantiate\
    \ the full-adder module\n    assign C = Cout;\nendmodule\n/FinalCode/final.py\n\
    from sympy import FiniteSet, ProductSet\nfrom sympy.abc import a, b, n\nfrom veriloggen\
    \ import *\n\nclass full_adder_128(object):\n\tdef __init__(self):\n\t\tself.v\
    \ = VerilogGenerator()\n\t\tself.v.entity(\"Full_Adder\", [(\"A\", \"logic[7:0]\"\
    , In), (\"B\", \"logic[7:0]\", In), (\"C_in\", \"logic[7:0]\", In), (\"S_out\"\
    , \"logic[7:0]\", Out), (\"Cout\", \"logic\", Out)])\n\tdef build(self):\n\t\t\
    self.v.code(\"\")\n\t\tself.v.code(\"module Full_Adder #(parameter WIDTH = 8)\
    \ (\\n\\\n\t\t\tinput A,\\n\\\n\t\t\tinput B,\\n\\\n\t\t\tinput C_in,\\n\\\n\t\
    \t\toutput reg [WIDTH-1:0] S_out,\\n\\\n\t\t\toutput reg Cout\\n\\\n\t\t);\\n\\\
    \n\t\twire [WIDTH-1:0] Sb = A ^ B;\\n\\\n\t\twire [WIDTH-1:0] Cb = A & B;\\n\\\
    \n\t\tassign S_out = Sb;\\n\\\n\t\tassign Cout = Cout | Cb;\\n\\\n\t\tendmodule\"\
    )\n\t\tself.v.end_entity()\n\nclass full_adder_8(object):\n\tdef __init__(self):\n\
    \t\tself.v = VerilogGenerator()\n\t\tself.v.entity(\"Full_Adder\", [(\"A\", \"\
    logic[7:0]\", In), (\"B\", \"logic[7:0]\", In), (\"C_in\", \"logic\", In), (\"\
    S_out\", \"logic[7:0]\", Out), (\"Cout\", \"logic\", Out)])\n\tdef build(self):\n\
    \t\tself.v.code(\"\")\n\t\tself.v.code(\"module Full_Adder (\\n\\\n\t\t\tinput\
    \ A,\\n\\\n\t\t\tinput B,\\n\\\n\t\t\tinput C_in,\\n\\"
- code: "// Verilog code for Problem 7\nmodule Full_Adder(\n    input A, B, Cin,\n\
    \    output logic [7:0] Sum, logic Cout\n);\n    Half_Adder ha1(A,B,Sum,Carry);\n\
    \    Half_Adder ha2(Sum,Cin,Sum,Cout);\n    assign Cout = Carry;\nendmodule\n\
    05_2013/2013/05/27/verilog-code-for-an-integrated-circuit-adder-subtractor-using-full-adder-and-half-adder-modules/\n\
    # Verilog-Code-for-Circuit-Adder-Subtractor\nA verilog code for an integrated\
    \ circuit adder and subtractor using full adder and half adder modules.\n\nThe\
    \ circuit diagram can be found here:\nhttp://www.electronicdesign.com/sites/default/files/1all:\r\
    \n\tiverilog -o adder_subtractor *.v\r\n\t./adder_subtractor\r\n\r\nclean:\r\n\
    \trm -rf adder_subtractor *.vcd"
- code: |-
    // Verilog code for Problem 5
    module Logic_7_Segment_Decoder(
        input [7:0] a,
        input [1:0] b,
        output logic[11:0] q
    );
        always @ (*) begin
            case (b)
                0: begin // For 0
                    q[0] = 1;
                    q[1] =
- code: |-
    // Verilog code for Problem 5
    module Half
- code: "module Full_Adder_Chain(\n    input A, B, Cin,\n    output logic [15:0] S,\
    \ Cin_out\n);\n    reg [15:0] Sum, Cin_out;\n    Half_Adder HA_1 (A, B, Sum, C1);\
    \    // Sum = A ^ B, Cin = C1\n    Half_Adder HA_2 (C1, Sum, Sum, Cin); // Sum\
    \ = Sum ^ C1, Cin = Cin\n    Half_Adder HA_3 (Cin, Sum, Sum, Cin_out); // Sum\
    \ = Sum ^ Cin, Cin_out = Cin\nendmodule\n// End of Verilog code for Problem 8\n\
    /ECE 160 Final Project/Code/ECE160_Final_Project.py\n\"\"\"\nECE 160 Final Project\n\
    \"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef R_to_K(R):\n\
    \    \"\"\"\n    Convert resistance to conductance.\n    \n    R: resistance (float)\n\
    \    \"\"\"\n    K = np.sqrt(R)\n    return K\n\ndef K_to_R(K):\n    \"\"\"\n\
    \    Convert conductance to resistance.\n    \n    K: conductance (float)\n  \
    \  \"\"\"\n    R = 1 / (K ** 2)\n    return R\n\ndef R_to_S(R):\n    \"\"\"\n\
    \    Convert resistance to admittance.\n    \n    R: resistance (float)\n    \"\
    \"\"\n    S = 1 / R\n    return S\n\ndef S_to_R(S):\n    \"\"\"\n    Convert admittance\
    \ to resistance.\n    \n    S: admittance (float)\n    \"\"\"\n    R = 1 / S\n\
    \    return R\n\ndef R_to_Z(R):\n    \"\"\"\n    Convert resistance to impedance.\n\
    \    \n    R: resistance (float)\n    \"\"\"\n    Z = np.sqrt(R)\n    return Z\n\
    \ndef Z_to_R(Z):\n    \"\"\"\n    Convert impedance to resistance.\n    \n   \
    \ Z: impedance (float)\n    \"\"\"\n    R = Z ** 2\n    return R\n\ndef R_to_Y(R):\n\
    \    \"\"\"\n    Convert resistance to susceptance.\n    \n    R: resistance (float)\n\
    \    \"\"\"\n    Y = 1 / R\n    return Y\n\ndef Y_to_R(Y):\n    \"\"\"\n    Convert\
    \ susceptance to resistance.\n    \n    Y: susceptance (float)\n    \"\"\"\n \
    \   R = 1 / Y\n    return R\n\ndef Z_to_S(Z):\n    \"\"\"\n    Convert impedance\
    \ to admittance.\n    \n    Z: impedance (float)\n    \"\"\"\n    S = 1 / Z\n\
    \    return S\n\ndef S_to_Z(S):\n    \"\"\"\n    Convert admittance to impedance.\n\
    \    \n    S: admittance (float)\n    \"\"\"\n    Z = 1 / S\n    return Z\n\n\
    def Z_to_Y(Z):\n    \"\"\"\n    Convert impedance to susceptance.\n    \n    Z:\
    \ impedance (float)\n    \"\"\"\n    Y = Z ** -2\n    return Y\n\ndef Y_to_Z(Y):\n\
    \    \"\"\"\n    Convert susceptance to impedance.\n    \n    Y: susceptance (float)\n\
    \    \"\"\"\n    Z = Y ** -1\n    return Z\n\ndef S_to_Y(S):\n    \"\"\"\n   \
    \ Convert admittance to susceptance.\n    \n    S: admittance (float)\n    \"\"\
    \"\n    Y = 1 / S\n    return Y\n\ndef Y_to_S(Y):\n    \"\"\"\n    Convert susceptance\
    \ to admittance.\n    \n    Y: susceptance (float)\n    \"\"\"\n    S = 1 / Y\n\
    \    return S\n\ndef Y_to_V(Y):\n    \"\"\"\n    Convert susceptance to voltage.\n\
    \    \n    Y: susceptance (float)\n    \"\"\"\n    V = 1 / Y\n    return V\n\n\
    def V_to_Y(V):\n    \"\"\"\n    Convert voltage to susceptance.\n    \n    V:\
    \ voltage (float)\n    \"\"\"\n    Y = 1 / V\n    return Y\n\nif __name__ == \"\
    __main__\":\n    # Problem 1: S & Z\n    Z = 31 * 10 ** 9\n    Z = Z_to_S(Z)\n\
    \    S = Z ** -1\n    print(\"Problem 1: S & Z\")\n    print(\"Z = {:.4f} Ohms\"\
    .format(Z))\n    print(\"S = {:.4e} S\".format(S))\n    print(\"\\n\")\n\n   \
    \ # Problem 2: R & Y\n    Y = 3 * 10 ** 3\n    Y = Y_to_R(Y)\n    R = 1 / Y\n\
    \    print(\"Problem 2: R & Y\")\n    print(\"Y = {:.4f} Ohms\".format(Y))\n \
    \   print(\"R = {:.4f} Ohms\".format(R))\n    print(\"\\n\")\n\n    # Problem\
    \ 3:\n    # 1) R = R_to_K(125)\n    # 2) R = R_to_S(125)\n    # 3) R = R_to_Z(125)\n\
    \    # 4) R = R_to_Y(125)\n    R = 125\n    R = R_to_K(R)\n    print(\"Problem\
    \ 3: R\")\n    print"
- code: "module Half_Adder(\n    input logic A, B,\n    output logic Sum, Carry\n\
    );\n    assign Sum = A ^ B;\n    assign Carry = A & B;\nendmodule\n### Input File:\n\
    input.v\n### Modified Input File:\n[Verilog]\nmodule Half_Adder(\n    input A,\
    \ B,\n    output Sum, Carry\n);\n    assign Sum = A ^ B;\n    assign Carry = A\
    \ & B;\nendmodule\n\n### Output File:\noutput.v\n### Modified Output File:\n[Verilog]\n\
    module Half_Adder(\n    input logic A, B,\n    output logic [7:0] Sum, Carry\n\
    );\n    assign Sum = A ^ B;\n    assign Carry = A & B;\nendmodule\n\n### Output\
    \ File:\noutput_tb.v\n### Modified Output File:\n[Verilog]\nmodule Half_Adder_tb;\n\
    \    reg A = 0;\n    reg B = 0;\n    reg Sum = 0;\n    reg Carry = 0;\n    Half_Adder\
    \ half_adder (\n       .A(A),\n       .B(B),\n       .Sum(Sum),\n       .Carry(Carry)\n\
    \    );\n    initial begin\n        A = 0;\n        B = 1;\n        #20\n    \
    \    A = 1;\n        B = 0;\n        #20\n        A = 0;\n        B = 0;\n   \
    \     #20\n        A = 0;\n        B = 0;\n    end\nendmodule\n### Makefile:\n\
    Makefile\n### Modified Makefile:\nVERILOG_FILES = input.v\n\nall: $(VERILOG_FILES)\n\
    \tiverilog -o output.vha $(VERILOG_FILES)\n\tvvp output.vha\n\nclean:\n\trm -rf\
    \ *.vho *.vvp *.vda *.do *.log *.wlf *.vlog\n\nclean_verilog:\n\trm -rf *.v\n\n\
    clean_output:\n\trm -rf output.vha output.v output_tb.v\n\nclean_all: clean_verilog\
    \ clean_output\n/assignment1/v1/Makefile\nall:\n\tiver\n\nclean:\n\trm -rf output.vha\
    \ output.v output_tb.v\n\nclean_verilog:\n\trm -rf *.v\n\nclean_output:\n\trm\
    \ -rf output.vha output.v\n\nclean_all: clean_verilog clean_output\nilog -o output.vha\
    \ input.v\n\tvvp output.vha\n\nclean_verilog:\n\trm -rf *.v/README.md\n# EEE1027\n\
    All my source code and coursework for Embedded System Programming (EEE1027-02)\
    \ at NTU, Taiwan University.\n\n## Course Description\n\n> An introduction to\
    \ the fundamentals of signal and data processing, along with the principles of\
    \ embedded system design and application software. Topics include digital logic\
    \ design, Verilog and VHDL languages, software development tools, and system design\
    \ and verification.\n\n## Course Schedule\n\n|Week|Date|Topic|Lecture|Lab|\n|-|----|-|-|-|\n\
    |1.1|2020/08/31|[Part 1. Introduction](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v1/README.md)|0831-001\
    \ - [Introduction to Logic and Fundamental Digital Design](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L1.pdf)|-|\n\
    |1.2|2020/09/01|[Part 2. Logic Design](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v2/README.md)|0901-001\
    \ - [Logic Design](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L2.pdf)|1015-012\
    \ - [Logic Design: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L2.pdf)|\n\
    |[1.3](https://github.com/zahn-s/EEE1027/tree/main/assignment1/v3)|2020/09/02|[Part\
    \ 3. Sequential Logic](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v3/README.md)|0902-001\
    \ - [Sequential Logic](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L3.pdf)|1015-012\
    \ - [Logic Design: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L2.pdf)|\n\
    |1.4|2020/09/03|[Part 4. Combinational Circuits](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v4/README.md)|0903-001\
    \ - [Combinational Circuits](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L4.pdf)|1015-012\
    \ - [Logic Design: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L2.pdf)|\n\
    |1.5|2020/09/06|[Part 5. Sequential Circuits](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v5/README.md)|0906-001\
    \ - [Sequential Circuits](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L5.pdf)|1015-012\
    \ - [Logic Design: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L2.pdf)|\n\
    |1.6|2020/09/07|[Part 1. Microprocessor Systems](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v6/README.md)|0907-001\
    \ - [Microprocessor Systems](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L6.pdf)|1014-012\
    \ - [Microprocessor Systems: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L6.pdf)|\n\
    |1.7|2020/09/08|[Part 2. Digital Design](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v7/README.md)|0908-001\
    \ - [Digital Design](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L7.pdf)|1014-012\
    \ - [Microprocessor Systems: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L6.pdf)|\n\
    |1.8|2020/09/09|[Part 3. Digital Systems](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v8/README.md)|0909-001\
    \ - [Digital Systems](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L8.pdf)|1014-012\
    \ - [Microprocessor Systems: Lab](https://ntu-csie.github.io/2020-fall-01-embedded-systems/labs/L6.pdf)|\n\
    |1.9|2020/09/10|[Part 4. FPGA Design](https://github.com/zahn-s/EEE1027/blob/main/assignment1/v9/README.md)|0910-001\
    \ - [FPGA Design](https://ntu-csie.github.io/2020-fall-01-embedded-systems/lectures/L9.pdf)|1014-012\
    \ - [Microprocessor Systems: Lab](https://ntu"
- code: "module Half_Adder(\n    input logic [1:0] A, B,\n    output logic [1:0] Sum,\
    \ Carry\n);\n    assign Sum = A ^ B;\n    assign Carry = A & B;\nendmodule\n###\
    \ Output for Problem 5:\n// Half Adder Testbench \nmodule Half_Adder_tb();\n \
    \   // Inputs\n    logic [1:0] A = 1'b0;\n    logic [1:0] B = 1'b0;\n\n    //\
    \ Outputs\n    logic [1:0] Sum;\n    logic [1:0] Carry;\n\n    // Instantiate\
    \ the Module\n    Half_Adder half_adder (\n       .A(A),.B(B),.Sum(Sum),.Carry(Carry)\n\
    \    );\n\n    initial begin\n        $dumpfile(\"Half_Adder_tb.vcd\");\n    \
    \    $dumpvars(0, Half_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 6:\n// Half Adder Testbench\nmodule Half_Adder_tb();\n    // Inputs\n    logic\
    \ A, B;\n\n    // Outputs\n    logic Sum, Carry;\n\n    // Instantiate the Module\n\
    \    Half_Adder half_adder (\n       .A(A),.B(B),.Sum(Sum),.Carry(Carry)\n   \
    \ );\n\n    initial begin\n        $dumpfile(\"Half_Adder_tb.vcd\");\n       \
    \ $dumpvars(0, Half_Adder_tb);\n    end\nendmodule\n### Output for Problem 7:\n\
    // Full Adder Testbench\nmodule Full_Adder_tb();\n    // Inputs\n    logic [1:0]\
    \ A, B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpfile(\"Full_Adder_tb.vcd\");\n    \
    \    $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 8:\n// Full Adder Testbench\nmodule Full_Adder_tb(\n    logic [1:0] A = 1'b0,\
    \ B = 1'b0, Cin = 1'b0,\n    logic [1:0] Sum, Cout\n);\n    // Inputs\n    logic\
    \ [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpfile(\"Full_Adder_tb.vcd\");\n    \
    \    $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 9:\n// Full Adder Testbench\nmodule Full_Adder_tb(\n    logic A = 1'b0, B =\
    \ 1'b0, Cin = 1'b0,\n    logic Sum, Cout\n);\n    // Inputs\n    logic [1:0] A,\
    \ B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpfile(\"Full_Adder_tb.vcd\");\n    \
    \    $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 10:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n    // Inputs\n    logic\
    \ [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n      .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpvars(0, Full_Adder_tb);\n    end\n\
    endmodule\n### Output for Problem 11:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n\
    \    // Inputs\n    logic [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0]\
    \ Sum, Cout;\n\n    // Instantiate the Module\n    Full_Adder full_adder (\n \
    \      .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n    );\n\n    initial begin\n\
    \        $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 12:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n    // Inputs\n    logic\
    \ [1:0] A = 1'b0, B = 1'b0, Cin = 1'b0;\n\n    // Outputs\n    logic [1:0] Sum,\
    \ Cout;\n\n    // Instantiate the Module\n    Full_Adder full_adder (\n      \
    \ .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n    );\n\n    initial begin\n \
    \       $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 13:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n    // Inputs\n    logic\
    \ [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n       .A()A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpvars(0, Full_Adder_tb);\n    end\n\
    endmodule\n### Output for Problem 14:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n\
    \    // Inputs\n    logic [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0]\
    \ Sum, Cout;\n\n    // Instantiate the Module\n    Full_Adder full_adder (\n \
    \      .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n    );\n\n    initial begin\n\
    \        $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 15:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n    // Inputs\n    logic\
    \ A, B, Cin;\n\n    // Outputs\n    logic Sum, Cout;\n\n    // Instantiate the\
    \ Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpvars(0, Full_Adder_tb);\n    end\n\
    endmodule\n### Output for Problem 16:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n\
    \    // Inputs\n    logic A, B, Cin;\n\n    // Outputs\n    logic Sum, Cout;\n\
    \n    // Instantiate the Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpvars(0, Full_Adder_tb);\n    end\n\
    endmodule\n### Output for Problem 17:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n\
    \    // Inputs\n    logic [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0]\
    \ Sum, Cout;\n\n    // Instantiate the Module\n    Full_Adder full_adder (\n \
    \      .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n    );\n\n    initial begin\n\
    \        $dumpvars(0, Full_Adder_tb);\n    end\nendmodule\n### Output for Problem\
    \ 18:\n// Full Adder Testbench\nmodule Full_Adder_tb;\n    // Inputs\n    logic\
    \ [1:0] A, B, Cin;\n\n    // Outputs\n    logic [1:0] Sum, Cout;\n\n    // Instantiate\
    \ the Module\n    Full_Adder full_adder (\n       .A(A),.B(B),.Cin(Cin),.Sum(Sum),.Cout(Cout)\n\
    \    );\n\n    initial begin\n        $dumpvars(0, Full_Adder_tb);\n    end\n\
    endmodule\n/Labs/Lab4/Test Code/Lab4_1_Example.cpp\n#include <iostream>\n#include\
    \ \"Lab4_1.h\"\n\nusing namespace std;\n\nint main(int argc, char const *argv[])\n\
    {\n    int n;\n    // int N = 10;\n    cout << \"Enter the value of n: \";\n \
    \   cin >> n;\n    cout << \"The factorial of your input is: \" << factor"
- code: |-
    // Full_Adder.v
    // Verilog code for Problem 11
    module Full_Adder(
        input logic [7:0] A, B, logic Cin,
        output logic [7:0] Sum, logic Cout
    );
        Half_Adder HA
- code: "module Half_Adder_V2(\n    input logic [1:0] A, B,\n    output logic [1:0]\
    \ Sum, Carry\n);\n    reg logic [1:0] Sum, Carry;\n    assign Sum = A + B;\n \
    \   assign Carry = A & B;\nendmodule\n### Testbench Code:\n`timescale 1ns / 1ps\n\
    module Half_Adder_V2(\n    input A, B,\n    output Sum, Carry\n);\n    reg [7:0]\
    \ Sum, Carry;\n    assign Sum = A + B;\n    assign Carry = A & B;\nendmodule\n\
    `timescale 1ns\n\nmodule half_adder_v2_tb;\n\treg \tA[2:0], B[2:0], Sum[8:0],\
    \ Carry[8:0], Carry_Expected[8:0];\n\n\talways begin\n\t\tA = 'b00;\n\t\tB = 'b00;\n\
    \t\tSum = 'b00;\n\t\tCarry = 'b00;\n\t\tCarry_Expected = 'b00;\n\t\t#20\n\tend\n\
    \n\talways@(A or B) begin\n\t\tA = 1;\n\t\t#20\n\tend\n\n\talways@(A or B) begin\n\
    \t\tB = 1;\n\t\t#20\n\tend\n\n\tinitial begin\n\t\t$display(\"Running Testbench\
    \ for Half Adder!\");\n\t\t#150\n\t\t$display(Sum, Carry, Carry_Expected);\n\t\
    \t#100\n\n\t\t// Test 0: A and B are zero, Sum and Carry are zero\n\t\tA = 'b00;\n\
    \t\tB = 'b00;\n\t\tSum = 'b00;\n\t\tCarry = 'b00;\n\t\tCarry_Expected = 'b00;\n\
    \t\t#100\n\t\t$display(Sum, Carry, Carry_Expected);\n\t\t#100\n\n\t\t// Test 1:\
    \ A equals 1, B equals 0, Sum equals 1, Carry equals 0\n\t\tA = 'b00;\n\t\tB =\
    \ 'b01;\n\t\tSum = 'b01;\n\t\tCarry = 'b00;\n\t\tCarry_Expected = 'b00;\n\t\t\
    #100\n\t\t$display(Sum, Carry, Carry_Expected);\n\t\t#100\n\n\t\t// Test 2: A\
    \ equals 1, B equals 1, Sum equals 0, Carry equals 1\n\t\tA = 'b01;\n\t\tB = 'b01;\n\
    \t\tSum = 'b00;\n\t\tCarry = 'b01;\n\t\tCarry_Expected = 'b01;\n\t\t#100\n\t\t\
    $display(Sum, Carry, Carry_Expected);\n\t\t#500\n\n\t\t// Test 3: A equals 0,\
    \ B equals 1, Sum equals 1, Carry equals 1\n\t\tA = 'b10;\n\t\tB = 'b01;\n\t\t\
    Sum = 'b01;\n\t\tCarry = 'b01;\n\t\tCarry_Expected = 'b01;\n\t\t#100\n\t\t$display(Sum,\
    \ Carry, Carry_Expected);\n\t\t#500\n\n\t\t// Test 3: A equals 0, B equals 0,\
    \ Sum equals 0, Carry equals 0\n\t\tA = 'b10;\n\t\tB = 'b10;\n\t\tSum = 'b10;\n\
    \t\tCarry = 'b10;\n\t\tCarry_Expected = 'b10;\n\t\t#100\n\t\t$display(Sum, Carry,\
    \ Carry_Expected);\n\t\t#500\n\n\t\t$finish;\n\tend\n\nendmodule\n\n### Output:\n\
    Running Testbench for Half Adder!\n0 0 0\n0 1 0\n1 0 0\n1 1 0\n1 1 1\n0 0 0\n\n\
    \n### Discussion:\nWith the newer version, it worked with the tests we had before.\n\
    \nThe testbench was also changed slightly. I added a comment in the code saying\
    \ that it would use the older version, while still maintaining the new version\
    \ at the end of the code.\n\n###"
- code: "```VHalf_Adder.v\nmodule Half_Adder(\n    input A, B,\n    output logic[7:0]\
    \ Sum, logic[7:0] Carry\n);\n    assign Sum = A ^ B;\n    assign Carry = A & B;\n\
    endmodule\n```\n\n### Output Results:\n```Console\n$ verilator Half_Adder_tb.v\
    \ Half_Adder.v\n$ make -f VHalf_Adder_tb.mk\n$./VHalf_Adder_tb\n```\n\n## Screenshot\
    \ 1\n\n![Screenshot 1](screenshot/screenshot1.png)\n\n## Screenshot 2\n\n![Screenshot\
    \ 2](screenshot/screenshot2.png)\n\n## Screenshot 3\n\n![Screenshot 3](screenshot/screenshot3.png)\n\
    \n## Screenshot 4\n\n![Screenshot 4](screenshot/screenshot4.png)\n\n## Screenshot\
    \ 5\n\n![Screenshot 5](screenshot/screenshot5.png)\n\n## Screenshot 6\n\n![Screenshot\
    \ 6](screenshot/screenshot6.png)\n/Computer Architecture/hw3/README.md\n# Computer\
    \ Architecture - Homework 3\n\n## \n\n## I pledge my honor that I have abided\
    \ by the Stevens Honor System.\n\n## Verilog Code\n```Verilog\nmodule full_adder(\n\
    \  input A, B, C,\n  output [1:0] S,\n  output [3"
- code: |-
    <img src="Images/alu8_4bit_inputs.png" width="700" height="600">

    ## ALU 9
    <img src="Images/alu9.png" width="700" height="600">
    ### Base Verilog Code:
    module tst_alu9();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00;
- code: |-
    ```

    // alu_1.v

    module alu_1(c,co,a,b,f,cci);
    reg [3:0]a,b; reg [1:0]f; reg cci;

    wire [3:0]d;

    // Addittion
    assign d=a+b;

    // Multiplication
    assign d=a*b;

    // Comparision
    assign c=a==b;

    // Condition Branching
    assign co=a>b;

    // Clear Condition (Clears any pending condition)
    assign c=cci;

    endmodule

    ```

    ### Testing Results:

    ```

    // Input/Output stimulus
    module tst_alu2();
      reg [3:0]a,b; reg [1:0] f2; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f2,cci); // Instantiate ALU
      initial begin cci=1'b0; f2=2'b00; a=4'h0; b=4'h1; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule


    // Input/Output stimulus
    module tst_alu3();
      reg [3:0]a,b; reg [1:0] f3; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f3,cci); // Instantiate ALU
      initial begin cci=1'b0; f3=2'b00; a=4'h0; b=4'h2; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu4();
      reg [3:0]a,b,f4; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f4,cci); // Instantiate ALU
      initial begin cci=1'b0; f4=2'b00; a=4'h1; b=4'h2; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu5();
      reg [3:0]a,b,f5; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f5,cci); // Instantiate ALU
      initial begin cci=1'b0; f5=2'b01; a=4'h1; b=4'h1; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu6();
      reg [3:0]a,b,f6; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f6,cci); // Instantiate ALU
      initial begin cci=1'b0; f6=2'b10; a=4'h1; b=4'h1; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu7();
      reg [3:0]a,b,f7; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f7,cci); // Instantiate ALU
      initial begin cci=1'b0; f7=2'b11; a=4'h1; b=4'h1; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu8();
      reg [3:0]a,b,f8; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f8,cci); // Instantiate ALU
      initial begin cci=1'b0; f8=2'b00; a=4'h1; b=4'h9; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu9();
      reg [3:0]a,b,f9; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f9,cci); // Instantiate ALU
      initial begin cci=1'b0; f9=2'b00; a=4'h0; b=4'h9; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu10();
      reg [3:0]a,b,f10; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f10,cci); // Instantiate ALU
      initial begin cci=1'b0; f10=2'b01; a=4'h0; b=4'h9; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu11();
      reg [3:0]a,b,f11; reg cci; wire [3:0]d; wire co;
      alu_1 aa(d,co,a,b,f11,cci); // Instantiate ALU
      initial begin cci=1'b0; f11=2'b10; a=4'h0; b=4'h9; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule

    // Input/Output stimulus
    module tst_alu12();
      reg [3:0]a,b,f12; reg cci; wire [3:0]d;
- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=15'b0000000000000000; b=15'b0000000000000000; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    /000_Testbench_code/03_BasicVerilog/04_MultiBit_CombinationalLogic/alu_2.cpp
    #include "alu_2.h"
    #include <verilated.h>
    #include <iostream>

    vluint64_t alu_2::time = 0;

    //Constructor
    alu_2::alu_2(int a, int b,int f, int &d, int &co, char &cci)
    {
        //Assign inputs
        A = a;
        B = b;
        F=f;
        //Assign Outputs
        d = 0;
        co = 0;
        cci = '0';
    }

    //Function to update the current state of register file
    void alu_2::update()
    {
        //The current state of register file
        d = A & B;
        co =!d;
    }

    //Reset the testbench
    void alu_2::reset()
    {
        //Reset the clock
        clock = 0;
        //Reset the register file
        d = 0;
        co = 0;
        cci = '0';
    }

    //Function to run the testbench
    void alu_2::eval()
    {
        //If clock is low
        if (clock == 0)
        {
            //Assign the next value of clock
            clock = 1;
            //Increment the time
            time = time + 1;
            //Update the register file
            update();
        }
        //If clock is high
        else
        {
            //Assign the next value of clock
            clock = 0;
            cci = '0';
        }
        //If (F==0) then increment time
        if (F == 0)
        {
            time++;
            //Update the register file
            update();
        }
        //If (F==1) then decrement time
        if (F == 1)
        {
            time--;
            //Update the register file
            update();
        }
        //Update the display at every 10 time steps
        if (time % 10 == 0)
        {
            cout << "time = " << time << " A = " << A << " B = " << B << " f = " << F << " d = " << d << " co = " << co << " cci = " << cci << endl;
        }
        //Advance the state of the testbench
        vluint64_t delay = 10;
        vlThreadDelay(delay);
    }

    //Function to run the testbench for a number of cycles
    void alu_2::run(int cycles)
    {
        //Run the testbench for 100 cycles
        for (int i = 1; i <= cycles; i++)
        {
            //Advance the state of the testbench
            eval();
        }
    }
    //Function to run the testbench for a specified number of cycles
    void alu_2::run(int cycles, int a, int b, int f)
    {
        //Assign a,b,f to inputs of testbench
        this->A = a;
        this->B = b;
        this->F = f;
        //Run the testbench for 100 cycles
        for (int i = 1; i <= cycles; i++)
        {
            //Advance the state of the testbench
            eval();
        }
    }
    /000_Testbench_code/03_BasicVerilog/01_SingleBit_CombinationalLogic/alu_1.cpp
    #include "alu_1.h"
    #include <verilated.h>
    #include <iostream>

    vluint64_t alu_1::time = 0;

    //Constructor
    alu_1::alu_1(int a, int b,int f, int &d, int &co, char &cci)
    {
        //Assign inputs
        A = a;
        B = b;
        F=f;
        //Assign Outputs
        d = 0;
        co = 0;
        cci = '0';
    }

    //Function to update the current state of register file
    void alu_1::update()
    {
        //The current state of register file
        d = A & B;
        co =!d;
    }

    //Reset the testbench
    void alu_1::reset()
    {
        //Reset the clock
        clock = 0;
        //Reset the register file
        d = 0;
        co = 0;
        cci = '0';
    }

    //Function to run the testbench
    void alu_1::eval()
    {
        //If clock is low
        if (clock == 0)
        {
            //Assign the next value of clock
            clock = 1;
            //Increment the time
            time = time + 1;
            //Update the register file
            update();
        }
        //If clock is high
        else
        {
            //Assign the next value of clock
            clock = 0;
            cci = '0';
        }
        //If (F==0) then increment time
        if (F == 0)
        {
            time++;
            //Update the register file
            update();
        }
        //If (F==1) then decrement time
        if (F == 1)
        {
            time--;
            //Update the register file
            update();
        }
        //Update the display at every 10 time steps
        if (time % 10 == 0)
        {
            cout << "time = " << time << " A = " << A << " B = " << B << " f = " << F << " d = " << d << " co = " << co << " cci = " << cci << endl;
        }
        //Advance the state of the testbench
        vluint64_t delay = 10;
        vlThreadDelay(delay);
    }

    //Function to run the testbench for a number of cycles
    void alu_1::run(int cycles)
    {
        //Run the testbench for 100 cycles
        for (int i = 1; i <= cycles; i++)
        {
            //Advance the state of the testbench
            eval();
        }
    }
    //Function to run the testbench for a specified number of cycles
    void alu_1::run(int cycles, int a, int b, int f)
    {
        //Assign a,b,f to inputs of testbench
        this->A = a;
        this->B = b;
        this->F = f;
        //Run the testbench for 100 cycles
        for (int i = 1; i <= cycles; i++)
        {
            //Advance the state of the testbench
            eval();
        }
    }
    /000_Testbench_code/03_BasicVerilog/04_MultiBit_CombinationalLogic/alu_2.h
    #ifndef ALU_2_H
    #define ALU_2_H

    class alu_2
    {
    public:
        //Constructor to initialize testbench
        alu_2(int a, int b,int f, int &d, int &co, char &cci);
        //Function to reset the testbench
        void reset();
        //Function to run the testbench
        void eval();
        //Function to run the testbench for a number of cycles
        void run(int cycles);
        //Function to run the testbench for a specified number of cycles
        void run(int cycles, int a, int b, int f);

    private:
        //Function to update the current state of register file
        void update();
        //Clock input
        int clock = 0;
        //Register file
        int A;
        int B;
        int d;
        int co;
        int F;
        char cci;
        //Time
        static vluint64_t time;
    };
    #endif/000_Testbench_code/03_BasicVerilog/04_MultiBit_CombinationalLogic/alu_1.h
    #ifndef ALU_1_H
    #define ALU_1_H

    class alu_1
    {
    public:
        //Constructor to initialize testbench
        alu_1(int a, int b,int f, int &d, int &co, char &cci);
        //Function to reset the test
- code: "module alu_8bit_1();\n  input [7:0] a,b;\n  input    f;\n  output    [7:0]\
    \ d;\n  output    co;\n  reg cci;\n  wire [7:0] alu_sum;\n  assign d = alu_sum;\n\
    \  CarryAdd c0(cci,co,f);\n  alu_8bit alu(alumin8,alu_sum,a,b,f,cci);\n  initial\
    \ begin cci=1'b0; alumin8=8'h0; f=2'b00; alu_sum=8'b0; a=8'h0; b=8'h0; #30 $stop;\
    \ end\nendmodule\n![image](https://user-images.githubusercontent.com/33499623/126174685-94940a2d-a0cf-41b0-8007-e8d8d0487a2e.png)\n\
    #include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\
    #include <unistd.h>\n#include <sys/shm.h>\n#include <sys/ipc.h>\n#include <sys/wait.h>\n\
    #include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <errno.h>\n\
    #include <semaphore.h>\n#include <sys/mman.h>\n#include <time.h>\n#include <sys/time.h>\n\
    #include <pthread.h>\n#include <sys/mman.h>\n\n#define N 8\n#define SIZE (N+2)\n\
    #define PRODUCER 0\n#define CONSUMER 1\n\n\nchar buf[SIZE];\nint in=0;\nint out=0;\n\
    \nsem_t sem_empty;\nsem_t sem_full;\n\npthread_mutex_t mutex;\n\n\nvoid *producer(void\
    \ *arg){\n\tint i,index;\n  while(1){\n    //pthread_mutex_lock(&mutex);\n\t\t\
    index = in;\n\t\tin = (in+1)%N;\n\n\t\tfor(int i=0;i<strlen((char*)arg);i++){\n\
    \t\t\tbuf[index] = ((char*)arg)[i];\n\t\t\tsleep(2);\n\t\t\tindex++;\n\t\t\tindex\
    \ = index%N;\n\t\t}\n\n    //pthread_mutex_unlock(&mutex);\n\t\tsem_post(&sem_full);\n\
    \    sem_wait(&sem_empty);\n\t}\n}\n\nvoid *consumer(void *arg){\n\tint index;\n\
    \twhile(1){\n\t\tsem_wait(&sem_full"
- code: |-
    ### Base Verilog Code:
    module tst_alu5();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0
- code: "For example, the code is as follows:\nmodule tst_alu1();\n  reg [3:0]a,b;\
    \ reg[1:0] f; reg cci; wire[3:0]d; wire co;\n  alu_1 aa(d,co,a,b,f,cci); // Instantiate\
    \ ALU\n  initial begin cci=1'b0; f=2'b00; a=4'h1; b=4'h2; #30 $stop; end // Initialize\
    \ & stop\n  always begin // Apply stimulus\n  end\n  initial $monitor($time, \"\
    \ cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b \",cci,a,b,f,d,co); // Use %h\nendmodule\n\
    /Lab4/Project/Makefile\ntop?= top_alu1\ntb?= $(top)_tb\n\nVICFLAGS=-O4\n\nifdef\
    \ VICFLAGS\nCXXFLAGS=$(VICFLAGS)\nelse\nCXXFLAGS=-O0 -ggdb\nendif\n\nSRCS=$(wildcard\
    \ *.cpp *.v)\n\n%.o: %.cpp\n\t$(CXX) $(CXXFLAGS) -c $<\n\n%.o: %.v\n\tvlog $(VICFLAGS)\
    \ $<\n\nall: $(tb).bin\n\n$(tb).bin: $(tb).o $(top).o\n\t$(CXX) -o $@ $^\n\n$(top).o:\
    \ $(top).cpp\n\n%.obj: %.v\n\tvlog $(VICFLAGS) $<\n\n%.obj: %.cpp\n\t$(CXX) $(CXXFLAGS)\
    \ -c $<\n\nclean:\n\trm -f *.o $(tb).bin *~ $(top).o\n\n.PHONY: all clean\n/Lab1/Project2/test-alu1.cpp\n\
    #include <iostream>\n#include <string>\n#include <climits>\n\n#include \"alu1.h\"\
    \n\nint main(int argc, char** argv) {\n  alu1 alu1;\n  alu1.set_cci(1);\n  std::cout\
    \ << \"cci: \" << std::hex << alu1.get_cci() << std::endl;\n  alu1.set_f(0);\n\
    \  std::cout << \"f: \" << std::hex << alu1.get_f() << std::endl;\n  alu1.set_a(UINT32_MAX);\n\
    \  std::cout << \"a: \" << std::hex << alu1.get_a() << std::endl;\n  alu1.set_b(UINT32_MAX);\n\
    \  std::cout << \"b: \" << std::hex << alu1.get_b() << std::endl;\n  alu1.propagate();\n\
    \  std::cout << std::endl;\n  std::cout << \"d: \" << std::hex << alu1.get_d()\
    \ << std::endl;\n  std::cout << \"ci: \" << std::hex << alu1.get_ci() << std::endl;\n\
    \  std::cout << \"co: \" << std::hex << alu1.get_co() << std::endl;\n  alu1.set_cci(0);\n\
    \  alu1.propagate();\n  std::cout << \"cci: \" << std::hex << alu1.get_cci() <<\
    \ std::endl;\n  std::cout << \"f: \" << std::hex << alu1.get_f() << std::endl;\n\
    \  alu1.set_a(UINT32_MAX);\n  alu1.set_b(UINT32_MAX);\n  alu1.propagate();\n \
    \ std::cout << std::endl;\n  std::cout << \"d: \" << std::hex << alu1.get_d()\
    \ << std::endl;\n  std::cout << \"ci: \" << std::hex << alu1.get_ci() << std::endl;\n\
    \  std::cout << \"co: \" << std::hex << alu1.get_co() << std::endl;\n  std::cout\
    \ << std::endl;\n  alu1.set_cci(1);\n  alu1.set_a(UINT32_MAX);\n  alu1.set_b(UINT32_MAX);\n\
    \  alu1.propagate();\n  std::cout << std::endl;\n  std::cout << \"d: \" << std::hex\
    \ << alu1.get_d() << std::endl;\n  std::cout << \"ci: \" << std::hex << alu1.get_ci()\
    \ << std::endl;\n  std::cout << \"co: \" << std::hex << alu1.get_co() << std::endl;\n\
    \  alu1.set_cci(1);\n  alu1.set_a(0x1234);\n  alu1.set_b(0x5678);\n  alu1.propagate();\n\
    \  std::cout << std::endl;\n  std::cout << \"d: \" << std::hex << alu1.get_d()\
    \ << std::endl;\n  std::cout << \"ci: \" << std::hex << alu1.get_ci() << std::endl;\n\
    \  std::cout << \"co: \" << std::hex << alu1.get_co() << std::endl;\n  alu1.set_cci(0);\n\
    \  alu1.propagate();\n  std::cout << \"cci: \" << std::hex << alu1.get_cci() <<\
    \ std::endl;\n  std::cout << \"f: \" << std::hex << alu1.get_f() << std::endl;\n\
    \  alu1.set_a(0x1234);\n  alu1.set_b(0x5678);\n  alu1.set_cci(1);\n  alu1.set_f(1);\n\
    \  alu1.propagate();\n  std::cout << std::endl;\n  std::cout << \"d: \" << std::hex\
    \ << alu1.get_d() << std::endl;\n  std::cout << \"ci: \" << std::hex << alu1.get_ci()\
    \ << std::endl;\n  std::cout << \"co: \" << std::hex << alu1.get_co() << std::endl;\n\
    \  alu1.set_cci(0);\n  alu1.set_f(1);\n  alu1.set_a(0x1234);\n  alu1.set_b(0x5678);\n\
    \  alu1.set_cci(1);\n  alu1.propagate();\n  std::cout << \"cci: \" << std::hex\
    \ << alu1.get_cci() << std::endl;\n  std::cout << \"f: \" << std::hex << alu1.get_f()\
    \ << std::endl;\n  alu1.set_a(0x1234);\n  alu1.set_b(0x5678);\n  alu1.set_cci(1);\n\
    \  alu1.set_f(2);\n  alu1.propagate();\n  std::cout << std::endl;\n  std::cout\
    \ << \"d: \" << std::hex << alu1.get_d() << std::endl;\n  std::cout << \"ci: \"\
    \ << std::hex << alu1.get_ci() << std::endl;\n  std::cout << \"co: \" << std::hex\
    \ << alu1.get_co() << std::endl;\n  alu1.set_cci(0);\n  alu1.set_f(2);\n  alu1.set_a(0x1234);\n\
    \  alu1.set_b(0x5678);\n  alu1.set_cci(1);\n  alu1.propagate();\n  std::cout <<\
    \ \"cci: \" << std::hex << alu1.get_cci() << std::endl;\n  std::cout << \"f: \"\
    \ << std::hex << alu1.get_f() << std::endl;\n  return 0;\n}\n/Lab3/Project/test_alu2.cpp\n\
    #include <iostream>\n#include <string>\n#include <climits>\n#include <cstdlib>\n\
    \n#include \"alu2.h\"\n\nint main(int argc, char** argv) {\n  alu2 alu2;\n  alu2.set_cci(1);\n\
    \  std::cout << \"cci: \" << std::hex << alu2.get_cci() << std::endl;\n  alu2.set_f(0);\n\
    \  std::cout << \"f: \" << std::hex << alu2.get_f() << std::endl;\n  alu2.set_a(UINT32_MAX);\n\
    \  std::cout << \"a: \" << std::hex << alu2.get_a() << std::"
- code: module alu_6( output [3:0] d, output co,
- code: |-
    module tst_mul_reg1();
      reg[3:0]a,b,result;  reg cci;
      mul_reg1 aa (a,b,result,cci); // Instantiate Multiplier
      initial begin cci=1'b0;  a=4'b0000; b=4'b0000; #30 $stop; end // Initialize & stop
      initial $monitor($time, " cci = %b, a= %b,b = %b,result = %b,cci = %b ",cci,a,b,result,cci); // Use %b
    endmodule
    ### Results:
    ![mul_reg1.png](images/mul_reg1.png)

    ## Multi-Bit Registers (8-bit)
    ### Base Verilog Code:
    module tst_mul_reg2();
      reg[7:0]a,b,result;  reg cci;
      mul_reg2 aa (a,b,result,cci); // Instantiate Multiplier
      initial begin cci=1'b0;  a=8'h0; b=8'h0; #30 $stop; end // Initialize & stop
      initial $monitor($time, " cci = %b, a= %h,b = %h,result = %h,cci = %b ",cci,a,b,result,cci); // Use %h
    endmodule
    ### Variation Instruction:
    Replace the inputs A and B with 8-bit logic vectors and the output D with 8-bit to test multi-bit combinational logic behavior.
    ### Modified Code:
- code: |-
    module tst_alu1();
      reg [3:0]a,b; reg [1:0] f; reg cci; wire [3:0] d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    # VHDL Code:
    ### Base Verilog Code:
    module tst_alu1();
      reg [3:0]a,b; reg[1:0] f; reg cci; wire[3:0]d; wire co;
      alu_1 aa(d,co,a,b,f,cci); // Instantiate ALU
      initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end // Initialize & stop
      always begin // Apply stimulus
      end
      initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co); // Use %h
    endmodule
    ### Variation Instruction:
    Replace the inputs A and B with 4-bit logic vectors to test multi-bit combinational logic behavior.
- code: |-
    #### module tst_alu1();
    ####   reg [3:0]a,b; reg[1:0] f; reg cci;
    ####   wire[7:0] d; wire co;
    ####   alu_1 aa(d,co,a,b,f,cci);
    ####
    ####   initial begin cci=1'b0; f=2'b00; a=4'h0; b=4'h0; #30 $stop; end
    ####
    ####   always begin
    ####   end
    ####
    ####   initial $monitor($time, " cci = %b, a= %h,b = %h,f = %b,d =%h,co= %b ",cci,a,b,f,d,co);
    #### endmodule
    ####
    #### module alu_1(d,co,a,b,f,cci);
    ####   input[3:0] a,b; input[1:0] f;
    ####   output co; output[3:0] d;
    ####   wire[3:0] tmp1,tmp2,tmp1_r,tmp2_r;
    ####   reg[3:0] tmp1_r_1,tmp1_r_2,tmp1_r_3,tmp2_r_1,tmp2_r_2,tmp2_r_3;
    ####
    ####   assign tmp1 = cat(b[3:1], a[3:1]);
    ####   assign tmp2 = (a[3:1]);
    ####   assign tmp1_r = $ite(cci, tmp2, tmp1);
    ####
    ####   assign tmp2_r = $ite(f[1:0] > 0, tmp1_r, tmp2);
    ####
    ####   assign d = cat(b[3:0], tmp2_r[3:0]);
    ####   assign co = (f[1:0]==0 && a[3:0]==b[3:0]) || (f[1:0]==0 && a[3:0]!=b[3:0]) || (f[1:0]==1 && a[3:0]!=b[3:0]) || (f[1:0]==2 && a[3:0]!=b[3:0]);
    ####
    ####   always @(a,b,f) begin // Implement combinational logic for ALU1
    ####     if (f[1:0] == 0) begin
    ####       case (a[3:0], b[3:0])
    ####         4'b0000, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b0000, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b0001, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b0001, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b0010, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b0010, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b0011, 4'b0000, tmp1_r_1 <= a[3:0]; tmp1_r_2 <= a[3:0]; tmp1_r_3 <= a[3:0];
    ####         4'b0011, 4'b0001, d <= tmp1_r_3[3:0];
    ####         4'b0100, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b0100, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b0101, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b0101, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b0110, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b0110, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b0111, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b0111, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b1000, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b1000, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b1001, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b1001, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b1010, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b1010, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b1011, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b1011, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b1100, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b1100, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b1101, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b1101, 4'b0001, d <= tmp2_r[3:0];
    ####         4'b1110, 4'b0000, d <= tmp2_r[3:0];
    ####         4'b1110, 4'b0001, d <= tmp1_r[3:0];
    ####         4'b1111, 4'b0000, d <= tmp1_r[3:0];
    ####         4'b1111, 4'b0001, d <= tmp2_r[3:0];
    ####        endcase
    ####      end
    ####    end
    #### ```

    ## **Testbench**

    ### **Simple Testbench**

    ```verilog

    `timescale 1ns / 1ps
    module alu_tb;

      reg [3:0]a,b;
      reg[1:0] f;
      reg cci;

      wire co_1;
      wire[7:0] d_1;

      wire co_2;
      wire[7:0] d_2;

      wire[7:0] alu_tb_co;
      wire[7:0] alu_tb_d;

      alu_1 tb_tb1(.d_1(d_1),.co(co_1),.a(a),.b(b),.f(f),.cci(cci));

      alu_2 tb_tb2(.d_2(d_2),.co(co_2),.a(a),.b(b),.cci(cci));

      always begin;
      case(f[1:0])
      2'b00:
       case(a[3:0],b[3:0])
       4'b0000: 4'b0000, 4'b0000;
       4'b0000: d_1 <= a[3:0] + b[3:0];
       4'b0001: d_1 <= a[3:0] + b[3:0];
       4'b0010: 4'b0000, 4'b0000;
       4'b0010: d_1 <= a[3:0] + b[3:0];
       4'b0011: d_1 <= a[3:0] + b[3:0];
       4'b0100: 4'b000
- code: "module ALU_TB (\ninput wire [7:0] a,\ninput wire [7:0] b,\ninput wire [3:0]\
    \ ctrl,\noutput wire [7:0] y\n);\n\n// Instantiate the two ALU modules using the\
    \ module instantiator\n// module ALU_TB_instantiation_module();\n// Instantiate\
    \ the ALU modules with initial values\nALU sw2led2_test_inst(\n.a(a),\n.b(b),\n\
    .ctrl(ctrl),\n.y(y)\n);\n\nALU sw2led2_inst(\n.a(a),\n.b(b),\n.ctrl(ctrl),\n.y(y)\n\
    );\n// Instantiate the ALU modules with initial values\nALU_TB_instantiation_module(\n\
    .a(a),\n.b(b),\n.ctrl(ctrl),\n.y(y)\n);\nassign a = 2\u2019b1000;\nassign b =\
    \ 2\u2019b0101;\nassign ctrl = 6\u2019b0111;\nendmodule\nmodule ALU (\ninput wire\
    \ [3:0] ctrl,\ninput wire [7:0] a,\ninput wire [7:0] b,\noutput wire [7:0] y\n\
    );\n\n// Instantiate the ALU\n// module ALU_instantiation_module();\n\ncase (ctrl)\n\
    6\u2019b0000:\ny = a + b;\nendcase\n6\u2019b0001:\ny = a - b;\nendcase\n6\u2019\
    b0010:\ny = a & b;\nendcase\n6\u2019b0011:\ny = a | b;\nendcase\n6\u2019b0100:\n\
    y = a ^ b;\nendcase\n6\u2019b0101:\ny = ~a;\nendcase\n6\u2019b0110:\ny = a <<\
    \ 1;\nendcase\n6\u2019b0111:\ny = a >> 1;\nendcase\n6\u2019b1000:\ny = a * b;\n\
    endcase\n6\u2019b1001:\ny = a / b;\nendcase\n6\u2019b1010:\ny = a & b;\nendcase\n\
    6\u2019b1011:\ny = a | b;\nendcase\n6\u2019b1100:\ny = a ^ b;\nendcase\n6\u2019\
    b110"
- code: "module ALU (\ninput clk,\ninput [7:0] op1,\ninput [7:0] op2,\ninput [4:0]\
    \ op,\noutput [7:0] result\n);\nwire [7:0] op1_signed, op2_signed, result_signed\
    \ ;\nwire [7:0] ALU_result_signed ;\n\nassign op1_signed = (op1[7])? ~op1 + 1'b1\
    \ : op1;\nassign op2_signed = (op2[7])? ~op2 + 1'b1 : op2;\n\nassign ALU_result_signed\
    \ = (result[7])? ~result + 1'b1 : result;\n\nbegin\ncase (op)\n4'b0000 : result\
    \ = op1 + op2;\n//4'b0001 : result = op1 - op2;\n//4'b0010 : result = op1 * op2;\n\
    //4'b0011 : result = op1 / op2;\n//4'b0100 : result = op1 & op2;\n//4'b0101 :\
    \ result = op1 | op2;\n//4'b0110 : result = op1 ^ op2;\n//4'b0111 : result = -op1;\n\
    //4'b1000 : result = --op1;\n//4'b1001 : result = op1 + 1'b1;\n//4'b1010 : result\
    \ = op1 + 1'b0;\n//4'b1011 : result = op1 << 1;\n//4'b1100 : result = op1 >> 1;\n\
    default: result = op1;\nendcase\nendmodule\n### Run the Simulation:\nOpen the\
    \ new test bench file created by the modifications in the ALU module.\nRun the\
    \ simulation:\n\n## Week 8\n\n### Base Verilog Code:\nmodule ALU (\ninput clk,\n\
    input [7:0] op1,\ninput [7:0] op2,\ninput [4:0] op,\noutput [7:0] result\n);\n\
    \nassign result = op1 + op2;\nendmodule\n### Variation Instruction:\nModify the\
    \ ALU module to allow the ALU to support the following 8-bit integer arithmetic\
    \ operations:\n\n\u2022 Addition\n\u2022 Subtraction\n\u2022 Multiplication\n\u2022\
    \ Division\n\u2022 Bitwise and\n\u2022 Bitwise OR\n\u2022 Bitwise XOR\n\u2022\
    \ Increment\n\u2022 Decrement\n\u2022"
- code: |-
    module alu_tb (
    input clk,
    input alu,
    input alu_op,
    input [7:0] inA,
    input [7:0] inB
- code: |-
    module sw2led2(
    input wire [7:0] sw,
    output wire [7:0] ld
    ) ;
    wire [7:0] ldr;
    wire [7:0] alu_rst;
    wire [7:0] alu_a;
    wire [7:0] alu_b;
    wire [7:0] alu_r;
    wire [7:0] r_out;
    wire [7:0] r_out_r;
    wire [7:0] r_out_r_r;
    wire [7:0] r_out_r_r_r;
    wire [7:0] r_out_r_r_r_r;
    assign alu_rst = ldr[5];
    assign alu_a = alu_rst? ~ldr[4] : ldr[4];
    assign alu_b = alu_rst? ~ldr[1] : ldr[1];
    assign alu_r = (alu_rst == 1)? { r_out, r_out_r, r_out_r_r, r_out_r_r_r }
    : { ~r_out, ~r_out_r, ~r_out_r_r, ~r_out_r_r_r };
    assign r_out = alu_rst? { alu_a, alu_b } : { alu_a, alu_b, alu_rst };
    assign r_out_r = r_out ^ alu_rst ;
    assign r_out_r_r = r_out_r ^ alu_rst ;
    assign r_out_r_r_r = r_out_r_r ^ alu_rst ;
    assign r_out_r_r_r_r = r_out_r_r_r ^ alu_rst ;
    assign ld = alu_a & alu_r;
    endmodule
    ### Testbench Code:
    module testbench (
    input wire clk,
    input wire reset,
    input wire [7:0] sw,
    output wire [7:0] ld,
    output reg [7:0] led_out
    ) ;
    sw2led2 inst_sw2led2 (.sw (sw),.ld (ld));
    always @ (posedge clk or posedge reset) begin
    if (reset) begin
    ld <= 8'b0;
    led_out <= 8'b0;
    end
    else begin
    ld <= 8'b11111111;
    ld <= 8'b00001111;
    ld <= 8'b00010000;
    ld <= 8'b00100000;
    ld <= 8'b01000000;
    ld <= 8'b10000000;
    ld <= 8'b11111111;
    end
    end
    endmodule

    ## Verilog Code

    module sw2led2(
    input wire [7:0] sw,
    output wire [7:0] ld
    ) ;
    wire [7:0] ldr;
    wire [7:0] alu_rst;
    wire [7:0] alu_a;
    wire [7:0] alu_b;
    wire [7:0] alu_r;
    wire [7:0] r_out;
    wire [7:0] r_out_r;
    wire [7:0] r_out_r_r;
    wire [7:0] r_out_r_r_r;
    wire [7:0] r_out_r_r_r_r;
    assign alu_rst = ldr[5];
    assign alu_a = alu_rst? ~ldr[4] : ldr[4];
    assign alu_b = alu_rst? ~ldr[1] : ldr[1];
    assign alu_r = (alu_rst == 1)? { r_out, r_out_r, r_out_r_r, r_out_r_r_r }
    : { ~r_out, ~r_out_r, ~r_out_r_r, ~r_out_r_r_r };
    assign r_out = alu_rst? { alu_a, alu_b } : { alu_a, alu_b, alu_rst };
    assign r_out_r = r_out ^ alu_rst ;
    assign r_out_r_r = r_out_r ^ alu_rst ;
    assign r_out_r_r_r = r_out_r_r ^ alu_rst ;
    assign r_out_r_r_r_r = r_out_r_r_r ^ alu_rst ;
    assign ld = alu_a & alu_r;
    endmodule


    ## Testbench Code

    module testbench (
    input wire clk,
    input wire reset,
    input wire [7:0] sw,
    output wire [7:0] ld,
    output reg [7:0] led_out
    ) ;
    sw2led2 inst_sw2led2 (.sw (sw),.ld (ld));
    always @ (posedge clk or posedge reset) begin
    if (reset) begin
    ld <= 8'b0;
    led_out <= 8'b0;
    end
    else begin
    ld <= 8'b11111111;
    ld <= 8'b00001111;
    ld <= 8'b00010000;
    ld <= 8'b00100000;
    ld <= 8'b01000000;
    ld <= 8'b10000000;
    ld <= 8'b11111111;
    end
    end
    endmodule


    ## Results

    ### Circuit

    Figure 5. Circuit Diagram

    ### Waveforms

    Figure 6. Waveforms

    ## Conclusion

    In this tutorial, we were able to show how we can implement an ALU unit.

    In a real-world implementation, we have to take into account many different factors when designing the ALU unit including instruction set, data organization, instruction/data paths, logic gates, registers, and latches/flip-flops.

    This tutorial was inspired by an article that can be found at:

    https://medium.com/@gokulrams/what-is-an-alu-6332f3d306d9

    ## References

    [1],. Computer Architecture: A Quantitative Approach - Addison-Wesley Longman Publishing Group, 6th Edition.

    [2],. Computer Architecture: A Quantitative Approach - Addison-Wesley Longman Publishing Group, 6th Edition.

    [3] https://en.wikipedia.org/wiki/Arithmetic-logic_unit

    [4] https://en.wikipedia.org/wiki/Control_unit

    [5] https://en.wikipedia.org/wiki/Control_unit

    [6] https://en.wikipedia.org/wiki/Control_unit

    [7] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [8] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [9] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [10] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [11] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [12] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [13] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-ALU-Unit-Part-A/

    [14] https://www.edn.com/article/441641/A-Newbie-Gets-It-Right-The-
- code: |-
    module sw2led2 (
    input wire [7:0] sw,
    input wire unsigned s_sw,
    input wire signed s_sw,
    output wire [7:0] ld
    ) ;
    assign ld = sw;
    assign ld = s_sw;
    assign ld = s_sw;
    endmodule
    ### Simulation Results:

    ### New Code:
    module ALU_tb (
    input wire [7:0] op_a,
    input wire [7:0] op_b,
    input wire [7:0] data_in,
    input wire [7:0] data_out,
    output wire [7:0] control,
    output wire [7:0] data_o_signed,
    output wire [7:0] data_o_unsigned,
    output wire [7:0] op_result,
    output wire [7:0] zero,
    output wire [7:0] negate,
    output wire [7:0] overflow,
    output wire [7:0] signed,
    output wire [7:0] c_out_signed,
    output wire [7:0] c_out_unsigned,
    output wire [7:0] c_out_result,
    output wire [7:0] c_out_zero,
    output wire [7:0] c_out_negate,
    output wire [7:0] c_out_overflow,
    output wire [7:0] c_out_signed,
    output wire [7:0] c_out_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_zero,
    output wire [7:0] c_out_negate,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_overflow,
    output wire [7:0] c_out_signed,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [7:0] c_out_op_result,
    output wire [
- code: |-
    ### Test Vector:
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    32'h890abcde  32'h1234abcd  32'h33333333  32'h890abcde
    #### Simulation Results:
    Test Number 0:
    The first test case is for unsigned addition.
    A = 32'h890abcde, B = 32'h1234abcd, result = 32'h9b3ebce6, carry = 0, zero = 0
    The test passed!

    Test Number 1:
    The second test case is for unsigned subtraction.
    A = 32'h1234abcd, B = 32'h890abcde, result = 32'he6d85031, carry = 0, zero = 0
    The test passed!

    Test Number 2:
    The third test case is for unsigned multiplication.
    A = 32'h1234abcd, B = 32'h890abcde,
- code: |-
    module alu_test_m;

    import "C:\Users\HP\Desktop\lab5\Lab5\testbench_alu_m.v"

    integer i;

    module test_module (
    input clk,
    input rst,
    input [7:0] a,
    input [3:0] op,
    input [7:0] b,
    output [7:0] res
    );

    ALU alu_module (
    .clk (clk),
    .a (a),
    .b (b),
    .op (op),
    .res (res)
    );

    endmodule

    assign res = alu_module.res;

    endmodule

    ### Testbench Code:
    module alu_test (
    input clk,
    input rst,
    input [7:0] a,
    input [3:0] op,
    input [7:0] b,
    output [7:0] res
    );

    ALU alu_module (
    .clk (clk),
    .a (a),
    .b (b),
    .op (op),
    .res (res)
    );

    assign alu_module.op = 8'b00000001;

    assign alu_module.op = 8'b10000111;

    endmodule

    assign alu_module.op = 8'b01000001;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b10101001;

    endmodule

    assign alu_module.op = 8'b10000001;

    endmodule

    assign alu_module.op = 8'b00000001;

    endmodule

    assign alu_module.op = 8'b11101011;

    endmodule

    assign alu_module.op = 8'b11001011;

    endmodule

    assign alu_module.op = 8'b11001001;

    endmodule

    assign alu_module.op = 8'b00000011;

    endmodule

    assign alu_module.op = 8'b11101001;

    endmodule

    assign alu_module.op = 8'b10100001;

    endmodule

    assign alu_module.op = 8'b10100011;

    endmodule

    assign alu_module.op = 8'b10100011;

    endmodule

    assign alu_module.op = 8'b10000011;

    endmodule

    assign alu_module.op = 8'b00000011;

    endmodule

    assign alu_module.op = 8'b01100011;

    endmodule

    assign alu_module.op = 8'b00100011;

    endmodule

    assign alu_module.op = 8'b01100001;

    endmodule

    assign alu_module.op = 8'b10100001;

    endmodule

    assign alu_module.op = 8'b01100001;

    endmodule

    assign alu_module.op = 8'b10100101;

    endmodule

    assign alu_module.op = 8'b10000101;

    endmodule

    assign alu_module.op = 8'b00000101;

    endmodule

    assign alu_module.op = 8'b11100101;

    endmodule

    assign alu_module.op = 8'b00000101;

    endmodule

    assign alu_module.op = 8'b11000101;

    endmodule

    assign alu_module.op = 8'b11000101;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b01101011;

    endmodule

    assign alu_module.op = 8'b10101001;

    endmodule

    assign alu_module.op = 8'b01101001;

    endmodule

    assign alu_module.op = 8'b10001001;

    endmodule

    assign alu_module.op = 8'b00001001;

    endmodule

    assign alu_module.op = 8'b11101001;

    endmodule

    assign alu_module.op = 8'b11001001;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b00101011;

    endmodule

    assign alu_module.op = 8'b10101001;

    endmodule

    assign alu_module.op = 8'b00101001;

    endmodule

    assign alu_module.op = 8'b10001001;

    endmodule

    assign alu_module.op = 8'b00001001;

    endmodule

    assign alu_module.op = 8'b01101001;

    endmodule

    assign alu_module.op = 8'b00101001;

    endmodule

    assign alu_module.op = 8'b01101011;

    endmodule

    assign alu_module.op = 8'b00101011;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b11101011;

    endmodule

    assign alu_module.op = 8'b11001011;

    endmodule

    assign alu_module.op = 8'b10001011;

    endmodule

    assign alu_module.op = 8'b00001011;

    endmodule

    assign alu_module.op = 8'b11101011;

    endmodule

    assign alu_module.op = 8'b01101011;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b11001011;

    endmodule

    assign alu_module.op = 8'b11001001;

    endmodule

    assign alu_module.op = 8'b01101001;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b11101011;

    endmodule

    assign alu_module.op = 8'b01101011;

    endmodule

    assign alu_module.op = 8'b00101011;

    endmodule

    assign alu_module.op = 8'b10101011;

    endmodule

    assign alu_module.op = 8'b01101011;

    endmodule

    assign alu_module.op = 8'b11101001;

    endmodule

    assign alu_module.op = 8'b11001001;

    endmodule

    assign alu_module.op = 8'b101
- code: |-
    module sw2led2 (
    input wire [7:0] sw,
    output wire
- code: |-
    module ALUTest (
    input wire clk,
    input wire rst,
    input wire [1:0] sel,
    input wire [31:0] A,
    input wire [31:0] B,
    input wire [31:0] S,
    input wire [31:0] LHS,
    input wire [31:0] RHS,
    input wire [31:0] M,
    input wire [8:0] Q_exp,
    input wire [8:
- code: "Now a 5 bit signed number is added to an 8 bit value. The sum is then written\
    \ to an 8 bit value.\nThe expected output is sign extended to 8 bits and the expected\
    \ output is the sum.\nmodule alu(\ninput T in1,\ninput T in2,\ninput T in3,\n\
    input T in4,\ninput T in5,\ninput T in6,\ninput T in7,\ninput T in8,\noutput T\
    \ out\n) ;\nassign out = in1 + in2 + in3 + in4 + in5 + in6 + in7 + in8;\nendmodule\n\
    module sw2led3 (\ninput wire [7:0] sw,\noutput wire [7:0] ld\n) ;\nassign ld =\
    \ sw;\nendmodule\nmodule alu_tb(\ninput [7:0] a,\ninput [7:0] b,\ninput [7:0]\
    \ c,\ninput [7:0] d,\ninput [7:0] e,\ninput [7:0] f,\ninput [7:0] g,\ninput [7:0]\
    \ h,\ninput [7:0] out\n) ;\nalu u_alu(.in1 (a),.in2 (b),.in3 (c),.in4 (d),.in5\
    \ (e),.in6 (f),.in7 (g),.in8 (h),.out (out) );\nsw2led3 u_led (.sw (out),.ld (o)\
    \ );\nendmodule\n\n## Signed Arithmetic Operations\n\nThe sign of the result is\
    \ the sign of the first operand, and so if both operands are negative the result\
    \ is negative. Otherwise, the result is positive.\n\n## Sign Extension\n\n###\
    \ Sign Extension Signals\n\nTo simulate a sign extension we will use a special\
    \ kind of signal called a combinatorial logic signal. The combinatorial signal\
    \ is a signal that changes only on the rising edge of the clock, and is driven\
    \ to the value of the signal on the rising edge.\n\nThe purpose of a combinatorial\
    \ signal is to represent a signal that is subject to a finite range, and whose\
    \ value does not change for a while after it is first changed.\n\n### Combinational\
    \ Logic Gates\n\nTo simulate a combinatorial logic design we will use combinational\
    \ logic gates. Each combinational logic design is made up of a number of combinational\
    \ logic gates, which are made up of logic gates.\n\nThe logic gates that we will\
    \ use for combinational logic are:\n\n\u2022 NOT\n\u2022 AND\n\u2022 OR\n\u2022\
    \ X-OR\n\u2022 NAND\n\u2022 NOR\n\u2022 XNOR\n\n### Sign Extension\n\nSuppose\
    \ we have a 32-bit number. We can represent that number in 8 bits in a unsigned\
    \ manner, like this:\n\n```    11111111111111111111111111111111\n```\n\nWe can\
    \ represent that same number in 8 bits in a signed manner, like this:\n\n``` \
    \   11111111111111111111111111111111\n```\n\nNote that the 32-bit value represents\
    \ a 8-bit signed value.\n\n### Sign Extension\n\nWe can sign extend a 32-bit unsigned\
    \ value to a 8-bit signed value by using a NOT (XNOR) gate. The output is just\
    \ the same as the input value when the input is zero. If the input is a one, then\
    \ the output of the NOT (XNOR) gate is the complement of the input value.\n\n\
    In this case, the output is a one when the input is a zero, and a zero otherwise.\n\
    \n### Sign Extension\n\nWe can sign extend a 32-bit unsigned value to a 8-bit\
    \ signed value by using a NOT (XNOR) gate. The output is just the same as the\
    \ input value when the input is zero. If the input is a one, then the output of\
    \ the NOT (XNOR) gate is the complement of the input value.\n\nIn this case, the\
    \ output is a one when the input is a zero, and a zero otherwise.\n\n### Sign\
    \ Extension\n\nWe can sign extend a 32-bit unsigned value to a 8-bit signed value\
    \ by using a NOT (XNOR) gate. The output is just the same as the input value when\
    \ the input is zero. If the input is a one, then the output of the NOT (XNOR)\
    \ gate is the complement of the input value.\n\nIn this case, the output is a\
    \ one when the input is a zero, and a zero otherwise.\n\n### Sign Extension\n\n\
    We can sign extend a 32-bit unsigned value to a 8-bit signed value by using a\
    \ NOT (XNOR) gate. The output is just the same as the input value when the input\
    \ is zero. If the input is a one, then the output of the NOT (XNOR) gate is the\
    \ complement of the input value.\n\nIn this case, the output is a one when the\
    \ input is a zero, and a zero otherwise.\n\n### Sign Extension\n\nWe can sign\
    \ extend a 32-bit unsigned value to a 8-bit signed value by using a NOT (XNOR)\
    \ gate. The output is just the same as the input value when the input is zero.\
    \ If the input is a one, then the output of the NOT (XNOR) gate is the complement\
    \ of the input value.\n\nIn this case, the output is a one when the input is a\
    \ zero, and a zero otherwise.\n\n### Sign Extension\n\nWe can sign extend a 32-bit\
    \ unsigned value to a 8-bit signed value by using a NOT (XNOR) gate. The output\
    \ is just the same as the input value when the input is zero. If the input is\
    \ a one, then the output of the NOT (XNOR) gate is the complement of the input\
    \ value.\n\nIn this case, the output is a one when the input is a zero, and a\
    \ zero otherwise.\n\n### Sign Extension\n\nWe can sign extend a 32-bit unsigned\
    \ value to a 8-bit signed value by using a NOT (XNOR) gate. The output is just\
    \ the same as the input value when the input is zero. If the input is a one, then\
    \ the output of the NOT (XNOR) gate is the complement of the input value.\n\n\
    In this case, the output is a one when the input is a zero, and a zero otherwise.\n\
    \n### Sign Extension\n\nWe can sign extend a 32-bit unsigned value to a 8-bit\
    \ signed value by using a NOT (XNOR) gate. The output is just the same as the\
    \ input value when the input is zero. If the input is a one, then the output of\
    \ the NOT (XNOR) gate is the complement of the input value.\n\nIn this case, the\
    \ output is a one when the input is a zero, and a zero otherwise.\n\n### Sign\
    \ Extension\n\nWe can sign extend a 32-bit unsigned value to a 8-bit signed value\
    \ by using a NOT (XNOR) gate. The output is just the same as the input value when\
    \ the input is zero. If the input is a one, then the output of the NOT (XNOR)\
    \ gate is the complement of the input value.\n\nIn this case, the output is a\
    \ one when the input is a zero, and a zero otherwise.\n\n### Sign Extension\n\n\
    We can sign extend a 32-bit unsigned value to a 8-bit signed value by using a\
    \ NOT (XNOR) gate. The output is just the same as the input value when the input\
    \ is zero. If the input is a one, then the output of the NOT (XNOR) gate is the\
    \ complement of the input value.\n\nIn this case, the output is a one when the\
    \ input is a zero, and a zero otherwise.\n\n### Sign Extension\n\nWe can sign\
    \ extend a 32-bit unsigned value to a 8-bit signed value by using a NOT (XNOR)\
    \ gate. The output is just the same as the input value when the input is zero.\
    \ If the input is a one, then the output of the NOT (XNOR) gate is the complement\
    \ of the input value.\n\nIn this case, the output is a one when the input is a\
    \ zero, and a zero otherwise.\n\n### Sign Extension\n\nWe can sign extend a 32-bit\
    \ unsigned value to a 8-bit signed value by using a NOT (XNOR) gate. The output\
    \ is just the same as the input value when the input is zero. If the input is\
    \ a one, then the output of the NOT (XNOR) gate is the complement of the input\
    \ value.\n\nIn this case, the output is a one when the input is a zero, and a\
    \ zero otherwise.\n\n### Sign Extension\n\nIn this case, the output is a one when\
    \ the input is a zero, and a zero otherwise.\n\n### Sign Extension\n\nWe can sign\
    \ extend a 32-bit unsigned value to a 8-bit signed value by using a NOT (XNOR)\
    \ gate.\n\nIn this case, the output is a one when the input"
- code: "```systemverilog\nmodule orfr_tst; // Testbench for OR gate with force/release\n\
    \  reg b,c; wire a;\n  initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize\
    \ inputs\n  always #3 c = ~c; // Toggle input 'c' every 3 time units\n  or_fr_rl\
    \ dd(a,b,c); // Instantiate the module containing force/release\nendmodule\n\n\
    struct {logic a,b,c; string s;} dd;  // add this line\n\nmodule dd(DataIn,DataOut);\
    \         // module declaration\n  wire DataOut; DataOut=DataIn;     // instantiate\
    \ the module\n  assign DataOut=DataIn[1:0];       // force data to be 2 bits\n\
    endmodule\n```\n### Output:\nThe testbench output is:\n```bash\nDataIn DataOut\
    \  a  b  c\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1\
    \ 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\nDataIn DataOut  a  b  c\n0 0 0\n\
    0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n\
    0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n\
    1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n0 0 0\n0 1 1\n1 1 1\n1 0 1\n```\ntall\n/install.sh\n\
    #!/bin/bash\n# Installs all the requirements for running this tool\n# Written\
    \ by \n# 10/25/2021\nset -e\n\n# Install requirements\nyum -y update\nyum install\
    \ -y git\nyum install -y python3-pip\nyum install -y python37-pip\nyum install\
    \ -y graphviz\nyum install -y python3-devel\nyum install -y python3-setuptools\n\
    yum install -y epel-release\nyum install -y wget\nyum install -y python2-gobject\n\
    yum install -y git\nyum install -y python-devel\nyum install -y python3-devel\n\
    wget https://bootstrap.pypa.io/get-pip.py\npython2 get-pip.py\npython3 get-pip.py\n\
    rm get-pip.py\npip3 install --upgrade pip\npip3 install --upgrade setuptools\n\
    pip3 install --upgrade pygraphviz\npip3 install --upgrade colorama\npip3 install\
    \ --upgrade git+https://github.com/josh-perry/jason-parser.git#egg=jason-parser\n\
    pip3 install --upgrade git+https://github.com/josh-perry/json-parser.git#egg=json-parser\n\
    pip3 install --upgrade git+https://github.com/josh-perry/python"
- code: |-
    ```verilog
    module or_ffl_fr(input a, input b, input c, input force, input release, output y);
      assign y = a | b | c | a & b | a & c | b & c | a & b & c;
    endmodule
    ```/veriloggen/types/struct_unpack.py

    import sys

    from. import BaseTypes
    from.struct import _Struct

    class _StructUnpack(_Struct):
        """
        A structure which contains unpacked fields.
        """
        def __init__(self, fields, typename="struct"):
            self._typename = typename if isinstance(typename, str) else "struct_unpack"
            super().__init__(fields, typename=self._typename)

        def _get_typename(self, fields):
            """get type name"""
            if not isinstance(fields, dict):
                return self._typename
            else:
                return self._typename + "_" + "_".join([f"{k}_{v}" for k, v in fields.items()])

        def as_instance(self, name):
            return super().as_instance(name)

        def __call__(self, *args, **kwargs):

            if not isinstance(args, (list, tuple)) or not isinstance(args[0], (list, tuple)):
                raise ValueError("Invalid parameters. 1st parameter must be a list.")

            inputs = []
            self._unpack(args, inputs)
            if len(inputs)!= len(self.fields):
                msg = f"Number of inputs must be {len(self.fields)} but given {len(inputs)}."
                raise ValueError(msg)
            return super(BaseTypes.Logic, self).__call__(*inputs, **kwargs)

        def _pack(self, inputs, ret):
            """pack"""
            if not self.fields:
                return inputs[0]
            d = dict(zip(self.fields.keys(), inputs))
            for k, v in d.items():
                ret[k] = v
            return ret

        def _unpack(self, inputs, ret):
            """unpack"""
            if not self.fields:
                return inputs[0]
            d = dict(zip(self.fields.keys(), inputs))
            for k, v in d.items():
                ret.append(v)
            return ret
    /veriloggen/generators/vcd_generator.py

    import os
    import re
    import sys
    import inspect

    import veriloggen.stream as S
    from veriloggen import Module, clock, enable, reset, randstate, RandSeq
    from veriloggen.stream import Stream, stream, StreamSignal
    from veriloggen.types import Int, Bits, Logic, WildCard, Bits1, Bits2, Bits3, Bits4, Bits5, Bits6, Bits7, \
        Bits8, Bits9, Bits10, Bits11, Bits12, Bits13, Bits14, Bits15, Bits16, Bits17, Bits18, Bits19, Bits20, Bits21, Bits22, Bits23, Bits24, Bits25, Bits26, Bits27, Bits28, Bits29, Bits30, Bits31, Bits32, Bits33, Bits34, Bits35, Bits36, Bits37, Bits38, Bits39, Bits40, Bits41, Bits42, Bits43, Bits44, Bits45, Bits46, Bits47, Bits48, Bits49
    Bit, Bit1, Bit2, Bit3, Bit4, Bit5, Bit6, Bit7, Bit8, Bit9, Bit10, Bit11, Bit12, Bit13, Bit14, Bit15, Bit16
    from veriloggen import verilog

    from collections import OrderedDict


    class VCDGenerator():
        def __init__(self, output_dir=".", append_date=False):
            self.output_dir = output_dir
            self.append_date = append_date
            self.stream_info = OrderedDict()
            self.io_info = OrderedDict()
            self.signals = OrderedDict()
            self.names = OrderedDict()
            self.all_signals = OrderedDict()
            self.all_names = OrderedDict()
            self.module = None

        def set_module(self, module):
            """Set Top-level module."""
            self.module = module

        def dump(self, filename, append_date=False, **kwargs):
            """"""
            filename = filename + ".vcd" if not filename.endswith(".vcd") else filename
            if not filename.endswith(".vcd"):
                filename += ".vcd"

            if not append_date:
                os.makedirs(self.output_dir, exist_ok=True)
                with open(os.path.join(self.output_dir, filename), "w") as f:
                    self.dump(f, **kwargs)
                return

            today = datetime.now().strftime("%Y%m%d")
            filename = filename.replace(".vcd", f"_gen_{today}.vcd")
            if not filename.endswith(".vcd"):
                filename += ".vcd"
            os.makedirs(self.output_dir, exist_ok=True)
            with open(os.path.join(self.output_dir, filename), "w") as f:
                self.dump(f, **kwargs)
            return

        def dump(self, fobj, append_date=False, **kwargs):
            """"""
            fobj.write("$_version: 5:1:1$_\n")
            fobj.write("$_date: {}$_\n".format(datetime.now().isoformat()))
            fobj.write("$_f$:\n")
            fobj.write("$_end$\n")
            fobj.write("$_f$_vcd_$timescale$:\n")
            fobj.write("1ns$ $timescale$\n")
            fobj.write("$_end$\n")
            fobj.write("$_f$_vcd_$scope$:\n")
            fobj.write("$scope module {}\n".format(self.module.name))
            for sig_name in self.signals:
                fobj.write("$var wire {0} {1} {2} {3}\n".format(self.signals[sig_name], sig_name,
                                                              self.names[sig_name], self.stream_info[sig_name]))
            for sig_name in self.all_signals:
                fobj.write("$var wire {0} {1} {2}
- code: |-
    module or_fr_rl_unpacked (DataIn, DataOut);
      logic [3:0] a, b, c; // Input signals are unpacked
      // Output signal will be a string to indicate the state of the input signals
      string [8] output; // Output signal is a string

      logic f_a, r_a;
      logic f_b, r_b;
      logic f_c, r_c;
      logic s_a, s_b, s_c; // Forces and releases are unpacked
      logic f, r;

      always_ff @(posedge f or posedge r) begin
          if (f) f_a <= a;
          if (f) f_b <= b;
          if (f)
- code: "or_fr_rl.v:\n```\nmodule or_fr_rl(DataIn, DataOut, clock);\nparameter Delay\
    \ = 2;\t// Delay in time units of the OR gate\nparameter Delay_release = 5;\t\
    // Amount of time to hold the release line\n\n// Parameter block\nparameter [0:0]\
    \ DataIn_tmp = {DataIn[2:0]};\n\ninput clock;\ninput [1:0] DataIn;\noutput reg\
    \ [1:0] DataOut;\n\n// Registers and inverters\nreg [1:0] D_n;\nreg [1:0] D_not;\n\
    \n// Delayed assignments\n\nalways @(posedge clock) begin\n\tD_not[2:0] <= ~DataIn[2:0];\n\
    \tD_not[1] <= 1;\nend\n\nalways @(posedge clock) begin\n\tcase(DataOut)\t// Compare\
    \ register and output toggling (case 1)\n\t\tDataOut[2:0]: begin\n\t\t\tD_n[0]\
    \ <= 1;\n\t\t\tD_n[1] <= 0;\n\t\tend\n\t\tdefault: begin\n\t\t\tD_n[0] <= 0;\n\
    \t\t\tD_n[1] <= 0;\n\t\tend\n\tendcase\nend\n\nalways @(posedge clock) begin\n\
    \tcase(D_n)\t// Compare delay and register (case 2)\n\t\tD_not[2:0]: begin\n\t\
    \t\tD_n[2] <= Delay_release + Delay;\n\t\t\tD_n[3] <= ~Delay_release + Delay;\n\
    \t\tend\n\t\tdefault: begin\n\t\t\tD_n[2] <= Delay;\n\t\t\tD_n[3] <= Delay;\n\t\
    \tend\n\tendcase\nend\n\nalways @(posedge clock) begin\n\tD_n[2:0] <= D_not[2:0];\n\
    end\n\nassign DataOut = D_n;\n\n// Forces\nalways @(posedge clock) begin\n\tD_n[1]\
    \ <= 1;\t// Force '1' to 'DataOut'\nend\n\nalways @(posedge clock) begin\n\tD_n[1]\
    \ <= 0;\t// Release '1' from 'DataOut'\nend\n```\n\n# Task 6\n\n### Base Verilog\
    \ Code:\nmodule or_fr_rl; // OR gate with force/release\n  reg b,c; wire a;\n\
    \  initial begin b=1'b0; c=1'b0; #20 $stop; end // Initialize inputs\n  always\
    \ #3 c = ~c; // Toggle input 'c' every 3 time units\n  or_fr_rl dd(a,b,"
- code: "module or_fr_rl(DataIn, DataOut, a, b, c); // OR gate with force/release\n\
    \tparameter O_MASK = 4'b1111; // 4 bit register mask\n\tparameter F_MASK = 4'b1111;\
    \ // 4 bit register mask\n\t// Register outputs are the outputs of the mux, OR\
    \ function, and mux\n\toutput reg [3:0] O_mux;\n\toutput reg [3:0] O_OR;\n\toutput\
    \ reg [3:0] O_mux_sel;\n\t// Register inputs are the inputs of the muxes\n\tinput\
    \ [3:0] I_mux_1;\n\tinput [3:0] I_mux_2;\n\t// Register forces and releases are\
    \ the data in and out of the registers\n\tinput [3:0] F_mux_1;\n\tinput [3:0]\
    \ F_mux_2;\n\tinput [3:0] F_mux_3;\n\tinput [3:0] F_mux_4;\n\tinput [3:0] F_mux_5;\n\
    \tinput [3:0] F_mux_6;\n\tinput [3:0] F_mux_7;\n\tinput [3:0] F_mux_8;\n\tinput\
    \ [3:0] F_mux_9;\n\tinput [3:0] F_mux_10;\n\tinput [3:0] F_mux_11;\n\tinput [3:0]\
    \ F_mux_12;\n\tinput [3:0] F_mux_13;\n\tinput [3:0] F_mux_14;\n\tinput [3:0] F_mux_15;\n\
    \n\tassign O_mux = I_mux_1;\n\tassign O_mux_sel = I_mux_2;\n\n\tassign O_OR =\
    \ O_mux ^ O_mux_sel;\n\n\tassign F_mux_1 = |DataIn.A & ~DataIn.F;\n\tassign F_mux_2\
    \ = |DataIn.B & ~DataIn.F;\n\tassign F_mux_3 = |DataIn.C & ~DataIn.F;\n\tassign\
    \ F_mux_4 = |DataIn.D & ~DataIn.F;\n\tassign F_mux_5 = |DataIn.E & ~DataIn.F;\n\
    \tassign F_mux_6 = |DataIn.F & ~DataIn.F;\n\tassign F_mux_7 = |DataIn.G & ~DataIn.F;\n\
    \tassign F_mux_8 = |DataIn.H & ~DataIn.F;\n\tassign F_mux_9 = |DataIn.I & ~DataIn.F;\n\
    \tassign F_mux_10 = |DataIn.J & ~DataIn.F;\n\tassign F_mux_11 = |DataIn.K & ~DataIn.F;\n\
    \tassign F_mux_12 = |DataIn.L & ~DataIn.F;\n\tassign F_mux_13 = |DataIn.M & ~DataIn.F;\n\
    \tassign F_mux_14 = |DataIn.N & ~DataIn.F;\n\tassign F_mux_15 = |DataIn.O & ~DataIn.F;\n\
    \n\tassign DataOut.A = F_mux_1;\n\tassign DataOut.B = F_mux_2;\n\tassign DataOut.C\
    \ = F_mux_3;\n\tassign DataOut.D = F_mux_4;\n\tassign DataOut.E = F_mux_5;\n\t\
    assign DataOut.F = F_mux_6;\n\tassign DataOut.G = F_mux_7;\n\tassign DataOut.H\
    \ = F_mux_8;\n\tassign DataOut.I = F_mux_9;\n\tassign DataOut.J = F_mux_10;\n\t\
    assign DataOut.K = F_mux_11;\n\tassign DataOut.L = F_mux_12;\n\tassign DataOut.M\
    \ = F_mux_13;\n\tassign DataOut.N = F_mux_14;\n\tassign DataOut.O = F_mux_15;\n\
    endmodule\n\n### Generated Testbench Code:\norfr_tst orfr_tb;\nor_fr_rl orfr_inst(.DataIn(orfr_tb.DataIn),.DataOut(orfr_tb.DataOut),.a(orfr_tb.a),.b(orfr_tb.b),.c(orfr_tb.c));\n\
    ### Input Testbench Code:\ntest orfr_tb\n\tinput a, b, c;\n\tinput [31:0] DataIn[2:0];\n\
    \toutput reg [31:0] DataOut[2:0];\n\n\treg [4:0] DataIn_A;\n\treg [4:0] DataIn_B;\n\
    \treg [4:0] DataIn_C;\n\treg [4:0] DataIn_D;\n\treg [4:0] DataIn_E;\n\treg [4:0]\
    \ DataIn_F;\n\treg [4:0] DataIn_G;\n\treg [4:0] DataIn_H;\n\treg [4:0] DataIn_I;\n\
    \treg [4:0] DataIn_J;\n\treg [4:0] DataIn_K;\n\treg [4:0] DataIn_L;\n\treg [4:0]\
    \ DataIn_M;\n\treg [4:0] DataIn_N;\n\treg [4:0] DataIn_O;\n\n\tinitial begin\n\
    \t\tDataIn_A = {DataIn[0], DataIn[1], DataIn[2], DataIn[3]};\n\t\tDataIn_B = {DataIn[4],\
    \ DataIn[5], DataIn[6], DataIn[7]};\n\t\tDataIn_C = {DataIn[8], DataIn[9], DataIn[10],\
    \ DataIn[11]};\n\t\tDataIn_D = {DataIn[12], DataIn[13], DataIn[14], DataIn[15]};\n\
    \t\tDataIn_E = {DataIn[16], DataIn[17], DataIn[18], DataIn[19]};\n\t\tDataIn_F\
    \ = {DataIn[20], DataIn[21], DataIn[22], DataIn[23]};\n\t\tDataIn_G = {DataIn[24],\
    \ DataIn[25], DataIn[26], DataIn[27]};\n\t\tDataIn_H = {DataIn[28], DataIn[29],\
    \ DataIn[30], DataIn[31]};\n\t\tDataIn_I = {DataIn[32], DataIn[33], DataIn[34],\
    \ DataIn[35]};\n\t\tDataIn_J = {DataIn[36], DataIn[37], DataIn[38], DataIn[39]};\n\
    \t\tDataIn_K = {DataIn[40], DataIn[41], DataIn[42], DataIn[43]};\n\t\tDataIn_L\
    \ = {DataIn[44], DataIn[45], DataIn[46], DataIn[47]};\n\t\tDataIn_M = {DataIn[48],\
    \ DataIn[49], DataIn[50], DataIn[51]};\n\t\tDataIn_N = {DataIn[52], DataIn[53],\
    \ DataIn[54], DataIn[55]};\n\t\tDataIn_O = {DataIn[56], DataIn[57], DataIn[58],\
    \ DataIn[59]};\n\tend\n\n\tinitial begin\n\t\t$monitor(DataOut, DataIn_A, DataIn_B,\
    \ DataIn_C, DataIn_D, DataIn_E, DataIn_F, DataIn_G, DataIn_H, DataIn_I, DataIn_J,\
    \ DataIn_K, DataIn_L, DataIn_M, DataIn_N, DataIn_O);\n\t\t$monitor(DataOut, DataIn_A\
    \ ^ DataIn_B, DataIn_C ^ DataIn_D, DataIn_E ^ DataIn_F, DataIn_G ^ DataIn_H, DataIn_I\
    \ ^ DataIn_J, DataIn_K ^ DataIn_L, DataIn_M ^ DataIn_N, DataIn_O ^ DataIn_O);\n\
    \t\t#10 #stop;\n\tend\n\n\tinitial begin\n\t\t$monitor(DataOut, a, b, c);\n\t\t\
    $monitor(DataOut, a, b ^ c);\n\t\t$monitor(DataOut, a, b & c);\n\t\t$monitor(DataOut,\
    \ a, b | c);\n\t\t#10 #stop;"
- code: |-
    package or_fr_rl #(parameter Width=1, parameter T=100)
    (
      input clock, reset,
      input [Width-1:0] DataIn,
      input [Width-1:0] DataOut,
      input force, release, enable,
      output enable_n
    );

    logic [Width-1:0] D_in, D_out;
    logic [Width-1:0] D_in_f, D_in_r, D_in_c_n;
    logic [Width-1:0] Data_c_n, Data_c_f, Data_c_r;
    localparam l_DataIn_force = 5'h01;
    localparam l_DataIn_release = 5'h00;
    localparam l_DataIn_c_force = 5'h02;
    localparam l_DataIn_c_release = 5'h03;
    localparam l_DataIn_c_n = 5'h04;
    localparam l_DataOut_f = 5'h01;
    localparam l_DataOut_release = 5'h00;

    always@(posedge reset or posedge clock)
      if(reset)
        begin
          D_in_f <= 1'b0; D_in_r <= 1'b0;
          Data_c_n <= 1'b0;
          D_in_c_n <= 1'b0;
          enable_n <= 1'b1;
        end
      else
        begin
          if(enable)
            if(force)
              if(D_in_f)
                begin
                  D_out <= DataOut;
                  D_in_c_f <= DataIn;
                  D_in_c_n <= 1'b1;
                end
              else if(D_in_r)
                begin
                  D_out <= DataOut;
                  D_in_c_r <= DataIn;
                  D_in_c_n <= 1'b1;
                end
              else
                begin
                  D_in_c_n <= 1'b0;
                end
            else if(release)
              if(D_in_r)
                begin
                  D_out <= DataOut;
                  D_in_c_r <= DataIn;
                  D_in_c_n <= 1'b1;
                end
              else if(D_in_f)
                begin
                  D_out <= DataOut;
                  D_in_c_f <= DataIn;
                  D_in_c_n <= 1'b1;
                end
              else
                begin
                  D_in_c_n <= 1'b0;
                end
            else
              begin
                D_in_c_n <= 1'b1;
                D_in_f <= 1'b0;
                D_in_r <= 1'b0;
              end
          else
            begin
              D_in_c_n <= 1'b1;
              D_in_f <= 1'b1;
              D_in_r <= 1'b1;
            end
          end

          if(D_in_c_n)
            if(D_in_c_f)
              D_in_c_n <= 1'b1;
            else if(D_in_c_r)
              D_in_c_n <= 1'b0;
          else if(D_in_c_f)
            D_in_c_n <= 1'b1;
          else if(D_in_c_r)
            D_in_c_n <= 1'b0;

          D_in <= D_in_c_n;
          D_out <= DataOut;
          enable_n <= 1'b1;
        end

    endmodule
    ### Result:

    ```

    <img
- code: "module orfr_tst; // Testbench for OR gate with force/release\n  struct io\
    \ {   logic a, b, c;   logic [3:0] string; };\n  io din, dout;\n  initial begin\
    \ din.a = bit_or_fr_rl(0,0,0); din.b = bit_or_fr_rl(0,1,1); din.c = bit_or_fr_rl(1,0,1);\
    \ #1 $dumpfile(\"inputs.v\"); foreach (din.a, din.b, din.c) $dumpvars(1, din);\
    \ #20 $stop; end // Initialize inputs\n  always #3 c = ~c; // Toggle input 'c'\
    \ every 3 time units\n  or_fr_rl dd(din,dout); // Instantiate the module containing\
    \ force/release\nendmodule\n### Expected Behavior:\n- All the inputs get dumped\
    \ to a file named inputs.v\n- The module instantiation is correctly passed the\
    \ 3 packed inputs and uses them inside the module to assign the unpacked inputs\
    \ din.a, din.b, din.c.\n- The module outputs are correctly assigned to a single\
    \ unpacked struct.\n### Actual Behavior:\n- All the inputs get dumped to a file\
    \ named inputs.v\n- The module instantiation is correctly passed the 3 packed\
    \ inputs and uses them inside the module to assign the unpacked inputs din.a,\
    \ din.b, din.c.\n- The module outputs are correctly assigned to a single unpacked\
    \ struct.\n\n### Steps to Reproduce:\nPlease refer to the testbench code above.\n\
    \n### Other Relevant Information:\nI have to use a struct to use the multiple\
    \ inputs in the module instantiation. It is expected and right in the context\
    \ of the testbench. The issue is that the unpacked structs assigned to the module\
    \ inputs are not passed to the module and are not in the scope of the module to\
    \ perform the appropriate unpacking.\n\n---\n\nI have run into some odd behavior\
    \ with the Verilator tool. I am looking for some guidance on this one. I have\
    \ some code that allows me to instantiate an instance of a module with multiple\
    \ fields assigned to a single instance of a struct. This works as expected when\
    \ I run the code with Verilog input files and the output is as expected. I am\
    \ also able to compile the code with the code generation set to always inline\
    \ and I get the expected output. However, when I try to compile the code with\
    \ the code generation set as always static, I get the following error message.\n\
    \nCode Generation Error: Static code generation may not be performed on this module\
    \ because it contains unverifiable code.\n\nAny ideas on what is going on here\
    \ or how I can get around this?\n\nThanks!username_1: You could simply create\
    \ a module wrapper, which instantiates your module:\n\n```\nmodule test(\n   \
    \ output logic a,\n    output logic b,\n    output logic c\n);\n\nmodule wrapper(\n\
    \    input logic [1:0] a,\n    input logic [1:0] b,\n    input logic [1:0] c,\n\
    \    output logic [1:0] sa,\n    output logic [1:0] sb,\n    output logic [1:0]\
    \ sc\n);\n\n// instantiate test module here\n\nendmodule\n\n```\nUpvotes: 1 username_2:\
    \ > \n> How can I use multiple fields of a struct in a Verilog module instantiation\
    \ without creating multiple modules?\n> \n> \n> \n\nUse a [package](https://design-examples.readthedocs.io/en/latest/design_examples/design_examples/verilog_code_examples/basic_examples/basic_packages/basic_packages.html)\
    \ for this.  \n\nThis is a good way to group modules together that perform similar\
    \ functions.\n\n> \n> How can I pass multiple fields of a struct to a Verilog\
    \ module?\n> \n> \n> \n\nYou put them together in a struct.  \n\nYou can pass\
    \ a struct to a module.\n\n> \n> When I try to instantiate the struct, the fields\
    \ cannot be accessed inside the struct!\n> \n> \n> \n\nThis is not true of structs\
    \ in Verilog.\nYou can access them inside the struct with `din.a`, `din.b`, etc.\n\
    \n> \n> Why does this happen?\n> \n> \n> \n\nYour module is a functional unit,\
    \ and the inputs are the same data type as the outputs.  \n\nThis is not the case\
    \ with a struct.  \n\nThe inputs and outputs of a module are not the same data\
    \ type.  \n\nAn error is thrown when this happens.\n\nIt is possible to assign\
    \ a struct to a struct.\n\n```\nstruct io {\n    logic a, b, c;\n    logic [3:0]\
    \ string;\n};\n\nstruct io din, dout;\n\ndin.a = bit_or_fr_rl(0,0,0);\ndin.b =\
    \ bit_or_fr_rl(0,1,1);\ndin.c = bit_or_fr_rl(1,0,1);\n\ndout.a = din.a;\ndout.b\
    \ = din.b;\ndout.c = din.c;\ndout.string = din.string;\n\n```\n\nYou can not assign\
    \ a struct to a logic, as the data types are not equal.\nUpvotes: 3 [selected_answer]"
- code: |-
    module andfr_tst(DIn, DOut); // Testbench for OR gate with force/release
      reg b,c; wire a;

      // Inputs and outputs to be packed into a structure
      struct packed_data_in {logic f0; logic f1; logic f2; logic f3; logic f4; logic f5; logic f6; logic f7;} DIn;
      struct packed_data_in DIn_f;
      struct packed_data_in DIn_r;
      struct packed_data_out {logic f0; logic f1; logic f2; logic f3; logic f4; logic f5; logic f6; logic f7;} DOut;

      // Pack the inputs into a structure
      assign DIn_f.f0 = DIn.f0;
      assign DIn_f.f1 = DIn.f1;
      assign DIn_f.f2 = DIn.f2;
      assign DIn_f.f3 = DIn.f3;
      assign DIn_f.f4 = DIn.f4;
      assign DIn_f.f5 = DIn.f5;
      assign DIn_f.f6 = DIn.f6;
      assign DIn_f.f7 = DIn.f7;

      assign DIn_r.f0 = DIn.r0;
      assign DIn_r.f1 = DIn.r1;
      assign DIn_r.f2 = DIn.r2;
      assign DIn_r.f3 = DIn.r3;
      assign DIn_r.f4 = DIn.r4;
      assign DIn_r.f5 = DIn.r5;
      assign DIn_r.f6 = DIn.r6;
      assign DIn_r.f7 = DIn.r7;

      // Instantiate the module containing force/release
      and_fr_rl dd(a,b,c,DIn_f,DIn_r,DOut);
    endmodule
    ### Expected Results:
    All outputs should be logic 1.

    ---

    ## Task 5
- code: |-
    ```verilog
    or_fr_rl dd(a,b,c); // Instantiate the module containing force/release
    module or_fr_rl(DataIn, DataOut); // Module containing force/release
      reg b,c; wire a;
      always @(a or b) begin // Change the order of the outputs to allow for easier testing
        DataOut.logic = a xor b; // Assign the logic value to the 'logic' field
        DataOut.str = '01001100; // Assign the string value to the'str' field
        #20 $stop; // Stop the simulation after 20 time units
      end
    endmodule
    ```
    ### Generated Testbench Code:
    ```verilog
    or_fr_rl tb(data_in, data_out); // Instantiate the generated testbench code
    module or_fr_rl(DataIn, DataOut); // Module containing force/release
      reg b,c; wire a;
      always @(a or b) begin // Change the order of the outputs to allow for easier testing
        DataOut.logic = a xor b; // Assign the logic value to the 'logic' field
        DataOut.str = '01001100; // Assign the string value to the'str' field
        #20 $stop; // Stop the simulation after 20 time units
      end
      or_fr_rl dd(data_in, b, c); // Instantiate the module containing force/release
    endmodule
    ```
    ### Testbench Output:
    ```verilog
    #  20
    #  40
    #  80
    # 160
    DATA_IN: DATA_IN = '001'b
    DATA_IN: DATA_OUT = DATA_IN = '001'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '010'b
    DATA_IN: DATA_OUT = DATA_IN = '010'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '100'b
    DATA_IN: DATA_OUT = DATA_IN = '100'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '111'b
    DATA_IN: DATA_OUT = DATA_IN = '111'b
    ```
    ### Expected Output:
    ```verilog
    #  20
    #  40
    #  80
    # 160
    DATA_IN: DATA_IN = '001'b
    DATA_IN: DATA_OUT = DATA_IN = '001'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '010'b
    DATA_IN: DATA_OUT = DATA_IN = '010'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '100'b
    DATA_IN: DATA_OUT = DATA_IN = '100'b

    # 180
    # 360
    # 720
    # 1440
    DATA_IN: DATA_IN = '111'b
    DATA_IN: DATA_OUT = DATA_IN = '111'b
    ```
    #include <stdio.h>
    #include <stdlib.h>

    int main(int argc, char **argv) {
      FILE *fptr;
      char *line = NULL;
      size_t n = 0;
      char *filename = argv[1];
      fptr = fopen(filename, "r");
      if (fptr == NULL) {
        printf("Unable to open file.\n");
        exit(EXIT_FAILURE);
      }
      printf("File opened successfully.\n");
      while (getline(&line, &n, fptr)!= -1) {
        printf("%s", line);
      }
      fclose(fptr);
      free(line);
      return 0;
    }
    #include "systemc.h"

    SC_MODULE(or_fr_rl) {
      sc_in<bool> DataIn;
      sc_out<bool> DataOut;
      sc_signal<bool> b, c, d, f, r;
      sc_clock clk("clk", 50, SC_NS);
      void or_fr_rl_func();
      SC_CTOR(or_fr_rl) {
        SC_THREAD(or_fr_rl_func);
        sensitive << clk.pos();
      }
    };

    void or_fr_rl::or_fr_rl_func() {
      d = DataIn;
      b = DataIn;
      c =!DataIn;
      f = c & d; // Force the signal to 1
      r = c &!d; // Release the signal
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      while(true) {
        wait();
        d = DataIn;
        b = DataIn;
        c =!DataIn;
        f = c & d; // Force the signal to 1
        r = c &!d; // Release the signal
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
    }
    #include "or_fr_rl.hpp"

    SC_MODULE(or_fr_rl) {
      sc_signal<struct DataIn, struct DataOut> DataIn;
      sc_out<struct DataIn, struct DataOut> DataOut;
      sc_signal<bool> b, c, d, f, r;
      sc_clock clk("clk", 50, SC_NS);
      void or_fr_rl_func();
      SC_CTOR(or_fr_rl) {
        SC_THREAD(or_fr_rl_func);
        sensitive << clk.pos();
      }
    };

    void or_fr_rl::or_fr_rl_func() {
      d = DataIn.logic;
      b = DataIn.logic;
      c = DataIn.logic;
      f = c & d; // Force the signal to 1
      r = c &!d; // Release the signal
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
      while(true) {
        wait();
        d = DataIn.logic;
        b = DataIn.logic;
        c = DataIn.logic;
        f = c & d; // Force the signal to 1
        r = c &!d; // Release the signal
      }
      for (int i = 0; i < 15; i++) {
        wait();
      }
    }
    ## Verilog Testbench Design

    - **Input:** two inputs, `a` and `b`, of the same width and of a type of `logic`.
    - **Output:** an output, `c`, of the same width, of type `logic`, and a second output, `d`, of exactly the same type as `c`, where `d` is identical to `c` except flipped.
    #include <stdio.h>
    #include <stdlib.h>

    int main() {
      char *s1 = "Hello World!";
      char *s2 = "Hello World!";
      char *s3 = "Hello World!";
      char *s4 = "Hello World!";
      char *s5 = "Hello World!";
      char *s6 = "Hello World!";
      char *s7 = "Hello World!";
      char *s8 = "Hello World!";
      char *s9 = "Hello World!";
      char *s10 = "Hello World!";
      char *s11 = "Hello World!";
      char *s12 = "Hello World!";
      char *s13 = "Hello World!";
      char *s14 = "Hello World!";
      char *s15 = "Hello World!";
      char *s16 = "Hello World!";
      char *s17 = "Hello World!";
      char *s18 = "Hello World!";
      char *s19 = "Hello World!";
      char *s20 = "Hello World!";
      char *s21 = "Hello World!";
      char *s2
- code: |-
    module xor_fr_rl; // Data Flow Control Module with Force and Release
      input a,b;
      input c;
      output o;
      wire a_f;
      wire a_r;
      unpacked struct dIn {logic a,b,c; logic [7:0] f,r;} dIn;
      unpacked struct dOut {logic a,b,c; logic [7:0] f,r;} dOut;
      dataIn dIn; dataOut dOut;
      dIn.a = 1'b0; dIn.a = 1'b1; dIn.c = 1'b1; dIn.f = 102; dIn.r = 204;
      dOut.f = dIn.f; dOut.r = dIn.r;
      xor_fr_rl xor (
       .a(dIn),
       .b(dIn),
       .c(dIn),
       .o(o),
       .a_f(a_f),
       .a_r(a_r)
      );
      force a_f;
      release a_r;
      force b_f;
      release b_r;
      force c_f;
      release c_r;
      initial a_f = '1;
      initial a_r = '0;
      initial b_f = '1;
      initial b_r = '0;
      initial c_f = '1;
      initial c_r = '0;

    endmodule

    ## 5.10.12.5. mux_fr_rl

    ### Base Verilog Code:
    module mux_fr_rl;
      input a,b;
      input c;
      output o;
      localparam f = 102;
      localparam r = 204;
      wire a_f;
      wire a_r;
      wire b_f;
      wire b_r;
      wire c_f;
      wire c_r;
      mux_fr_rl mux_fr (
       .a(a),
       .b(b),
       .c(c),
       .o(o),
       .a_f(a_f),
       .a_r(a_r),
       .b_f(b_f),
       .b_r(b_r),
       .c_f(c_f),
       .c_r(c_r)
      );
      force a_f;
      release a_r;
      force b_f;
      release b_r;
      force c_f;
      release c_r;
      initial a_f = '1;
      initial a_r = '0;
      initial b_f = '1;
      initial b_r = '0;
      initial c_f = '1;
      initial c_r = '0;

    endmodule
    ### Variation Instruction:
    Change DataIn
- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
    ### Test Instruction:
    s<a,b> = 2'b00;  // unsigned
    s<a,b> = 2'b01;  // signed
    s<a,b> = 2'b10;  // unsigned
    s<a,b> = 2'b11;  // signed
    ### Test Results:
    | Test Case  | Pass/Fail | Result |
    | --------   | --------  | ------ |
    | s<a,b> = 2'b00 | Passed | s20 59 65 2 |
    | s<a,b> = 2'b01 | Passed | s35 4 65 2 |
    | s<a,b> = 2'b10 | Passed | s20 59 65 2 |
    | s<a,b> = 2'b11 | Passed | s35 4 65 2 |
    /Week-1/README.md
    # Week One

    ## VCS Code Base

    ### Base Code:
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule

    ### Variation Instruction:
    Add a test harness to your design where you will generate the test vector file, the test bench, and a test driver for the ALU module
- code: |-
    module ALU (output [31:0] Result, input [31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
        (ArgA, ArgB) ='s(ArgA, ArgB);
    endspecify
    endmodule


    ## DUT Parameters
    The DUT (Design Under Test) is a top level module comprised of the ALU, the ALU Testbench, and the ALU Testbench Testbench. The top level module is used to instantiate the 3 different ALU variants as well as the Testbench. The Testbench is used to test the top level module, specifically to run the 3 different tests and also to generate the test case parameters. The Testbench does not include the top level module. The ALU has 6 input signals and one output signal. The ALU output signal is 32 bits and has a time to rise and time to fall attributes of 5 and 4 clock cycles respectively. The ALU input signals have time to rise attributes of 10 and 2 clock cycles respectively.

    ## Testbench Parameters
    The testbench is comprised of the same 6 input signals found in the DUT and their respective time to rise and time to fall attributes. The testbench has the following input signals: ArgA, ArgB, CLK, Reset_N, and Test_N.

    The following input signals have time to rise attributes of 10 and 2 clock cycles respectively.

    ArgA has a time to rise attribute of 10 clock cycles.

    ArgB has a time to rise attribute of 2 clock cycles.

    CLK has a time to rise attribute of 5 clock cycles.

    Reset_N has a time to rise attribute of 5 clock cycles.

    Test_N has a time to rise attribute of 5 clock cycles.

    The following input signals have time to fall attributes of 10 and 2 clock cycles respectively.

    ArgA has a time to fall attribute of 10 clock cycles.

    ArgB has a time to fall attribute of 2 clock cycles.

    CLK has a time to fall attribute of 5 clock cycles.

    Reset_N has a time to fall attribute of 5 clock cycles.

    Test_N has a time to fall attribute of 5 clock cycles.

    The following 6 registers are used in the testbench:

    Reg_Clk has a reset value of 0.

    Reg_RST has a reset value of 0.

    Reg_TST has a reset value of 0.

    Reg_A has a reset value of 0.

    Reg_B has a reset value of 0.

    Reg_CLK has a reset value of 0.

    The testbench has a clock signal, CLK, that is used to generate the 3 different variations of the ALU. The clock signal has a time to rise of 1 clock cycle.

    The testbench has 2 reset signals, Reset_N and Test_N. The Test_N signal is used to generate the 3 different variations of the ALU. The Test_N signal has a time to rise of 5 clock cycles. The Test_N signal has a time to fall of 5 clock cycles. The reset signal is used to reset the registers and to start the tests. The Reset_N signal has a time to rise of 5 clock cycles. The Reset_N signal has a time to fall of 5 clock cycles.

    ## Testbench Description
    The testbench follows the same steps as in the lecture notes:

    1. Reset the registers to their reset values.

    2. Set the Test_N signal to 0.

    3. Set the Reset_N signal to 0.

    4. Set the Reset_N signal to 1. Wait 5 clock cycles.

    5. Set the Reset_N signal to 0.

    6. Set the Reset_N signal to 1. Wait 5 clock cycles.

    7. Set the Reset_N signal to 0.

    8. Set the ArgA input signal to 0.

    9. Set the ArgB input signal to 0.

    10. Wait for the ArgA input signal to fall.

    11. Set the ArgA input signal to 1.

    12. Set the ArgB input signal to 1.

    13. Wait for the ArgA and ArgB input signals to rise.

    14. Set the Test_N signal to 1. Wait 5 clock cycles.

    15. Set the Test_N signal to 0.

    16. Set the Reset_N signal to 1. Wait 5 clock cycles.

    17. Set the Reset_N signal to 0.

    The testbench also generates the test cases that will be run. The test cases are created by:

    1. Setting the ArgA and ArgB input signals to 0.

    2. Setting the Test_N signal to 1. Wait 5 clock cycles.

    3. Setting the Test_N signal to 0.

    4. Setting the Reset_N signal to 1. Wait 5 clock cycles.

    5. Setting the Reset_N signal to 0.

    6. Setting the ArgA and ArgB input signals to 1.

    7. Setting the Test_N signal to 1. Wait 5 clock cycles.

    8. Setting the Test_N signal to 0.

    9. Setting the Reset_N signal to 1. Wait 5 clock cycles.

    10. Setting the Reset_N signal to 0.

    11. Setting the ArgA and ArgB input signals to 1.

    12. Setting the Test_N signal to 1. Wait 5 clock cycles.

    13. Setting the Test_N signal to 0.

    14. Setting the Reset_N signal to 1. Wait 5 clock cycles.

    15. Setting the Reset_N signal to 0.

    For each of the 12 test cases, the testbench will generate 12 different variations of the ALU by modifying the ArgA and ArgB input signals in a specific manner. To generate the first variation of the ALU, the user must set the ArgA and ArgB input signals to 0.

    To generate the second variation of the ALU, the user must set the ArgA and ArgB input signals to -0.

    To generate the third variation of the ALU, the user must set the ArgA and ArgB input signals to 1.

    To generate the fourth variation of the ALU, the user must set the ArgA and ArgB input signals to -1.

    To generate the fifth variation of the ALU, the user must set the ArgA and ArgB input signals to -1.

    To generate the sixth variation of the ALU, the user must set the ArgA and ArgB input signals to 1.

    To generate the seventh variation of the ALU, the user must set the ArgA and ArgB input signals to -1.

    To generate the eighth variation of the ALU, the user must set the ArgA and ArgB input signals to 0.

    To generate the ninth variation of the ALU, the user must set the ArgA and ArgB input signals to 0.

    To generate the tenth variation of the ALU, the user must set the ArgA and ArgB input signals to 1.

    To generate the eleventh variation of the ALU, the user must set the ArgA and ArgB input signals to 1.

    To generate the twelfth variation of the ALU, the user must set the ArgA and ArgB input signals to 1.

    The testbench will have the following functions:

    void ALUFunc(void);
    void ALUFunc_Signed_Addition(void);
    void ALUFunc_Signed_Subtraction(void);
    void ALUFunc_Signed_Multiplication(void);

    The ALUFunc function is a wrapper function that will call the 3 different ALU functions depending on the value of the Test_N signal. The ALUFunc function has an if and else if statement that checks if the Test_N signal is 0, 1, or 2. If the Test_N signal is 0, the ALUFunc function will call the ALUFunc_Signed_Addition function. Otherwise if the Test_N signal is 1, the ALUFunc function will call the ALUFunc_Signed_Subtraction function. Otherwise if the Test_N signal is 2, the ALUFunc function will call the ALUFunc_Signed_Multiplication function.

    The ALUFunc_Signed_Addition function is used to add two signed numbers.

    The ALUFunc_Signed_Subtraction function is used to subtract two signed numbers.

    The ALUFunc_Signed_Multiplication function is used to multiply two signed numbers.

    The testbench will have the following functions:

    void ALUFunc(void);
    void ALUFunc_Signed_Addition(void);
    void ALUFunc_Signed_Subtraction(void);
    void ALUFunc_Signed_Multiplication(void);

    The
- code: |-
    module Test (inout a, inout b, inout c);
    (a -> b) =
- code: |-
    module ALU (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
    generate if(ArgA > ArgB) begin:
    end
    ### Test Bench:
    module TestBench();

    Logic signed [3:0] arg1, arg2;
    Logic [3:0] expected;

    -- Test data for the ALU Module --
    initial begin
        arg1 = 5'b0101;
        arg2 = 5'b1010;

        expected = 5'b0001;
    end

    -- Instantiate the ALU module under test, Test ALU --
    ALU test_alu(
       .Result(arg1),
       .ArgA(arg2),
       .ArgB(arg2)
        );
    endmodule


    ### Test Result:

    The test failed showing the expected result was 5'b0001 and the result was 5'b0010.
    The test was successful.
    /Lab4E/Lab4E.md
    ## Lab
- code: |-
    .
    ### Notes:
    1.  The timing annotation is still correct.
    2.  The code in the
- code: |-
    module ALU #(parameter WIDTH = 32) (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
    ### Expected Results:
    The expected results are as follows:
    ```
    ### Test Results:
    Test passed.
    ```


    ### Test 281

    ```
    module ALU #(parameter WIDTH = 32) (output[WIDTH-1:0] Result, input[WIDTH-1:0] ArgA, ArgB, input Clk);
    specify
        specparam tRise = 5, tFall = 4;
        (Clk *> Result) = (tRise, tFall);
    endspecify
    endmodule
    ### Variation Instruction:
    Convert inputs
- code: |-
    ```vhdl
    library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

    entity ALU is
      port (ArgA: in std_logic_vector(31 down 0);
            ArgB: in std_logic_vector(31 down 0);
            Clk: in std_logic;
            Result: out std_logic_vector(31 down
- code: "module ALU (output[31:0] Result, input[31:0] ArgA, signed [31:0] ArgB, input\
    \ Clk);\nspecify\n    specparam tRise = 5, tFall = 4;\n    (Clk *> Result) = (tRise,\
    \ tFall);\nendspecify\nendmodule\n```\n\n#### Example 2: Signed Arithmetic Operations\n\
    The following verilog code shows signed addition and subtraction in action.\n\n\
    ```verilog\nmodule ALU_SignedAddSub (output[31:0] Result, input[31:0] ArgA, ArgB,\
    \ input Clk);\n\tassign Result = ArgA + ArgB;\nendmodule\n```\n\nThe following\
    \ verilog code shows signed multiplication in action.\n\n```verilog\nmodule ALU_SignedMul\
    \ (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\n\tassign Result =\
    \ ArgA * ArgB;\nendmodule\n```\n\nThe following verilog code shows signed division\
    \ in action.\n\n```verilog\nmodule ALU_SignedDiv (output[31:0] Result, input[31:0]\
    \ ArgA, ArgB, input Clk);\n\tassign Result = ArgA / ArgB;\n\talways @(posedge\
    \ Clk) begin\n\t\tif (ArgB > 0x7fffffff) Result <= -32768; // Max negative signed\
    \ number = -32768\n\tend\nendmodule\n```\n\nThe following code gives the complete\
    \ working verilog code for signed arithmetic with an example testbench.\n```verilog\n\
    module ALU_SignedAddSub (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\n\
    \tassign Result = ArgA + ArgB;\nendmodule\n\nmodule ALU_SignedMul (output[31:0]\
    \ Result, input[31:0] ArgA, ArgB, input Clk);\n\tassign Result = ArgA * ArgB;\n\
    endmodule\n\nmodule ALU_SignedDiv (output[31:0] Result, input[31:0] ArgA, ArgB,\
    \ input Clk);\n\tassign Result = ArgA / ArgB;\n\talways @(posedge Clk) begin\n\
    \t\tif (ArgB > 0x7fffffff) Result <= -32768; // Max negative signed number = -32768\n\
    \tend\nendmodule\n\nmodule ALU; // Combinational\n\tinput clk, a_signed, b_signed;\n\
    \toutput [31:0] result_signed;\n\tinput [31:0] a, b;\n\twire [31:0] result_logic;\n\
    \tALU_SignedAddSub addition;\n\tALU_SignedMul multiplication;\n\tALU_SignedDiv\
    \ division;\n\tassign a_signed = a[31];\n\tassign b_signed = b[31];\n\tassign\
    \ result_logic = a_signed? addition.Result : multiplication.Result;\n\tassign\
    \ result_signed = result_logic [31:0];\n\tALU_SignedAddSub addition (.ArgA (a),.ArgB\
    \ (b),.Clk(clk));\n\tALU_SignedMul multiplication (.ArgA (a),.ArgB (b),.Clk(clk));\n\
    \tALU_SignedDiv division (.ArgA (a),.ArgB (b),.Clk(clk));\nendmodule\n\nmodule\
    \ tb_ALU;\n\tinitial begin\n\t\t$monitor(\"ALU Output: %b\", $value$plusargs(\"\
    Result\", result_signed));\n\tend\n\treg clk;\n\treg [31:0] a, b;\n\twire [31:0]\
    \ result_signed;\n\treg [31:0] result_logic;\n\twire a_signed, b_signed;\n\tALU\
    \ addsub (.ArgA (a),.ArgB (b),.Clk(clk));\n\tALU multiplication (.ArgA (a),.ArgB\
    \ (b),.Clk(clk));\n\tALU division (.ArgA (a),.ArgB (b),.Clk(clk));\n\tALU ALU1(.result_logic(result_logic),.a(a),.b(b),.clk(clk));\n\
    \tALU_SignedAddSub addition;\n\tALU_SignedMul multiplication;\n\tALU_SignedDiv\
    \ division;\n\tALU ALU2 (.result_signed(result_signed),.a(a),.b(b),.clk(clk),.a_signed(a_signed),.b_signed(b_signed));\n\
    \n\talways begin\n\t\tclk <= ~clk;\n\t\t#5;\n\t\ta <= 4'b0100;\n\t\tb <= 4'b0101;\n\
    \tend\n    \nendmodule\n```\n\n#### Example 3: Signed Arithmetic Operations with\
    \ Testbench\nThe following verilog code shows signed addition and subtraction\
    \ in action.\n```verilog\nmodule ALU_SignedAddSub (output[31:0] Result, input[31:0]\
    \ ArgA, ArgB, input Clk);\n\tassign Result = ArgA + ArgB;\nendmodule\n```\n\n\
    The following verilog code shows signed multiplication in action.\n```verilog\n\
    module ALU_SignedMul (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\n\
    \tassign Result = ArgA * ArgB;\nendmodule\n```\n\nThe following verilog code shows\
    \ signed division in action.\n```verilog\nmodule ALU_SignedDiv (output[31:0] Result,\
    \ input[31:0] ArgA, ArgB, input Clk);\n\tassign Result = ArgA / ArgB;\n\talways\
    \ @(posedge Clk) begin\n\t\tif (ArgB > 0x7fffffff) Result <= -32768; // Max negative\
    \ signed number = -32768\n\tend\nendmodule\n```\n\nThe following code gives the\
    \ complete working verilog code for signed arithmetic with an example testbench.\n\
    ```verilog\nmodule ALU_SignedAddSub (output[31:0] Result, input[31:0] ArgA, ArgB,\
    \ input Clk);\n\tassign Result = ArgA + ArgB;\nendmodule\n\nmodule ALU_SignedMul\
    \ (output[31:0] Result, input[31:0] ArgA, ArgB, input Clk);\n\tassign Result =\
    \ ArgA * ArgB;\nendmodule\n\nmodule ALU_SignedDiv (output[31:0] Result, input[31:0]\
    \ ArgA, ArgB, input Clk);\n\tassign Result = ArgA / ArgB;\n\talways @(posedge\
    \ Clk) begin\n\t\tif (ArgB > 0x7fffffff) Result <= -32768; // Max negative signed\
    \ number = -32768\n\tend\nendmodule\n\nmodule ALU; // Combinational\n\tinput clk,\
    \ a_signed, b_signed;\n\toutput [31:0] result_signed;\n\tinput [31:0] a, b;\n\t\
    wire [31:0] result_logic;\n\tALU_SignedAddSub addition;\n\tALU_SignedMul multiplication;\n\
    \tALU_SignedDiv division;\n\tassign a_signed = a[31];\n\tassign b_signed = b[31];\n\
    \tassign result_logic = a_signed? addition.Result : multiplication.Result;\n\t\
    assign result_signed = result_logic [31:0];\n\tALU_SignedAddSub addition (.ArgA\
    \ (a),.ArgB (b),.Clk(clk));\n\tALU_SignedMul multiplication (.ArgA (a),.ArgB (b),.Clk(clk));\n\
    \tALU_SignedDiv division (.ArgA (a),.ArgB (b),.Clk(clk));\nendmodule\n\nmodule\
    \ tb_ALU;\n\tinitial begin\n\t\t$monitor(\"ALU Output: %b\", $value$plusargs(\"\
    Result\", result_signed));\n\t\t$monitor(\"ALU Output: %b\", $value$plusargs(\"\
    Result\", unsigned(result_signed)));\n\tend\n\treg clk;\n\treg [31:0] a, b;\n\t\
    wire [31:0] result_signed;\n\treg [31:0] result_logic;\n\twire a_signed, b_signed;\n\
    \tALU addsub (.ArgA (a),.ArgB (b),.Clk(clk));\n\tALU multiplication (.ArgA (a),.ArgB\
    \ (b),.Clk(clk));\n\tALU division (.ArgA (a),.ArgB (b),.Clk(clk));\n\tALU ALU1(.result_logic(result_logic),.a(a),.b(b),.clk(clk));\n\
    \tALU_SignedAddSub addition;"
- code: |-
    module FSM (output[1:0] Q, input[1:0] D, input Clk);
    specify
        specparam tRise = 2, tFall = 2;
        (Clk *> (logic[1:0] Q)) = (tRise, tFall);
    endspecify
    endmodule
    /lab2/lab2.py
    import sys
    import re

    def main():
        if len(sys.argv) < 2:
            usage()
        if not (sys.argv[1] == 'c'):
            print('Invalid command provided')
            sys.exit()
        with open('sim_log.txt') as f:
            for line in f:
                if not (re.search(r'Time\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s
- code: "module ALU (output[31:0] Result, input[31:0] a, b, input Clk);\n\tlocalparam\
    \ signed [31:0] a = a;\n    localparam signed [31:0] b = b;\n\tspecify\n    specparam\
    \ tRise = 5, tFall = 4;\n    (Clk *> Result) = (tRise, tFall);\nendspecify\nendmodule\n\
    \n### Base Verilog Code:\nmodule ALU (output[31:0] Result, input[31:0] ArgA, ArgB,\
    \ input Clk);\nspecify\n    specparam tRise = 5, tFall = 4;\n    (Clk *> Result)\
    \ = (tRise, tFall);\nendspecify\nendmodule"
- code: "module show_aa(ao,ai); // NOT gate with delay 2\n  output ao; input ai; wire\
    \ ao, ai;\n  \n  not #2 (ao,ai);\nendmodule\n\"\n\ndef test_2():\n    print \"\
    test 2\"\n    assert False\n\n\nif __name__ == \"__main__\":\n    test_1()\n \
    \   test_2()\n/test/code-gen/verilog/not-1.py\n# Copyright 2017-2018 The PyhDI\
    \ Authors\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\"\
    );\r\n# you may not use this file except in compliance with the License.\r\n#\
    \ You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\
    \n#\r\n# Unless required by applicable law or agreed to in writing, software\r\
    \n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the\
    \ License for the specific language governing permissions and\r\n# limitations\
    \ under the License.\r\n#\r\n#\r\n# Author: \r\n# Date: 2017-09-22\r\n#\r\n\r\n\
    \"\"\"\r\nTests of PyhDI with Verilog target\r\n\"\"\"\r\n\r\nfrom veriloggen\
    \ import *\r\n\r\ndef test_1():\r\n    print \"test 1\"\r\n    print \"### Base\
    \ Verilog Code: \"\r\n    print \"\"\"\r\nmodule show_aa(ao,ai);\r\n  output ao;\
    \ input ai;\r\n  not #2 (ao,ai);\r\nendmodule\r\n### Variation Instruction:\r\n\
    Change A and B from logic to packed enums with default and non-default values\
    \ to test enum-based inputs.\r\n### Modified Code:\r\n\"\"\"\r\n    \r\n    print_verilog(show_aa(),filename=\"\
    show_aa.v\")\r\n    assert False\r\n\r\ndef test_2():\r\n    print \"test 2\"\r\
    \n    assert False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1()\r\n\
    \    test_2()\r\n/test/code-gen/verilog/subr-4.py\n# Copyright 2017-2018 The PyhDI\
    \ Authors\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\"\
    );\r\n# you may not use this file except in compliance with the License.\r\n#\
    \ You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\
    \n#\r\n# Unless required by applicable law or agreed to in writing, software\r\
    \n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the\
    \ License for the specific language governing permissions and\r\n# limitations\
    \ under the License.\r\n#\r\n#\r\n# Author: \r\n# Date: 2017-09-22\r\n#\r\n\r\n\
    \"\"\"\r\nTests of PyhDI with Verilog target\r\n\"\"\"\r\n\r\nfrom veriloggen\
    \ import *\r\n\r\ndef test_1():\r\n    print \"test 1\"\r\n    print \"### Base\
    \ Verilog Code: \"\r\n    print \"\"\"\r\nmodule show_aa(ao,ai);\r\n  output ao;\
    \ input ai;\r\n  not #2 (ao,ai);\r\nendmodule\r\n### Variation Instruction:\r\n\
    Change A and B from logic to packed enums with default and non-default values\
    \ to test enum-based inputs.\r\n### Modified Code:\r\n\"\"\"\r\n    \r\n    print_verilog(show_aa(),filename=\"\
    show_aa.v\")\r\n    assert False\r\n\r\ndef test_2():\r\n    print \"test 2\"\r\
    \n    assert False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1()\r\n\
    \    test_2()\r\n/test/code-gen/verilog/subr-10.py\n# Copyright 2017-2018 The\
    \ PyhDI Authors\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the\
    \ \"License\");\r\n# you may not use this file except in compliance with the License.\r\
    \n# You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\
    \n#\r\n# Unless required by applicable law or agreed to in writing, software\r\
    \n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the\
    \ License for the specific language governing permissions and\r\n# limitations\
    \ under the License.\r\n#\r\n#\r\n# Author: \r\n# Date: 2017-09-22\r\n#\r\n\r\n\
    \"\"\"\r\nTests of PyhDI with Verilog target\r\n\"\"\"\r\n\r\nfrom veriloggen\
    \ import *\r\n\r\ndef test_1():\r\n    print \"test 1\"\r\n    print \"### Base\
    \ Verilog Code: \"\r\n    print \"\"\"\r\nmodule show_aa(ao,ai);\r\n  output ao;\
    \ input ai;\r\n  not #2 (ao,ai);\r\nendmodule\r\n### Variation Instruction:\r\n\
    Change A and B from logic to packed enums with default and non-default values\
    \ to test enum-based inputs.\r\n### Modified Code:\r\n\"\"\"\r\n    \r\n    print_verilog(show_aa(),filename=\"\
    show_aa.v\")\r\n    assert False\r\n\r\ndef test_2():\r\n    print \"test 2\"\r\
    \n    assert False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1()\r\n\
    \    test_2()\r\n/test/code-gen/verilog/subr-7.py\n# Copyright 2017-2018 The PyhDI\
    \ Authors\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\"\
    );\r\n# you may not use this file except in compliance with the License.\r\n#\
    \ You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\
    \n#\r\n# Unless required by applicable law or agreed to in writing, software\r\
    \n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the\
    \ License for the specific language governing permissions and\r\n# limitations\
    \ under the License.\r\n#\r\n#\r\n# Author: \r\n# Date: 2017-09-22\r\n#\r\n\r\n\
    \"\"\"\r\nTests of PyhDI with Verilog target\r\n\"\"\"\r\n\r\nfrom veriloggen\
    \ import *\r\n\r\ndef test_1():\r\n    print \"test 1\"\r\n    print \"### Base\
    \ Verilog Code: \"\r\n    print \"\"\"\r\nmodule show_aa(ao,ai);\r\n  output ao;\
    \ input ai;\r\n  not #2 (ao,ai);\r\nendmodule\r\n### Variation Instruction:\r\n\
    Change A and B from logic to packed enums with default and non-default values\
    \ to test enum-based inputs.\r\n### Modified Code:\r\n\"\"\"\r\n    \r\n    print_verilog(show_aa(),filename=\"\
    show_aa.v\")\r\n    assert False\r\n\r\ndef test_2():\r\n    print \"test 2\"\r\
    \n    assert False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1()\r\n\
    \    test_2()\r\n/test/code-gen/verilog/subr-9.py\n# Copyright 2017-2018 The PyhDI\
    \ Authors\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\"\
    );\r\n# you may not use this file except in compliance with the License.\r\n#\
    \ You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\
    \n#\r\n# Unless required by applicable law or agreed to in writing, software\r\
    \n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the\
    \ License for the specific language governing permissions and\r\n# limitations\
    \ under the License.\r\n#\r\n#\r\n# Author: \r\n# Date: 2017-09-22\r\n#\r\n\r\n\
    \"\"\"\r\nTests of PyhDI with Verilog target\r\n\"\"\"\r\n\r\nfrom veriloggen\
    \ import *\r\n\r\ndef test_1():\r\n    print \"test 1\"\r\n    print \"### Base\
    \ Verilog Code: \"\r\n    print \"\"\"\r\nmodule show_aa(ao,ai);\r\n  output ao;\
    \ input ai;\r\n  not #2 (ao,ai);\r\nendmodule\r\n### Variation Instruction:\r\n\
    Change A and B from logic to packed enums with default and non-default values\
    \ to test enum-based inputs.\r\n### Modified Code:\r\n\"\"\"\r\n    \r\n    print_verilog(show_aa(),filename=\"\
    show_aa.v\")\r\n    assert False\r\n\r\ndef test_2():\r\n    print \"test 2\"\r\
    \n    assert False\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    test_1()\r\n\
    \    test_2"
- code: |-
    module inst_flop(a,d,s,q);
      input a, b, c;
      output d, q;

      typedef enum logic [1:0] { DEFAULT, NON_DEFAULT } my_enum;

      packed struct my_struct {
        my_enum A, B;
      } default_input_str, non_default_input_str;

      default_input_str default_input_str_inst =.A(DEFAULT),.B(NON_DEFAULT);
      non_default_input_str non_default_input_str_inst =.A(NON_DEFAULT),.B(DEFAULT);

      assign d = b | c;
      assign q = a & d;
    endmodule

    ## Module instantiation as a block
    // Copyright lowRISC contributors.
    // Licensed under the Apache License, Version 2.0, see LICENSE for details.
    // SPDX-License-Identifier: Apache-2.0

    use crate::ast::*;
    use crate::error::Error;
    use crate::position::Pos;
    use crate::token::{Token, TokenKind};

    /// The scanner produces tokens matching the grammar.
    pub struct Scanner<'a> {
        // The source code to be tokenized.
        src: &'a str,

        // The location of the current token within `src`.
        pos: Pos,

        // The next token to be returned.
        tok: Token<'a>,

        // The next token to be generated.
        next: Token<'a>,
    }

    /// Helper struct for lexical analysis.
    struct Analyze<'a> {
        pos: Pos,
        tok: Token<'a>,
    }

    impl<'a> Analyze<'a> {
        /// Creates a new `Analyze` object.
        fn new(pos: Pos, tok: Token<'a>) -> Self {
            Analyze { pos, tok }
        }

        /// Consumes this `Analyze` object and generates the next token.
        fn next(&mut self, src: &'a str) -> Option<Token<'a>> {
            self.tok = self.tok.next(src)?;
            Some(self.tok.clone())
        }
    }

    impl<'a> Scanner<'a> {
        /// Creates a
- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao;
      packed enum{
        A = 1,
        B = 2,
        none = 0,
      } ai;
      wire ao,ai;
      not #2 (ao,ai);
    endmodule
    ```

    For a more complex example, the `not` gate can be used to swap two input variables by using `wire` to declare an aliaed signal, then using `assign` to assign the `not`ed signal to the aliaed signal.  For example, to swap two packed enums, the following code can be used:

    ```verilog
    module show_aa(ao_out,ai_in,ai_out);
      packed enum{A = 1, B = 2, none = 0} ai_in;
      packed enum{A = 1, B = 2, none = 0} ai_out;
      output [1:0] ao_out;
      wire [1:0] ai_out[1:0];

      not #2 (ao_out, ai_out); // ai_out =!ai_out
      assign ai_out[1:0] = ai_in[1:0];
      assign ai_in[1:0] = ai_out[1:0];
    endmodule
    ```

    The `not` gate can be used to swap two variables by using `wire` to declare an aliaed signal, then using `assign` to assign the `not`ed signal to the aliaed signal.  For example, to swap two packed enums, the following code can be used:

    ```verilog
    module show_aa(ao_out,ai_in,ai_out);
      packed enum{A = 1, B = 2, none = 0} ai_in;
      packed enum{A = 1, B = 2, none = 0} ai_out;
      output [1:0] ao_out;
      wire [1:0] ao_in[1:0];

      not #2 (ao_out, ao_in); // ao_in =!ao_in
      assign ao_out[1:0] = ao_in[1:0];
      assign ao_in[1:0] = ao_out[1:0];
    endmodule
    ```

    ### Packing vs. Enum-Packing

    One interesting thing about `packed` enums is that any enum element can be used in a `packed` enum declaration.  By enumering all values except 0, any element can be used in the `packed` enum declaration.  For example,

    ```verilog
    // This is an invalid declaration of packed enum, because 0 is not in the enum list
    packed enum{
        A = 1, B = 2, none = 0
    } ao;
    ```

    However, a packed enum is not limited to only having elements in the enum list.  For example, the code below is valid, because the second element is also in the enum list.

    ```verilog
    packed enum{
        A = 1, B = 2, none = 0
    } ao;
    ```

    ### Packed Enums in Verilog

    As of November 12th, 2014, packed enums are not yet supported by the Bison Verilog parser and the Verilator compiler.  You must use the `packed` keyword when declaring packed enums to make sure that the enum values are packed.  However, this restriction does not apply to the `enum` keyword, which is used to create packed enums.  For example, the following code is valid, but the code below will not compile because the second element is not in the enum list.

    ```verilog
    // This is a valid declaration of packed enum
    packed enum{
        A = 1, B = 2, none = 0
    } ao;
    ```

    ```verilog
    // This is an invalid declaration of packed enum, because second element is not in list
    packed enum{
        A = 1, B = 2
    } ao;
    ```

    ### Caveat: Using Enums in Verilog

    Enums are not natively supported by Verilog.  Because of this, enums must be cast to integers before they can be used in a Verilog testbench or other simulation.  For example, the following code will not compile:

    ```verilog
    module show_aa(ao);
      enum {
        A = 1, B = 2, none = 0
      } ai;
      output ao;
      assign ao = ai;
    endmodule
    ```

    This will not compile because the enum is an uncast enum and cannot be used in a Verilog testbench.  However, the following code will compile because the enum is cast to `int`.

    ```verilog
    module show_aa(ao);
      enum {
        A = 1, B = 2, none = 0
      } ai;
      output ao;
      assign ao = int(ai);
    endmodule
    ```

    ### Casting Enums in Verilog

    Casting enums to integers in Verilog will not work for all cases.  If the enum is not used, then the enum can be cast simply to an integer without issues.  For example, the following code will compile.

    ```verilog
    module show_aa(ao);
      enum {
        A = 1, B = 2, none = 0
      } ai;
      output ao;
      assign ao = int(ai);
    endmodule
    ```

    However, if the enum is used in a testbench, then casting to an integer will not work in all cases.  For example, the following code will not compile, because the enum is used as an output in a testbench.

    ```verilog
    module show_aa(ao);
      enum {
        A = 1, B = 2, none = 0
      } ai;
      output ao;
      assign ao = int(ai);
    endmodule
    ```

    ```verilog
    module show_aa_tb(ao);
      input clk;
      wire ai;
      show_aa(ai,clk,2'b00);
      initial begin
        ai = 1;
      end
      initial begin
        posedge clk begin
          ai = ai + 1;
        end
      end
    endmodule
    ```

    This will not compile because the enum is used as an output in a testbench.  However, this will compile if the enum is not used as an output in a testbench.

    ```verilog
    module show_aa_tb(ao);
      input clk;
      wire ai;
      show_aa(ai,clk,2'b00);
      initial begin
        ai = 1;
      end
      initial begin
        posedge clk begin
          ai = ai + 1;
        end
      end
    endmodule
    ```

    The following code will work because the enum is not used as an output in a testbench.

    ```verilog
    module show_aa_tb(ao);
      input clk;
      wire ai;
      show_aa(ao,clk,2'b00);
      initial begin
        ai = 1;
      end
      initial begin
        posedge clk begin
          ai = ai + 1;
        end
      end
    endmodule
    ```

    ### Packed Enum vs. Non-Packed Enum

    Packed enums are represented as arrays of bits.  Non-packed enums are represented as integers.  As such, the code below will not work, because `non_packed_enum` is not a packed enum type.

    ```verilog
    packed enum{
      A = 1, B = 2, none = 0
    } packed_enum;

    non_packed_enum non_packed_enum;
    ```

    When using the `packed` keyword, the size of an enum can be set by using the `:` character operator.  For example, `show_aa` can be used to show an example of specifying the size of an enum.

    ```verilog
    show_aa(ao, ai, 2'b00);
    show_aa(ao, ai, 3'b00);
    show_aa(ao, ai, 4'b00);
    ```

    If a value is not specified, Verilog will use the default size of an `int` type, which is 32 bits.  For example, `show_aa` can be used to show an example of specifying the size of an enum.

    ```verilog
    show_aa(ao, ai);
    ```

    ### Enums vs. Bit-Vectors

    Enums are different than bit-vectors in that enums can only be assigned `0` or `1` values.  For example, the following code will not compile, because the enum is not assigned a value.

    ```verilog
    enum a; // Compiler Error, cannot have unassigned enums
    ```

    ## 7. Functions

    ### Basic Function

    Verilog functions can only contain input and output ports.  For example, if `add_one` were to be used as a function, the following code will not compile because it has an input port `clk`.

    ```verilog
    module add_one(ao,ai); // Function should not have input ports
      // Function should not have input ports
- code: |-
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai;
      packed bit B;
      B = 1'b0;
      A = 0;
      not #2 (B,ai);
    endmodule
    ### Original Code:
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai;
      packed bit B;
      B = 1'b0;
      A = 0;
      not #2 (B,ai);
    endmodule

    ### Base Verilog Code:
    module show_aa(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ### Variation Instruction:
    Change A and B from logic to packed enums with default and non-default values to test enum-based inputs.
- code: "module show_cc(ao,ai,bo,bi); // NOT gate with delay 2\n  output ao; input\
    \ ai; output bo; input bi;\n  wire [7:0] packed_ai; assign packed_ai = ai;\n \
    \ wire [7:0] packed_bi; assign packed_bi = bi;\n  not #2 (ao,packed_ai);\n  not\
    \ #2 (bo,packed_bi);\nendmodule\n/README.md\n# 121_hw5\n\n**Authors:**,, \n\n\
    **Files:**\n\n* [tests.v](tests.v): contains the instruction set and logic to\
    \ run each instruction\n* [test_scripts/test_all.tcl](test_scripts/test_all.tcl):\
    \ contains the script that tests every test\n* [test_scripts/test_all_sim.tcl](test_scripts/test_all_sim.tcl):\
    \ contains the script that runs the test simulations\n* [test_scripts/test_all_mem.tcl](test_scripts/test_all_mem.tcl):\
    \ contains the script that runs the test memories\n* [test_scripts/test.tcl](test_scripts/test.tcl):\
    \ a script that runs the test simulation for a single test\n* [test_scripts/run_all.sh](test_scripts/run_all.sh):\
    \ a script that runs the test simulation for all tests\n* [test_scripts/run_mem_all.sh](test_scripts/run_mem_all.sh):\
    \ a script that runs the test memory for all tests\n* [test_scripts/run_sim_all.sh](test_scripts/run_sim_all.sh):\
    \ a script that runs all tests\n* [test_scripts/run_all_and_mem.sh](test_scripts/run_all_and_mem.sh):\
    \ a script that runs all tests and their memories\n* [test_scripts/runmem.sh](test_scripts/runmem.sh):\
    \ a script that runs all tests' memories\n* [test_scripts/runsim.sh](test_scripts/runsim.sh):\
    \ a script that runs all tests' memories\n\n**Instructions:**\n\n* To run the\
    \ test, enter `bash <script_name>` (or `bash run_all.sh` with the `.sh` extensions\
    \ removed). \n* To run only the test script, just enter `bash test.tcl` (or `bash\
    \ test.tcl` with the `.tcl` extensions removed) with the name of the test in the\
    \ `test.tcl`. The test scripts will be located in the `test_scripts` folder. \n\
    * To run the test simulations, enter `bash run_sim_all.sh` (or `bash run_sim_all.sh`\
    \ with the `.sh` extensions removed).\n* To run the test memories, enter `bash\
    \ run_mem_all.sh` (or `bash run_mem_all.sh` with the `.sh` extensions removed).\n\
    * To run the test simulations and memories, enter `bash run_all_and_mem.sh` (or\
    \ `bash run_all_and_mem.sh` with the `.sh` extensions removed).\n* To run all\
    \ tests except the memories, enter `bash run_all.sh` (or `bash run_all.sh` with\
    \ the `.sh` extensions removed).\n* To run all memories except the tests, enter\
    \ `bash runmem.sh` (or `bash runmem.sh` with the `.sh` extensions removed).\n\
    * To run the tests' memories, enter `bash run_all_mem.sh` (or `bash run_all_mem.sh`\
    \ with the `.sh` extensions removed).\n* To run the tests' simulations, enter\
    \ `bash run_all_sim.sh` (or `bash run_all_sim.sh` with the `.sh` extensions removed).\n\
    \n**Notes:**\n\n* The test cases are in the `test_scripts` folder. To run a simulation,\
    \ you can copy/paste the base simulation code in `test_scripts/test_mem_base.v`\
    \ into a new file. To run a memory, you can copy/paste the base memory code in\
    \ `test_scripts/test_mem_base.v` into a new file.\n* Each test case is in a `test_<test_type>.v`\
    \ file.\n* You can comment out a test case by putting a `/*` before and after\
    \ the test case in the `tests.v` file."
- code: "module show_aa(ao,ai); // NOT gate with delay 2\n  output ao; input ai;\n\
    \  not #1 packed (ao,ai);\nendmodule\n### Expected Results:\nError: (verilog-vpi)\
    \ \"not#\" statement: the first input is not named and it is not a packed array.\n\
    ### Expected Explanations:\nverilator-vpi does not support mixed-mode enums (i.e.\
    \ non-packed arrays) as the first input.\nThe second input should be a valid packed\
    \ array of one or more bool values.\n### User Action:\nThe user should change\
    \ the implementation of the show_aa module in order to support the mixed-mode\
    \ enums.\nFor example, convert to a single-bit enum, or use an actual packed array\
    \ of one or more bool values.\nIn the case above, the user may decide that the\
    \ packed array of bits is the correct implementation.\n### Additional Resources:\n\
    None\n\n\n/vpi-verilator/README.md\n# VPI Verilator\nThis is a VPI-based implementation\
    \ of the Verilator simulator using the generic VPI interface.\n\n## Requirements:\n\
    In order to run this VPI, a verilator installation including verilator-vpi should\
    \ be present.\nInstallation instructions for verilator-vpi can be found here:\
    \ https://github.com/verilator/verilator-vpi\n\n## Running the VPI:\nTo run the\
    \ VPI, simply run the following command from the root directory of the VPI-Verilator\
    \ repository:\n```\npython3 vpi.py\n```\n\n## Supported Verilator Features:\n\
    The following features are supported by the current implementation:\n\n| Feature\
    \ | Supported | Notes |\n| ------- | --------- | ----- |\n| Module Instantiation\
    \ | \u2705 | Module instances are supported for the most part, however, the verilator\
    \ language does not support the `parameter` keyword. Instead, the parameter definitions\
    \ are embedded directly into the module instance. |\n| Module Ports | \u2705 |\
    \ Input and output ports are treated as ports to the module. In the case of modules\
    \ that are instantiated inside of other modules, the ports are bound to the module\
    \ instance, rather than the module itself. |\n| Module Parameters | \u2705 | Parameter\
    \ definitions are embedded directly into the module definition. |\n| Module Local\
    \ Parameter | \u2705 | Local parameters are supported, but not as part of the\
    \ Verilog specification. Rather, they are used to represent module ports that\
    \ are internally used by the module. The behavior of these parameters is undefined.\
    \ |\n| Module Variable | \u2705 | The `wire` and `reg` keywords are supported.\
    \ |\n| Module Combinational | \u2705 | All module statements (other than `initial`,\
    \ `always`, and `always_comb`) are supported. |\n| Module Verilog Task | \u2705\
    \ | Tasks are supported. |\n| Module Verilog Module | \u2705 | Modules are supported.\
    \ |\n| Module Verilog Function | \u274C | Functions are not supported. |\n| Module\
    \ Verilog If-Else | \u274C | Verilog `if` and `else` statements are not supported.\
    \ |\n| Module Verilog Case | \u274C | Verilog `case` statements are not supported.\
    \ |\n| Module Verilog For-Each | \u2705 | `for` and `foreach` statements are supported.\
    \ |\n| Module Verilog Foreach-Select | \u2705 | `foreach` statements that contain\
    \ a `select` statement are supported. |\n| Module Verilog Foreach-Default | \u274C\
    \ | `foreach` statements that do not contain a `select` statement are not supported.\
    \ |\n| Module Verilog Foreach-Default-Always | \u274C | `foreach` statements that\
    \ contain a `default` statement are not supported. |\n| Module Verilog Foreach-Default-Case\
    \ | \u274C | `foreach` statements that contain a `default` statement are not supported.\
    \ |\n| Module Verilog Foreach-Parallel | \u274C | `foreach` statements that contain\
    \ a `parallel` statement are not supported. |\n| Module Verilog Foreach-Sequential\
    \ | \u274C | `foreach` statements that contain a `sequential` statement are not\
    \ supported. |\n| Module Verilog Foreach-Sequential-If | \u274C | `foreach` statements\
    \ that contain a `sequential` statement and an `if` statement are not supported.\
    \ |\n| Module Verilog Foreach-Sequential-If-Else | \u274C | `foreach` statements\
    \ that contain a `sequential` statement and an `if` statement are not supported.\
    \ |\n| Module Verilog Foreach-Sequential-If-Case | \u274C | `foreach` statements\
    \ that contain a `sequential` statement and an `if` statement are not supported.\
    \ |\n| Module Verilog Foreach-Sequential-Case | \u274C | `foreach` statements\
    \ that contain a `sequential` statement and a `case` statement are not supported.\
    \ |\n| Module Verilog Foreach-Case-If | \u274C | `foreach` statements that contain\
    \ a `case` statement and an `if` statement are not supported. |\n| Module Verilog\
    \ Foreach-Case-If-Else | \u274C | `foreach` statements that contain a `case` statement\
    \ and an `if` statement are not supported. |\n| Module Verilog Foreach-Case-Case\
    \ | \u274C | `foreach` statements that contain a `case` statement and a `case`\
    \ statement are not supported. |\n| Module Verilog Foreach-Case-Case-If | \u274C\
    \ | `foreach` statements that contain a `case` statement and a `case` statement\
    \ and an `if` statement are not supported. |\n| Module Verilog Foreach-Case-Case-If-Else\
    \ | \u274C | `foreach` statements that contain a `case` statement and a `case`\
    \ statement and an `if` statement are not supported. |\n| Module Verilog Foreach-Case-Case-Case\
    \ | \u274C | `foreach` statements that contain a `case` statement and a `case`\
    \ statement and a `case` statement are not supported. |\n| Module Verilog Foreach-Case-Case-Case-If\
    \ | \u274C | `foreach` statements that contain a `case` statement and a `case`\
    \ statement and a `case` statement and an `if` statement are not supported. |\n\
    | Module Verilog Foreach-Case-Case-Case-If-Else | \u274C | `foreach` statements\
    \ that contain a `case` statement and a `case` statement and a `case` statement\
    \ and an `if` statement are not supported. |\n| Module Verilog Foreach-Case-Case-Case-Case\
    \ | \u274C | `foreach` statements that contain a `case` statement and a `case`\
    \ statement and a `case` statement and a `case` statement are not supported. |\n\
    | Module Verilog Foreach-Case-Case-Case-Case-If | \u274C | `foreach` statements\
    \ that contain a `case` statement and a `case` statement and a `case` statement\
    \ and a `case` statement and an `if` statement are not supported. |\n| Module\
    \ Verilog Foreach-Case-Case-Case-Case-If-Else | \u274C | `foreach` statements\
    \ that contain a `case` statement and a `case` statement and a `case` statement\
    \ and a `case` statement and an `if` statement are not supported. |\n| Module\
    \ Verilog Foreach-Case-Case-Case-Case-Case | \u274C | `foreach` statements that\
    \ contain a `case` statement and a `case` statement and a `case` statement and\
    \ a `case` statement and a `case` statement are not supported. |\n| Module Verilog\
    \ Foreach-Case-Case-Case-Case-Case-If | \u274C | `foreach` statements that contain\
    \ a `case` statement and a `case` statement and a `case` statement and a `case`\
    \ statement and a `case` statement and an `if` statement are not supported. |\n\
    | Module Verilog Foreach-Case-Case-Case-Case-Case-If-Else | \u274C | `foreach`\
    \ statements that contain a `case` statement and"
- code: "```\nmodule show_aa(ao,ai); // NOT gate with delay 2\n  output ao; input\
    \ ai; enum aa { A = 0, B, Default };\n  wire ao, ai;\n  not #2 (ao,ai);\nendmodule\n\
    ### Expected Result:\nShow that the inputs are defaulted to 0 and non-default\
    \ values are selected for the test.\n\"\"\"\n\n# Create the module instance\n\
    show_aa = top[\"show_aa\"]\n\n# Create the test instance\ntest_aa = show_aa.test\n\
    \n# Set the input\ntest_aa.ai = \"Default\"\n\n# Run the test\ntest_aa()\n\n#\
    \ Check the result\nassert show_aa.ao == 0\nassert show_aa.trace.time == 2\n\n\
    # Verify that the module was called with the correct arguments\ndef check_show_aa_input(context,\
    \ name, value):\n    if name == \"ai\":\n        assert value == \"Default\"\n\
    \        return True\n\nmodule_call_context.add_check(check_show_aa_input)\n\n\
    # Verify that the module was called with the correct arguments with default value\n\
    show_aa.ai = None\ntest_aa()\nassert show_aa.trace.time == 0\n\n# Set the input\n\
    test_aa.ai = \"A\"\n\n# Run the test\ntest_aa()\n\n# Check the result\nassert\
    \ show_aa.ao == 0\nassert show_aa.trace.time == 2\n\n# Verify that the module\
    \ was called with the correct arguments\ndef check_show_aa_input(context, name,\
    \ value):\n    if name == \"ai\":\n        assert value == \"A\"\n        return\
    \ True\n\nmodule_call_context.add_check(check_show_aa_input)\nimport numpy as\
    \ np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as\
    \ sns\nimport math\n\nn = 10\nA = np.random.normal(0, 1, (n, n))\nA = A @ A.T\n\
    plt.imshow(A)\nplt.colorbar()\nplt.show()\n\ne, v = np.linalg.eig(A)\n\nplt.hist(e)\
    \ # plot the distribution of eigenvalues\nplt.show()\n\ne_sorted = sorted(e, reverse=True)\n\
    acc = 0\nfor i in e_sorted:\n    acc += i\n    print(acc)\n    if acc > 0.99 *\
    \ np.sum(e):\n        break\n\n# plot the top 10 eigenvalues to see the distribution\n\
    plt.hist(e[0:10])\nplt.show()#include <stdio.h>\n\nint main() {\n  int i=0;\n\n\
    \  for (; i<20; i++) {\n    printf(\"Hello from process %d\\n\", i);\n  }\n  return\
    \ 0;\n}#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\
    \ {\n  if (argc!= 3) {\n    printf(\"Usage: a.out <number of processes> <number\
    \ of rounds>\\n\");\n    exit(1);\n  }\n\n  int n = atoi(argv[1]);\n  int r =\
    \ atoi(argv[2]);\n\n  int *arr = malloc(n * sizeof(int));\n\n  for (int i=0; i<n;\
    \ i++) {\n    arr[i] = i;\n  }\n\n  int next = 1;\n  int curr = 0;\n  int i =\
    \ 0;\n\n  for (int j=0; j<r; j++) {\n    int temp = arr[curr];\n    arr[curr]\
    \ = arr[next];\n    next += 1;\n    if (next >= n) {\n      next = 0;\n    }\n\
    \    curr += 1;\n    if (curr >= n) {\n      curr = 0;\n    }\n    i += temp;\n\
    \    i %= n;\n  }\n\n  printf(\"Result: %d\\n\", i);\n  free(arr);\n  return 0;\n\
    }#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge(int *arr, int l, int m,\
    \ int r) {\n  int i, j, k;\n  int n1 = m - l + 1;\n  int n2 = r - m;\n  int *L\
    \ = malloc((n1) * sizeof(int));\n  int *R = malloc((n2) * sizeof(int));\n\n  for\
    \ (i = 0; i < n1; i++)\n    L[i] = arr[l + i];\n  for (j = 0; j < n2; j++)\n \
    \   R[j] = arr[m + 1 + j];\n\n  i = 0;\n  j = 0;\n  k = l;\n  while (i < n1 &&\
    \ j < n2) {\n    if (L[i] < R[j]) {\n      arr[k] = L[i];\n      i += 1;\n   \
    \ }\n    else {\n      arr[k] = R[j];\n      j += 1;\n    }\n    k += 1;\n  }\n\
    \  while (i < n1) {\n    arr[k] = L[i];\n    i += 1;\n    k += 1;\n  }\n  while\
    \ (j < n2) {\n    arr[k] = R[j];\n    j += 1;\n    k += 1;\n  }\n\n  free(L);\n\
    \  free(R);\n}\n\nvoid merge_sort(int *arr, int l, int r) {\n\n  if (l < r) {\n\
    \    int m = l + (r - l) / 2;\n\n    merge_sort(arr, l, m);\n    merge_sort(arr,\
    \ m + 1, r);\n\n    merge(arr, l, m, r);\n  }\n}\n\nint main(int argc, char *argv[])\
    \ {\n  if (argc!= 2) {\n    printf(\"Usage: a.out <length>\\n\");\n    return\
    \ 1;\n  }\n\n  int n = atoi(argv[1]);\n  int *arr = calloc(n, sizeof(int));\n\
    \  for (int i=0; i<n; i++) {\n    arr[i] = rand() % 1000;\n  }\n\n  printf(\"\
    Input:\\n\");\n  for (int i=0; i<n; i++) {\n    printf(\"%d \", arr[i]);\n  }\n\
    \  printf(\"\\n\");\n\n  merge_sort(arr, 0, n - 1);\n\n  printf(\"Output:\\n\"\
    );\n  for (int i=0; i<n; i++) {\n    printf(\"%d \", arr[i]);\n  }\n  printf(\"\
    \\n\");\n\n  free(arr);\n  return 0;\n}#include <stdio.h>\n#include <string.h>\n\
    #include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n  int fd = open(\"input.txt\"\
    , O_RDONLY);\n  char *buf = malloc(256);\n  read(fd, buf, 256);\n  printf(\"Input:\
    \ %s\\n\", buf);\n  free(buf);\n  close(fd);\n  return 0;\n}## Project\n\nThe\
    \ goal of the project is to create a C/Python tool that will automatically generate\
    \ a test suite for a verilog or VHDL simulation. This tool should be capable of\
    \ generating test sequences (either random or otherwise specified) that will be\
    \ executed in succession and check the correctness of the simulation.\n\n## Code\n\
    \nThe following is a partial code coverage checker for VHDL. \n\n### Installation\n\
    \n* Requires Python 3.\n* Requires the python-verilog library: `pip install python-verilog`\n\
    * Requires the networkx library: `pip install networkx`\n* `python3 -m pip install\
    \ -U pip` (if pip is outdated)\n\n### Usage\n\n* Run `python3 main.py -h` for\
    \ help.\n* Run `python3 main.py` for the default options.\n\n### Examples\n\n\
    For the C-based [AES code](https://github.com/cs5490-19s/aes-c), run the following:\n\
    \n```\npython3 main.py -m aes_test -i tests/aes_tests.json -v -o aes_coverge.html\n\
    ```\n\n## Description\n\nThe tool will generate a test suite for a Verilog module.\
    \ The test suite will include a set of random inputs to the module and a set of\
    \ test cases selected from a list of test cases.\n\nThe test cases are selected\
    \ based on the module's inputs and outputs. Inputs are selected randomly, while\
    \ outputs are selected from a set of test cases. The test cases are selected from\
    \ a set of user-defined test cases.\n\nTo specify a set of test cases:\n\n```\n\
    [\n  {\n    \"name\": \"test case name\",\n    \"inputs\": {\n      \"input 1\
    \ name\": \"input 1 value\",\n      \"input 2 name\": \"input 2 value\"\n    },\n\
    \    \"outputs\": {\n      \"output 1 name\": \"output 1 value\",\n      \"output"
- code: |-
    module show_cc(ao,.A,.B); // NOT gate with delay 2
      output ao; // default value is 0
      packed enum A {A_LOW, A_HIGH}.A; // default value is A_HIGH
      packed enum B {B_LOW, B_HIGH}.B; // default value is B_HIGH
      wire ao, ai;
      not #2 (ao,ai);
    endmodule
    ```
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.20"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Verilator: Verilator/include/verilator/verilated.h Source File</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
     <tbody>
     <tr style="height: 56px;">
      <td id="projectalign" style="padding-left: 0.5em;">
       <div id="projectname">Verilator
       </div>
       <div id="projectbrief">Verilator: Verilog simulator and TLM model generator</div>
      </td>
     </tr>
     </tbody>
    </table>
    </div>
    <!-- end header part -->
    <!-- Generated by Doxygen 1.8.20 -->
    <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:cf05388f26
- code: |-
    ```
    module show_aa(o,i); // NOT gate with delay 2

      output o;
      input i;
      wire ai, ao;

      not #2 (i,o);

    endmodule
    ```
    ## show_bb_a
    ### Base Verilog Code:
    module show_bb(ao,ai); // NOT gate with delay 2
      output ao; input ai; wire ao, ai;
      not #2 (ai,ao);
    endmodule
    ### Variation Instruction:
    Change A and B from logic to packed enums with default and non-default values to test enum-based
- code: "module show_aa(ao,ai); // NOT gate with delay 2\n  output [1:1'b0] ao; input\
    \ [2:1'b0] ai; wire [1:1'b0] ao, ai;\n  not #2 (ao,ai);\nendmodule\n/src/common/CMakeLists.txt\n\
    #=============================================================\n# Copyright 2014-2019,,\
    \ All rights reserved\n#\n# Licensed under the terms described in LICENSE, which\
    \ is part of this source code package.\n# \n# 3-clause BSD License\n# \n#=============================================================\n\
    \n# Source files for the common library\nSET(common_srcs src/util.c)\n\n# Make\
    \ the library\nadd_library(common STATIC ${common_srcs})\n\n# Install the common\
    \ library\ninstall(TARGETS common LIBRARY DESTINATION lib)\n/src/core/Makefile\n\
    #=============================================================\n# Copyright 2014-2019,,\
    \ All rights reserved\n#\n# Licensed under the terms described in LICENSE, which\
    \ is part of this source code package.\n# \n# 3-clause BSD License\n# \n#=============================================================\n\
    \n# Specify the source files\nSRCS = core.c\n\n# Specify the header files\nHDRS\
    \ =\n\n# Specify the C compiler\nCC = gcc\n\n# Specify the C compiler flags\n\
    CFLAGS = -I../common -I../utils -std=c99 -Wall -Werror\n\n# Specify the build\
    \ directory\nBUILDDIR =.\n\n# Specify the executable\nEXE = testcore\n\n# Specify\
    \ the library to link to\nLIBS =../common/libcommon.so../utils/libutils.so\n\n\
    # Specify the library paths\nLIBDIR =../common../utils\n\n# Specify the C compiler\
    \ flags for linking\nLDFLAGS = $(foreach lib,$(LIBDIR),-L$(lib)) $(foreach lib,$(LIBS),-l$(lib))\
    \ \n\n# Build all\nall: ${EXE}\n\n# Build the executable\n${EXE}: $(SRCS:.c=.o)\
    \ ${LIBS}\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^\n\n# Clean all\n.PHONY: clean\n\
    clean:\n\t@echo \"Cleaning...\"\n\trm -f./*.o./*.so./$(EXE) \n/src/utils/Makefile\n\
    #=============================================================\n# Copyright 2014-2019,,\
    \ All rights reserved\n#\n# Licensed under the terms described in LICENSE, which\
    \ is part of this source code package.\n# \n# 3-clause BSD License\n# \n#=============================================================\n\
    \n# Specify the source files\nSRCS = src/utils.c\n\n# Specify the header files\n\
    HDRS =\n\n# Specify the C compiler\nCC = gcc\n\n# Specify the C compiler flags\n\
    CFLAGS = -I../common -std=c99 -Wall -Werror\n\n# Specify the build directory\n\
    BUILDDIR =.\n\n# Specify the library to link to\nLIBS =../common/libcommon.so\n\
    \n# Specify the library paths\nLIBDIR =../common\n\n# Specify the C compiler flags\
    \ for linking\nLDFLAGS = $(foreach lib,$(LIBDIR),-L$(lib)) $(foreach lib,$(LIBS),-l$(lib))\n\
    \n# Build all\nall: libutils.so\n\n# Build the library\nlibutils.so: $(SRCS:.c=.o)\
    \ ${LIBS}\n\t$(CC) $(CFLAGS) $(LDFLAGS) -shared -o $@ $^\n\n# Clean all\n.PHONY:\
    \ clean\nclean:\n\t@echo \"Cleaning...\"\n\trm -f./*.o./*.so\n/tools/utils/make_header.py\n\
    #!/usr/bin/env python3\n\n#=============================================================\n\
    # Copyright 2014-2019,, All rights reserved\n#\n# Licensed under the terms described\
    \ in LICENSE, which is part of this source code package.\n# \n# 3-clause BSD License\n\
    # \n#=============================================================\n\nimport sys\n\
    import os\nimport argparse\nimport re\nimport subprocess\n\n#=============================================================\n\
    # Function: create_header\n#\n# Create a header file using the given input directory\n\
    #\n#=============================================================\ndef create_header(input_dir):\n\
    \    # The directory we're working in\n    cwd = os.getcwd()\n\n    # The name\
    \ of the header file\n    header_fname = os.path.join(input_dir, \"header.h\"\
    )\n\n    # Make sure we're at the top directory\n    os.chdir(cwd)\n    \n   \
    \ # Open the header file\n    header = open(header_fname, \"w\")\n\n    # Write\
    \ the directory header\n    header.write(\"#ifndef __HEADER_H_\\n\")\n    header.write(\"\
    #define __HEADER_H_\\n\")\n    header.write(\"\\n\")\n\n    # Write the include\
    \ guard\n    header.write(\"#ifdef __cplusplus\\n\")\n    header.write(\"extern\
    \ \\\"C\\\" {\\n\");\n    header.write(\"#endif\\n\")\n    header.write(\"\\n\"\
    )\n\n    # Check for the base directory\n    if input_dir == \".\":\n        header.write(\"\
    // Include the base header\\n\")\n        header.write(\"#include \\\"../common.h\\\
    \"\\n\\n\")\n    else:\n       header.write(\"// Include the base header\\n\"\
    )\n       header."
- code: |-
    module test_inst(clk, reset, c_data, c_out);

    reg clk = 0;
    reg reset = 0;

    lpm_ff flipflop[1:0](.data(c_data[0]),.aclr(reset),.clock(clk),.q(c_out[0]));
    defparam flipflop[1:0].lpm_width = 1;
    lpm_ff flipflop[2:1](.data(c_data[1]),.aclr(reset),.clock(clk),.q(c_out[1]));
    defparam flipflop[2:1].lpm_width = 1;

    initial
    begin
    for(int i = 0; i < 8; i++)
    #20 clk = ~clk;
    end

    initial
    begin
    reset = 0;

    for(int i = 0; i < 32; i++)
    #20 clk = ~clk;
    end

    initial
    begin
    $display("start test"); reset = 1; #10$display("input %d, expected: %d", c_data[0], c_out[0]);
    $display("input %d, expected: %d", c_data[1], c_out[1]); reset = 0; for(int i = 0; i < 32; i++) #20 clk = ~clk; end end module ### Results: Start test input 1, expected: 0 input 0, expected: 1 ### 11.07 (c): Design a circuit to implement the half adder and full adder using a single lpm_ff. Hint: you can write the design as a function of 2 2-bit input operands. ### Base Verilog Code: module half_adder(in_a, in_b, c_out, sum_out); input in_a, in_b; output c_out, sum_out; lpm_ff sum(.data(in_a ^ in_b),.aclr(in_b),.q(sum_out)); defparam sum.lpm_width = 2; lpm_ff carry(.data(in_a & in_b),.aclr(in_b),.q(c_out)); defparam carry.lpm_width = 2; endmodule ### Variation Instruction: Expand the testbench to include test cases using a dynamic array as input operands. ### Modified Code: module test_inst(clk, reset, c_data, c_out, carry_out, sum_out); reg clk = 0; reg reset = 0; lpm_ff carry[1:0](.data(c_data[0] & c_data[1]),.aclr(reset),.clock(clk),.q(carry_out[0])); defparam carry[1:0].lpm_width = 2; lpm_ff sum[1:0](.data(c_data[0] ^ c_data[1]),.aclr(reset),.clock(clk),.q(sum_out[0])); defparam sum[1:0].lpm_width = 2; initial begin reset = 0; for(int i = 0; i < 32; i++) #20 clk = ~clk; end initial begin$display("start test");
    reset = 1;

    $display("input %d, %d, expected: %d", c_data[0], c_data[1], carry_out[0]);$display("input %d, %d, expected: %d", c_data[0], c_data[1], sum_out[0]);
    reset = 0;

    for(int i = 0; i < 32; i++)
    #20 clk = ~clk;
    end
    endmodule
    ### Results:
    Start test
    input 1, 1, expected: 0
    input 0, 1, expected: 1
- code: "module test_dff(D, Clock, Resetn, Q);\nlpm_ff dff_inst(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\n\
    defparam dff_inst.lpm_width = 1;\n\n//Create an array of 16 test cases.\ninteger\
    \ D_in[128] = {1};\ninteger  Clock_in[128] = {1};\ninteger Resetn_in[128] = {0};\n\
    integer Q_out[128] = {1};\n\ninteger i;\nfor(i = 0; i < 128; i++){\nassign dff_inst.data\
    \ = D_in[i];\nassign dff_inst.aclr = Resetn_in[i];\nassign dff_inst.clock = Clock_in[i];\n\
    initial begin\n#10;\nend\n#50;\nClock_in[i] <= 0;\nD_in[i] = D_in[i] + 1;\nend\n\
    initial\n\n#32;\nend\n\nendmodule\n\n### Output:\n\nTestbench Output:\n\nTest\
    \ Case 1:\n\nTest Case 2:\n\nTest Case 3:\n\nTest Case 4:\n\nTest Case 5:\n\n\
    Test Case 6:\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\n\
    A dynamic array is a variable of type \u201Carray of N\u201D in Verilog.\n\n\u2022\
    \ Arrays hold a sequence of elements of a uniform type.\n\u2022 These elements\
    \ are addressed by their index.\n\u2022 The index is an integer in the interval\
    \ 0\_\u2264\_index\_\u2264\_N\u22121.\n\u2022 The elements of an array are always\
    \ of the same type.\n\u2022 Arrays are defined with a left-hand and right-hand\
    \ size.\n\u2022 The array size must be known at compile time.\nA dynamic array\
    \ can be used to store sequence of elements of a similar type.\nThe index at which\
    \ the element stores starts from 0.\nDynamic arrays are defined in the following\
    \ syntax:\ninteger array_name[N] = {list_of_elements};\ninteger array_name[N]\
    \ = {list_of_elements, list_of_elements,...};\ninteger array_name[N] = {value,value,value,...,\
    \ value,value, value};\n\n### Example\n\ndynamic array integer array_1[16] = {0};\n\
    dynamic array integer array_2[4] = {1,2,3,4};\ndynamic array integer array_3[4]\
    \ = {10,20,30,40};\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\
    \nArrays can also be used to store the sequence of values obtained from another\
    \ array.\ndynamic array integer array_1[16] = {0};\ninteger i;\nfor(i=0; i<16;\
    \ i++){\narray_1[i] <= 2*i;\nend\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\
    \n### Example\n\nDynamic array is used to store sequence of values obtained from\
    \ another array.\ndynamic array integer array_1[16] = {0};\ndynamic array integer\
    \ array_2[4] = {1,2,3,4};\ninteger i;\nfor(i=0; i<16; i++){\narray_1[i] <= array_2[i];\n\
    end\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\nDynamic arrays\
    \ are useful in situations where the size of the array must be determined at run\
    \ time.\n\n### Example\n\ndynamic array integer array_1[16]; // Dynamic array\
    \ defined.\ninteger array_1_size = 7; // Size of the array.\narray_1[0] = 1;\n\
    array_1[1] = 2;\narray_1[2] = 3;\narray_1[3] = 4;\narray_1[4] = 5;\narray_1[5]\
    \ = 6;\narray_1[6] = 7;\ninteger i;\nfor(i=0; i<array_1_size; i++){\n$display(\"\
    array_1[%d]=%d\", i, array_1[i]); #100; end ## Dynamic Array in Verilog Code (Module/Function/Program)\
    \ ### Example Dynamic array is declared but not defined. This type of array is\
    \ known as a parameter array. dynamic array parameter integer array[16] array_1;\
    \ integer array_1_size = 7; array_1[0] = 1; array_1[1] = 2; array_1[2] = 3; array_1[3]\
    \ = 4; array_1[4] = 5; array_1[5] = 6; array_1[6] = 7; integer i; for(i=0; i<array_1_size;\
    \ i++){$display(\"array_1[%d]=%d\", i, array_1[i]);\n#100;\nend\n\n## Dynamic\
    \ Array in Verilog Code (Module/Function/Program)\n\nDynamic array is declared\
    \ along with the other parameters in the function declaration.\n\n### Example\n\
    \ndynamic array integer array_1[16]; // Dynamic array defined.\ninteger array_1_size\
    \ = 7; // Size of the array.\nfunction integer array_add(integer array[16] array_1,\
    \ integer array_1_size);\ninteger i;\nfor(i=0; i<array_1_size; i++){\narray_1[i]\
    \ = array_1[i] + 1;\n}\ninteger array_add(integer array[16] array_1, integer array_1_size){\n\
    integer i;\nfor(i=0; i<array_1_size; i++){\narray_1[i] = array_1[i] + 1;\n}\n\
    }\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\nDynamic array\
    \ is declared along with the other parameters in the function declaration.\n\n\
    ### Example\n\nThe following example shows how to modify an element of dynamic\
    \ array.\n\nfunction integer array_mod(integer array[16] array_1, integer array_1_size,\
    \ integer index, integer element);\ninteger i;\nfor(i=0; i<array_1_size; i++){\n\
    assign array_1[i] = array_1[i] + 1;\n}\ninteger array_mod(integer array[16] array_1,\
    \ integer array_1_size, integer index, integer element){\ninteger i;\nfor(i=0;\
    \ i<array_1_size; i++){\narray_1[i] = array_1[i] + 1;\n}\n}\n\n## Dynamic Array\
    \ in Verilog Code (Module/Function/Program)\n\nDynamic array is declared along\
    \ with the other parameters in the function declaration.\n\n### Example\n\nThe\
    \ following example shows how to add two dynamic arrays.\n\nfunction integer array_add(integer\
    \ array[16] array_1, integer array_1_size, integer index, integer element);\n\
    integer i;\nfor(i=0; i<array_1_size; i++){\nassign array_1[i] = array_1[i] + 1;\n\
    }\ninteger array_add(integer array[16] array_1, integer array_1_size, integer\
    \ index, integer element){\ninteger i;\nfor(i=0; i<array_1_size; i++){\narray_1[i]\
    \ = array_1[i] + 1;\n}\n}\n\n## Dynamic Array in Verilog Code (Module/Function/Program)\n\
    \nDynamic array is declared along with the other parameters in the function declaration.\n\
    \n### Example\n\nThe following example shows how to add two dynamic arrays.\n\n\
    function integer array_add(integer array[16] array_1, integer array_1_size, integer\
    \ index, integer element);\ninteger i;\nfor(i=0; i<array_1_size; i++){\nassign\
    \ array_1[i] = array_1[i] + 1;\n}\ninteger array_add(integer array[16] array_1,\
    \ integer array_1_size, integer index, integer element){\ninteger i;\nfor(i=0;\
    \ i<array_1_size; i++){\narray_1[i] = array_1[i] + 1;\n}\n}\n\n## Dynamic Array\
    \ in Verilog Code (Module/Function/Program)\n\nDynamic array is declared along\
    \ with the other parameters in the function declaration.\n\n### Example\n\nThe\
    \ following example shows how to multiply all the elements of the dynamic array.\n\
    \nfunction integer array_mult(integer array[16] array_1, integer array_1_size,\
    \ integer index, integer element);\ninteger i;\nfor(i"
- code: |-
    module dff_inst(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    integer[1:0] data;
    data = {D,Resetn};
- code: |-
    The modified verilog code is as following:
    module dff_inst(D, Clock, Resetn, Q);
    input D, Clock, Resetn;
    output Q;
    // dynamic array for the test cases
    reg [1:0] testcases[0];
    // to test different values for the inputs
    always @(posedge Clock)
    testcases[0] = ~testcases[0];
    assign Q = testcases[0];
    endmodule
- code: |-
    module tb_dff_inst(clk, rst, D, Q);
    input clk, rst;

    logic [7:0] D[0];
    logic [15:0] Q[0];
    logic [0] clk_i;

    dff_inst dff_i (
    .clk(clk_i),.rst(rst),.D(D[0]),.Q(Q[0]));

    initial
    begin
    clk_i = 1;
    rst = 0;
    for (int i = 0; i < 5; i = i + 1)
    begin
    clk_i = ~clk_i;
    D[i] = 7'b1000000;
    end

    always begin
    #10 clk_i = 1;
    #10 clk_i = 0;
    end

    endmodule


    ## Output

    #### Testbench Output

    ## Conclusion

    The DFF is very common and easy to understand in Verilog. Thus, this exercise was simple and straightforward. However, more complex designs can be done by expanding Verilog syntax and understanding the Verilog language. The DFF can take in a variety of inputs, as well as, can be expanded to include more components, such as the latch, or the flipflop. Additionally, there is more to Verilog than just this.
- code: "import std.stdio;\nimport std.array;\n\nmodule dff_inst(D, Clock, Resetn,\
    \ Q);\ninput D, Clock, Resetn;\noutput Q;\n\nlpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\n\
    \ndefparam flipflop.lpm_width = 1;\nendmodule\n\nmodule tb;\ninitial\nfor (int\
    \ i = 0; i < 4; i++)\n$dumpfile(\"dumpfile.vcd\");$dumpvars(0, tb);\n\nreg Clock,\
    \ Resetn;\n\ninitial\nClock = 1'b0;\nResetn = 1'b1;\n\ninitial\nfor (int i = 0;\
    \ i < 10; i++) {\n\n$dumpvars(1, tb); Clock =!Clock; } while (false);$dumpvars(1,\
    \ tb);\n\nendmodule\n\n\n\u2022 I think the problem was that the top module name\
    \ was used as the name of the parameter in the lpm_ff instruction, as such the\
    \ module named top_inst didn\u2019t have any parameters. \u2013\_Maurice Aug 10\
    \ at 10:55"
- code: |-
    module dff_inst(D, Clock, Resetn, Q);
    reg D, Resetn, Q;
    `
- code: |-
    I just added a new output and a case statement
    module dff_inst(D, Clock, Resetn, Q, Q_dynamic, test);
    input D, Clock, Resetn;
    output Q;
    output Q_dynamic, test;
    lpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q),.q_dynamic(Q_dynamic),.test(test));
    defparam flipflop.lpm_width = 1;
    endmodule

    ### Testbench Code:
    module lpm_ff_tb;

    // Inputs to the module
    reg D, Clock, Resetn;

    // Outputs from the module
    wire Q, Q_dynamic, test;

    dff_inst DFF (.D(D),.Clock(Clock),.Resetn(Resetn),.Q(Q));

    initial
    begin
    D=1'b0;
    Clock = 0;
    Resetn = 1;
    $dumpfile("lpm_ff_dump.vcd");$dumpvars(0, lpm_ff_tb);
    while (1) begin
    Clock = ~Clock;
    if ((Clock == 1'b1) || (Clock == 1'b0)) begin
    D = ~D;
    #1;
    end
    end
    end

    initial
    begin
    #10;
    for (Resetn = 0; Resetn <= 1; Resetn = Resetn + 1) begin
    for (D = 0; D <= 1; D = D + 1) begin
    $dumpreset(1);$dumpvars(1, lpm_ff_tb);
    end
    end
    end

    initial
    begin
    D = 1'b0;
    Clock = 0;
    Resetn = 0;
    $dumpvars(0, lpm_ff_tb); while (1) begin Clock = ~Clock; if ((Clock == 1'b1) || (Clock == 1'b0)) begin #1; Q = D; D = ~D; Q_dynamic = ~D; test = ~D; end end end initial begin D = 1'b1; Clock = 0; Resetn = 0;$dumpvars(0, lpm_ff_tb);
    while (1) begin
    Clock = ~Clock;
    if ((Clock == 1'b1) || (Clock == 1'b0)) begin
    #1;
    Q = D;
    D = ~D; Q_dynamic = ~D; test = ~D;
    end
    end
    end
    endmodule
- code: "module dff_inst(D, Clock, Resetn, Q);\ninput D, Clock, Resetn;\noutput Q;\n\
    lpm_ff flipflop(.data(D),.aclr(Resetn),.clock(Clock),.q(Q));\ndefparam flipflop.lpm_width\
    \ = 1;\nint num_inputs = sizeof(inputs) / sizeof(inputs[0]);\nint random_number\
    \ = 0;\nfor (int i = 0; i < num_inputs; i += 1) {\nrandom_number = rand();\n}\n\
    endmodule\n### Expected outputs:\nThe testbench should run in a loop and generate\
    \ random inputs.\n\n## 1.8 Tips\n\n### Tips 1.1\n\nTestbench file (main.sv)\n\n\
    module main;\n`include \"testbench.sv\"\nendmodule\n\nTestbench (testbench.sv)\n\
    \nmodule testbench;\nreg     clk;\nwire    rst;\nwire    test_module;\n\ndff_inst\
    \ tb (\n.D(test_module),\n.clk(clk),\n.rst(rst)\n);\n\ninitial begin\n#5 clk =\
    \ ~clk;\nend\n\ninitial begin\n#10 rst = 1'b1;\n#30 rst = 1'b0;\nend\n\nendmodule\n\
    \n### Tips 1.2\n\nTestbench file (testbench.sv)\n\n`include \"dff_inst.sv\"\n\n\
    dff_inst test_module(\n.D(1'b1),\n.clk(clk),\n.rst(rst)\n);\n\n### Tips 1.3\n\n\
    Testbench file (testbench.sv)\n\n`include \"dff_inst.sv\"\n\ndff_inst tb(\n.D(1'b1),\n\
    .clk(clk),\n.rst(rst)\n);\n\n### Tips 1.4\n\nTestbench file (testbench.sv)\n\n\
    `include \"dff_inst.sv\"\n\ndff_inst tb(\n.D(1'b0),\n.clk(clk),\n.rst(rst)\n);\n\
    \n### Tips 1.5\n\nTestbench file (testbench.sv)\n\n`include \"dff_inst.sv\"\n\n\
    dff_inst tb(\n.D(1'bn1),\n.clk(clk),\n.rst(rst)\n);\n\n## 1.9 Summary\n\n\u2022\
    \ The DFF module is a simple combinational module that has a single input and\
    \ single output.\n\u2022 The DFF is a module to create a dynamic number of DFFs\
    \ in a testbench.\n\u2022 The input signals can be used to generate a random number\
    \ for each dynamic DFF.\n\u2022 The random number can be used to change the DFF\
    \ data input.\n\u2022 The testbench should be modified to allow multiple inputs\
    \ and multiple outputs to be created based on a list of inputs.\n\n## 1.10 References\n\
    \n\u2022 [1] Moore,. (2014). Verilog HDL: A Hardware Description Language. Pearson\
    \ Higher Education."
- code: |-
    # Generate a sequence of 1000 clock pulses
    # Generate a reset pulse
    # Generate a sequence of 1000 clock pulses

    ###
- code: |-
    module latch (input d, c, input [5:0] clk, output [7:0] q, q_b );

    reg [7:0] d_b;
    reg [7:0] c_b;

    initial
    begin
    d_b <= d;
    c_b <= c;
    end

    always @(posedge clk)
    begin
    d_b <= d;
    c_b <= c;
    end
    endmodule

    ### Observed Behavior:

    ### Expected Behavior:

    ### Steps to Reproduce:

    ### Error Messages:
- code: |-
    module latch (input d, c, output reg q, q_b );
    always begin
    wait ( c );
    end
    endmodule

    ## 5. Testbench
    The testbench performs the following tests:
    * 256 sequential cycles of the circuit, with a data input of 000000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit, with a data input of 011111111111111111111111111111111111111.
    * 256 sequential cycles of the circuit, with a data input of 100000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit, with a data input of 000000000000111111111111111111111111111.

    The testbench also performs the following additional tests:
    * 256 sequential cycles of the circuit, with a data input of all 1s and all 0s.
    * 256 sequential cycles of the circuit, with a data input of all 1s.
    * 256 sequential cycles of the circuit, with a data input of all 0s.
    * 256 sequential cycles of the circuit with a data input of all 1s and all 0s, and with the clock pulse set to 000000000000000000000000000000000000000, and with only the clock pulse set to 000000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit with a data input of all 1s and all 0s, and with the clock pulse set to 000000000000000000000000000000000000000, and with only the clock pulse set to 000000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit with the clock pulse set to 000000000000000000000000000000000000000, and with only the clock pulse set to 000000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit with a data input of all 1s and all 0s, and with the clock pulse set to 000000000000000000000000000000000000000, and with only the clock pulse set to 000000000000000000000000000000000000000.
    * 256 sequential cycles of the circuit with the clock pulse set to 000000000000000000000000000000000000000, and with only the clock pulse set to 000000000000000000000000000000000000000.

    The testbench also performs the following extra tests of the circuit:
    * 256 sequential cycles of the circuit where the data input is all 1s and clock pulse is all 1s, and where the data input is all 0s and clock pulse is all 0s.
    * 256 sequential cycles of the circuit where the data input is all 1s and clock pulse is all 1s, and where the data input is all 1s and clock pulse is all 1s.
    * 256 sequential cycles of the circuit with the data input of all 1s and clock pulse is all 1s and with the data input of all 0s and clock pulse is all 0s.
    * 256 sequential cycles of the circuit with the data input of all 1s and clock pulse is all 1s and with the data input of all 1s and clock pulse is all 1s.

    ## 6. Results
    In the following test, we have made a mistake in our testbench, which is the 3rd test. The expected output of the 3rd test should be 000000000000000000000000000000000000000. However, the current testbench is expecting the output 000000000001111111111111111111111111110.

    ![1](https://github.com/S180005/lab2/blob/master/lab2_image/1.PNG)

    ![2](https://github.com/S180005/lab2/blob/master/lab2_image/2.PNG)

    ![3](https://github.com/S180005/lab2/blob/master/lab2_image/3.PNG)

    ![4](https://github.com/S180005/lab2/blob/master/lab2_image/4.PNG)

    ![5](https://github.com/S180005/lab2/blob/master/lab2_image/5.PNG)

    ![6](https://github.com/S180005/lab2/blob/master/lab2_image/6.PNG)

    ![7](https://github.com/S180005/lab2/blob/master/lab2_image/7.PNG)

    ![8](https://github.com/S180005/lab2/blob/master/lab2_image/8.PNG)

    ![9](https://github.com/S180005/lab2/blob/master/lab2_image/9.PNG)

    ![10](https://github.com/S180005/lab2/blob/master/lab2_image/10.PNG)

    ![11](https://github.com/S180005/lab2/blob/master/lab2_image/11.PNG)
- code: "module latch (input d, c, output reg q, q_b );\nalways begin\nwait ( c );\n\
    end\nendmodule\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\
    #include <map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\
    \nstruct Instruction{\n  string opcode;\n  int operand;\n};\n\nint main(int argc,\
    \ char **argv){\n  if(argc!= 2){\n    cout << \"Usage: \" << argv[0] << \" <input\
    \ file name>\" << endl;\n    return 1;\n  }\n\n  string line;\n  string file_name\
    \ = argv[1];\n  ifstream input;\n  input.open(file_name);\n  \n  map<string, int>\
    \ symbol_table;\n  int locctr = 0;\n  int start_locctr = 0;\n  bool symbol_found\
    \ = 0;\n  int program_size = 0;\n  int opcode_index = 0;\n  \n  while(getline(input,line)){\n\
    \    istringstream is(line);\n    \n    int opcode_index = 4;\n    Instruction\
    \ instruction;\n    instruction.opcode = \"\";\n    instruction.operand = 0;\n\
    \    \n    while(is.good() && opcode_index!= 0){\n      string token;\n      is\
    \ >> token;\n      if(token == \".org\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \".fill\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tis >> program_size;\n\tprogram_size = stoi(program_size);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> program_size;\n\
    \tprogram_size = stoi(program_size);\n\tsymbol_found = 0;\n      }\n      else\
    \ if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found\
    \ = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> program_size;\n\
    \tprogram_size = stoi(program_size);\n\tsymbol_found = 0;\n      }\n      else\
    \ if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found\
    \ = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol_found = 0;\n      }\n      else if(token == \"\"){\n\tis >> locctr;\n\
    \tlocctr = stoi(token);\n\tsymbol_found = 0;\n      }\n      else if(token ==\
    \ \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\tsymbol_found = 0;\n    \
    \  }\n      else if(token == \"\"){\n\tis >> locctr;\n\tlocctr = stoi(token);\n\
    \tsymbol"
- code: |-
    module latch (input d, c, output q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    1.
    The behavior of the test-bench is the same as the Base Verilog.
    2.
    The Verilog-Source code is not synthesizable.
    3.
    The Verilog-Source code is synthesizable. However, the synthesized netlist cannot be implemented in either Xilinx or Altera.
    4.
    The Verilog-Source code is synthesizable. The synthesized netlist can be implemented in both Xilinx and Altera.
    5.
    None of the above.

    ## 5.
    A test-bench is required to test a Verilog-Source code, but only test-benches are not sufficient. A test-bench must also include a test-vector.
    1.
    True
    2.
    False
    3.
    None of the above

    ## 6.
    A test-bench must include a test-vector in order to test a Verilog-Source code.
    1.
    True
    2.
    False
    3.
    None of the above

    ## 7.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    0
    0
    1
    0
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    0
    0
    1
    0
    1
    1
    1
    0
    0
    1
    0
    1
    0
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 8.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 9.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 10.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 11.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 12.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 13.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 14.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 15.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 16.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 17.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    1
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    0
    1
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 18.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 19.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 20.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    0
    0
    0
    0
    1
    0
    0
    1
    1
    1
    1
    0
    0
    1
    1
    1
    0
    0
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 21.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    1
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    0
    1
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 22.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    1
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    0
    1
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    0
    1
    1
    0
    1
    1
    1
    1
    1
    1
    1
    1
    1

    ## 23.
    The test-vector for the latch is the following:
    d
    c
    q
    q_b
    1
    1
    1
    1
    0
    1
    1
    0
    1
    0
    1
    1
    1
    0
    1
    1
    1
    1
    0
    1
    1
    0
    1
    1
- code: |-
    module test_case(input clk, input [3:0] addr_a, input [3:0] addr_d, input [2:0] mem_wr, input [3:0] data_in, output reg [3:0] data_out, output reg dout );
    always begin
    dout = data_out;
    end
    endmodule
    ### Run Result:
    [lscc] 27-bit: 1961237871088466379
    [lscc] 32-bit: 2089071671502896631
    [lscc] 37-bit: 2097037831314590598
    [lscc] 42-bit: 2097874499068412446
    [lscc] 47-bit: 2099942146449344576
    [lscc] 52-bit: 2102675657539514370
    [lscc] 57-bit: 2102712169652098575
    ### Analysis Notes:
    - The two examples were actually equivalent, so the differences in timing are a result of the difference in number of bits used in the register (a 27-bit register, versus a 32-bit register)
    - There were no run time penalties when output was driven by data_out.
    /Lab3/Lab3_files/isim/cpu_tb_isim_beh.exe.sim/work/a_1880429497_3212880686.c
    /**********************************************************************/
    /*   ____  ____                                                       */
    /*  /   /\/   /                                                       */
    /* /___/  \  /                                                        */
    /* \   \   \/                                                       */
    /*  \   \        Copyright (c) 2003-2009 Xilinx, Inc.                */
    /*  /   /          All Right Reserved.                                 */
    /* /---/   /\                                                         */
    /* \   \  /  \                                                      */
    /*  \___\/\___\                                                    */
    /***********************************************************************/

    /* This file is designed for use with ISim build 0x7708f090 */

    #define XSI_HIDE_SYMBOL_SPEC true
    #include "xsi.h"
    #include <memory.h>
    #ifdef __GNUC__
    #include <stdlib.h>
    #else
    #include <malloc.h>
    #define alloca _alloca
    #endif
    static const char *ng0 = "C:/Users/t/Documents/CS3610_FPGA_Lab/Lab3/aluaddsub.vhd";
    extern char *IEEE_P_2592010699;
    extern char *IEEE_P_3620187407;

    unsigned char ieee_p_2592010699_sub_1744673427_503743352(char *, char *, unsigned int, unsigned int );
- code: |-
    module latch (input d, c, output reg [7:0] q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Test File:
    latch_test.v

    ```

    ### Running the Test
    Run the test using the following command:
    ```
    % make test
    ```

    The output should be similar to the following:

    <img src="latch_test.png" alt="Screen Shot 2022-03-09 at 1 39 27 PM" width="400" >

    ### Test Results
    The test passes if no errors are detected.

    ## Lab 7: Behavioral Verilog

    ### Objective
    Objective: This lab will introduce the use of assignment statements, blocking and non-blocking assignments, and basic timing constructs.

    ### Lab Overview

    This lab will give you the opportunity to practice writing a behavioral Verilog 3.x code. For the behavioral code, the task will be to implement a simple ALU (arithmetic logic unit).

    ### Getting Started
    Create the required files for the lab by running the following command:
    ```
    % make
    ```

    The test file is located in:
    ```
    % cd./src/testbench/behavioral
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % ls -l
    %  -rw-r--r-- 1 mschult  mschult   1518 Mar  9 13:05 alu.v
    %  -rw-r--r-- 1 mschult  mschult   1099 Mar  9 13:05 alu_tb.v
    %  -rw-r--r-- 1 mschult  mschult   5621 Mar  9 13:05 gen_alu.sh
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % cd src/testbench
    % ls -l
    %  -rwxr-xr-x 1 mschult  mschult  11291 Mar  9 13:16 gen_alu_tb.sh
    ```

    ### Running the Test
    Run the test using the following command:
    ```
    % make test
    ```

    The output should be similar to the following:

    <img src="behavioral_alu_test.png" alt="Screen Shot 2022-03-09 at 1 47 47 PM" width="400" >

    ### Test Results
    The test passes if no errors are detected.

    ## Lab 8: Behavioral Verilog

    ### Objective
    This lab will introduce the use of procedural constructs, state machines and more advanced timing constructs.

    ### Lab Overview

    This lab will give you the opportunity to practice writing a behavioral Verilog 3.x code. For the behavioral code, the task will be to implement a simple ALU (arithmetic logic unit).

    ### Getting Started
    Create the required files for the lab by running the following command:
    ```
    % make
    ```

    The test file is located in:
    ```
    % cd./src/testbench/behavioral
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % ls -l
    %  -rw-r--r-- 1 mschult  mschult   1518 Mar  9 13:05 alu.v
    %  -rw-r--r-- 1 mschult  mschult   1099 Mar  9 13:05 alu_tb.v
    %  -rw-r--r-- 1 mschult  mschult   5621 Mar  9 13:05 gen_alu.sh
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % cd src/testbench
    % ls -l
    %  -rwxr-xr-x 1 mschult  mschult  11291 Mar  9 13:16 gen_alu_tb.sh
    ```

    ### Running the Test
    Run the test using the following command:
    ```
    % make test
    ```

    The output should be similar to the following:

    <img src="behavioral_counter_test.png" alt="Screen Shot 2022-03-09 at 1 55 04 PM" width="400" >

    ### Test Results
    The test passes if no errors are detected.

    ## Lab 9: Behavioral Verilog

    ### Objective
    This lab introduces the use of procedural constructs, state machines and more advanced timing constructs.

    ### Lab Overview

    This lab will give you the opportunity to practice writing a behavioral Verilog 3.x code. For the behavioral code, the task will be to implement a simple ALU (arithmetic logic unit).

    ### Getting Started
    Create the required files for the lab by running the following command:
    ```
    % make
    ```

    The test file is located in:
    ```
    % cd./src/testbench/behavioral
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % ls -l
    %  -rw-r--r-- 1 mschult  mschult   1518 Mar  9 13:05 alu.v
    %  -rw-r--r-- 1 mschult  mschult   1099 Mar  9 13:05 alu_tb.v
    %  -rw-r--r-- 1 mschult  mschult   5621 Mar  9 13:05 gen_alu.sh
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % cd src/testbench
    % ls -l
    %  -rwxr-xr-x 1 mschult  mschult  11291 Mar  9 13:16 gen_alu_tb.sh
    ```

    ### Running the Test
    Run the test using the following command:
    ```
    % make test
    ```

    The output should be similar to the following:

    <img src="behavioral_counter_test.png" alt="Screen Shot 2022-03-09 at 1 55 04 PM" width="400" >

    ### Test Results
    The test passes if no errors are detected.

    ## Lab 10: Behavioral Verilog

    ### Objective

    This lab introduces the use of procedural constructs, state machines and more advanced timing constructs.

    ### Lab Overview

    This lab will give you the opportunity to practice writing a behavioral Verilog 3.x code. For the behavioral code, the task will be to implement a simple ALU (arithmetic logic unit).

    ### Getting started
    Create the required files for the lab by running the following command:
    ```
    % make
    ```

    The test file is located in:
    ```
    % cd./src/testbench/behavioral
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % ls -l
    %  -rw-r--r-- 1 mschult  mschult   1518 Mar  9 13:05 alu.v
    %  -rw-r--r-- 1 mschult  mschult   1099 Mar  9 13:05 alu_tb.v
    %  -rw-r--r-- 1 mschult  mschult   5621 Mar  9 13:05 gen_alu.sh
    ```

    The following files are automatically created in the src/testbench/behavioral directory:
    ```
    % cd src/testbench
    % ls -l
    %  -rwxr-xr-x 1 mschult  mschult  11291 Mar  9 13:16 gen_alu_tb.sh
    ```

    ### Running the Test
    Run the test using the following command:
    ```
    % make test
    ```

    The output should be similar to the following:

    <img src="behavioral_counter_test.png" alt="Screen Shot 2022-03-09 at 1 55 04 PM" width="400" >

    ### Test Results
    The test passes if no errors are detected.

    ## Lab 11: Behavioral Verilog

    ### Objective

    This lab introduces the use of procedural constructs, state machines and more advanced timing constructs.

    ### Lab Overview

    This lab will give you the opportunity to practice writing a behavioral Verilog 3.x code. For the behavioral code, the task will be to implement a simple ALU (arithmetic logic unit).

    ### Getting started
    Create the required files for the lab by
- code: |-
    module latch (input d, c, output reg [7:0] q, q_b );
    always @(*)
    case (c)
    1'b0:
    q = d;
    q_b = 0;
    break;
    1'b1:
    q = q_b;
    q_b = 0;
    break;
    default:
    q = d;
    q_b = 0;
    break;
    endcase
    end
    ### Comment:
    This variation produced errors and crashed the compiler.

    ---

    ## Testing Unpacking Structures (13)

    **File:** TestModule.v

    ### Base Verilog Code:
    module latch (input d, c, output q, q_b
- code: |-
    module latch (input d, c, output reg q, q_b );
    always begin
    wait ( c );
    end
    endmodule
    ### Expected Behavior:
    The behavior should be same as previous code with single bit outputs.
    ### Actual Behavior:
    Error: 3417: This expression may not be used in this context
    Error: 3232: Undefined identifier 'q_b'
    ### Steps to Reproduce the Problem:
    1. Select a latch file and run "Test"

    ### Specifications:
      - Version: 1.0.6
      - Platform: (e.g. Python, Visual Studio Code, etc) Python/VS Code
      - Subsystem: (e.g. frontend or backend, or both) Verilogusername_1: Fixed since #2678
- code: "module latch (input d, c, output [7:0] q, q_b );\n```\n\n## 3) Verilog code:\n\
    ```\n/**\n * Description:\n *  This is a basic latch using two signals\n *  d\
    \ and clock c.\n */\n\nmodule latch (\n\tinput d,\n\tinput c,\n\toutput reg q,\n\
    \toutput q_b\n);\n\nalways begin\n\twait ( c );\nend\n\nendmodule\n```\n\n## 4)\
    \ Running the code\n```\nbash-3.2$./run.sh\n```\n/2/README.md\n# Week 2\n\n##\
    \ Problem 1\n\n### 1) Verilog code (part 1):\n```\n/**\n* Description:\n*  This\
    \ is an adder circuit\n*  with 2 2-bit inputs and \n*  one 4-bit output.\n**/\n\
    module adder(\n\tinput [1:0] a,\n\tinput [1:0] b,\n\toutput [3:0] c\n);\n\nreg\
    \ [1:0] c0;\nreg [1:0] c1;\nreg [1:0] c2;\nreg [1:0] c3;\nreg [1:0] c4;\nreg [1:0]\
    \ c5;\nreg [1:0] c6;\nreg [1:0] c7;\n\nalways begin\n\tc0 = a[1] xor b[1];\n\t\
    c1 = ~a[1] & b[1];\n\tc2 = a[1] & ~b[1];\n\tc3 = ~a[1] & ~b[1];\n\tc4 = c[3];\n\
    \tc5 = ~a[0] & b[0];\n\tc6 = a[0] & ~b[0];\n\tc7 = ~a[0] & ~b[0];\n\tc[3:0] =\
    \ c0 + c1 + c2 + c3 + c4 + c5 + c6 + c7;\nend\n\nendmodule\n```\n\n### 2) Verilog\
    \ code (part 2):\n```\n/**\n* Description:\n*  This is an adder circuit\n*  with\
    \ 2 2-bit inputs and \n*  one 4-bit output.\n**/\nmodule adder(\n\tinput [1:0]\
    \ a,\n\tinput [1:0] b,\n\toutput [3:0] c\n);\n\nreg [1:0] c0;\nreg [1:0] c1;\n\
    reg [1:0] c2;\nreg [1:0] c3;\nreg [1:0] c4;\nreg [1:0] c5;\nreg [1:0] c6;\nreg\
    \ [1:0] c7;\n\nalways begin\n\tc0 = a[1] xor b[1];\n\tc1 = ~a[1] & b[1];\n\tc2\
    \ = a[1] & ~b[1];\n\tc3 = ~a[1] & ~b[1];\n\tc4 = c[3];\n\tc5 = ~a[0] & b[0];\n\
    \tc6 = a[0] & ~b[0];\n\tc7 = ~a[0] & ~b[0];\n\tc[3:0] = c0 + c1 + c2 + c3 + c4\
    \ + c5 + c6 + c7;\nend\n\nendmodule\n```\n\n### 3) Verilog code (part 3):\n```\n\
    /**\n* Description:\n*  This is an adder circuit\n*  with 2 2-bit inputs and \n\
    *  one 4-bit output.\n**/\nmodule adder(\n\tinput [1:0] a,\n\tinput [1:0] b,\n\
    \toutput [3:0] c\n);\n\nreg [1:0] c0;\nreg [1:0] c1;\nreg [1:0] c2;\nreg [1:0]\
    \ c3;\nreg [1:0] c4;\nreg [1:0] c5;\nreg [1:0] c6;\nreg [1:0] c7;\n\nalways begin\n\
    \tc0 = a[1] xor b[1];\n\tc1 = ~a[1] & b[1];\n\tc2 = a[1] & ~b[1];\n\tc3 = ~a[1]\
    \ & ~b[1];\n\tc4 = c[3];\n\tc5 = ~a[0] & b[0];\n\tc6 = a[0] & ~b[0];\n\tc7 = ~a[0]\
    \ & ~b[0];\n\tc[3:0] = c0 + c1 + c2 + c3 + c4 + c5 + c6 + c7;\nend\n\nendmodule\n\
    ```\n\n### 4) Verilog code (part 4):\n```\n/**\n* Description:\n*  This is an\
    \ adder circuit\n*  with 2 2-bit inputs and \n*  one 4-bit output.\n**/\nmodule\
    \ adder(\n\tinput [1:0] a,\n\tinput [1:0] b,\n\toutput [3:0] c\n);\n\nreg [1:0]\
    \ c0;\nreg [1:0] c1;\nreg [1:0] c2;\nreg [1:0] c3;\nreg [1:0] c4;\nreg [1:0] c5;\n\
    reg [1:0] c6;\nreg [1:0] c7;\n\nalways begin\n\tc0 = a[1] xor b[1];\n\tc1 = ~a[1]\
    \ & b[1];\n\tc2 = a[1] & ~b[1];\n\tc3 = ~a[1] & ~b[1];\n\tc4 = c[3];\n\tc5 = ~a[0]\
    \ & b[0];\n\tc6 = a[0] & ~b[0];\n\tc7 = ~a[0] & ~b[0];\n\tc[3:0] = c0 + c1 + c2\
    \ + c3 + c4 + c5 + c6 + c7;\nend\n\nendmodule\n```\n\n### 5) Verilog code (part\
    \ 5):\n```\n/**\n* Description:\n*  This is an adder circuit\n*  with 2 2-bit\
    \ inputs and \n*  one 4-bit output.\n**/\nmodule adder(\n\tinput [1:0] a,\n\t\
    input [1:0] b,\n\toutput [3:0] c\n);\n\nreg [1:0] c0;\nreg [1:0] c1;\nreg [1:0]\
    \ c2;\nreg [1:0] c3;\nreg [1:0] c4;\nreg [1:0] c5;\nreg [1:0] c6;\nreg [1:0] c7;\n\
    \nalways begin\n\tc0 = a[1] xor b[1];\n\tc1 = ~a[1] & b[1];\n\tc2 = a[1] & ~b[1];\n\
    \tc3 = ~a[1] & ~b[1];\n\tc4 = c[3];\n\tc5 = ~a[0] & b[0];\n\tc6 = a[0] & ~b[0];\n\
    \tc7 = ~a[0] & ~b[0];\n\tc[3:0] = c0 + c1 + c2 + c3 + c4 + c5 + c6 + c7;\nend\n\
    \nendmodule\n```\n\n### 6) Verilog code (part 6):\n```\n/**\n* Description:"
- code: |-
    module latch (input d, c, output union {
    packed reg [7:0] q, q_b;
    }
    q_out );
    always begin
    wait ( c );
    end
    endmodule
    ### Testbench:
    #include <systemc.h>
    SC_MODULE(test) {
    // Inputs
    sc_in <bool> d, c;
    // Outputs
    sc_out <unsigned int> q_out;
    // SystemC process
    SC_CTOR(test) {
    SC_THREAD(test_proc);
    }
    void test_proc() {

    while(1)
    {
    q_out.write(0);
    wait();
    }
    // Test-Case 1
    q_out.write(1);
    q_out.write(2);
    wait();
    q_out.write(3);
    wait();
    q_out.write(4);
    wait();
    q_out.write(5);
    wait();
    q_out.write(6);
    wait();
    q_out.write(7);
    wait();
    q_out.write(8);
    wait();
    q_out.write(9);
    wait();
    q_out.write(10);
    wait();
    q_out.write(11);
    wait();
    q_out.write(12);
    wait();
    q_out.write(13);
    wait();
    q_out.write(14);
    wait();
    q_out.write(15);
    wait();
    q_out.write(16);
    wait();
    q_out.write(17);
    wait();
    q_out.write(18);
    wait();
    q_out.write(19);
    wait();
    q_out.write(20);
    wait();
    q_out.write(21);
    wait();
    q_out.write(22);
    wait();
    q_out.write(23);
    wait();
    q_out.write(24);
    wait();
    q_out.write(25);
    wait();
    q_out.write(26);
    wait();
    q_out.write(27);
    wait();
    q_out.write(28);
    wait();
    q_out.write(29);
    wait();
    q_out.write(30);
    wait();
    q_out.write(31);
    wait();
    q_out.write(32);
    wait();
    q_out.write(33);
    wait();
    q_out.write(34);
    wait();
    q_out.write(35);
    wait();
    q_out.write(36);
    wait();
    q_out.write(37);
    wait();
    q_out.write(38);
    wait();
    q_out.write(39);
    wait();
    q_out.write(40);
    wait();
    q_out.write(41);
    wait();
    q_out.write(42);
    wait();
    q_out.write(43);
    wait();
    q_out.write(44);
    wait();
    q_out.write(45);
    wait();
    q_out.write(46);
    wait();
    q_out.write(47);
    wait();
    q_out.write(48);
    wait();
    q_out.write(49);
    wait();
    q_out.write(50);
    wait();
    q_out.write(51);
    wait();
    q_out.write(52);
    wait();
    q_out.write(53);
    wait();
    q_out.write(54);
    wait();
    q_out.write(55);
    wait();
    q_out.write(56);
    wait();
    q_out.write(57);
    wait();
    q_out.write(58);
    wait();
    q_out.write(59);
    wait();
    q_out.write(60);
    wait();
    q_out.write(61);
    wait();
    q_out.write(62);
    wait();
    q_out.write(63);
    wait();
    // Test-Case 2
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    q_out.write(0);
    q_out.write(0);
    q_out.write(0);
    wait();
    }
    }
    SC_CTOR(test) {
    SC_THREAD(test_proc2);
    }
    void test_proc2() {
    q_out.write(0);
    wait();
    }
    void test_proc3() {
    q_out.write(0);
    wait();
    }
    void test_proc4() {
    q_out.write(0);
    wait();
    }
    };
    int sc_main(int argc, char *argv[]) {
    test tb("tb");
    tb.d(d_in);
    tb.c(c_in);
    tb.q_out(q_out);
    sc_start(SC_ZERO_TIME);
    return 0;
    }

    I used SystemC 2.3.1, and the compiler is "C:\Program Files\Synopsys\HDL Tools\vHDL\2014.1.0.0\bin\vcom.exe"

    When I run the testbench using vsim, I get the following error.

    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out cannot be output, it is not writable
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out cannot be output, it is not writable
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out cannot be output, it is not writable
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out cannot be output, it is not writable
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out cannot be output, it is not writable
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh\Desktop\Testbench\testbench/test.v: (23, 23): variable q_out must be an array
    Error (1005): VerilogNet: vcom: file C:\Users\hitesh
- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    localparam r_struct = rand_struct(rand0, rand1, rand2, rand3, rand4, rand5, rand6, rand7, rand8, rand9);
    assign g = (
- code: |-
    module example6(a, b, f);
    input b, a;
    output f;
    parameter c = 10;
    struct rand s;
    structure {
    wire b, a;
    reg f;
    } s_inst;
    assign f = 1;
    initial begin
    s.b = random();
    s.a = random();
    s_inst.b = s.b;
    s_inst.a = s.a;
    s_inst.f = s.f;
    end
    always @(posedge s_inst.b) begin
    s_inst.f = (!s_inst.b | s_inst.a);
    end
    always @* begin
    s.b = s_inst.b;
    s.a = s_inst.a;
    s.f = s_inst.f;
    end
    endmodule
    ### Tests:
    1 - Verify that b is randomized
    2 - Verify that a is randomized
    3 - Verify that f is randomized
    4 - Verify that the final result (f) satisfies the given expressions.

    ### Questions

    1)

    Is this a randomized structure?

    Yes. Each of the statements in this structure has a random input.

    2)

    Does the final result (f) satisfy the given expressions?

    No. The final result is the same as in the original design.

    3)

    Generate some random seeds that cause the final result (f) of this design to satisfy the given expressions.

    Using a 32-bit seed value of 1211544672, we can see that f is 0 at the end.
- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    reg f_out_0, f_out_1, f_out_2, f_out_3;
    always @* begin
    f_out_0 = 0;
    f_out_1 = 0;
    f_out_2 = 0;
    f_out_3 = 0;
    #2
    f_out_0 = 1;
    f_out_1 = 0;
    f_out_2 = 0;
    f_out_3 = 0;
    #2
    f_out_0 = 1;
    f_out_1 = 1;
    f_out_2 = 0;
    f_out_3 = 0;
    #2
    f_out_0 = 1;
    f_out_1 = 1;
    f_out_2 = 1;
    f_out_3 = 0;
    end
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    endmodule
    ### Testing Results
    ```
    [Info] Output file: /tmp/vvp-4517cb.fst
    [Info] Finished simulation for 500 seeds.
    [Info] Seed 1
    [Info] Fst-dump file for seed 1: /home/user/verilator/FST-Sim/vvp-4517cb_seed1.fst
    [Info] Seed 2
    [Info] Fst-dump file for seed 2: /home/user/verilator/FST-Sim/vvp-4517cb_seed2.fst
    [Info] Seed 3
    [Info] Fst-dump file for seed 3: /home/user/verilator/FST-Sim/vvp-4517cb_seed3.fst
    [Info] Seed 4
    [Info] Fst-dump file for seed 4: /home/user/verilator/FST-Sim/vvp-4517cb_seed4.fst
    [Info] Seed 5
    [Info] Fst-dump file for seed 5: /home/user/verilator/FST-Sim/vvp-4517cb_seed5.fst
    [Info] Seed 6
    [Info] Fst-dump file for seed 6: /home/user/verilator/FST-Sim/vvp-4517cb_seed6.fst
    [Info] Seed 7
    [Info] Fst-dump file for seed 7: /home/user/verilator/FST-Sim/vvp-4517cb_seed7.fst
    [Info] Seed 8
    [Info] Fst-dump file for seed 8: /home/user/verilator/FST-Sim/vvp-4517cb_seed8.fst
    [Info] Seed 9
    [Info] Fst-dump file for seed 9: /home/user/verilator/FST-Sim/vvp-4517cb_seed9.fst
    [Info] Seed 10
    [Info] Fst-dump file for seed 10: /home/user/verilator/FST-Sim/vvp-4517cb_seed10.fst
    [Info] Seed 11
    [Info] Fst-dump file for seed 11: /home/user/verilator/FST-Sim/vvp-4517cb_seed11.fst
    [Info] Seed 12
    [Info] Fst-dump file for seed 12: /home/user/verilator/FST-Sim/vvp-4517cb_seed12.fst
    [Info] Seed 13
    [Info] Fst-dump file for seed 13: /home/user/verilator/FST-Sim/vvp-4517cb_seed13.fst
    [Info] Seed 14
    [Info] Fst-dump file for seed 14: /home/user/verilator/FST-Sim/vvp-4517cb_seed14.fst
    [Info] Seed 15
    [Info] Fst-dump file for seed 15: /home/user/verilator/FST-Sim/vvp-4517cb_seed15.fst
    [Info] Seed 16
    [Info] Fst-dump file for seed 16: /home/user/verilator/FST-Sim/vvp-4517cb_seed16.fst
    [Info] Seed 17
    [Info] Fst-dump file for seed 17: /home/user/verilator/FST-Sim/vvp-4517cb_seed17.fst
    [Info] Seed 18
    [Info] Fst-dump file for seed 18: /home/user/verilator/FST-Sim/vvp-4517cb_seed18.fst
    [Info] Seed 19
    [Info] Fst-dump file for seed 19: /home/user/verilator/FST-Sim/vvp-4517cb_seed19.fst
    [Info] Seed 20
    [Info] Fst-dump file for seed 20: /home/user/verilator/FST-Sim/vvp-4517cb_seed20.fst
    [Info] Seed 21
    [Info] Fst-dump file for seed 21: /home/user/verilator/FST-Sim/vvp-4517cb_seed21.fst
    [Info] Seed 22
    [Info] Fst-dump file for seed 22: /home/user/verilator/FST-Sim/vvp-4517cb_seed22.fst
    [Info] Seed 23
    [Info] Fst-dump file for seed 23: /home/user/verilator/FST-Sim/vvp-4517cb_seed23.fst
    [Info] Seed 24
    [Info] Fst-dump file for seed 24: /home/user/verilator/FST-Sim/vvp-4517cb_seed24.fst
    [Info] Seed 25
    [Info] Fst-dump file for seed 25: /home/user/verilator/FST-Sim/vvp-4517cb_seed25.fst
    [Info] Seed 26
    [Info] Fst-dump file for seed 26: /home/user/verilator/FST-Sim/vvp-4517cb_seed26.fst
    [Info] Seed 27
    [Info] Fst-dump file for seed 27: /home/user/verilator/FST-Sim/vvp-4517cb_seed27.fst
    [Info] Seed 28
    [Info] Fst-dump file for seed 28: /home/user/verilator/FST-Sim/vvp-4517cb_seed28.fst
    [Info] Seed 29
    [Info] Fst-dump file for seed 29: /home/user/verilator/FST-Sim/vvp-4517cb_seed29.fst
    [Info] Seed 30
    [Info] Fst-dump file for seed 30: /home/user/verilator/FST-Sim/vvp-4517cb_seed30.fst
    [Info] Seed 31
    [Info] Fst-dump file for seed 31: /home/user/verilator/FST-Sim/vvp-4517cb_seed31.fst
    [Info] Seed 32
    [Info] Fst-dump file for seed 32: /home/user/verilator/FST-Sim/vvp-4517cb_seed32.fst
    [Info] Seed 33
    [Info] Fst-dump file for seed 33: /home/user/verilator/FST-Sim/vvp-4517cb_seed33.fst
    [Info] Seed 34
    [Info] Fst-dump file for seed 34: /home/user/verilator/FST-Sim/vvp-4517cb_seed34.fst
    [Info] Seed 3
- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    import rand;
    input x1, x2, x3, x4;
    output f, g, h;
    rand rg1(0, 0), rg2(0, 1), rg3(1, 1), rg4(2, 2), rg5(3, 3), rg6(1, 3
- code: "module example4(x1, x2, x3, x4, f, g, h);\ninput x1, x2, x3, x4;\noutput\
    \ f, g, h;\nwire g_r, h_r, f_r;\nstruct rand {\nrand();\nreg g_r, h_r, f_r;\n\
    always @(x1 or x2 or x3 or x4) begin\ng_r <= (x1 & x3) | (x2 & x4);\nh_r <= (x1\
    \ | x3) & (x2 | x4);\nf_r <= g_r | h_r;\nend\nassign f = f_r;\nendmodule\n###\
    \ Explanation:\nIn this program, we can see that the output f is simply the sum\
    \ of g and h. Thus to test the behaviour of the output f, we need to provide a\
    \ test case where g and h are different from each other. As g and h are random\
    \ variables, we can specify it as an input parameter to the test harness. We can\
    \ use the following code to assign an input parameter to a module called example4.\n\
    ### Test Harness:\ndef test_example4():\ndut = example4(x1=5, x2=6, x3=11, x4=12)\n\
    def setup():\nyield dut.x1.next, 5\nyield dut.x2.next, 6\nyield dut.x3.next, 11\n\
    yield dut.x4.next, 12\ndef test():\nyield dut.g.next, 4\nyield dut.h.next, 3\n\
    yield dut.f.expect, 7\nrun_ simulation()\n\nThere are some limitations in using\
    \ the structure in this case, however, we can create this structure by using a\
    \ structural replacement rule. In case we want a random variable to be a structural\
    \ member, we need to declare them as wire.\n\n### Exercise 1\n\nWrite a structural\
    \ replacement rule that generates a random variable for each structural member.\n\
    \n\u2022 The structural replacement rule should be called rand_member.\n\u2022\
    \ It should take in a module as the first argument and a structure as the second\
    \ argument.\n\u2022 It should create a wire variable that is called rand_member\
    \ and should be of the same type and size of the structure member.\n\u2022 The\
    \ value of rand_member should be random.\n\u2022 It should assign the value of\
    \ the rand_member to the structure member and should be a blocking assignment.\n\
    import pyverilog.vparser.parser as parser\nimport pyverilog.vpgen.random as random\n\
    import random\nfrom collections import OrderedDict\ndef rand_member(module, structure):\n\
    random_var = random.random_wire(structure)\nreturn (random_var, random_var.type,\
    \ random_var.bits)\n\nThe module should have one structural member rand_member\
    \ and we can test it as the following.\nfrom random import randint\ndef test():\n\
    yield dut.rand_member.next, 5\nyield dut.rand_member.expect, 5\nyield dut.rand_member.next,\
    \ 6\nyield dut.rand_member.expect, 6\nrun_simulation()\n\nSimilar to what we have\
    \ done before, we can also create a function that generates random wires of all\
    \ the structural members in the module and assign them to the outputs of the module\
    \ so that we can test the outputs.\n\n### Exercise 2\n\nWrite a structural replacement\
    \ rule that generates random wires for all the structural members and assigns\
    \ it to the outputs of a module.\n\n\u2022 The structural replacement rule should\
    \ be called rand_module.\n\u2022 It should take in a module as the first argument\
    \ and it should not take in a structure as the second argument.\n\u2022 It should\
    \ return a dictionary of wires as the outputs.\ndef rand_module(module):\nwire_dict\
    \ = OrderedDict()\nfor name, member in module.structural.items():\nwire_dict[name]\
    \ = rand_member(module, member)\nreturn wire_dict\n\nThe module should have three\
    \ structural members rand_member, rand_module, and rand_struct. We can test it\
    \ as the following.\ndef setup():\nyield dut.rand_module.next, 4\nyield dut.rand_struct.next,\
    \ 3\nyield dut.rand_member.expect, 4\nyield dut.rand_struct.expect, 3\n\nThe module\
    \ that we use for testing should be defined as the following.\nmodule test(rand_module,\
    \ rand_struct, rand_member);\ninput rand_module;\ninput rand_struct;\ninput rand_member;\n\
    wire rand_module;\nwire rand_struct;\nwire rand_member;\nassign rand_module =\
    \ rand_module;\nassign rand_struct = rand_struct;\nassign rand_member = rand_member;\n\
    endmodule\n\nThe test harness should be defined as the following.\ndef test():\n\
    dut = test(rand_module=1, rand_struct=2, rand_member=3)\nyield dut.rand_module.expect,\
    \ 1\nyield dut.rand_struct.expect, 2\nyield dut.rand_member.expect, 3\nrun_simulation()\n\
    \nTo test the behaviour of the module test, we can run it.\n\n### Exercise 3\n\
    \nWrite a structural replacement rule that generates a random variable for each\
    \ structure member and assigns it to the inputs of a module.\n\n\u2022 The structural\
    \ replacement rule should be called rand_struct.\n\u2022 It should take in a module\
    \ as the first argument and a structure as the second argument.\n\u2022 It should\
    \ create a wire variable that is called rand_struct and should be of the same\
    \ type and size of the structure member.\n\u2022 The value of rand_struct should\
    \ be random.\n\u2022 It should assign the value of the rand_struct to the structure\
    \ member and should be a blocking assignment.\ndef rand_struct(module, structure):\n\
    random_var = random.random_wire(structure)\nreturn (random_var, random_var.type,\
    \ random_var.bits)\n\nThe module should have one structural member rand_member\
    \ and we can test it as the following.\ndef test():\ndut = test(rand_module=1,\
    \ rand_struct=2, rand_member=3)\nyield dut.rand_module.expect, 1\nyield dut.rand_struct.expect,\
    \ 2\nyield dut.rand_member.expect, 3\nrun_simulation()\n\nThe module that we use\
    \ for testing should be defined as the following.\nmodule test(rand_module, rand_struct,\
    \ rand_member);\ninput rand_module;\ninput rand_struct;\ninput rand_member;\n\
    wire rand_module;\nwire rand_struct;\nwire rand_member;\nassign rand_module =\
    \ rand_module;\nassign rand_struct = rand_struct;\nassign rand_member = rand_member;\n\
    endmodule\n\nThe test harness should be defined as the following.\ndef test():\n\
    dut = test(rand_module=1, rand_struct=2, rand_member=3)\nyield dut.rand_module.expect,\
    \ 1\nyield dut.rand_struct.expect, 2\nyield dut.rand_member.expect, 3\nrun_simulation()\n\
    \nTo test the behaviour of the module test, we can run it.\n\nThere is a limitation\
    \ in the way we have created these functions. To test the behaviour of a module\
    \ that has a structural member, we need to assign it to a wire. However, if we\
    \ have a random variable as the structural member, the assignment will not be\
    \ a blocking assignment. A structural member is a random variable that is assigned\
    \ to the structural member. So we need to create a function that returns a blocking\
    \ assignment instead of a random variable.\n\n### Exercise 4\n\nModify the function\
    \ rand_member to create a blocking assignment.\n\n\u2022 The blocking assignment\
    \ should be created by using a structural replacement rule called rand_member_assign.\n\
    \u2022 It should take in a module as the first argument and a structure as the\
    \ second argument.\n\u2022 It should create a wire variable and assign the value\
    \ of the rand_member to it.\n\u2022 It should assign the value of the assigned\
    \ wire to the structure member.\n\u2022 The function should return the assigned\
    \ wire.\nimport pyverilog.vparser.parser as parser\nimport pyverilog.vpgen.random\
    \ as random\nimport random\nfrom collections import OrderedDict\ndef rand_member_assign(module,\
    \ structure):\nassign_wire = random.random_wire(structure)\nassign_wire.assign_to(structure)\n\
    return assign_wire\n\nThe module should have one structural member rand_member\
    \ and we can test it as the following.\ndef test():\ndut = test(rand_module=1,\
    \ rand_struct=2, rand_member=3)\nyield dut.rand_module.expect, 1\nyield dut.rand_struct.expect,\
    \ 2\nyield dut.rand_member.expect, 3\nrun_simulation()\n\nThe module that we use\
    \ for testing should be defined as the following.\nmodule test(rand_module, rand_struct"
- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    integer random_integer;
    boolean rand_boolean = 1'b0;
    real rand_real = 0.5;
    string rand_string = "hello";

    randomization
    structure rand_structure;
    rand_structure.integer = random_integer;
    rand_structure.boolean = rand_boolean;
    rand_structure.real = rand_real;
    rand_structure.string = rand_string;
    endrandomization

    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = g | h;
    endmodule

    ### Results:

    #### RANDOM FUNCTION:
    Test results of random function.

    ![image](https://user-images.githubusercontent.com/65753626/123552020-88a30a00-d772-11eb-955b-70c91b33505f.png)

    #### RANDOM NUMBER:
    Test results of the random number function.

    ![image](https://user-images.githubusercontent.com/65753626/123552033-96588f80-d772-11eb-841b-86a82f9a858d.png)

    #### RANDOM STRING:
    Test results of the random string function with different lengths of the string.

    ![image](https://user-images.githubusercontent.com/65753626/123552043-a07a8e00-d772-11eb-95e9-17e95e586974.png)

    #### RANDOM REAL:
    Test results of the random real function.

    ![image](https://user-images.githubusercontent.com/65753626/123552051-a8d2c900-d772-11eb-8190-27b33c2e02f2.png)

    #### RANDOM BOOLEAN:
    Test results of the random boolean function.

    ![image](https://user-images.githubusercontent.com/65753626/123552060-b0926d80-d772-11eb-816d-80f438147b19.png)

    #### RANDOM CHARACTER:
    Test results of the random character function.

    ![image](https://user-images.githubusercontent.com/65753626/123552065-bb4d0280-d772-11eb-9f60-05c014b58543.png)

    #### RANDOM INTEGER:
    Test results of the random integer function.

    ![image](https://user-images.githubusercontent.com/65753626/123552078-c43dd400-d772-11eb-8c73-d14621748ca5.png)

    #### RANDOM STRUCTURE:
    Test results of the random structure function.

    ![image](https://user-images.githubusercontent.com/65753626/123552086-d0299600-d772-11eb-80b6-027a0881fe98.png)


    /src/test_bench.py
    import sys
    from pathlib import Path
    from time import time
    from functools import wraps
    from tempfile import gettempdir
    from shutil import rmtree
    from contextlib import contextmanager
    from subprocess import check_output, CalledProcessError, PIPE, STDOUT
    from argparse import ArgumentParser
    from random import randint, random, choice

    from pyverilog.ast_code_generator import gen_module, gen_code
    from pyverilog.parser.parser import parse


    def test(func, *args):
        t0, result = time(), func(*args)
        print(f'{func.__name__}, {t0:.0f} ms', end='')
        print(f' [{result}]') if result is not None else print()


    def random_func_arg():
        '''Generate a random function name.'''
        n = randint(1, 3)
        return 'random' + ''.join(('integer','real','string', 'boolean',
                                   'character', 'integer','real','string',
                                   'boolean', 'character')[i] for i in range(n))


    def random_string():
        '''Generate a random string.'''
        return''.join(choice('abcdefghijklmnopqrstuvwxyz') for _ in range(randint(1, 5)))


    def random_integer():
        '''Generate a random integer.'''
        return randint(-(1 << 32), 1 << 32)


    def random_real():
        '''Generate a random real.'''
        return random()


    def random_boolean():
        '''Generate a random boolean.'''
        return bool(randint(0, 1))


    def random_character():
        '''Generate a random character.'''
        return chr(randint(0, 255))


    def random_structure():
        '''Generate a random structure.'''
        return type('random_structure', (object,), {
            'integer': random_integer(),'real': random_real(),
           'string': random_string(), 'boolean': random_boolean(),
            'character': random_character()})


    def random_var():
        '''Generate a random variable.'''
        return f'random_{random_func_arg()}'


    def random_port():
        '''Generate a random port.'''
        return random_var()


    def test_func(func):
        '''Function decorator, add function's name to func attribute.'''
        @wraps(func)
        def wrapper(*args):
            return func(*args)
        wrapper.func = func.__name__
        return wrapper


    def remove_temp_files(dir_path):
        '''Remove temporary files and folders.'''
        rmtree(Path(dir_path), ignore_errors=True)


    @contextmanager
    def temporary_directory():
        '''Create a temporary directory.'''
        try:
            yield gettempdir()
        except OSError:
            return None
        except:
            raise
        else:
            return gettempdir()


    def generate_test_file(file_path, content):
        '''Genreate a test file.'''
        with open(file_path, 'w') as f_file:
            f_file.write(content)


    def get_test_file_path(file_path):
        return Path(file_path).absolute()


    def get_test_file_dir(file_path):
        return get_test_file_path(file_path).parent.absolute()


    def compile_test_file(file_path):
        '''Compile an RTL test file.'''
        test_file_dir = get_test_file_dir(file_path)
        code = gen_module(parse(file_path))
        generate_test_file(test_file_dir / 'test_bench_pyverilog.v', code)
        compile_cmd = ['iverilog', '-o', test_file_dir / 'test_bench_pyverilog_compiled.vvp',
                       test_file_dir / 'test_bench_pyverilog.v']
        try:
            check_output(compile_cmd, cwd=test_file_dir, stderr=STDOUT)
        except CalledProcessError as e:
            raise CalledProcessError(e.cmd, e.returncode, e.output)


    @test_func
    def generate_module(name, content):
        '''Generate an RTL module.'''
        file_path = get_test_file_path(name)
        generate_test_file(file_path, content)
        compile_test_file(file_path)

        @test_func
        def compile_module(name):
            '''Compile an RTL module.'''
            compile_test_file(name)

        @test_func
        def execute_module(name):
            '''Execute an RTL module.'''
            test_file_dir = get_test_file_dir(name)
            run_cmd = ['vvp', '-N', test_file_dir / 'test_bench_pyverilog_compiled.vvp',
                       test_file_dir / 'test_bench_pyverilog.v']
            try:
                check_output(run_cmd, cwd=test_file_dir, stderr=STDOUT)
            except CalledProcessError as e
- code: |-
    module example3_1 (x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    struct {
    rand : 1;
    } s;
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    always_ff @(posedge clk or negedge rst_n) begin
    if (rst_n == 1'b1) begin
    f <= 1'b0;
    g <= 1'b0;
    h <= 1'b0;
    end else begin
    f <= g | h;
    end
    end endmodule

    module example3_2 (x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    struct {
    rand : 1;
    } s;
    assign g = (x1 | x3) & (x2 | x4);
    assign h = (x1 | x3) & (x2 | x4);
    always_ff @(posedge clk or negedge rst_n) begin
    if (rst_n == 1'b1) begin
    f <= 1'b0;
    g <= 1'b0;
    h <= 1'b0;
    end else begin
    f <= g | h;
    end
    end endmodule
    ### Output:
    test_result = FAIL
    ### Expected Output:
    test_result = PASS
    /test/benchmarks/vpp/src/vpp_tests_6/src/vpp_tests_6.c
    ///
    /// @file vpp_tests_6.c
    ///
    /// @copyright All code copyright Movidius Ltd 2012, all rights reserved
    ///            For License Warranty see: common/license.txt
    ///
    /// @defgroup
    /// @{
    /// @brief    VPP Tests
    /// @details  VPP test suite
    /// @{
    /// @brief    Tests : CMXVPP_6
    /// @details
    /// @{

    #ifdef __XC__
    #include <stdio.h>
    #include <stdlib.h>
    #endif

    #include <string.h>

    /* Unit Test includes */
    #include "Test.h"
    #include "v
- code: |-
    module example4(x1, x2, x3, x4, f, g, h);
    input x1, x2, x3, x4;
    output f, g, h;
    logic rand1, rand2, rand3, rand4;
    always_comb
    begin
    rand1 = 1'b0;
    rand2 = 1'b0;
    rand3 = 1'b0;
    rand4 = 1'b0;
    {rand1, rand2} = {rand1, rand3};
    {rand2, rand4} = {rand2, rand4};
    assign g = (x1 & x3) | (x2 & x4);
    assign h = (x1 | x3) & (x2 | x4);
    assign f = (g | h) & (rand1 | rand2);
    end
    endmodule
    `

    ```

    Note: `//wait(c)` should be replaced with `wait()` that is blocking for `100ns`.
    Upvotes: 4 [selected_answer]
- code: |-
    module example13(x1, x2, x3, x4, g);
    input x1, x2, x3, x4;
    output g;

    initial
    g = 0;

    always @(posedge clk) begin
    g = i0? (x1 & x3) : (x2 & x4);
    g = i1? g : g;
    g = i2? g : g;
    g = i3? g: g;
    end
    '''

    _example14 = '''
    ### Base Verilog Code:
    module example14(x1, x2, x3, x4, g);
    input x1, x2, x3, x4;
    output g;

    always @(posedge clk)
    g = (x
- code: "module example6(x1, x2, x3, x4, f, g, h);\ninput x1, x2, x3, x4;\noutput\
    \ f, g, h;\n\n// Test nested randomized structure\nrand bit r1;\nrand bit r2;\n\
    rand bit r3;\nstruct random_struct {\nbit rand b1 = 100;\nbit rand b2 = 100;\n\
    bit rand b3 = 100;\n} random_structure_instance;\n\n// Test blocking assignment\n\
    assign g <- (x1 & x3) | (x2 & x4);\nassign h <- (x1 | x3) & (x2 | x4);\nassign\
    \ f <- g | h;\nendmodule\n### Simulation Results:\n\n\u2022 x1 and x2 are assigned\
    \ using a constant value.\n\u2022 x3 and x4 are assigned using a constant value.\n\
    \u2022 f is assigned the value of g or h.\n\n### Observations:\n\n\u2022 Conditional\
    \ randomization on a blocking assignment inside a nested randomized structure\
    \ was not supported.\n\n### Limitations\n\n\u2022 Conditional randomization of\
    \ structure members are not currently supported by EDA Playground."
- code: |-
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    struct pack {
    logic [0] p0, p1;
    logic [1] p2, p3;
    };
    pack in_split;
    struct pack_xor {
    logic [0] p0, p1;
    logic [1] p2, p3;
    };
    pack_xor in_xor;
    assign parity = in_xor.p0;
    assign all_ones = in_xor.p1;
    assign in_split.p0 = in[0];
    assign in_split.p1 = in[1];
    assign in_split.p2 = in[2];
    assign in_split.p3 = in[3];
    assign in_xor.p0 = in_split.p0;
    assign in_xor.p1 = in_split.p1;
    assign in_xor.p2 = in_split.p2;
    assign in_xor.p3 = in_split.p3;
    endmodule
    ### Simulation Result:
    Simulation shows 128 errors in the Base Verilog code and 0 errors in the Variation Instruction code.

    **Summary:**
    This simulation result shows the effect of structure-based logic operation on the performance of the design under the variation instruction. The number of errors in the Variation Instruction code was less than the number of errors in the Base Verilog code.
- code: "module par(in, parity, all_ones);\ninput [7:0] in;\noutput parity, all_ones;\n\
    struct logic [7:0] {logic [0:3] x1, x0} in_struct;\nassign in_struct.x1 = {in[3:0],\
    \ in[7:4]};\nassign in_struct.x0 = in[7:4];\nassign parity = ^in_struct.x1 ^ ^in_struct.x0;\n\
    assign all_ones = &in_struct.x1 & &in_struct.x0;\nendmodule\n### Results:\n\u2022\
    \ The original code is more compact and allows for more efficient testbenches\
    \ because it is more generic and can be used for any length, width and type of\
    \ inputs, instead of having to test each individually.\n\u2022 The modified code\
    \ is easier to read and understand.\n\u2022 The modified code generates fewer\
    \ testcases compared to the original code, since they are all generated by using\
    \ bitwise operations on the struct.\n\n## Summary\n\nThe aim of this project was\
    \ to test the performance of a 64-bit synthesizable parallel array with multiple\
    \ testbenches which take inputs of different lengths, widths and types of logic\
    \ values. Three testbenches are implemented, each one for a different instruction\
    \ and logic operation in the synthesized design. They are:\n\n\u2022 The first\
    \ testbench is for a \u201Cbitwise not\u201D operation where the width of the\
    \ input is unknown.\n\u2022 The second testbench is for a \u201Cbitwise and\u201D\
    \ operation where the width of the input is unknown.\n\u2022 The third testbench\
    \ is for a \u201Cbitwise parity\u201D operation where the width of the input is\
    \ unknown.\n\n## Conclusion\n\n\u2022 The parallel structure allows for efficient\
    \ testbenches for multiple inputs of different widths and lengths.\n\u2022 It\
    \ also allows for more generic testbenches and is less time consuming than a testbench\
    \ for each individual input.\n\u2022 This makes it a better candidate for implementation\
    \ in the FPGA.\n\n## References\n\n[1],, and. The parallel array: A powerful technique\
    \ for parallel-style verification. IEEE Transactions on Computer-Aided Design\
    \ of Integrated Circuits and Systems, 17(6):325\u2013332, 1998.\n\n## Appendix\n\
    \nA copy of the original verilog code is provided below. It includes the declaration\
    \ of logic fields for the unpacked inputs, an assignment of the inputs into these\
    \ fields and then the actual logic operation on the fields.\n\nmodule par(in,\
    \ parity, all_ones);\ninput [7:0] in;\noutput parity, all_ones;\n\nstruct logic\
    \ [7:0] {logic [0:3] x1, x0} in_struct;\n\nassign in_struct.x1 = {in[3:0], in[7:4]};\n\
    assign in_struct.x0 = in[7:4];\n\nassign parity = ^in_struct.x1 ^ ^in_struct.x0;\n\
    assign all_ones = &in_struct.x1 & &in_struct.x0;\n\nendmodule\nA copy of the modified\
    \ verilog code is provided below. It uses the parallel structure to unpack the\
    \ input into the struct and then apply the operations on the struct.\nmodule par(in,\
    \ parity, all_ones);\ninput [7:0] in;\noutput parity, all_ones;\n\nstruct logic\
    \ [7:0] {logic [0:3] x1, x0} in_struct;\n\nassign in_struct.x1 = {in[3:0], in[7:4]};\n\
    assign in_struct.x0 = in[7:4];\n\nassign parity = ^in_struct.x1 ^ ^in_struct.x0;\n\
    assign all_ones = &in_struct.x1 & &in_struct.x0;\n\nendmodule\n\n### [1]\n\n[1],,\
    \ and. The parallel array: A powerful technique for parallel-style verification.\
    \ IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems,\
    \ 17(6):325\u2013332, 1998.\n\nThe design was then synthesised using the ABC9.2\
    \ software package. After the synthesis process, the resulting verilog source\
    \ code was converted into a netlist file using the ABC9.2 software, which was\
    \ converted into an ELF file using the S2E software, which was then converted\
    \ into a C file. The resulting C file was then compiled using the gcc compiler\
    \ and then executed using the simulator in the S2E software."
- code: "module par(in, parity, all_ones);\ninput [7:0] in;\noutput parity, all_ones;\n\
    \nstruct struct_1{\n\tlogic [7:0] x1;\n\tlogic [7:0] x2;\n};\nstruct struct_1\
    \ s;\n\nassign s.x1 = in[0:7];\nassign s.x2 = in[8:15];\n\nassign parity = s.x1\
    \ ^ s.x2;\nassign all_ones = s.x1 & s.x2;\nendmodule\n\n## 15.13 Example:\n###\
    \ Base Verilog Code:\nmodule par(in, parity, all_ones);\ninput [7:0] in;\noutput\
    \ parity, all_"
- code: "module par(in, parity, all_ones);\ninput [7:0] in;\noutput parity, all_ones;\n\
    wire [7:0] inputs;\nwire [2:0] parity;\nwire [1:0] all_ones;\nassign parity =\
    \ inputs[3] ^ inputs[2] ^ inputs[1] ^ inputs[0];\nassign all_ones = inputs[4]\
    \ & inputs[3] & inputs[2] & inputs[1];\n\nendmodule\n\n#include <stdio.h>\n#include\
    \ <stdint.h>\n\nunion u32 {\nuint32_t u;\nstruct {\nuint8_t x1 : 1;\nuint8_t x2\
    \ : 1;\nuint8_t x3 : 1;\nuint8_t x4 : 1;\n};\n};\n\nint main()\n{\nunion u32 input\
    \ = {0};\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x9e;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x6e;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x3e;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x1e;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0xe;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x0;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\ninput.u\
    \ = 0x77;\nprintf(\"%d \\t %d\", input.x1, input.x2);\nprintf(\"\\n\");\nreturn\
    \ 0;\n}\n\n### Output:\n0 \t0\n1 \t1\n1 \t1\n1 \t1\n1 \t1\n1 \t1\n0 \t0\n1 \t\
    0\n\n## Interesting facts:\n\n\u2022 All logic operations can be performed using\
    \ a single bitwise operation.\n\u2022 The number of bits needed is determined\
    \ by the operation, and there appears to be no upper limit.\n\u2022 If you have\
    \ an even number of inputs, parity is just the exclusive OR of the inputs. (N\
    \ & P)\n\u2022 If you have an odd number of inputs, every other bit is a parity\
    \ bit, and the parity is the exclusive OR of those bits.\n\u2022 The maximum number\
    \ of inputs can be calculated using the formula: (N-1) & (N-2)\n\n## Pipelined\
    \ MUXes:\n\nThe idea behind pipelining is to take the current stage input(s) of\
    \ a circuit, and give output at the next stage. The timing of the current stage\
    \ will not determine the timing of the next stage.\n\nThe next stage will be executed\
    \ when the data of the current stage is ready to be used.\n\nA typical example\
    \ of a pipelined MUX would be a pipelined CPU.\n\n## Pipelined CPU:\n\nPipelined\
    \ CPU consists of the following stages:\n\n1. Instruction fetch\n2. Instruction\
    \ decode\n3. ALU execution\n4. Memory access\n5. Write back\n\nThe first stage\
    \ can be done in parallel, while the fourth and fifth stage will depend on the\
    \ outputs of the earlier stages.\n\nThe instruction fetch and write back will\
    \ be independent, since they are not dependant on each other.\n\n## Pipelined\
    \ CPU Example:\n\nWe will be using the following Verilog code for a pipelined\
    \ CPU, the program counter (PC) is incremented for each instruction.\n\nmodule\
    \ CPU(clk, reset, pc_i, ir_i, m_i, r15_i, r16_i, r17_i, r18_i, op_i, out_i, out_2_i);\n\
    input clk, reset;\ninput [15:0] pc_i, ir_i, r15_i, r16_i, r17_i, r18_i;\noutput\
    \ [15:0] op_i, out_i, out_2_i;\n\nwire [15:0] pc;\nwire [15:0] ir;\nwire [15:0]\
    \ r15;\nwire [15:0] r16;\nwire [15:0] r17;\nwire [15:0] r18;\n\nassign op_i =\
    \ {ir[3:0], ir[5], ir[6:4], ir[7:0]};\n\nalways @ (posedge clk or posedge reset\
    \ or posedge reset)\nbegin\nif(reset)\nbegin\npc <= 0;\nop_i <= 0;\nout_i <= 0;\n\
    out_2_i <= 0;\nend\nelse\nbegin\npc <= pc_i;\nir <= ir_i;\nr15 <= r15_i;\nr16\
    \ <= r16_i;\nr17 <= r17_i;\nr18 <= r18_i;\nend\nend\n\nalways @ (posedge clk)\n\
    begin\nout_i <= 16'd0;\nout_2_i <= 16'd0;\nif(ir[2] == 1)\nout_i = r15;\nelse\
    \ if(ir[2] == 2)\nout_i = r16;\nelse if(ir[2] == 3)\nout_i = r17;\nelse if(ir[2]\
    \ == 4)\nout_i = r18;\nelse if(ir[2] == 5)\nout_i = pc + 16'd0;\nelse if(ir[2]\
    \ == 6)\nout_i = pc + 8'd1;\nelse\nout_i = out_2_i;\n\nif(ir[1] == 1)\nout_2_i\
    \ = out_i;\nelse if(ir[1] == 2)\nout_2_i = 16'd0;\nelse if(ir[1] == 3)\nout_2_i\
    \ = 16'hffff;\nelse if(ir[1] == 4)\nout_2_i = pc + 16'd0;\nelse if(ir[1] == 5)\n\
    out_2_i = pc + 8'd1;\nelse if(ir[1] == 6)\nout_2_i = pc + 8'd2;\nelse if(ir[1]\
    \ == 7)\nout_2_i = pc + 8'd4;\nelse if(ir[1] == 8)\nout_2_i = pc + 8'd8;\nelse\
    \ if(ir[1] == 9)\nout_2_i = pc + 8'd16;\nelse\nout_2_i = ir[0];\n\nend\n\nendmodule\n\
    \n## Output:\n\n### Assembly Code:\n\n.data\n.align 2\n.set _sp, 1\n.global _start\n\
    .global _fin\n.global _in\n_in:\n.word 16'h0123\n.word 16'h0456\n.word 16'h0789\n\
    _fin:\n.word 0\n.text\n.align 2\n.global _start\n_start:\nlui X0, %hi(_in)\naddi\
    \ X0, X0, %lo(_in)\nlw X3, 0(X0)\n\naddi X1, X0, 16\nbeq X3, X1, _fin\n\nlw X3,\
    \ 12(X0)\nsrai X3, X3, 4\naddi X3, X3, 8\nbeq X3, X1, _fin\n\naddi X1, X0, 8\n\
    beq X3, X1, _fin\n\nlw X3, 24(X0)\nsrai X3, X3, 4\naddi X3, X3, 8\nbeq X3, X1,\
    \ _fin\n\naddi X1, X0, 4\nbeq X3, X1, _fin\n\naddi X1, X0, 0\nbeq X3, X1, _fin\n\
    \naddi X1, X0, 8\nbeq X3, X1, _fin\n\naddi X1, X0, 16\nbeq X3, X1, _fin\n\naddi\
    \ X0, X0, 16\nj"
- code: "module par(in, parity, all_ones);\ninput [7:0] in;\noutput one, all_ones;\n\
    assign parity   = ~in;\nassign all_ones = in;\nendmodule\n### Output:\n![image](https://github.com/KarthikG10/Structural-Design/blob/main/Images/5/output.png)\n\
    # Exercise5: Structural Design\n### Task: 05\nImplement the following primitive\
    \ logic functions:\n\n\u2022 AND\n\n\u2022 NAND\n\n\u2022 OR\n\n\u2022 NOR\n\n\
    \u2022 XOR\n\n\u2022 NXOR\n\n\u2022 NOT\n\n\u2022 NAND16, NAND32, NAND64, NAND128,\
    \ NAND256, and NAND512\n\n\u2022 OR16, OR32, OR64, OR128, OR256, and OR512\n\n\
    \u2022 XOR16, XOR32, XOR64, XOR128, XOR256, and XOR512\n\n\u2022 NOT16, NOT32,\
    \ NOT64, NOT128, NOT256, and NOT512\n\n\u2022 NAND8, NAND12, NAND24, NAND48, NAND96,\
    \ and NAND256\n\n\u2022 OR8, OR12, OR24, OR48, OR96, and OR256\n\n\u2022 XOR8,\
    \ XOR12, XOR24, XOR48, XOR96, and XOR256\n\n\u2022 NOT8, NOT12, NOT24, NOT48,\
    \ NOT96, and NOT256\n\n\u2022 NAND8, NAND16, NAND32, NAND64, NAND128, and NAND256\n\
    \n\u2022 OR8, OR16, OR32, OR64, OR128, and OR256\n\n\u2022 XOR8, XOR16, XOR32,\
    \ XOR64, XOR128, and XOR256\n\n\u2022 NOT8, NOT16, NOT32, NOT64, NOT128, and NOT256\n\
    \n\u2022 AND8, AND16, AND32, AND64, AND128, and AND256\n\n\u2022 OR8, OR16, OR32,\
    \ OR64, OR128, and OR256\n\n\u2022 XOR8, XOR16, XOR32, XOR64, XOR128, and XOR256\n\
    \n\u2022 NOT8, NOT16, NOT32, NOT64, NOT128, and NOT256\n\n\u2022 NAND16, NAND256\n\
    \n\u2022 OR16, OR256\n\n\u2022 XOR16, XOR256\n\n\u2022 NOT16, NOT256\n\n\u2022\
    \ AND16, AND256\n\n\u2022 OR16, OR256\n\n\u2022 XOR16, XOR256\n\n\u2022 NOT16,\
    \ NOT256\n\n\u2022 AND32, AND64, AND128\n\n\u2022 OR32, OR64, OR128\n\n\u2022\
    \ XOR32, XOR64, XOR128\n\n\u2022 NOT32, NOT64, NOT128\n\n\u2022 AND64, AND128\n\
    \n\u2022 OR64, OR128\n\n\u2022 XOR64, XOR128\n\n\u2022 NOT64, NOT128\n\n\u2022\
    \ NAND64, NAND128\n\n\u2022 OR64, OR128\n\n\u2022 XOR64, XOR128\n\n\u2022 NOT64,\
    \ NOT128\n\n\u2022 AND128\n\n\u2022 OR128\n\n\u2022 XOR128\n\n\u2022 NOT128\n\n\
    \u2022 NAND128\n\n\u2022 OR128\n\n\u2022 XOR128\n\n\u2022 NOT128\n\n\u2022 AND16,\
    \ AND32, AND64, AND128, AND256\n\n\u2022 OR16, OR32, OR64, OR128, OR256\n\n\u2022\
    \ XOR16, XOR32, XOR64, XOR128, XOR256\n\n\u2022 NOT16, NOT32, NOT64, NOT128, NOT256\n\
    \nTo check that the circuit works correctly, input 0 or 1 to each port and check\
    \ the output. The input to AND/NAND, OR/NOR, XOR/NXOR, NOT and the input to the\
    \ 16-to-8 decoders should be 0 and the 8-to-1 decoder input should be 0.\n\n###\
    \ Code:\n\n`module AND(A,B,Y);`\n`input A,B;`\n`output Y;`\n`assign Y = A & B;`\n\
    `endmodule`\n\n`module NAND(A,B,Y);`\n`input A,B;`\n`output Y;`\n`assign Y = ~(A\
    \ & B);`\n`endmodule`\n\n`module OR(A,B,Y);`\n`input A,B;`\n`output Y;`\n`assign\
    \ Y = A | B;`\n`endmodule`\n\n`module NOR(A,B,Y);`\n`input A,B;`\n`output Y;`\n\
    `assign Y = ~(A | B);`\n`endmodule`\n\n`module XOR(A,B,Y);`\n`input A,B;`\n`output\
    \ Y;`\n`assign Y = ~(A ^ B);`\n`endmodule`\n\n`module NXOR(A,B,Y);`\n`input A,B;`\n\
    `output Y;`\n`assign Y = ~(A ^ B);`\n`endmodule`\n\n`module NOT(A,Y);`\n`input\
    \  A;`\n`output  Y;`\n`assign  Y = ~A;`\n`endmodule`\n\n`module NAND16(A,B,C,D,E,F,G,H,Y);`\n\
    `input A,B,C,D,E,F,G,H;`\n`output Y;`\n`assign Y = ~((A & B) | (C & D) | (E &\
    \ F) | (G & H));`\n`endmodule`\n\n`module NAND32(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Y);`\n\
    `input A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P;`\n`output Y;`\n`assign Y = ~((A & B) |\
    \ (C & D) | (E & F) | (G & H) | (I & J) | (K & L) | (M & N) | (O & P));`\n`endmodule`\n\
    \n`module NAND64(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y);`\n`input\
    \ A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X;`\n`output Y;`\n`assign Y =\
    \ ~((A & B) | (C & D) | (E & F) | (G & H) | (I & J) | (K & L) | (M & N) | (O &\
    \ P) | (Q & R) | (S & T) | (U & V) | (W & X));`\n`endmodule`\n\n`module NAND128(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,AA,AB,Y);`\n\
    `input A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,AA,AB;`\n`output Y;`\n\
    `assign Y = ~((A & B) | (C & D) | (E & F) | (G & H) | (I & J) | (K & L) | (M &\
    \ N) | (O & P) | (Q & R) | (S & T) | (U & V) | (W & X) | (Y & Z) | (AA & AB));`\n\
    `endmodule`\n\n`module NAND256(A,B,C,D,E,F,G,H,I,J,"
- code: |-
    module par_packed(in, par, all_ones);
    input [3:0] in1,in2,in3,in4;
    output par,all_ones;
    wire par1,par2,par3,par4;
    assign par = in1 ^ in2;
    assign par4 = in1 & in2;
    assign par3 = in1 | in2;
    assign par2 = in1 ^ in3;
    assign par1 = in1 & in3;
    assign all_ones = in1 & in2 & in3 & in4;
    endmodule
    ### Testbench:
    module tb_par_packed;
    reg [3:0] in1,in2,in3,in4;
    reg par, all_ones;
    par_packed inst_par_packed (.in1 (in1[0]),.in2 (in1[1]),.in3 (in1[2]),.in4 (in1[3]),.par(par),.all_ones(all_ones));
    initial begin
    in1 = 5'b1010;
    in2 = 5'b1011;
    in3 = 5'b1101;
    in4 = 5'b1110;
    end
    endmodule
    ### Simulation:
    ![image](https://user-images.githubusercontent.com/68240004/121687570-04921e00-cab8-11eb-9229-8c811d373108.png)
    /1809050/Assignment_4/Lab_4_Task_05/Lab_4_Task_05/isim/tb_test_isim_beh.exe.sim/work/a_0375707084_3212880686.c
    /**********************************************************************/
    /*   ____  ____                                                       */
    /*  /   /\/   /                                                       */
    /* /___/  \  /                                                        */
    /* \   \   \/                                                       */
    /*  \   \        Copyright (c) 2003-2009 Xilinx, Inc.                */
    /*  /   /          All Right Reserved.                                 */
    /* /---/   /\                                                         */
    /* \   \  /  \                                                      */
    /*  \___\/\___\                                                    */
    /***********************************************************************/

    /* This file is designed for use with ISim build 0x7708f090 */

    #define XSI_HIDE_SYMBOL_SPEC true
    #include "xsi.h"
    #include <memory.h>
    #ifdef __GNUC__
    #include <stdlib.h>
    #else
    #include <malloc.h>
    #define alloca _alloca
    #endif
    static unsigned int ng0[] = {213U, 0U};
    static unsigned int ng1[] = {2U, 0U};
    static int ng2[] = {4, 0};
    static int ng3[] = {3, 0};
    static int ng4[] = {2, 0};
    static int ng5[] = {1, 0};
    static unsigned int ng6[] = {0U, 0U};
    static unsigned int ng7[] = {31U, 0U};
    static unsigned int ng8[] = {30U, 0U};
    static unsigned int ng9[] = {29U, 0U};
    static unsigned int ng10[] = {28U, 0U};
    static unsigned int ng11[] = {27U, 0U};
    static unsigned int ng12[] = {26U, 0U};
    static unsigned int ng13[] = {25U, 0U};
    static unsigned int ng14[] = {24U, 0U};
    static unsigned int ng15[] = {23U, 0U};
    static unsigned int ng16[] = {22U, 0U};
    static unsigned int ng17[] = {21U, 0U};
    static unsigned int ng18[] = {20U, 0U};
    static unsigned int ng19[] = {19U, 0U};
    static unsigned int ng20[] = {18U, 0U};
    static unsigned int ng21[] = {17U, 0U};
    static unsigned int ng22[] = {16U, 0U};
    static unsigned int ng23[] = {15U, 0U};
    static unsigned int ng24[] = {14U, 0U};
    static unsigned int ng25[] = {13U, 0U};
    static unsigned int ng26[] = {12U, 0U};
    static unsigned int ng27[] = {11U, 0U};
    static unsigned int ng28[] = {10U, 0U};
    static unsigned int ng29[] = {9U, 0U};
    static unsigned int ng30[] = {8U, 0U};
    static unsigned int ng31[] = {7U, 0U};
    static unsigned int ng32[] = {6U, 0U};
    static unsigned int ng33[] = {5U, 0U};
    static unsigned int ng34[] = {4U, 0U};
    static unsigned int ng35[] = {3U, 0U};
    static unsigned int ng36[] = {31U, 1U};
    static unsigned int ng37[] = {30U, 1U};
    static unsigned int ng38[] = {29U, 1U};
    static unsigned int ng39[] = {28U, 1U};
    static unsigned int ng40[] = {27U, 1U};
    static unsigned int ng41[] = {26U, 1U};
    static unsigned int ng42[] = {25U, 1U};
    static unsigned int ng43[] = {24U, 1U};
    static unsigned int ng44[] = {23U, 1U};
    static unsigned int ng45[] = {22U, 1U};
    static unsigned int ng46[] = {21U, 1U};
    static unsigned int ng47[] = {20U, 1U};
    static unsigned int ng48[] = {19U, 1U};
    static unsigned int ng49[] = {18U, 1U};
    static unsigned int ng50[] = {17U, 1U};
    static unsigned int ng51[] = {16U, 1U};
    static unsigned int ng52[] = {15U, 1U};
    static unsigned int ng53[] = {14U, 1U};
    static unsigned int ng54[] = {13U, 1U};
    static unsigned int ng55[] = {12U, 1U};
    static unsigned int ng56[] = {11U, 1U};
    static unsigned int ng57[] = {10U, 1U};
    static unsigned int ng58[] = {9U, 1U};
    static unsigned int ng59[] = {8U, 1U};
    static unsigned int ng60[] = {7U, 1U};
    static unsigned int ng61[] = {6U, 1U};
    static unsigned int ng62[] = {5U, 1U};
    static unsigned int ng63[] = {4U, 1U};
    static unsigned int ng64[] = {3U, 1U};
    static unsigned int ng65[] = {31U, 0U, 2U};
    static unsigned int ng66[] = {30U, 0U, 2U};
    static unsigned int ng67[] = {29U, 0U, 2U};
    static unsigned int ng68[] = {28U, 0U, 2U};
    static unsigned int ng69[] = {27U, 0U, 2U};
    static unsigned int ng70[] = {26U, 0U, 2U};
    static unsigned int ng71[] = {25U, 0U, 2U};
    static unsigned int ng72[] = {24U, 0U, 2U};
    static unsigned int ng73[] = {23U, 0U, 2U};
    static unsigned int ng74[] = {22U, 0U, 2U};
    static unsigned int ng75[] = {21U, 0U, 2U};
    static unsigned int ng76[] = {20U, 0U, 2U};
    static unsigned int ng77[] = {19U,
- code: "module par_new(in, parity, all_ones);\nParity_struct packed_x;\n\nassign\
    \ packed_x.x1 = in[0];\nassign packed_x.x2 = in[1];\nassign packed_x.x3 = in[2];\n\
    assign packed_x.x4 = in[3];\n\nassign packed_x.parity = packed_x.x1 ^ packed_x.x2\
    \ ^ packed_x.x3 ^ packed_x.x4;\nassign packed_x.all_ones = packed_x.x1 & packed_x.x2\
    \ & packed_x.x3 & packed_x.x4;\n\nendmodule\n\n# Summary\n\nThe structure-based\
    \ logic is a powerful technology that can be used to reduce the number of logic\
    \ gates required to implement a particular design. However, it comes at a cost\
    \ of complexity in the design process itself. This complexity arises due to the\
    \ necessity of structuring designs into different components.\n\n# References\n\
    \n\u201CStructure-Based Logic.\u201D Wikipedia, Wikimedia Foundation, 21 Sept.\
    \ 2022, en.wikipedia.org/wiki/Structure-based_logic."
- code: "module par(in, parity, all_ones);\n\ntypedef struct packed {\nlogic [3:0]\
    \ x4;\nlogic [7:0] x1;\nlogic [7:0] x2;\nlogic [7:0] x3;\nlogic [7:0] x5;\nlogic\
    \ [7:0] x6;\nlogic [7:0] x7;\n} input_t;\n\ntypedef struct packed {\nlogic [3:0]\
    \ x4;\nlogic parity;\nlogic all_ones;\n} output_t;\n\ninput_t in;\noutput_t out;\n\
    \nassign out.x1 = in.x1;\nassign out.x2 = in.x2;\nassign out.x3 = in.x3;\nassign\
    \ out.x4 = in.x4;\nassign out.x5 = in.x5;\nassign out.x6 = in.x6;\nassign out.x7\
    \ = in.x7;\nassign out.parity = ^in.x4;\nassign out.all_ones = &in.x4;\n\nendmodule\n\
    ## 4.2.1.5. Exercise:\n\n### Original Code:\nmodule par(in, parity, all_ones);\n\
    \ntypedef struct packed {\nlogic [3:0] x4;\nlogic [7:0] x1;\nlogic [7:0] x2;\n\
    logic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic [7:0] x7;\n} input_t;\n\
    \ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\nlogic all_ones;\n}\
    \ output_t;\n\ninput_t in;\n\nassign parity = ^in.x4;\nassign all_ones = &in.x4;\n\
    \nendmodule\n\n### Variation Instruction:\n\nConvert the inputs x1\u2013x4 into\
    \ a single unpacked struct with logic fields and apply operations on the structure\
    \ to test structure-based logic operations.\n\n### Original Code:\nmodule par(in,\
    \ parity, all_ones);\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic [7:0]\
    \ x1;\nlogic [7:0] x2;\nlogic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic\
    \ [7:0] x7;\n} input_t;\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\n\
    logic all_ones;\n} output_t;\n\ninput_t in;\n\nassign parity = ^in.x4;\nassign\
    \ all_ones = &in.x4;\n\nendmodule\n\n### Variation Instruction:\n\nConvert the\
    \ inputs x1\u2013x4 into a single unpacked struct with logic fields and apply\
    \ operations on the structure to test structure-based logic operations.\n\n##\
    \ 4.2.1.6. Exercise:\n\n### Original Code:\nmodule par(in, parity, all_ones);\n\
    \ntypedef struct packed {\nlogic [3:0] x4;\nlogic [7:0] x1;\nlogic [7:0] x2;\n\
    logic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic [7:0] x7;\n} input_t;\n\
    \ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\nlogic all_ones;\n}\
    \ output_t;\n\ninput_t in;\n\nassign parity = ^in.x4;\nassign all_ones = &in.x4;\n\
    \nendmodule\n\n### Variation Instruction:\n\nConvert the inputs x1\u2013x4 into\
    \ a single unpacked struct with logic fields and apply operations on the structure\
    \ to test structure-based logic operations.\n\n### Original Code:\nmodule par(in,\
    \ parity, all_ones);\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic [7:0]\
    \ x1;\nlogic [7:0] x2;\nlogic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic\
    \ [7:0] x7;\n} input_t;\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\n\
    logic all_ones;\n} output_t;\n\ninput_t in;\n\nassign parity = ^in.x4;\nassign\
    \ all_ones = &in.x4;\n\nendmodule\n\n### Variation Instruction:\n\nConvert the\
    \ inputs x1\u2013x4 into a single unpacked struct with logic fields and apply\
    \ operations on the structure to test structure-based logic operations.\n\n##\
    \ 4.2.1.7. Exercise:\n\n### Original Code:\nmodule par(out, parity, all_ones);\n\
    \ntypedef struct packed {\nlogic [7:0] x1;\nlogic [7:0] x2;\nlogic [7:0] x3;\n\
    logic [7:0] x5;\nlogic [7:0] x6;\nlogic [7:0] x7;\n} input_t;\n\ntypedef struct\
    \ packed {\nlogic [3:0] x4;\nlogic parity;\nlogic all_ones;\n} output_t;\n\ninput_t\
    \ in;\noutput_t out;\n\nassign out.x1 = in.x1;\nassign out.x2 = in.x2;\nassign\
    \ out.x3 = in.x3;\nassign out.x4 = in.x4;\nassign out.x5 = in.x5;\nassign out.x6\
    \ = in.x6;\nassign out.x7 = in.x7;\nassign out.parity = ^in.x4;\nassign out.all_ones\
    \ = &in.x4;\n\nendmodule\n\n### Variation Instruction:\n\nConvert the inputs x1\u2013\
    x4 into a single unpacked struct with logic fields and apply operations on the\
    \ structure to test structure-based logic operations.\n\n### Original Code:\n\
    module par(out, parity, all_ones);\n\ntypedef struct packed {\nlogic [7:0] x1;\n\
    logic [7:0] x2;\nlogic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic [7:0]\
    \ x7;\n} input_t;\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\n\
    logic all_ones;\n} output_t;\n\ninput_t in;\noutput_t out;\n\nassign out.x1 =\
    \ in.x1;\nassign out.x2 = in.x2;\nassign out.x3 = in.x3;\nassign out.x4 = in.x4;\n\
    assign out.x5 = in.x5;\nassign out.x6 = in.x6;\nassign out.x7 = in.x7;\nassign\
    \ out.parity = ^in.x4;\nassign out.all_ones = &in.x4;\n\nendmodule\n\n### Variation\
    \ Instruction:\n\nConvert the inputs x1\u2013x4 into a single unpacked struct\
    \ with logic fields and apply operations on the structure to test structure-based\
    \ logic operations.\n\n## 4.2.1.8. Exercise:\n\n### Original Code:\nmodule par(out,\
    \ parity, all_ones);\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic [7:0]\
    \ x1;\nlogic [7:0] x2;\nlogic [7:0] x3;\nlogic [7:0] x5;\nlogic [7:0] x6;\nlogic\
    \ [7:0] x7;\n} input_t;\n\ntypedef struct packed {\nlogic [3:0] x4;\nlogic parity;\n\
    logic all_ones;\n} output_t;\n\ninput_t in;\noutput_t out;\n\nassign out.x1 =\
    \ in.x1;\nassign out.x2 = in.x2;\nassign out.x3 = in.x3;\nassign out.x4 = in.x4;\n\
    assign out.x5 = in.x5;\nassign out.x6 = in.x6;\nassign out.x7 = in.x7;\nassign\
    \ out.parity = ^in.x4;\nassign out.all_ones = &in.x4;\n\nendmodule\n\n### Variation\
    \ Instruction:\n\nConvert the inputs x1\u2013x4 into a single unpacked struct\
    \ with logic fields and apply operations on the structure to test structure-based\
    \ logic operations.\n\n### Original Code:\nmodule par(out, parity, all_ones);\n\
    \ntypedef struct packed {\nlogic [3:0] x4;\nlogic"
- code: |-
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    logic [7:0] in_expanded;
    assign in_expanded = in << 8;
    assign in_expanded = in_expanded ^ in;
    assign parity = in_expanded;
    assign all_ones = in_expanded & in;
    endmodule
    ### Variation Result:
    Test Report:

    Test #1: FAIL
    Test #2: PASS
    Test #3: PASS

    ### Original Verilog Test Code:
    module par(in, parity, all_ones);
    input [7:0] in;
    output parity, all_ones;
    assign all_ones = in ^ in;
    endmodule
    ### Base Verilog Code:
    module par(
- code: |-
    module unpack_struct_with_field_width(in, out);
    input [7:0] in;
    output [3:2] out;
    wire x1, x2, x3, x4;
    assign x1 = in[0];
    assign x2 = in[1];
    assign x3 = in[2];
    assign x4 = in[3];
    assign out = in[7:4];
    endmodule
    ### Comparison:
    This implementation is more compact than the previous instruction, but it does not provide the same functionality as the previous instruction. It is not possible to access the individual bit fields, so the previous instruction is useful when you want to execute bit-based operations on the data.

    ### Base Verilog Code:
    module unpack_struct_
- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg0 (.Q(QWire),.D(D),.Clk(Clk));
    DFF DReg0 (.Q(QWire),.D(D),.Clk(Clk));
    DFF DReg0 (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Variation Result:
    The test case passed.

    ## Test Case 16
    ### Case Description:
    Test case 16 creates a simple test case where three instances of a simple component is placed in the hierarchy.

    ### Input Data:
    The three component instances are named: DFF DReg0, DFF DReg1, and DFF DReg2.

    ### Expected Output:
    The expected output is to see the three component instances in the hierarchy.

    ### Base Verilog Code:
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Variation Instruction:
    None.
    ###
- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output logic[1:0] Q, input logic[3:0] D, input logic Ena, Clk);
    wire[1:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[1:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Result:
    ![FourFlopsStructL_8V_1H_result.PNG](https://github.com/joshua19881010/CSE225_Project/blob/master/Results/FourFlopsStructL_8V_1H_result.PNG)

    ### Base Verilog Code:
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DT
- code: "module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)\n(output[3:0] Q,\
    \ input[3:0] D, input Ena, Clk);\nwire[3:0] QWire;\nwire Q0, Q1, Q2, Q3;\nlocalparam\
    \ DTot = DBuf + DClk;\nDFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));\nassign #DTot\
    \ Q = (Ena==1'b1)? QWire : 'bz;\nendmodule\n/ECE 430/430_project_4/testbench/testbench.cpp\n\
    #include <systemc.h>\n#include \"430_project_4.h\"\nSC_MODULE(testbench) {\n\t\
    sc_out<bool> A_valid, B_valid, C_valid;\n\tsc_in<sc_uint<8>> A_data, B_data, C_data,\
    \ R_data;\n\tsc_out<bool> Clk;\n\tsc_signal<bool> reset;\n\tsc_signal<bool> done;\n\
    \tsc_signal<sc_uint<8>> A, B, C;\n\tsc_uint<8> R0;\n\tsc_fifo<sc_uint<8>> R_fifo;\n\
    \tsc_uint<8> R0_expected;\n\tsc_uint<32> start_addr, end_addr, addr;\n\tsc_uint<32>\
    \ num_addrs=1;\n\tsc_uint<8> max_val=100;\n\tsc_uint<8> min_val=0;\n\tsc_uint<8>\
    \ num_tests=100;\n\tsc_uint<8> t;\n\tsc_uint<8> num_test_passed=0;\n\tsc_uint<8>\
    \ num_test_failed=0;\n\tsc_uint<8> num_test_max_addr=1;\n\t\n\tvoid write_to_test_fifo(sc_uint<8>\
    \ addr, sc_uint<8> data) {\n\t\tR_fifo<<addr<<data;\n\t}\n\t\n\tvoid test_setup()\
    \ {\n\t\tbool A_valid, B_valid, C_valid;\n\t\tA_valid=0;\n\t\tB_valid=0;\n\t\t\
    C_valid=0;\n\t\tfor(t=0; t<num_tests; t++) {\n\t\t\tA_valid=0;\n\t\t\tB_valid=0;\n\
    \t\t\tC_valid=0;\n\t\t\taddr=0;\n\t\t\tfor(addr=0; addr<num_addrs; addr++) {\n\
    \t\t\t\tA=min_val+rand()%(max_val-min_val+1);\n\t\t\t\tB=min_val+rand()%(max_val-min_val+1);\n\
    \t\t\t\tC=min_val+rand()%(max_val-min_val+1);\n\t\t\t\twrite_to_test_fifo(addr,\
    \ A);\n\t\t\t\twrite_to_test_fifo(addr, B);\n\t\t\t\twrite_to_test_fifo(addr,\
    \ C);\n\t\t\t\tstart_addr=addr;\n\t\t\t\tend_addr=addr;\n\t\t\t\tA_valid=1;\n\t\
    \t\t\tB_valid=1;\n\t\t\t\tC_valid=1;\n\t\t\t}\n\t\t\tif(num_test_max_addr>1) {\n\
    \t\t\t\tdone=0;\n\t\t\t\twhile(!done.read()) {\n\t\t\t\t\twait(100, SC_NS);\n\t\
    \t\t\t}\n\t\t\t\tfor(addr=start_addr; addr<end_addr; addr++) {\n\t\t\t\t\tif(num_test_max_addr>1)\
    \ {\n\t\t\t\t\t\tR0=min_val+rand()%(max_val-min_val+1);\n\t\t\t\t\t\twrite_to_test_fifo(addr,\
    \ R0);\n\t\t\t\t\t}\n\t\t\t\t\tR0_expected=R_fifo.read();\n\t\t\t\t}\n\t\t\t\t\
    for(addr=start_addr; addr<end_addr; addr++) {\n\t\t\t\t\tA_data.write(A);\n\t\t\
    \t\t\tB_data.write(B);\n\t\t\t\t\tC_data.write(C);\n\t\t\t\t\tA_valid.write(A_valid);\n\
    \t\t\t\t\tB_valid.write(B_valid);\n\t\t\t\t\tC_valid.write(C_valid);\n\t\t\t\t\
    \tClk.write(1);\n\t\t\t\t\twait(100, SC_NS);\n\t\t\t\t\tClk.write(0);\n\t\t\t\t\
    \twait(100, SC_NS);\n\t\t\t\t\tR_data.read();\n\t\t\t\t\tdone.read();\n\t\t\t\t\
    \tdone.write(1);\n\t\t\t\t\twait(100, SC_NS);\n\t\t\t\t\tdone.write(0);\n\t\t\t\
    \t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdone=0;\n\t\t\t\twhile(!done.read()) {\n\t\
    \t\t\t\twait(100, SC_NS);\n\t\t\t\t}\n\t\t\t\tR0_expected=R_fifo.read();\n\t\t\
    \t\tA_data.write(A);\n\t\t\t\tB_data.write(B);\n\t\t\t\tC_data.write(C);\n\t\t\
    \t\tdone.write(1);\n\t\t\t\tA_valid.write(1);\n\t\t\t\tB_valid.write(1);\n\t\t\
    \t\tC_valid.write(1);\t\n\t\t\t\twait(100, SC_NS);\n\t\t\t\tClk.write(1);\n\t\t\
    \t\twait(100, SC_NS);\n\t\t\t\tClk.write(0);\n\t\t\t\twait(100, SC_NS);\n\t\t\t\
    \tR_data.read();\n\t\t\t\tdone.read();\n\t\t\t\tdone.write(0);\n\t\t\t\tfor(addr=start_addr+1;\
    \ addr<end_addr; addr++) {\n\t\t\t\t\tR_fifo.read();\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tif(R0_expected==R_data.read()) {\n\t\t\t\tnum_test_passed++;\n\t\t\t}\n\t\t\t\
    else {\n\t\t\t\tnum_test_failed++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSC_CTOR(testbench)\
    \ {\n\t\tSC_THREAD(test_setup);\n\t}\n};\n/ECE 390/390_lab_2/testbench.cpp\n#include\
    \ <systemc.h>\n\nSC_MODULE (testbench) {\n\tsc_signal<bool> A_valid, B_valid,\
    \ C_valid;\n\tsc_signal<sc_uint<8>> A_data, B_data, C_data;\n\tsc_signal<sc"
- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ### Generated Behavioral Verilog:
    module FourFlopsStructL(output[3:0] Q, input[3:0] D, input Ena, Clk);
    reg [1:0] clk_reg[0];
    reg [1:0] dreg[0];
    initial clk_reg[0] := 0;
    initial dreg[0] := 0;
    always @(posedge Clk)
    begin
    clk_reg[0] <= Clk;
    end
    always @(posedge Clk)
    begin
    dreg[0] <= D;
    end
    assign Q = (Ena==1'b1)? dreg[0] : 1'bz;
    endmodule
    ### Generated RTLIL:
    module FourFlopsStructL(output[3:0] Q, input[3:0] D, input Ena, Clk);
    reg clk_reg[0];
    reg dreg[0];
    clk_reg = 0;
    dreg = 0;
    Q = (Ena == 1'b1)? {dreg[2], dreg[1], dreg[0], dreg[1]} : 4'hff;
    if (Clk) begin
    clk_reg <= Clk;
    end
    if (Clk) begin
    dreg <= D;
    end
    endmodule
    ### Generated SMT-LIBv2:
    (module FourFlopsStructL
    (output Q
    (input D Ena Clk)
    (declare-fun Q () bv3)
    (declare-fun D () bv3)
    (declare-fun Ena () Bool)
    (declare-fun Clk () Bool)
    (declare-fun clk_reg () (Array Int Bool) )
    (declare-fun dreg () (Array Int Bool) )
    (declare-fun #DTot () Int)
    )
    (assert (and
    (and (bvult #DTot 4)
    (= #DTot 2))
    (= #DTot 1))
    (assert (not (= #DTot 0)))
    (assert (not (= #DTot 0)))
    (assert (= Q
    (ite (and
    (= Ena 1)
    (ite (bvult #DTot 4)
    (ite (bvult #DTot 2)
    (ite (bvult #DTot 1)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
    (ite (bvult #DTot 0)
- code: |-
    module DFFStructL_Byte2Logic_ByteSel #(parameter DBits = 2)(
    input Clk, input byte D, input byte[1:0] S,
    output byte Q);
    wire QWire;
    localparam DTot = 1;
    DFF DReg (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = QWire;
    endmodule
    ### Analysis:
    All passes.

    ## DFFStructL_Byte2Logic_ByteSel_
- code: |-
    module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)
    (output[3:0] Q, input[3:0] D, input Ena, Clk);
    wire[3:0] QWire;
    localparam DTot = DBuf + DClk;
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));
    assign #DTot Q = (Ena==1'b1)? QWire : 'bz;
    endmodule
    ###
- code: "module FourFlopsStructL #(parameter DClk = 2, DBuf = 1)\n(output[3:0] Q,\
    \ input[9:0] D, input Ena, Clk);\nwire[3:0] QWire;\nlocalparam DTot = DBuf + DClk;\n\
    DFF DReg[3:0] (.Q(QWire),.D(D),.Clk(Clk));\nassign #DTot Q = (Ena==1'b1)? QWire\
    \ : 'bz;\nendmodule\n\n## 3.3.10.\_The DFF Struct-L, with DClk = 2, D"
- code: |-
    module NibbleReg
    (output[1:0] N, input[1:0] D, Clk, input[1:0] size);
    wire[1:0] N_Wire;
    localparam DTot = 2;
    DFF DReg(.Q(N_Wire),.D(D[size+1:size]),.Clk(Clk));
    assign #DTot N = N_Wire;
    endmodule
    ### Final Result:
    The testbench passes with a 0.125ns period.

    #include <iostream>
    #include <unordered_map>
    #include <vector>

    namespace
    {

    struct Node
    {
        Node* prev, *next;
        Node(Node* p, Node* n, int v): prev(p), next(n), value(v) {}
        int value;
    };

    struct List
    {
        List(): head(nullptr), tail(nullptr) {}
        List(std::vector<int>& nums)
        {
            head = tail = nullptr;
            for(int i = 0; i < nums.size(); i++)
            {
                if(!tail)
                {
                    tail = head = new Node(nullptr, nullptr, nums[i]);
                }
                else
                {
                    tail = tail->next = new Node(tail, nullptr, nums[i]);
                }
            }
        }
        void print()
        {
            Node* temp = head;
            while(temp)
            {
                std::cout << temp->value << " ";
                temp = temp->next;
            }
            std::cout << "\n";
        }
        Node* head;
        Node* tail;
    };

    void del(Node* d)
    {
        if(d)
        {
            delete d;
        }
    }

    Node* merge(List* list1, List* list2)
    {
        Node* a = list1->head;
        Node* b = list2->head;
        Node* ans = nullptr;
        Node* tail = nullptr;
        while(a || b)
        {
            if(a && b)
            {
                if(a->value <= b->value)
                {
                    if(!ans)
                    {
                        ans = tail = a;
                    }
                    else
                    {
                        tail->next = a;
                        tail = a;
                    }
                    a = a->next;
                }
                else
                {
                    if(!ans)
                    {
                        ans = tail = b;
                    }
                    else
                    {
                        tail->next = b;
                        tail = b;
                    }
                    b = b->next;
                }
            }
            else
            {
                if(a)
                {
                    if(!ans)
                    {
                        ans = tail = a;
                    }
                    else
                    {
                        tail->next = a;
                        tail = a;
                    }
                }
                else
                {
                    if(!ans)
                    {
                        ans = tail = b;
                    }
                    else
                    {
                        tail->next = b;
                        tail = b;
                    }
                }
            }
        }
        return ans;
    }

    }

    int main(int argc, char* argv[])
    {
        List list1(std::vector<int>{1, 4, 7});
        List list2(std::vector<int>{2, 5, 8});
        std::cout << "Before merge:\n";
        list1.print();
        list2.print();
        Node* merged = merge(&list1, &list2);
        List list3(std::vector<int>{1, 2, 4, 5, 7, 8});
        std::cout << "After merge:\n";
        list3.print();
        std::cout << "Checking for validity:\n";
        while(merged)
        {
- code: |-
    module VMP_FIFO
    (
    output [7:0] Data,
    output [3:0] Ena,
    input  [2:0] Clk,
    input  [7:0] WData,
    input  [3:0] WEna
    );
    endmodule

    ## 3.566.1
- code: "module PipelinedRAM_Cell (input [Rows*Columns-1:0] Addr,\ninput [DBuf-1:0]\
    \ Ena,\ninput Clock,\noutput [Rows*Columns-1:0] Data);\n\nwire[DBuf-1:0] Clk,\n\
    wire[DBuf-1:0] Q;\n\nPipelinedRAM_Cell_Inst\n(Addr, Ena, Q,\n.Clk(Clock),\n.Data(Data));\n\
    endmodule\n### Baseline Results:\n\nclock speed: 1GHz\n\nSimulation Results:\n\
    \nclock speed: 1GHz\n\nSimulation Results:\n\n\u2022 The original code was correct.\n\
    \u2022 The modified code was correct.\n\u2022 I used the same testbench for both\
    \ modified and original code.\n\u2022 The modified code is faster.\n\u2022 The\
    \ modified code has the same performance as the original code.\n\n## Test 8: Pipelined\
    \ RAM Cell with Sequential DFFs\n\nIn this test, I created a simple testbench\
    \ for a pipelined RAM cell with sequential DFFs.\n\n### Base Verilog Code:\nmodule\
    \ PipelinedRAM_Cell_"
- code: "module Anding(input {2:0} a, b, output y);\nand (y, a, b);\nendmodule\n###\
    \ End:\n```\n**Note the following:**\n1. Only one instance of a module can be\
    \ instantiated in a testbench, even if it is contained in multiple source files.\n\
    2. Module instantiated within a testbench using the pack union method must use\
    \ the packed port name.\n3. If the module used in the testbench is not contained\
    \ in a separate source file, the modified module can be instantiated within the\
    \ testbench.\n4. The testbench file must not contain anything other than the following:\n\
    ```\n### Testbench Code:\n### Include test case file and source module.\n`include\
    \ \"DUT_testcases.svs\"\nmodule testbench();\n\n`ifdef BENCH\nparameter {2:0}\
    \ a = 2'h1;\nparameter b = 1'h1;\nparameter DUT_name = \"Anding\";\nparameter\
    \ src_name = \"../src/Anding.sv\";\nmodule_test(DUT_name, a, b, src_name);\nend\n\
    \n`ifdef TBM\n### Define the testbench parameters.\nparameter {2:0} a = 2'h1;\n\
    parameter b = 1'h1;\nparameter DUT_name = \"Anding\";\nparameter src_name = \"\
    ../src/Anding.sv\";\n\n### Instantiate the testbench.\nmodule testbench (DUT_name);\n\
    endmodule\n\n### Module instantiation of the DUT.\nmodule_test(DUT_name, a, b,\
    \ src_name);\nend\n\n### End:\n```\n**To test the behavior of the module:**\n\
    1. Run the following command in the terminal to compile the testbench:\n```\n\
    $ make BENCH=1\n```\n2. Run the following command in the terminal to execute the\
    \ testbench:\n```\n$ make BENCH=1 run\n```\n- The makefile includes an automatic\
    \ testbench execution command to run the testbench in the terminal.\n\n**To view\
    \ the testbench results, run the following command in the terminal:**\n```\n$\
    \ make view\n```\n- The makefile includes an automatic results file view command\
    \ to view the testbench results file in the terminal.\n- If this command results\
    \ in a permissions error, change the file permissions by typing the following\
    \ command in the terminal:\n```\n$ chmod a+rw /tmp/tbm_results.log\n```\n- If\
    \ this command does not work, move the results file to a different path and view\
    \ the results file manually.\n- The makefile generates the results file at \"\
    /tmp/tbm_results.log\"\n\n### Notes\n1. The project directories are created with\
    \ the same name of the file. The project file names are also the same.\n2. The\
    \ design top module is the same as the source module.\n3. The testbench ports\
    \ and parameters are the same as the source module.\n4. The parameters and modules\
    \ are declared as constants, not parameters.\n\n### Reference Documents\n- [System\
    \ Verilog User Guide](https://ieeexplore.ieee.org/document/1477981#page=99)\n\
    - [SystemVerilog Reference Manual](https://ieeexplore.ieee.org/document/1477981#page=99)\n\
    - [IEEE Xplore Document](https://ieeexplore.ieee.org/document/1477981)\n- [Youtube\
    \ Video](https://www.youtube.com/watch?v=z7gW02m0X7g)\n- [ECE 322 Documentation](https://www.ece.ualberta.ca/~farrar/ece322docs/SystemVerilog_UG_024.pdf)\n\
    /lab02/Makefile\n# \n# ECE 322\n# lab02\n# Makefile\n\n# Makefile for lab02\n\
    # Run the following commands in the terminal:\n# make bench:\tcompile and run\
    \ the testbench with bench flag set to 1.\n# make tbm:\tcompile and run the testbench\
    \ with tbm flag set to 1.\n# make view:\tview testbench results file.\n# make\
    \ clean:\tclean the project files.\n# make:\t\tcompile the testbench.\n# make\
    \ run:\tautomatically run the testbench.\n#\n\n# Specify the testbench and source\
    \ file locations.\nBENCH_FLAG = 1\nBENCH_TB = testbench\nBENCH_FILE = $(BENCH_TB).sv\n\
    \n# Specify the testbench and source file locations.\nTBM_FLAG = 1\nTBM_TB = testbench\n\
    TBM_FILE = $(TBM_TB).sv\n\n# Specify the testbench results file.\nRESULTS_FILE\
    \ = $(HOME)/lab02/tbm_results.log\n\n# Specify the compilation options.\nCFLAGS\
    \ = +acc -sverilog -Wall -O2 -Wpedantic -Werror -Wfatal-errors -D$(FLAG)\nCFLAGS_TB\
    \ = +acc -sverilog -Wall -O2 -Wpedantic -Werror -Wfatal-errors -D$(FLAG)\n\n#\
    \ Compile and link command.\nCOMPILE = vlib $(HOME)/lab02/testbench_project_files\n\
    LINK = vmap testbench_project_files\n\n# List all the source files and testbench\
    \ files to be compiled.\nSRC_FILES = $(HOME)/lab02/src/Anding.sv\nTB_FILES = $(HOME)/lab02/testbench/DUT_testcases.sv\n\
    TB_FILE = $(HOME)/lab02/testbench/testbench.sv\n\n# Compile the testbench command.\n\
    COMPILE_TB = iverilog $(CFLAGS_TB) $(SRC_FILES) $(TB_FILES) $(TB_FILE)\n\n# Run\
    \ the testbench command.\nRUN = vsim -c -do run_tb.do -quiet\n\n# View the testbench\
    \ results command.\nVIEW = more $(RESULTS_FILE)\n\n# Automatically run the testbench\
    \ command.\nRUN_TB = $(COMPILE_TB) && time $(RUN) && $(VIEW)\n\n# Define the make\
    \ command flags: bench and tbm.\nbench:\n\t$(COMPILE) && time $(COMPILE_TB) &&\
    \ time $(RUN) && $(VIEW)\n\ntbm:\n\t$(COMPILE) && time $(COMPILE_TB) && time $(RUN)\
    \ && $(VIEW)\n\n# Define the make clean command.\nclean:\n\trm -rf $(HOME)/lab02/testbench_project_files/*\n\
    \trm -rf $(HOME)/lab02/testbench_results/*\n\n# Define the make run command.\n\
    run:\n\t$(RUN_TB)\n\n# Define the make view command.\nview:\n\t$(VIEW)\n\n# End.\n\
    /lab01/Makefile\n# \n# ECE 322\n# lab01\n# Makefile\n\n# Makefile for lab01\n\
    # Run the following commands in the terminal:\n# make clean:\tclean the project\
    \ files.\n# make:\t\tcompile the system verilog code.\n# make view:\tview the\
    \ system verilog code in the terminal.\n# make run:\tautomatically run the system\
    \ verilog code.\n#\n\n# Specify the compilation options.\nCFLAGS = +acc -sverilog\
    \ -Wall -O2 -Wpedantic -Werror -Wfatal-errors\n\n# Compile command.\nCOMPILE =\
    \ iverilog $(CFLAGS)\n\n# Run command.\nRUN = vsim -c -do run.do -quiet\n\n# View\
    \ command.\nVIEW = more $(RESULTS_FILE)\n\n# Automatically run the testbench command.\n\
    RUN_TB = time $(COMPILE) && time $(RUN) && $(VIEW)\n\n# Define the make clean\
    \ command.\nclean:\n\trm -rf $(HOME)/lab01/testbench_project_files/*\n\trm -rf\
    \ $(HOME)/lab01/testbench_results/*\n\n# Define the make run command.\nrun:\n\t\
    $(RUN_TB)\n\n# Define the make view command.\nview:\n\t$(VIEW)\n\n# End.\n/lab06/Makefile\n\
    # \n# ECE 322\n# lab06\n\n# Makefile for lab06\n# Run the following commands in\
    \ the terminal:\n# make bench:\tcompile and run the testbench with bench flag\
    \ set to 1.\n# make tbm:\tcompile and run the testbench with tbm flag set to 1.\n\
    # make view:\tview testbench results file.\n# make clean:\tclean the project files.\n\
    # make:\t\tcompile the testbench.\n# make run:\tautomatically run the testbench.\n\
    #\n\n# Specify the testbench and source file locations.\nBENCH_FLAG = 1\nBENCH_TB\
    \ = testbench\nBENCH_FILE = $(BENCH_TB).sv\n\n# Specify the testbench and source\
    \ file locations.\nTBM_FLAG = 1\nTBM_TB = testbench\nTBM_FILE ="
- code: |-
    [Verilog Code](anding_union_packed.v)

    ### Simulation:
    ![anding_union_packed](./images/anding_union_packed.png)

    ### Test Suite:
    [Test Suite](anding_union_packed_testbench_suite.v)




    ## 4 Summary

    In this Tutorial you have learned to use the following:

    - Union
    - Packed Union
    - Use packed union as module port
    - Use packed union as module input

    Note that these concepts can be used in the same manner in Verilog and VHDL.

    ## 5 References

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=176&zoom=auto,-230,1001)

    [Xilinx - Verilog Union](https://www.xilinx.com/support/documentation/user_guides/ug478_7Series_Config.pdf#page=17
- code: module Counter(input clk, input rst, output reg [
- code: |-
    module Anding (input [1:0] a, b, output y, output dff);
    and (y, a, b);
    dff = (a == 0 | a == 1) | (b == 0 | b == 1);
    endmodule
- code: |-
    ```
    module Anding (input a, b, output y);
    and (y, a, b);
    endmodule
    ```
    ### Expected Results:
    No changes to the DUT should be visible.
    ### Expected Result:
    No failures should be reported.
    ### Results:
    The test was successful.
    ### Notes:
    No test notes.

    ## `224: (Test Case 3.8) Test Ports`
    ### Test Type:
    `Functionality Test`
    ### Test Description:
    `A test of the module to verify that
- code: "```verilog\nmodule Anding (input a, b, input [(W-1):0]{packed_ab}, output\
    \ y);\nand (y, a, b);\nendmodule\n```\n### Result:\n```verilog\nmodule Anding\
    \ (\n    input a, b, input [(W-1):0]{packed_ab},\n    output y);\nand (y, a, b);\n\
    endmodule\n```\n### Verilog Behavioural Description:\nThe following code shows\
    \ the behavioural description of the DFF module.\n```verilog\ninitial begin\n\t\
    // initial statements\n\tif (wr_n) {\n\t\tif (rd_n) y <= d;\n\t\telse y <= q;\n\
    \t}\nend\n```\n### VHDL Behavioural Description:\nThe following code shows the\
    \ behavioural description of the DFF module.\n```vhdl\nprocess (wr_n, rd_n)\n\
    begin\n\tif wr_n = '1' then\n\t\tif rd_n = '1' then\n\t\t\ty <= d;\n\t\telse\n\
    \t\t\ty <= q;\n\t\tend if;\n\tend if;\nend process;\n```/hw/hdl/examples/dffs/vhdl/Makefile\n\
    .PHONY: all\nall: dff\n\n.PHONY: clean\nclean:\n\trm -rf verilog\n\trm -rf vhdl\n\
    \n\n.PHONY: dff\ndff:\n\tmkdir -p verilog\n\tmkdir -p vhdl\n\tfor i in *.v; do\
    \ \\\n\t\techo \"====> Converting: $$i\"; \\\n\t\tpython../../../vhdl_to_verilog.py\
    \ -i $$i -o verilog/$$i; \\\n\t\tpython../../../verilog_to_vhdl.py -i verilog/$$i\
    \ -o vhdl/$$i; \\\n\tdone\n/hw/hdl/examples/muxes/vhdl/Makefile\n.PHONY: all\n\
    all: cmos_mux dff_mux alu_mux\n\n.PHONY: clean\nclean:\n\trm -rf verilog\n\trm\
    \ -rf vhdl\n\n\n.PHONY: cmos_mux\ncmos_mux:\n\tmkdir -p verilog\n\tmkdir -p vhdl\n\
    \tfor i in *.v; do \\\n\t\techo \"====> Converting: $$i\"; \\\n\t\tpython../../../vhdl_to_verilog.py\
    \ -i $$i -o verilog/$$i; \\\n\t\tpython../../../verilog_to_vhdl.py -i verilog/$$i\
    \ -o vhdl/$$i; \\\n\tdone\n\n.PHONY: dff_mux\ndff_mux:\n\tmkdir -p verilog\n\t\
    mkdir -p vhdl\n\tfor i in *.v; do \\\n\t\techo \"====> Converting: $$i\"; \\\n\
    \t\tpython../../../vhdl_to_verilog.py -i $$i -o verilog/$$i; \\\n\t\tpython../../../verilog_to_vhdl.py\
    \ -i verilog/$$i -o vhdl/$$i; \\\n\tdone\n\n.PHONY: alu_mux\nalu_mux:\n\tmkdir\
    \ -p verilog\n\tmkdir -p vhdl\n\tfor i in *.v; do \\\n\t\techo \"====> Converting:\
    \ $$i\"; \\\n\t\tpython../../../vhdl_to_verilog.py -i $$i -o verilog/$$i; \\\n\
    \t\tpython../../../verilog_to_vhdl.py -i verilog/$$i -o vhdl/$$i; \\\n\tdone\n\
    /hw/hdl/examples/adder/Makefile\n.PHONY: all\nall: cmos_adder carry_adder\n\n\
    .PHONY: clean\nclean:\n\trm -rf verilog\n\trm -rf vhdl\n\n\n.PHONY: cmos_adder\n\
    cmos_adder:\n\tmkdir -p verilog\n\tmkdir -p vhdl\n\tfor i in *.v; do \\\n\t\t\
    echo \"====> Converting: $$i\"; \\\n\t\tpython../../vhdl_to_verilog.py -i $$i\
    \ -o verilog/$$i; \\\n\t\tpython../../verilog_to_vhdl.py -i verilog/$$i -o vhdl/$$i;\
    \ \\\n\tdone\n\n.PHONY: carry_adder\ncarry_adder:\n\tmkdir -p verilog\n\tmkdir\
    \ -p vhdl\n\tfor i in *.v; do \\\n\t\techo \"====> Converting: $$i\"; \\\n\t\t\
    python../../vhdl_to_verilog.py -i $$i -o verilog/$$i; \\\n\t\tpython../../verilog_to_vhdl.py\
    \ -i verilog/$$i -o vhdl/$$i; \\\n\tdone\n/build.py\nimport os\nimport codecs\n\
    import glob\nimport subprocess\nimport argparse\nimport json\nimport random\n\
    import re\nimport logging\n\nfrom lib import lib\nfrom lib import build\n\nfrom\
    \ lib import __author__, __date__, __version__\n\ndef get_project_root_dir(path:\
    \ str = \"\") -> str:\n    \"\"\" Get the absolute path of the root of the project\n\
    \n    Return:\n        The absolute path of the root of the project.\n    \"\"\
    \"\n    project_root_dir = os.path.abspath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n\
    \    if path!= \"\" and os.path.exists(path):\n        project_root_dir = os.path.abspath(os.path.join(project_root_dir,\
    \ path))\n    return project_root_dir\n\ndef get_test_cases_dir(path: str = \"\
    \") -> str:\n    \"\"\" Get the absolute path of the test case directory\n\n \
    \   Return:\n        The absolute path of the test case directory.\n    \"\"\"\
    \n    project_root_dir = get_project_root_dir()\n    test_cases_dir = os.path.join(project_root_dir,\
    \ \"test_cases\")\n    if path!= \"\" and os.path.exists(path):\n        test_cases_dir\
    \ = os.path.join(test_cases_dir, path)\n    return test_cases_dir\n\ndef get_vhdl_dir(path:\
    \ str = \"\") -> str:\n    \"\"\" Get the absolute path of the vhdl directory\n\
    \n    Return:\n        The absolute path of the vhdl directory.\n    \"\"\"\n\
    \    project_root_dir = get_project_root_dir()\n    vhdl_dir = os.path.join(project_root_dir,\
    \ \"hw\", \"hdl\", \"examples\")\n    if path!= \"\" and os.path.exists(path):\n\
    \        vhdl_dir = os.path.join(vhdl_dir, path)\n    return vhdl_dir\n\ndef get_verilog_dir(path:\
    \ str = \"\") -> str:\n    \"\"\" Get the absolute path of the verilog directory\n\
    \n    Return:\n        The absolute path of the verilog directory.\n    \"\"\"\
    \n    project_root_dir = get_project_root_dir()\n    verilog_dir = os.path.join(project_root_dir,\
    \ \"hw\", \"hdl\", \"examples\")\n    if path!= \"\" and os.path.exists(path):\n\
    \        verilog_dir = os.path.join(verilog_dir, path)\n    return verilog_dir\n\
    \ndef get_testbench_dir(path: str = \"\") -> str:\n    \"\"\" Get the absolute\
    \ path of the testbench directory\n\n    Return:\n        The absolute path of\
    \ the testbench directory.\n    \"\"\"\n    project_root_dir = get_project_root_dir()\n\
    \    testbench_dir = os.path.join(project_root_dir, \"tests\", \"testbenches\"\
    )\n    if path!= \"\" and os.path.exists(path):\n        testbench_dir = os.path.join(testbench_dir,\
    \ path)\n    return testbench_dir\n\ndef get_design_dir(path: str = \"\") -> str:\n\
    \    \"\"\" Get the absolute path of the design directory\n\n    Return:\n   \
    \     The absolute path of the design directory.\n    \"\"\"\n    project_root_dir\
    \ = get_project_root_dir()\n    design_dir = os.path.join(project_root_dir, \"\
    design\")\n    if path!= \"\" and os.path.exists(path):\n        design_dir =\
    \ os.path.join(design_dir, path)\n    return design_dir\n\ndef get_simulation_dir(path:\
    \ str = \"\") -> str:\n    \"\"\" Get the absolute path of the simulation directory\n\
    \n    Return:\n        The absolute path of the simulation directory.\n    \"\"\
    \"\n    project_root_dir = get_project_root_dir()\n    simulation_dir = os.path.join(project_root_dir,\
    \ \"tests\", \"simulation\")\n    if path!= \"\" and os.path.exists(path):\n \
    \       simulation_dir = os.path.join(simulation_dir, path)\n    return simulation_dir\n\
    \ndef get_tools_dir(path: str = \"\") -> str:\n    \"\"\" Get the absolute path\
    \ of the tools directory\n\n    Return:\n        The absolute path of the tools\
    \ directory.\n    \"\"\"\n    project_root_dir = get_project_root_dir()\n    tools_dir\
    \ = os."
- code: |-
    module Anding (input a, b, output y);
    and (y, a, b);
    dff dff_init (
    .init(0),
    .init_p(0)
    );
    endmodule
    ### Expected Result:
    Two warnings:
    Warning: DFF instantiation and initialization values are both zero.
    Warning: DFF initialization is being overridden by the DFF instantiation.



    ## Test 7.2
    ### Base Verilog Code:
    module Anding (input a, b, output y);
    and (y,
- code: "module Anding (input a, b, output y);\nand (y, a, b);\nendmodule\n\n### Test\
    \ Code:\n\nmodule TestAnding;\nreg a, b;\nwire y;\nAnding uut (.a(a),.b(b),.y(y));\n\
    initial begin\na = 0;\nb = 0;\n#5 a = 1;\n#5 b = 1;\n#5 a = 0;\n#5 b = 0;\n#5\
    \ a = 1;\n#5 b = 1;\n#5 a = 0;\n#5 b = 0;\n#5 a = 1;\n#5 b = 1;\nend\nendmodule\n\
    \n### Results:\n\nI think we see a problem with this testbench. For one thing,\
    \ I think the testbench should be able to drive the inputs a and b directly. Since\
    \ the testbench is only connecting the a and b inputs to the Anding sub-module\
    \ (the Anding sub-module is not connecting its input to a and b, which is where\
    \ you would use a and b if you wanted to directly drive a and b), it seems like\
    \ the testbench should only use the ports of the Anding sub-module.\n\nSo, at\
    \ the very least, I think we need to change the testbench to look like this:\n\
    \nmodule TestAnding;\nreg a, b;\nwire y;\nAnding uut (.a(a),.b(b),.y(y));\ninitial\
    \ begin\na = 0;\nb = 0;\n#5 a = 1;\n#5 b = 1;\n#5 a = 0;\n#5 b = 0;\n#5 a = 1;\n\
    #5 b = 1;\n#5 a = 0;\n#5 b = 0;\n#5 a = 1;\n#5 b = 1;\nend\nendmodule\n\nOr, if\
    \ you really insist that the testbench drives the inputs directly, then I think\
    \ we need to change the testbench to look like this:\n\nmodule TestAnding;\nwire\
    \ [1:0] a;\nwire [1:0] b;\nwire y;\nAnding uut (.a(a),.b(b),.y(y));\ninitial begin\n\
    a[0] = 0;\na[1] = 0;\nb[0] = 0;\nb[1] = 0;\n#5 a[0] = 1;\n#5 a[1] = 1;\n#5 b[0]\
    \ = 1;\n#5 b[1] = 1;\n#5 a[0] = 0;\n#5 a[1] = 0;\n#5 b[0] = 0;\n#5 b[1] = 0;\n\
    #5 a[0] = 1;\n#5 a[1] = 1;\n#5 b[0] = 1;\n#5 b[1] = 1;\nend\nendmodule\n\nNote\
    \ the change in a and b from reg a and b to wire [1:0] a and wire [1:0] b.\n\n\
    In my opinion, the DFF sub-module should use a packed union. So, I think you should\
    \ change the DFF sub-module to use a packed union.\n\nmodule DFF (input in, output\
    \ out, output reg q);\n\nIf the default of a sub-module\u2019s port is packed,\
    \ then any default for a port\u2019s sub-port should be the same. In this case,\
    \ the DFF should allow the default for q to be either wire or reg.\n\n### Test\
    \ Code 2:\n\n#100 creg a = 2\u2019b11;\n#100 creg b = 2\u2019b10;\n\nmodule Anding\
    \ (input a, b, output y);\nand (y, a, b);\nendmodule\n\nmodule TestAnding;\nreg\
    \ a, b;\nwire y;\nAnding uut (.a(a),.b(b),.y(y));\ninitial begin\na = 0;\nb =\
    \ 0;\n#5 a = 1;\n#5 b = 1;\n#5 a = 0;\n#5 b = 0;\n#5 a = 1;\n#5 b = 1;\n#5 a =\
    \ 0;\n#5 b = 0;\n#5 a = 1;\n#5 b = 1;\nend\nendmodule\n\n### Results:\n\nThis\
    \ testbench is still showing a problem. For one thing, it still uses a reg to\
    \ drive the inputs.\n\nSo, at the very least, our testbench should drive the input\
    \ a and b directly. We can do this by either giving it a wire a and b or we can\
    \ give it a packed union a and b. Since we need to give it a packed union a and\
    \ b, we will need to define wire [1:0] a and wire [1:0] b.\n\nmodule TestAnding;\n\
    wire [1:0] a;\nwire [1:0] b;\nwire y;\nAnding uut (.a(a),.b(b),.y(y));\ninitial\
    \ begin\na[0] = 0;\na[1] = 0;\nb[0] = 0;\nb[1] = 0;\n#5 a[0] = 1;\n#5 a[1] = 1;\n\
    #5 b[0] = 1;\n#5 b[1] = 1;\n#5 a[0] = 0;\n#5 a[1] = 0;\n#5 b[0] = 0;\n#5 b[1]\
    \ = 0;\n#5 a[0] = 1;\n#5 a[1] = 1;\n#5 b[0] = 1;\n#5 b[1] = 1;\nend\nendmodule\n\
    \nHowever, we still have a problem. Since we are using a packed union, the testbench\
    \ can\u2019t set the default value of a and b.\n\nSo, I think we need to update\
    \ the testbench to use a packed union rather than a reg."
- code: |-
    module Anding (input a, b, output y);
    and #(2) (y, a, b);
    endmodule
    ### Expected Results:
    ### Actual Results: The compiler reports an "unknown port" error.  This is due to a feature in the Verilog parser that treats the packed structure as 2 separate signals.
    ### Lint Rule(s) Ran: 112-S1693 E:112-S1876
    ### Verilog Compiler Output:
    % mti_compile: /tmp/test.v:34: Error (112-S1693): Unknown port `y' in instance `and'.
    % mti_compile: /tmp/test.v:34: Error (112-S1876): Invalid number of port connections.
    ### End of File
    #include "fio.h"
    #include "ftu_common.h"
    #include "ftu_dft.h"
    #include "ftu_util.h"

    #include "ftu_dft_util.h"

    #define MAX_DFT_NUM_WAVES (512)

    typedef struct dft_params {
      unsigned long dft_num_waves;
      unsigned long dft_num_output_waves;
      unsigned long dft_wave_indices[MAX_DFT_NUM_WAVES];
    } dft_params;

    static void *dft_init(fio_session *session, void *context, int argc, char **argv);
    static void dft_fini(fio_session *session, void *context);
    static int dft_control(fio_session *session, void *context, int argc, char **argv);
    static void dft_run(fio_session *session, void *context, const char *input_filename, const char *output_filename, fio_run_info *runinfo);

    static dft_params *get_dft_params(fio_session *session, void *context);
    static void get_dft_params_from_command_line(fio_session *session, void *context, int argc, char **argv, dft_params *params);
    static void get_dft_params_from_file(fio_session *session, void *context, const char *filename, dft_params *params);
    static int get_indices_from_file(fio_session *session, void *context, const char *filename, unsigned long *indices, unsigned long *num_indices);
    static int get_indices_from_command_line(fio_session *session, void *context, int argc, char **argv, unsigned long *indices, unsigned long *num_indices);
    static int get_indices_from_file_or_command_line(fio_session *session, void *context, int argc, char **argv, fio_session_wave_info *wave_info, unsigned long *indices, unsigned long *num_indices);
    static void get_indices_from_wave_info(fio_session *session, void *context, fio_session_wave_info *wave_info, unsigned long *indices, unsigned long *num_indices);


    fio_algorithm dft = {
     .name = "FFT",
     .init = dft_init,
     .fini = dft_fini,
     .control = dft_control,
     .run = dft_run
    };

    static fio_algorithm_info dft_info = {
     .name = "FFT",
     .is_dft = FIO_TRUE,
     .is_fft = FIO_TRUE
    };

    #define HELP_STRING "FFT usage:\n\
    fft [-i <input filename>] [-o <output filename>] [-h] [-v] [--help]\n\
    \n\
    fft [-i <input filename>] [-o <output filename>] [-v] [--fft] [--dft] [-n <num waves>] [--num-waves=<num waves>]\n\
    \n\
    fft [-v] [--fft-wave=<start wave index>] [--dft-wave=<start wave index>] [-n <num-waves>]\n\
    \n\
    fft [-v] [--fft-wave=<start wave index>,<num-waves>] [--dft-wave=<start wave index>,<num-waves>]\n\
    \n\
    fft [-i <input filename>] [-o <output filename>] [--fft-wave=<start wave index>,<num-waves>] [--dft-wave=<start wave index>,<num-waves>]\n\
    \n\
    fft --fft-wave-file=<filename> [--dft-wave-file=<filename>]\n\
    \n\
    fft --fft-wave-file=<filename> [-m <num waves>] [--num-waves=<num waves>]\n\
    \n\
    fft --dft-wave-file=<filename> [--fft-wave-file=<filename>]\n\
    \n\
    fft [--fft-wave-file=<filename> | --dft-wave-file=<filename>]\n\
    \n\
    fft [--fft-wave-file=<filename> | --dft-wave-file=<filename>] [--num-waves=<num waves>]\n\
    \n\
    fft [-n <num waves>] [--num-waves=<num waves>]\n\
    \n\
    fft [--fft-wave-file=<filename> | --dft-wave-file=<filename>] [--num-waves=<num waves>]\n\
    \n\
    fft [--fft-wave-file=<filename> | --dft-wave-file=<filename>] [-m <num waves>] [--num-waves=<num waves>]\n"

    static char *get_argument_value(int argc, char **argv, const char *argument_name) {
      int i;
      if ((argc < 2) || (strcmp(argv[1], argument_name) == 0)) {
        return NULL;
      }
      for (i = 1; i < (argc - 1); i++) {
        if (strcmp(argv[i], argument_name) == 0) {
          return argv[i + 1];
        }
      }
      return NULL;
    }

    static void *dft_init(fio_session *session, void *context, int argc, char **argv) {
      dft_params *params = fio_malloc(sizeof(dft_params));
      if (params == NULL) {
        return NULL;
      }
      get_dft_params_from_command_line(session, context, argc, argv, params);
      return params;
    }

    static void dft_fini(fio_session *session, void *context) {
      dft_params *params = (dft_params *)context;
      if (params!= NULL) {
        fio_free(params);
      }
    }

    static int dft_control(fio_session *session, void *context, int argc, char **argv) {
      return 0;
    }

    static void dft_run(fio_session *session, void *context, const char *input_filename, const char *output_filename, fio_run_info *runinfo) {
      dft_params *params = get_dft_params(session, context);
      unsigned long i;
      unsigned long num_indices = params->dft_num_output_waves;
      unsigned long *indices = params->dft_wave_indices;
      fio_session_wave_info *wave_info = NULL;
      if (runinfo->run_type == FIO_RUN_TYPE_WAVE_INDEX_RANGE) {
        wave_info = fio_session_get_wave_info(session);
        if (wave_info == NULL) {
          fio_session_error(session, FIO_SESSION_ERROR_UNKNOWN, "Unknown error");
          return;
        }
        get_indices_from_wave_info(session, context, wave_info, indices, &num_indices);
        if (session->is_fatal) {
          return;
        }
      } else {
        get_dft_params_from_file(session, context, input_filename, params);
        if (session->is_fatal) {
          return;
        }
        if ((runinfo->run_type == FIO_RUN_TYPE_WAVE_INDEX) || (runinfo->run_type == FIO_RUN_TYPE_WAVE_INDEX_RANGE)) {
          for (i = 0; i < params->dft_num_output_waves; i++) {
            if (((runinfo->first_wave_index == 0) && (indices[i] == runinfo->first_wave_index)) ||
                ((runinfo->first_wave_index!= 0) && (indices[i] >= runinfo->first_wave_index) && (indices[i] - runinfo->first_wave_index < params->dft_num_output_waves
- code: module Xoring (input a, b, output y);
- code: |-
    module sat_adder (a, b, out, ovf);
    input [3:0] a, b;
    output [3:0] out;
    output ovf;
    wire [3:0] O;
    and (O[3], a, b); // A|B is signed 3-bit
    xor (O[2], a[2]^b[2]); // B[2] is s.u. 1-bit
    xor (O[1], a[1]^b[1]); // B[1] is s.u. 1-bit
    and (O[0], O[1], O[2]); // A[1:0] is s.u. 2-bit
    assign ovf = O[3];
    assign out = O & ~O[3];
    endmodule
    ### Modified Verilog Code:
    module sat_adder (a, b, out, ovf);
    input [3:0] a, b;
    output [3:0] out;
    output ovf;
    wire [3:0] O;
    and (O[3], a, b); // A|B is signed 3-bit
    xor (O[2], a[2]^b[2]); // B[2] is s.u. 1-bit
    xor (O[1], a[1]^b[1]); // B[1] is s.u. 1-bit
    and (O[0], O[1], O[2]); // A[1:0] is s.u. 2-bit
    assign ovf = O[3];
    assign out = O & ~O[3];
    endmodule
    ### Comparison:
    Before:
    1. 25.875%: Greater than 1-input gates
    2. 2.6875%: Not gates
    3. 16.625%: Or gates
    4
- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    logic [1:0] St;
    St = {(!c | a) & c, (!c |!a)};
    zn = |St[0] ^ St[1]; // St0 or St1 is the output and xor with St0 or St1
    zp = St[1]; // St1 is the output
    endmodule
    ### Result:
    ### Run 1:
    Testbench:
    module top_level;
    mos_strength u_mos (
    .a(1),
    .c(0)
    );
    mos_strength u_mos1 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos2 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos3 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos4 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos5 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos6 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos7 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos8 (
    .a(1),
    .c(0)
    );
    mos_strength u_mos9 (
    .a(1),
    .c(0)
    );
    initial begin
    #40 $display("Result 1: a=1, c=0"); #40$display("St0: %b", 1);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1); #40 $display("St0: %b", 1); #40$display("St1: %b", 0); #40 $display("Z: %b", 0); #40$display("St0: %b", 1);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 0); end #40$display("Result 2: a=1, c=1");
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1); #40 $display("Z: %b", 0); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 1); #40$display("Z: %b", 0);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 0); end #40$display("Result 3: a=0, c=0");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 0); #40 $display("Z: %b", 0); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 0);
    #40 $display("St0: %b", 0); #40$display("St1: %b", 0);
    #40 $display("Z: %b", 0); end #40$display("Result 4: a=0, c=1");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 1); #40 $display("Z: %b", 0); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 1); #40$display("Z: %b", 0);
    #40 $display("St0: %b", 0); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 1); end #40$display("Result 5: a=1, c=0 and vice versa");
    #40 $display("St0: %b", 1); #40$display("St1: %b", 0); #40 $display("Z: %b", 1); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 1); end #40$display("Result 6: a=1, c=1 and vice versa");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 0); #40 $display("Z: %b", 1); #40$display("St0: %b", 1);
    #40 $display("St1: %b", 1); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 0); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 1); end #40$display("Result 7: a=0, c=0 and vice versa");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 0); #40 $display("Z: %b", 1); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1);
    #40 $display("Z: %b", 1); end #40$display("Result 8: a=0, c=1 and vice versa");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 1); #40 $display("Z: %b", 1); #40$display("St0: %b", 1);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 0); #40$display("St1: %b", 0);
    #40 $display("Z: %b", 1); end #40$display("Result 9: a=1, c=0 and a=0, c=0");
    #40 $display("St0: %b", 1); #40$display("St1: %b", 0); #40 $display("Z: %b", 0); #40$display("St0: %b", 1);
    #40 $display("St1: %b", 0); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 0);
    #40 $display("Z: %b", 1); end #40$display("Result 10: a=1, c=0 and a=0, c=1");
    #40 $display("St0: %b", 1); #40$display("St1: %b", 1); #40 $display("Z: %b", 0); #40$display("St0: %b", 0);
    #40 $display("St1: %b", 1); #40$display("Z: %b", 1);
    #40 $display("St0: %b", 1); #40$display("St1: %b", 0);
    #40 $display("Z: %b", 1); end #40$display("Result 11: a=1, c=1 and a=1, c=0");
    #40 $display("St0: %b", 0); #40$display("St1: %b", 1); #40 $display("Z: %
- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    mos_strength_enum (zn, a, c);
    mos_strength_enum (zp, a, c);
    endmodule

    module mos_strength_enum(out_signal, in_a, in_c);

    input [15:0] in_c, in_a;
    output [15:0] out_signal;

    assign out_signal = {in_a, in_a} ^ in_c;

    endmodule

    ## Question 3: How can you implement a one-hot decoder?

    1. One-hot decoder
    module one_hot_decoder (in, out);
    input [3:0] in;
    output [3:0] out;

    assign out = in;

    endmodule

    ## Question 4: How do you create a multiplexer in Verilog?

    1. Multiplexer in Verilog
    module mux4_1 (a, b, s, x, y, z);
    input [3:0] a, b, x, y, z;
    output [3:0] s;

    assign s = {x, y, z}? a : b;

    endmodule

    ## Question 5: For the following equation, give the decimal equivalent.

    1. NAND gate
    $S = \overline{ A }\overline{ B }$

    2. OR gate
    $S = A + B$

    ## Question 6: How do you create a 2 to 1 multiplexer?

    1. Multiplexer
    module mux2_1 (a, b, s, x, y);
    input [1:0] a, b, x, y;
    output s;

    assign s = {x, y}? a : b;

    endmodule

    ## Question 7: How do you implement a full adder in Verilog?

    1. Two Full Adders
    module full_adder (a, b, cin, sum, cout);
    input a, b, cin;
    output sum, cout;

    wire t1, t2, t3, t4;
    t1 = a xor b;
    t2 = a and b;
    t3 = t1 and b;
    t4 = t1 and a;

    assign sum = (t3 << 1) ^ t1;
    assign cout = t2 or t3 or t4;

    endmodule

    ## Question 8: How can you implement a 2-bit comparator?

    1. 2-bit comparator
    module comparator2 (in0, in1, out, cmp_out);
    input in0, in1;
    output out, cmp_out;

    wire [1:0] diff;

    assign diff = in0 ^ in1;
    assign cmp_out = ~diff;

    case (diff)
    2'd0:
    out = 1'b0;
    break;
    2'd1:
    out = 1'b1;
    break;
    default:
    out = 1'b0;
    endcase

    endmodule

    ## Question 9: How do you create a comparator in Verilog?

    1. Comparator
    module comparator (in0, in1, out);
    input in0, in1;
    output out;

    comparator7 (out, in0, in1);

    endmodule

    2. Comparator
    module comparator7 (out, in0, in1);
    input in0, in1;
    output out;

    comparator7_s (out, in0, in1);

    endmodule

    3. Comparator
    module comparator7_s (out, in0, in1);
    input in0, in1;
    output out;

    out = in0 > in1;

    endmodule

    ## Question 10: How do you create a 4-bit comparator?

    1. 4-bit comparator
    module comparator4 (in0, in1, out, cmp_out);
    input in0, in1;
    output out, cmp_out;

    wire [3:0] diff;

    assign diff = in0 ^ in1;
    assign cmp_out = ~diff;

    case (diff)
    4'd0:
    out = 1'b0;
    break;
    4'd1:
    out = 1'b1;
    break;
    default:
    out = 1'b0;
    endcase

    endmodule

    ## Question 11: How can you implement a 4 input AND gate?

    1. 4-input AND Gate
    module and4 (in0, in1, in2, in3, out);
    input in0, in1, in2, in3;
    output out;

    assign out = in0 & in1 & in2 & in3;

    endmodule

    ## Question 12: How do you implement an 8 to 1 multiplexer and implement its truth table?

    $S = {000,0,0,0,1,1,1,1} {001,0,0,1,0,0,0,1} {010,0,0,1,1,0,1,0} {100,0,1,0,0,1,0,0} {101,0,1,0,1,1,1,1} {110,0,1,1,0,0,0,1} {111,0,1,1,1,1,1,1}$

    1. 8-to-1 Multiplexer
    module mux8_1 (a, b, s, x, y, z, z1, z2, z3);
    input [3:0] a, b, x, y, z, z1, z2, z3;
    output [3:0] s;

    assign s =
    {z2, z3} & {y, z}? a : b :
    {z1} & {x, z}? a : b :
    {z1, z2} & {x, y}? a : b :
    {z1, z3} & {x, z1}? a : b :
    {z2, z3} & {y, z1}? a : b :
    {z1, z2, z3}? a : b :
    1'b1 :
    {x, z1, z2, z3}? a : b;

    endmodule

    ## Question 13: How do you implement a 4 to 1 multiplexer and implement its truth table?

    $S = {000,0,0,0,1,1,1,1} {001,0,0,1,0,0,0,1} {010,0,1,0,1,0,1,0} {011,0,1,1,1,1,1,1} {100,1,0,0,0,1,0,0} {101,1,0,1,1,1,1,1} {110,1,1,0,0,0,0,1} {111,1,1,1,1,1,1,1}$

    1. 4-to-1 Multiplexer
    module mux4_1 (a, b, s, x, y);
    input [1:0] a, b, x, y;
    output [1:0] s;

    assign s =
    {y} & {x}? a : b :
    {x}? a : b;

    endmodule

    ## Question 14: How do you implement a 4 input OR gate?

    1. 4-input OR gate
    module or4 (in0, in1, in2, in3, out);
    input in0, in1, in2, in3;
    output out;

    assign out = in0 | in1 | in2 | in3;

    endmodule

    ## Question 15: How do you create a 2-bit to 4-bit decoder?

    1. 2-bit to 4-bit Decoder
    module decoder2_4 (in0, in1, out0, out1, out2, out3);
    input [1:0] in0, in1;
    output [3:0] out0, out1, out2, out3;

    assign out0 = in0;
    assign out1 = in1;
    assign out2 = (in0, in1) << 2;
    assign out3 = in0 & in1;

    endmodule

    ## Question 16: How do you implement a counter?

    1. 4-bit counter
    module counter4 (clk, rst, count, cout);
    input clk, rst;
    output [3:0] count;

    always @(posedge clk)
    if (rst == 1'b1)
    count <= 4
- code: |-
    import enum
    class Strength(enum.Enum):
    S0  = 0
    S1  = 1
    Z   = 2
    def __and__(self, other: Strength):
    if self == Strength.S1:
    return Strength.S1
    if other == Strength.S1:
    return Strength.S1
    return Strength.S0
    def __xor__(self, other: Strength):
    if self == Strength.S0:
    return other
    if other == Strength.S0:
    return self
    return Strength.Z
    ### Enum Tests:
    assert Strength.S0 & Strength.S0 == Strength.S0
    assert Strength.S1 & Strength.S1 == Strength.S1
    assert Strength.Z ^ Strength.S1 == Strength.S0
    assert Strength.S1 ^ Strength.S1 == Strength.Z

    The output is as expected.

    ### Base Verilog Code:
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    nmos (zn, a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp, a, c); // PMOS passes 'a' when 'c
- code: |-
    module delay (D1, D0, D, clk);
    input clk;
    output D;
    always @ (posedge clk) begin
    if (D == 0) begin
    D <= 1; // if
    end
    if (D == 1) begin
    D <=
- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output [1:0] zn, zp;
    nmos (zn[0], a, c); // NMOS passes 'a' when 'c' is 1 (outputs St0 or Z)
    pmos (zp[0], a, c); // PMOS passes 'a' when 'c' is 0 (outputs St1 or Z)
    pmos
- code: |-
    module mos_strength (a, c, zn, zp);
    input a, c;
    output zn, zp;
    if (a == 1'b1 && c == 1'b1)
    assign zn = 1'b1;
    else if (a == 1'b1 && c == 1'b0)
    assign zn = 1'b1;
    else if (a == 1'b0 && c == 1'b1)
    assign zn = 1'b1;
    else if (a ==
- code: |-
    ```
    module addsub_8bit(a, b, c, d, rd, result);
    input a;
    input b;
    input c;
    input d;
    output rd;
    output result;

    // generate the adders
    addsub_8bit (a, b, c, d, rd, result);

    // generate the outputs
    result[7] = result ^ sa ^ sb ^ sb_c ^ sc; // Z
    result = result;
    endmodule
    ```

    ## Exercise 8

    ### Base Verilog Code:
    module addsub_8bit(a, b, c, d, rd, result);
    input a;
    input b;
    input c;
    input d;
    output rd;
    output result;
    addsub_8bit (a, b, c, d, rd,
- code: |-
    module nmos_enum (o, i0, i1, b);
    input i0, i1, b;
    wire o;

    assign o = enum_nmos ({i0 & ~b, i1 & ~b, ~i0 & b, ~i1 & b});

    module enum_nmos (o, i0, i1, b) {
    output o;
    assign o = ~a & c | ~a & ~c & b | a & ~c | a & c & b;
    }

    output o;
    endmodule
    ### References:
    * [Assign](http://en.wikipedia.org/wiki/Assign)
    * [Wires](http://en.wikipedia.org/wiki/Wire)
    * [Enumerated Types](http://en.wikibooks.org/wiki/C_Programming/Enumerated_Types)
    * [Enums and Bitfields](http://gcc.gnu.org/onlinedocs/gcc-4.4.1/gcc/Type-Attributes.html)
    * [Enumerated Types](http://digital-forensics.sans.org/blog/2
- code: |-
    module c_sr (CLK, D, Q);
    input CLK;
    input D;
    output Q;
    wire Q_1;
    Q_1 = D;
    CLKED_1 #(.CLOCK("clk") ) clock_module (CLK, ~Q_1); // Clock module must have a clock named "clk"
    endmodule
    ### Test-bench:
    module test_c_sr;
    input wire CLK;
    input wire D;
    output wire Q;
    c_sr #(1) mod (CLK, D, Q);
    //c_sr #(1) mod (CLK, D, Q);
    initial begin
    $monitor("clk
- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
    ### Original IR:
    <IR>@ 0x18c <f694>
    [i_parameter]:
    [0x100] 0x1000 <f694> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1001 <f695> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1002 <f696> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1003 <f697> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1004 <f698> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1005 <f699> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1006 <f69a> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1007 <f69b> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1008 <f69c> "inertial_delay_default" "1"
    [i_parameter]:
    [0x100] 0x1009 <f69d> "inertial_delay_default" "1"
    [end_of_i_parameters]
    [i_port]:
    [0x100] 0x100a <f69e> "a1"
    [i_port]:
    [0x100] 0x100b <f69f> "a"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x100c <f6a0> "b"
    [i_port]:
    [0x100] 0x100d <f6a1> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x100e <f6a2> "b1"
    [i_port]:
    [0x100] 0x100f <f6a3> "c1"
    [end_of_i_ports]
    [o_port]:
    [0x100] 0x1010 <f6a4> "a"
    [o_port]:
    [0x100] 0x1011 <f6a5> "a1"
    [end_of_o_ports]
    [i_port]:
    [0x100] 0x1012 <f6a6> "b"
    [i_port]:
    [0x100] 0x1013 <f6a7> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1014 <f6a8> "b1"
    [i_port]:
    [0x100] 0x1015 <f6a9> "c1"
    [end_of_i_ports]
    [o_port]:
    [0x100] 0x1016 <f6aa> "a"
    [o_port]:
    [0x100] 0x1017 <f6ab> "a1"
    [end_of_o_ports]
    [i_port]:
    [0x100] 0x1018 <f6ac> "b"
    [i_port]:
    [0x100] 0x1019 <f6ad> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x101a <f6ae> "b1"
    [i_port]:
    [0x100] 0x101b <f6af> "c1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x101c <f6b0> "a"
    [i_port]:
    [0x100] 0x101d <f6b1> "a1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x101e <f6b2> "b"
    [i_port]:
    [0x100] 0x101f <f6b3> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1020 <f6b4> "b1"
    [i_port]:
    [0x100] 0x1021 <f6b5> "c1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1022 <f6b6> "a"
    [i_port]:
    [0x100] 0x1023 <f6b7> "a1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1024 <f6b8> "b"
    [i_port]:
    [0x100] 0x1025 <f6b9> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1026 <f6ba> "b1"
    [i_port]:
    [0x100] 0x1027 <f6bb> "c1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1028 <f6bc> "a"
    [i_port]:
    [0x100] 0x1029 <f6bd> "a1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x102a <f6be> "b"
    [i_port]:
    [0x100] 0x102b <f6bf> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x102c <f6c0> "b1"
    [i_port]:
    [0x100] 0x102d <f6c1> "c1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x102e <f6c2> "a"
    [i_port]:
    [0x100] 0x102f <f6c3> "a1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1030 <f6c4> "b"
    [i_port]:
    [0x100] 0x1031 <f6c5> "c"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1032 <f6c6> "b1"
    [i_port]:
    [0x100] 0x1033 <f6c7> "c1"
    [end_of_i_ports]
    [i_port]:
    [0x100] 0x1034 <f6c8> "a"
    [i_port]:
    [0x100]
- code: |-
    module my_module(input [2:0] I, output reg [2:0] O);

    reg clk;
    wire rst;
    wire [2:0] DIN;
    reg [2:0] Q;

    reg [2:0] F;

    always @(posedge clk) begin
    case (rst)
    1'b0:
    Q <= 1'b0;
    1'b1:
    Q
- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(.a1(c1),.c(b1),.b(b));
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(.a(c),.c(b),.b(b));
    endmodule
    ### Expected Results:
    The following error message will be reported:
    error: Expected a pack or unpacked structure as the output type
    ### Current Results:
    The above error message is not reported. The pack structure is outputted correctly, as expected.
- code: "module gade(input b,input c,input bit[3] d,output a);\noutput a;\n// Instantiate\
    \ OR gate with inertial delay 3\nor #3 gg1(a,c,b);\nendmodule\n### Expected Result:\n\
    The following error message should be issued:\n-- 4 Error(s) --\nError(121,45):\
    \ Variable gade.b[7:0] has unpacked array type. Cannot instantiate an unpacked\
    \ array input.\nError(121,52): Variable gade.c[7:0] has unpacked array type. Cannot\
    \ instantiate an unpacked array input.\nError(121,59): Variable gade.d[3:0] has\
    \ packed array type. Cannot instantiate a packed array input.\n\n### Notes:\n\
    (1) Test case cannot be generated.\n(2) This is a special case where there is\
    \ a unpacked structure in the input, and this unpacked structure contains a packed\
    \ array. This is the way Verilog allows packed array to be used in unpacked structure.\
    \ The problem here is that this cannot be handled by PackGen. This is not supported\
    \ in the next release of PackGen.\n(3) For more information about the unpacked\
    \ structure with parameterized instance, please refer to Section 5.5.3 of the\
    \ IEEE Std 1800-2012.\nSource(s):\n\u2022 User Manual: https://www.intel.com/content/dam/www/public/us/en/documents/software/verilog-2"
- code: |-
    parameter D=7;

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;

    wire [D-1:0] a_unpacked;
    wire [D-1:0] a1_unpacked;
    wire [D-1:0] b_unpacked;
    wire [D-1:0] c_unpacked;
    wire [D-1:0] b1_unpacked;
    wire [D-1:0] c1_unpacked;
    wire [D-1:0] d_unpacked;

    and #(2,1) gg2(a_unpacked,c_unpacked,b_unpacked);
    and #(2,1) gg3(a1_unpacked,c1_unpacked,b1_unpacked);
    or  #3 gg1(a1_unpacked,c1_unpacked,b1_unpacked);

    assign a1=a_unpacked[D-1], a=a_unpacked[D-2];
    assign b1=b_unpacked[D-1], b=b_unpacked[D-2];
    assign c1=c_unpacked[D-1], c=c_unpacked[D-2];

    endmodule
    ### Synthesis Log:
    #### With the default options

    Warning: $PATH_TO_XST/Xst/lib/util/Vivado_DSE/src/top_dse.v:270:9: (Warning) Unconnected Output pin $PATH_TO_XST/Xst/lib/util/Vivado
- code: |-
    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #10 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #100 gg2(a,c,b);
    endmodule
    ### Test Result:
    The new and modified code passes successfully.

    ## Detailed Description

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule

    The example for nested unpacked structure handling shows the way of using unpacked nested structure in the Verilog language. The unpacked nested structure can be used in the declaration of a module's output.

    For example, the declaration of the gade module shown below is declared as the output of the module. Because the output is a vector of four 8-bit signed integers, you must use a nested unpacked structure to describe the output.

    module gade(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial
- code: module gbe(a,b,c,d,e,f,
- code: "```c++\n// The first parameter of the unpacked structure is the output type.\
    \ \ntemplate<typename T>\nstruct NestedPackedStruct1 {    \n    T<T<int>,int>\
    \ nps1;   \n};\n\ntemplate<typename T>\nstruct NestedPackedStruct2 {    \n   \
    \ T<T<int>,T<int>> nps2;   \n};\n\nvoid f(NestedPackedStruct2<int> nps2)\n{\n\
    \    //cout <<\"nps1.nps1.a = \" << nps1.nps1.a <<endl; \n    //cout <<\"nps1.nps1.b\
    \ = \" << nps1.nps1.b <<endl; \n    //cout <<\"nps1.nps1.c = \" << nps1.nps1.c\
    \ <<endl; \n    cout <<\"nps2.nps1.a.a = \" << nps2.nps1.a.a <<endl; \n    cout\
    \ <<\"nps2.nps1.a.b = \" << nps2.nps1.a.b <<endl; \n    cout <<\"nps2.nps1.b.a\
    \ = \" << nps2.nps1.b.a <<endl; \n    cout <<\"nps2.nps1.b.b = \" << nps2.nps1.b.b\
    \ <<endl; \n    cout <<\"nps2.nps1.c.a = \" << nps2.nps1.c.a <<endl; \n    cout\
    \ <<\"nps2.nps1.c.b = \" << nps2.nps1.c.b <<endl; \n    \n    //cout <<\"nps2.nps1.a\
    \ = \" << nps2.nps1.a <<endl; \n    //cout <<\"nps2.nps1.b = \" << nps2.nps1.b\
    \ <<endl; \n    //cout <<\"nps2.nps1.c = \" << nps2.nps1.c <<endl; \n    //cout\
    \ <<\"nps2.nps2.a.a = \" << nps2.nps2.a.a <<endl; \n    //cout <<\"nps2.nps2.a.b\
    \ = \" << nps2.nps2.a.b <<endl; \n    //cout <<\"nps2.nps2.b.a = \" << nps2.nps2.b.a\
    \ <<endl; \n    //cout <<\"nps2.nps2.b.b = \" << nps2.nps2.b.b <<endl; \n    //cout\
    \ <<\"nps2.nps2.c.a = \" << nps2.nps2.c.a <<endl; \n    //cout <<\"nps2.nps2.c.b\
    \ = \" << nps2.nps2.c.b <<endl; \n}\n```\n### Output:\n```\nnps2.nps1.a.a = 1\n\
    nps2.nps1.a.b = 2\nnps2.nps1.b.a = 3\nnps2.nps1.b"
- code: |-
    module gade(a,a1,b,c,b1,c1);
    output [7:0] a,a1;
    output b,c,b1,c1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1);
    // Instantiate AND gate with rise=2, fall=1 inertial delay
    and #(2,1) gg2(a,c,b);
    endmodule
    ```
    ### Expected Behavior
    Compilation is successful.
    ### Actual Behavior
    ```
    ERROR: vlog_comp.bb:16:78: Instantiation of a(c1,b,-) failed.
    ```
    /utils/verilog/README.md
    # Verilog Utilities

    This directory contains several utility scripts and functions to help with Verilog development.

    * `vsim_wrapper.py`: a wrapper for vsim that adds support for Verilator (verilator.org) and Icarus (iverilog.icarus.com) simulators.
    * `check_files.py`: check for various common error types in Verilog source files.
    * `check_verilog_files.py`: a wrapper for the `check_files.py` script, specialized for Verilog source files.
    * `generate_covergroup_testbench.py`: a wrapper for the `generate_testbench.py` script, specialized for Verilog covergroups.
    * `generate_testbench.py`: generate a SystemVerilog testbench for a Verilog component.
    * `remove_comments.py`: remove comments from Verilog source code files.
    * `run_vsim`: a wrapper for vsim that adds a --run flag, and allows multiple vsim processes to be run in parallel.
    * `run_vcs`: a wrapper for vcs that adds support for Verilator (verilator.org) and Icarus (iverilog.icarus.com) simulators.
    * `run_vunit`: a wrapper for vunit that adds support for Verilator (verilator.org) and Icarus (iverilog.icarus.com) simulators.
    * `run_xvlog`: a wrapper for xvlog that adds support for Verilator (verilator.org) and Icarus (iverilog.icarus.com) simulators.
    * `run_yosys`: a wrapper for yosys that adds support for the Yosys Verilog backend.
    * `test_verilog_files.py`: a wrapper for the `check_files.py` script, specialized for Verilog source files.
    * `verilator_model_wrapper.py`: a wrapper for the Verilator C++ simulator that adds support for simulation options and output logging.
    * `verilator_wrapper.py`: a wrapper for the Verilator C++ simulator.
    * `vcs_model_wrapper.py`: a wrapper for the VCS simulator that adds support for simulation options and output logging.
    * `vcs_wrapper.py`: a wrapper for the VCS simulator.
    * `vunit_model_wrapper.py`: a wrapper for the VUnit simulator that adds support for simulation options and output logging.
    * `vunit_wrapper.py`: a wrapper for the VUnit simulator.
    * `xvlog_model_wrapper.py`: a wrapper for the Xilinx Vivado simulator that adds support for simulation options and output logging.
    * `xvlog_wrapper.py`: a wrapper for the Xilinx Vivado simulator.
    * `yosys_model_wrapper.py`: a wrapper for the Yosys simulator that adds support for simulation options and output logging.
    * `yosys_wrapper.py`: a wrapper for the Yosys simulator.
    * `yosys_verilog.py`: a wrapper for the Yosys Verilog backend that adds support for simulation options and output logging.
    * `zsim.py`: a wrapper for the zsim simulator.

    The `run_vcs`, `run_vunit`, and `run_xvlog` scripts all use the vcs, vunit, and xvlog simulators, respectively.

    The `verilog_test.py` script uses the `run_vcs`, `run_vunit`, `run_xvlog`, and `run_yosys` scripts to perform a complete functional verification suite for Verilog source files.

    The `vsim_wrapper.py` script uses the `run_vsim` script to perform a complete simulation suite for Verilog source files.

    The `verilator_wrapper.py` script uses the Verilator C++ simulator to perform a complete simulation suite for Verilog source files.

    ## Installing Verilator, VUnit, and Yosys

    Each of these scripts use a specific version of the corresponding simulator. To install the simulator, run the appropriate command:

    * Verilator: `pip install verilator`
    * VUnit: `pip install vunit`
    * Yosys: `pip install yosys`

    ## Running Verilator, VUnit, and Yosys Simulators

    Each of these scripts (along with the `run_vsim` script) use a specific tool to perform a simulation. To run the simulator, run the appropriate command:

    * Verilator: `verilator`
    * VUnit: `vunit`
    * Yosys: `yosys`

    The `run_vsim` script uses the Vivado simulator (xvlog) to run the Vivado simulation. You can use another simulator by modifying the `SIM` environment variable in these scripts.

    ## Running Verilog Simulation Scripts

    The `run_vsim` and `verilog_test.py` scripts both use the `run_vsim` script to perform a simulation. To run the simulator, run the appropriate command:

    ```
    $ run_vsim --version
    ```
    ## Running Verilog Verification Scripts

    The `verilog_test.py` script uses the `run_vcs` and `run_vunit` scripts to perform a complete functional verification suite for Verilog source files. To run the verification, run the appropriate command:

    ```
    $ verilog_test.py --version
    ```

    The `run_vcs`, `run_vunit`, and `run_xvlog` scripts use the `vcs`, `vunit`, and `xvlog` simulators, respectively. Since the Vivado simulator (xvlog) is used by the `run_vsim` script, these scripts should be run with the `SIM` environment variable set to `vsim`. In this case, a separate Vivado installation is not required.

    The `verilog_test.py` script does not use the `run_vcs`, `run_vunit`, or `run_xvlog` scripts.

    The `run_vsim` script uses the Vivado simulator (xvlog) to run the Vivado simulation. You can use another simulator by modifying the `SIM` environment variable. To run the simulator, run the appropriate command:

    ```
    $ run_vsim --version
    ```

    ## Installing Verilator, VUnit, and VCS/Icarus

    ```
    $ pip install verilator
    $ pip install vunit
    ```

    ## Running Verilator, VUnit, and VCS/Icarus Simulations

    ```
    $ vcs --version
    ```

    ## Running Verilog Simulation Scripts

    ```
    $ run_vcs --version
    $ run_vunit --version
    $ run_xvlog --version
    $ run_yosys --version
    ```

    ## Running Verilog Verification Scripts

    ```
    $ verilog_test.py --version
    ```

    ## Python Syntax

    Each script uses Python syntax to perform various tasks. You can run a script using the following command:

    ```
    $ python path/to/script.py
    ```

    Here are some useful Python syntax commands that can be used in scripts:

    * `print`: print an output message to the console.
    * `sys.argv`: a list of command-line arguments passed to the script.
    * `sys.exit`: exit the script with a given exit status code.
    * `sys.path`: a list of paths to search for Python source files.
    * `sys.stdout`: an object representing.0
    #include <verilog_file.vh>

    // Set the path to the Verilator header file
    #include <verilated.h>

    // Set the path to the Verilator model file
    #include <verilator_model.cpp>

    // Create a new Verilator model
    Testbench* testbench = new Testbench;

    // Run the Verilator simulation
    int main(int argc, char** argv) {
      Verilated::commandArgs(argc, argv);
      testbench->run();
      return 0;
    }
    ```

    ## Yosys

    ```verilog
    module testbench;
      input a;
      input b;
      output a1;
      output b1;
      logic a1_;
      logic b1_;
      reg [3:0] state;
      or #(.t
- code: |-
    module gads(a,a1,b,c,b1,c1);
    input b,c,b1,c1;
    output a,a1;
    // Instantiate OR gate with inertial delay 3
    or #3 gg1(a1,c1,b1
- code: |-
    module tstha_35();
      reg a; wire s,ca;
      packed clk_struct {
          a;
          (.) s, ca;
      };
      ha_35 hh(s,ca,a); // Instantiate HA with rise/fall path delays
      clk_struct clk_out;
      initial begin a=0; end
      always begin #5 a=1; end
      initial $monitor($time, " a = %b,out carry = %b, outsum = %b ",a,clk_out.ca,clk_out.s);
      initial #30 $stop;
    endmodule
    ### Base Verilog Code:
    module tstha_37();
      reg a; wire s,ca,cb;
      ha_37 hh(s,ca,cb,a); // Instantiate HA with rise/fall path delays
      initial begin a=0;
- code: |-
    ```verilog
    module tstha_14();
      reg a,b; wire s,ca;
      ha_14 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
- code: "module tstha_11();\n  reg a,b,c,d; wire s,ca;\n  ha_11 hh(s,ca,a,b,c,d);\
    \ // Instantiate HA with rise/fall path delays\n  initial begin a=0;b=0;c=0;d=0;\
    \ end\n  initial begin\n    struct packed_struct { reg a,b,c,d,e; } p;\n    p.a\
    \ = 0; p.b = 0; p.c = 0; p.d = 0; p.e = 1; \n    p.b = 1; #1 p.a = 2; #1 p.b =\
    \ 0; #1 p.c = 0; #1 p.d = 0; #1 p.e = 0; #1 p.b = 1; #1 p.c = 0; #1 p.d = 0; #1\
    \ p.e = 1; #1 p.b = 0; #1 p.c = 0; #1 p.d = 0; #1 p.e = 1; #1 p.b = 1; #1 p.c\
    \ = 0; #1 p.d = 1; #1 p.e = 0; #1 p.b = 0; #1 p.c = 0; #1 p.d = 1; #1 p.e = 1;\
    \ #1 p.b = 1; #1 p.c = 1; #1 p.d = 0; #1 p.e = 0; #1 p.b = 0; #1 p.c = 0; #1 p.d\
    \ = 1; #1 p.e = 0; #1 p.b = 1; \n  end\n  initial $monitor($time, \" a = %b, b\
    \ = %b, c = %b, d = %b, out carry = %b, outsum = %b \",a,b,c,d,ca,s);\n  initial\
    \ #30 $stop;\nendmodule\n### Base Verilog Code:\nmodule tstha_12();\n  reg a,b,c,d,e;\
    \ wire s,ca;\n  ha_12 hh(s,ca,a,b,c,d,e); // Instantiate HA with rise/fall path\
    \ delays\n  initial begin a=0;b=0;c=0;d=0;e=0; end\n  always begin #5 a=1;b=0;c=0;d=0;e=0;\
    \ #5 a=0;b=1;c=0;d=0;e=0; #5 a=1;b=1;c=0;d=0"
- code: |-
    ### Base Verilog Code:
    module tstha_9();
       reg a,b; wire s,ca;
       ha_9 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
       initial begin a=0;b=0; end
       always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
       initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
       initial #30 $stop;
    endmodule

    module tstha_9();
      reg a,b; wire s,ca;
      ha_9 hh(.CLK(CLK),s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule

    ```

    ## Demonstrate Signal Routing
- code: |-
    module tstha_13();
      reg a,b; wire s,ca;
      ha_13 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      wire clk[2];
      initial begin a=0;b=0; clk[0]=1;clk[1]=0; end
      always #5 begin a=1;b=0; clk[0]=1;clk[1]=0; end
      always #5 begin a=0;b=1; clk[0]=1;clk[1]=0; end
      always #5 begin a=1;b=1; clk[0]=1;clk[1]=0; end
      always #5 begin a=0;b=0; clk[0]=1;clk[1]=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule

    ### Base Verilog Code:
    module tstha_14();
      reg a,b; wire s,ca;
      ha_14 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #30 $stop;
    endmodule
    ### Variation Instruction:
    Modify the
- code: "#include <systemc.h>\n#include <time.h>\n#include \"ha_9.h\"\n//\n// Generated\
    \ by Synopsys Cordic 15.5.1 Standard Edition\n// #2021-04-05 18:49:12\n//\n\n\
    int sc_main(int argc, char* argv[]) {\n  struct {\n    sc_uint<1> a,b,s,ca;\n\
    \  } packed_data;\n  sc_clock clk_10M(\"clk_10M\",10,SC_NS);\n  sc_signal<sc_uint<1>\
    \ > a_9_in_10;\n  sc_signal<sc_uint<1> > b_9_in_10;\n  sc_signal<sc_uint<1> >\
    \ s_9_out_10;\n  sc_signal<sc_uint<1> > ca_9_out_10;\n  ha_9 ha_9_inst(\"ha_9_inst\"\
    );\n  sc_trace_file* tf_;\n  tf_ = sc_create_vcd_trace_file(\"tstha_9\");\n  tf_->set_time_unit(1,\
    \ SC_NS);\n  sc_trace(tf_, clk_10M, \"clk_10M\");\n  sc_trace(tf_, a_9_in_10,\
    \ \"a_9_in_10\");\n  sc_trace(tf_, b_9_in_10, \"b_9_in_10\");\n  sc_trace(tf_,\
    \ s_9_out_10, \"s_9_out_10\");\n  sc_trace(tf_, ca_9_out_10, \"ca_9_out_10\");\n\
    \  a_9_in_10.write(0);\n  b_9_in_10.write(0);\n  sc_start();\n  a_9_in_10.write(0);\n\
    \  b_9_in_10.write(1);\n  sc_start();\n  a_9_in_10.write(1);\n  b_9_in_10.write(0);\n\
    \  sc_start();\n  a_9_in_10.write(0);\n  b_9_in_10.write(0);\n  sc_start();\n\
    \  a_9_in_10.write(1);\n  b_9_in_10.write(1);\n  sc_start();\n  a_9_in_10.write(0);\n\
    \  b_9_in_10.write(0);\n  sc_start();\n  a_9_in_10.write(1);\n  b_9_in_10.write(0);\n\
    \  sc_start();\n  a_9_in_10.write(0);\n  b_9_in_10.write(1);\n  sc_start();\n\
    \  sc_stop();\n  sc_close_vcd_trace_file(tf_);\n  return 0;\n}\n// Generated by\
    \ Synopsys Cordic 15.5.1 Standard Edition\n// #2021-04-05 18:50:16\n//\n#line\
    \ 1 \"ha_9.v\"\nmodule ha_9(output reg s, output reg ca, input a, input b); \n\
    #line 22 \"ha_9.v\"\nwire s2; \n#line 23 \"ha_9.v\"\nwire ca2; \n#line 24 \"ha_9.v\"\
    \nassign ca = ca2; \n#line 25 \"ha_9.v\"\nassign s = s2; \n#line 26 \"ha_9.v\"\
    \nassign s2 = ((a==b)&&ca)? 1 : 0;  \n#line 27 \"ha_9.v\"\nassign ca2 = (((a==b)&&ca)?\
    \ 1 : 0) | (a^b);  \n#line 28 \"ha_9.v\"\nendmodule\n#line 29 \"ha_9.v\"\nmodule\
    \ tstha_9(); \n#line 31 \"ha_9.v\"\nreg a,b; \n#line 32 \"ha_9.v\"\nwire s,ca;\
    \ \n#line 33 \"ha_9.v\"\nha_9 hh(s,ca,a,b); \n#line 34 \"ha_9.v\"\ninitial begin\
    \ a=0;b=0; end \n#line 35 \"ha_9.v\"\nalways begin #5 a=1;b=0; #5 a=0;b=1; #5\
    \ a=1;b=1; #5 a=0;b=0; end \n#line 36 \"ha_9.v\"\ninitial $monitor($time, \" a\
    \ = %b, b = %b,out carry = %b, outsum = %b \",a,b,ca,s); \n#line 37 \"ha_9.v\"\
    \ninitial #30 $stop; \n#line 38 \"ha_9.v\"\nendmodule\ns.v\"\nreg a,b;\n#line\
    \ 32 \"ha_9.v\"\nwire s,ca;\n#line 33 \"ha_9.v\"\nha_9 hh(s,ca,a,b);\n#line 34\
    \ \"ha_9.v\"\ninitial begin a=0;b=0; end\n#line 35 \"ha_9.v\"\nalways begin #5\
    \ a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end\n#line 36 \"ha_9.v\"\ninitial\
    \ $monitor($time,\" a = %b, b = %b,out carry = %b, outsum = %b \",a,b,ca,s);\n\
    #line 37 \"ha_9.v\"\ninitial $stop;\n#line 38 \"ha_9.v\"\nendmodule\n#line 1 \"\
    tstha_9.v\"\nmodule tstha_9();\n#line 22 \"tstha_9.v\"\nreg a,b;\n#line 23 \"\
    tstha_9.v\"\nwire s,ca;\n#line 24 \"tstha_9.v\"\nha_9 hh(s,ca,a,b);\n#line 25\
    \ \"tstha_9.v\"\ninitial begin a=0;b=0; end\n#line 26 \"tstha_9.v\"\nalways begin\
    \ #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end\n#line 27 \"tstha_9.v\"\n\
    initial $monitor($time,\" a = %b, b = %b,out carry = %b, outsum = %b \",a,b,ca,s);\n\
    #line 28 \"tstha_9.v\"\ninitial $stop;\n#line 29 \"tstha_9.v\"\nendmodule\n#line\
    \ 30 \"tstha_9.v\"\nmodule ha_9(output reg s, output reg ca, input a, input b);\n\
    #line 22 \"ha_9.v\"\nwire s2;\n#line 23 \"ha_9.v\"\nwire ca2;\n#line 24 \"ha_9.v\"\
    \nassign ca = ca2;\n#line 25 \"ha_9.v\"\nassign s = s2;\n#line 26 \"ha_9.v\"\n\
    assign s2 = ((a==b)&&ca)?1:0;\n#line 27 \"ha_9.v\"\nassign ca2 = (((a==b)&&ca)?1:0)\
    \ | (a^b);\n#line 28 \"ha_9.v\"\nendmodule\n#line 29 \"ha_9.v\"\nmodule tstha_9();\n\
    #line 31 \"ha_9.v\"\nreg a,b;\n#line 32 \"ha_9.v\"\nwire s,ca;\n#line 33 \"ha_9.v\"\
    \nha_9 hh(s,ca,a,b);\n#line 34 \"ha_9.v\"\ninitial begin a=0;b=0; end\n#line 35\
    \ \"ha_9.v\"\nalways begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0;"
- code: "module tstha_9();\n  wire [1:0] clk;\n  reg a,b; wire s,ca;\n  ha_9 hh(s,ca,a,b);\
    \ // Instantiate HA with rise/fall path delays\n  initial begin a=0;b=0; end\n\
    \  initial begin clk=3'b100; end\n  always begin #5 clk=3'b110; #5 clk=3'b011;\
    \ #5 clk=3'b111; #5 clk=3'b010; end\n  initial $monitor($time, \" a = %b, b =\
    \ %b,out carry = %b, outsum = %b \",a,b,ca,s);\n  initial #30 $stop;\nendmodule/labs/lab6/lab6/lab6/lab6/ha_12.h\n\
    // ha_12.h\n// Header for 12 bit half adder\n\n// Verilog module ha_12\n// using\
    \ systemverilog logic types\n\n// Original author  - 2007-01-06\n\n// This file\
    \ is part of 'Verilog code generation using SystemVerilog'.\n// Copyright (c)\
    \ 2007, \n// All rights reserved.\n\n// Redistribution and use in source and binary\
    \ forms, with or without\n// modification, are permitted provided that the following\
    \ conditions are met:\n//     * Redistributions of source code must retain the\
    \ above copyright\n//       notice, this list of conditions and the following\
    \ disclaimer.\n//     * Redistributions in binary form must reproduce the above\
    \ copyright\n//       notice, this list of conditions and the following disclaimer\
    \ in the\n//       documentation and/or other materials provided with the distribution.\n\
    //     * Neither the name of the copyright holder nor the\n//       names of its\
    \ contributors may be used to endorse or promote products\n//       derived from\
    \ this software without specific prior written permission.\n\n// THIS SOFTWARE\
    \ IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY\
    \ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\
    // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n//\
    \ DISCLAIMED. IN NO EVENT SHALL  BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL,\
    \ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED\
    \ TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS;\
    \ OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY,\
    \ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR\
    \ OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED\
    \ OF THE POSSIBILITY OF SUCH DAMAGE.\n\nmodule ha_12\n#(\n    parameter WIDTH=4\n\
    )\n(\n    input  clk,\n    input  a,\n    input  b,\n    input  carry_in,\n  \
    \  output sum,\n    output carry_out\n);\n    // assign carry_out = {carry_in,\
    \ sum[WIDTH-1:0], carry_in, sum[WIDTH-1:0]};\n    assign carry_out = {carry_in,\
    \ sum[WIDTH-1:0], carry_in, sum[WIDTH-1:0]};\n\n    ha_12_inst#(\n       .WIDTH(WIDTH)\n\
    \    ) ha_inst(\n       .inclk(clk),\n       .ina(a),\n       .inb(b),\n     \
    \  .inci(carry_in),\n       .sum(sum),\n       .carry_out(carry_out)\n    );\n\
    endmodule\n/labs/lab12/lab12/lab12/lab12/tstha_1.h\n// tstha_1.h\n// Header for\
    \ testbench for half adder\n\n// Verilog module tstha_1\n\n// Original author\
    \  - 2007-01-06\n\n// This file is part of 'Verilog code generation using SystemVerilog'.\n\
    // Copyright (c) 2007, \n// All rights reserved.\n\n// Redistribution and use\
    \ in source and binary forms, with or without\n// modification, are permitted\
    \ provided that the following conditions are met:\n//     * Redistributions of\
    \ source code must retain the above copyright\n//       notice, this list of conditions\
    \ and the following disclaimer.\n//     * Redistributions in binary form must\
    \ reproduce the above copyright\n//       notice, this list of conditions and\
    \ the following disclaimer in the\n//       documentation and/or other materials\
    \ provided with the distribution.\n//     * Neither the name of the copyright\
    \ holder nor the\n//       names of its contributors may be used to endorse or\
    \ promote products\n//       derived from this software without specific prior\
    \ written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\
    \ AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\
    \ BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS\
    \ FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL  BE LIABLE FOR\
    \ ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\
    // (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\
    // LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\
    // ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\
    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\
    // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n`timescale\
    \ 1ns / 1ps\n\nmodule tstha_1();\n  reg a,b; wire s,ci;\n  ha_1 hh(s,ci,a,b);\
    \ // Instantiate HA with rise/fall path delays\n  initial begin a=0;b=0; end\n\
    \  initial begin #5 a=1;b=0; end\n  initial begin #5 a=0;b=1; end\n  initial begin\
    \ $monitor(a,b,ci,s); $stop; end\nendmodule\n/labs/lab11/lab11/lab11/lab11/ha_12.h\n\
    // ha_12.h\n// Header for 12 bit half adder\n\n// Verilog module ha_12\n// using\
    \ systemverilog logic types\n\n// Original author  - 2007-01-06\n\n// This file\
    \ is part of 'Verilog code generation using SystemVerilog'.\n// Copyright (c)\
    \ 2007, \n// All rights reserved.\n\n// Redistribution and use in source and binary\
    \ forms, with or without\n// modification, are permitted provided that the following\
    \ conditions are met:\n//     * Redistributions of source code must retain the\
    \ above copyright\n//       notice, this list of conditions and the following\
    \ disclaimer.\n//     * Redistributions in binary form must reproduce the above\
    \ copyright\n//       notice, this list of conditions and the following disclaimer\
    \ in the\n//       documentation and/or other materials provided with the distribution.\n\
    //     * Neither the name of the copyright holder nor the\n//       names of its\
    \ contributors may be used to endorse or promote products\n//       derived from\
    \ this software without specific prior written permission.\n\n// THIS SOFTWARE\
    \ IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY\
    \ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\
    // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n//\
    \ DISCLAIMED. IN NO EVENT SHALL  BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL,\
    \ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED\
    \ TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS;\
    \ OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY,\
    \ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR\
    \ OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED\
    \ OF THE POSSIBILITY OF SUCH DAMAGE.\n\nmodule ha_12\n#(\n    parameter WIDTH=4,\n\
    \    parameter DELAY=100\n)\n(\n    input  clk,\n    input  a,\n    input  b,\n\
    \    input  carry_in,\n    output sum,\n    output carry_out\n);\n    wire clk0,\
    \ clk1;\n    assign clk0 = clk & ~clk1;\n    assign clk1 = ~clk & clk1;\n\n  \
    \  ha_12_inst#(\n       .WIDTH(WIDTH),\n       .DELAY(DELAY)\n    ) ha_inst(\n\
    \       .inclk(clk0),\n       .ina(a),\n       .inb(b),\n       .inci(carry_in),\n\
    \       .sum(sum),\n       .carry_out(carry_out)\n    );\nendmodule\n/labs/lab12/lab12/lab12/lab12/ha_12_inst.h\n\
    // ha_12_inst.h\n// Header for 12 bit half adder\n\n// Verilog module ha_12\n\
    // using systemverilog logic types\n\n// Original author  - 2007-01-06\n\n// This\
    \ file is part of 'Verilog code generation using SystemVerilog'.\n// Copyright\
    \ (c) 2007, \n// All rights reserved.\n\n// Redistribution and use in source and\
    \ binary forms, with or without\n// modification, are permitted provided that\
    \ the following conditions are met:\n//     * Redistributions"
- code: "```\nmodule ha_10 (clk_3,rst_3, a, b, c, s, ca);\n  reg s;\n  reg ca;\n \
    \ always @(posedge clk_3|negedge rst_3) begin\n    if (rst_3) begin\n      s <=\
    \ 1'b1;\n      ca <= 1'b1;\n    end\n    else begin\n      s <= a ^ b;\n     \
    \ ca <= (a & b) | (a ^ b);\n    end\n  end\nendmodule\nmodule tstha_10();\n  reg\
    \ a,b;\n  reg c;\n  wire s,ca;\n  ha_10 hh(s,ca,a,b); // Instantiate HA with rise/fall\
    \ path delays\n  initial begin a=0;b=0; end\n  always begin #5 a=1;b=0; #5 a=0;b=1;\
    \ #5 a=1;b=1; #5 a=0;b=0; end\n  initial $monitor($time, \" a = %b, b = %b,out\
    \ carry = %b, outsum = %b \",a,b,ca,s);\n  initial #30 $stop;\nendmodule\n```\n\
    ### Output\n![alt_text](test14.png \"The Verilog Module\")\n![alt_text](test15.png\
    \ \"The Schematic Module\")\n![alt_text](test16.png \"The GDS Module\")\n![alt_text](test17.png\
    \ \"The GDS Module\")\n![alt_text](test18.png \"The GDS Module\")\n![alt_text](test19.png\
    \ \"The GDS Module\")\n\n### Results:\n```\na = %b, b = %b,out carry = %b, outsum\
    \ = %b \n0 0 0 0 \n0 0 0 1 \n0 1 1 0 \n0 1 1 1 \n1 0 1 0 \n1 0 1 1 \n1 1 0 0 \n\
    1 1 0 1 \n1 1 1 0 \n1 1 1 1 \n0 0 0 0 \n0 0 0 1 \n0 1 0 0 \n0 1 0 1 \n0 1 1 1\
    \ \n0 1 1 0 \n1 0 0 0 \n1 0 0 1 \n1 0 1 1 \n1 0 1 0 \n1 1 0 1 \n1 1 0 0 \n1 1\
    \ 1 1 \n1 1 1 0 \n1 1 1 1 \n1 1 1 0 \n0 0 0 0 \n0 0 0 1 \n0 1 1 1 \n0 1 1 0 \n\
    1 0 0 1 \n1 0 0 0 \n1 0 1 0 \n1 0 1 1 \n1 1 0 1 \n1 1 0 0 \n1 1 1 1 \n1 1 1 0\
    \ \n1 1 1 1 \n1 1 1 0 \n0 0 0 0 \n0"
- code: |-
    module tstha_1();
      packed struct {
        wire a;
        wire b;
      } regdata;
      wire s,ca;
      ha_1 hh(s,ca,regdata);
    endmodule


    ## Test Module: tstha_0
    ### Base Verilog Code:
    module tstha_0();
      reg a,b; wire s,ca;
      ha_0 hh(s,ca,a,b); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
- code: |-
    module tstha_7();
      reg a,b; wire s,ca;
      packed ha_7 hh(s,ca,a,b,clk); // Instantiate HA with rise/fall path delays
      initial begin a=0;b=0; end
      always begin #5 a=1;b=0; #5 a=0;b=1; #5 a=1;b=1; #5 a=0;b=0; end
      initial $monitor($time, " a = %b, b = %b,out carry = %b, outsum = %b ",a,b,ca,s);
      initial #50 $stop;
    endmodule
    ### Result:
    $./tb_tstha_7 < a=0,b=0,clk=0 > a=0,b=0,out carry=1,outsum=0
    $./tb_tstha_7 < a=0,b=1,clk=0 > a=0,b=1,out carry=0,outsum=1
    $./tb_tstha_7 < a=1,b=0,clk=0 > a=1,b=0,out carry=0,outsum=1
    $./tb_tstha_7 < a=1,b=1,clk=0 > a=1,b=1,out carry=1,outsum=0
    $./tb_tstha_7 < a=0,b=0,clk=1 > a=0,b=0,out carry=1,outsum=0
    $./tb_tstha_7 < a=0,b=1,clk=1 > a=0,b=1,out carry=0,outsum=1
    $./tb_tstha_7 < a=1,b=0,clk=1 > a=1,b=0,out carry=0,outsum=1
    $./tb_tstha_7 < a=1,b=1,clk=1 > a=1,b=1,out carry=1,outsum=0
    ### See Also:
    <a href
- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    wire [2:0] RegSum;
    Assign Sum = Data + RegSum;
    endmodule

    ### Explanation:
    The wire-array is not compatible with the register-array from the previous example.

    This is because, the wire-array is unpacked which is a list of wires,
    so, each item in the array is a scalar.
    The register is packed, so each item in the array is an array of registers.
    So, the register-array and wire-array in the design-file are incompatible.

    In the modified-code, the wire-array is packed so it is compatible with the register-array.
    #include <veriuser.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    #define MAX_WIDTH 16
    #define MAX_DEPTH 16

    #define MAX_WIRE_ARRAY_D1 16
    #define MAX_WIRE_ARRAY_D2 16
    #define MAX_WIRE_ARRAY_D3 16
    #define MAX_WIRE_ARRAY_D4 16

    #define MAX_REGISTER_ARRAY_D1 16
    #define MAX_REGISTER_ARRAY_D2 16
    #define MAX_REGISTER_ARRAY_D3 16
    #define MAX_REGISTER_ARRAY_D4 16

    #define MAX_ASSIGN_DATA 16

    #define MAX_TYPE_WIDTH 16
    #define MAX_TYPE_DEPTH 16

    #define BRANCH_LABEL_SIZE 16

    #define MAX_DATA_BIT_NUM 256

    #define MAX_REG_NUM 256

    #define MAX_WIRE_DATA_NUM 256

    #define MAX_WIRE_ARRAY_NUM 256

    #define MAX_REGISTER_ARRAY_NUM 256

    #define MAX_ASSIGN_NUM 256

    #define MAX_COMMENT_LINE_NUM 256

    #define MAX_CASE_NUM 256

    #define MAX_SWITCH_NUM 256

    #define MAX_FOR_NUM 256

    #define MAX_IF_NUM 256

    #define MAX_ASSIGN_NUM 256

    #define MAX_DATA_BIT_NUM 256

    #define MAX_REG_NUM 256

    #define MAX_NAME_NUM 256

    #define MAX_MODULE_NUM 256

    #define MAX_PACKAGE_NUM 256

    #define MAX_INPUT_DATA_NUM 256

    #define MAX_INPUT_DATA_WIDTH 256

    #define MAX_OUTPUT_DATA_NUM 256

    #define MAX_OUTPUT_DATA_WIDTH 256

    #define MAX_VAR_NUM 256

    #define MAX_VAR_NAME_NUM 256

    #define MAX_VAR_TYPE_WIDTH 256

    #define MAX_VAR_TYPE_DEPTH 256

    #define MAX_MODULE_NUM 256

    #define MAX_CLOCK_NUM 256

    #define MAX_RESET_NUM 256

    #define MAX_INPUT_NUM 256

    #define MAX_OUTPUT_NUM 256

    #define MAX_ASSIGN_NUM 256

    #define MAX_FUNC_NAME_NUM 256

    #define MAX_FUNC_DATA_TYPE_WIDTH 256

    #define MAX_FUNC_DATA_TYPE_DEPTH 256

    #define MAX_ARRAY_SIZE 256

    #define MAX_ARRAY_BIT 256

    #define MAX_ARRAY_VAR_NAME 256

    #define MAX_ARRAY_VAR_TYPE_WIDTH 256

    #define MAX_ARRAY_VAR_TYPE_DEPTH 256

    #define MAX_ARRAY_NUM 256

    #define MAX_VAR_ARRAY_NUM 256

    #define MAX_BRANCH_LABEL 256

    #define MAX_BRANCH_DATA 256

    #define MAX_BRANCH_TYPE 256

    #define MAX_BRANCH_VAR_
- code: "- Use the module name of example2 for the unpacked dimension (module name\
    \ is also the variable name).\n- Assign the variable name of the wire array to\
    \ the corresponding signal name in the Verilog code.\n- Modify the assign statement\
    \ to enable the Verilog code to pass the verification.\n\n---\n### Problem 3:\n\
    This is another variant of the previous problem, where the first bit of the two\
    \ input variables is used as a control bit. The control bit only accepts the values\
    \ 0 and 1, and the operation performed by the module is either Add or Subtract\
    \ depending on the value of the control bit.\n\n### Base Verilog Code:\nmodule\
    \ example4(Data1, Data2, Clock, Reset, ControlBit, AddBit, Result1, Result2);\n\
    input Clock, Reset;\ninput [3:0] Data1, Data2;\ninput ControlBit;\noutput [3:0]\
    \ Result1, Result2;\nreg4 R1 (Result1, Clock, Reset, AddBit);\nreg4 R2 (Result2,\
    \ Clock, Reset, AddBit);\nwire AddBit;\nassign AddBit = (ControlBit == 0);\nassign\
    \ Result1 = (AddBit? (Data1 + Data2) : (Data1 - Data2));\nassign Result2 = (AddBit?\
    \ (Data1 + Data2) : (Data1 - Data2));\nendmodule\n### Variation Instruction:\n\
    - Use the operator module name to assign the control bit name to the corresponding\
    \ variable in the Verilog code.\n- Assign the variable name of the control bit\
    \ to the corresponding signal name in the Verilog code.\n- Modify the assign statement\
    \ to enable the Verilog code to pass the verification.\n\n---\n### Problem 4:\n\
    This problem is similar to the previous problem, but this time the operands are\
    \ both multiplexed from another module.\n\n### Base Verilog Code:\nmodule example5(Operand1,\
    \ Operand2, Clock, Reset, ControlBit, Result);\ninput Clock, Reset;\ninput [3:0]\
    \ Operand1, Operand2, ControlBit;\noutput [3:0] Result;\nreg4 R1 (Result, Clock,\
    \ Reset, ControlBit);\nwire ControlBit;\nassign ControlBit = (ControlBit == 0);\n\
    assign Result = (ControlBit? (Operand1 * Operand2) : (Operand1 + Operand2));\n\
    endmodule\n### Variation Instruction:\n- Use the module name of example3 for the\
    \ unpacked dimension (module name is also the variable name) of the input operands.\n\
    - Assign the variable name of the operand to the corresponding signal name in\
    \ the Verilog code.\n- Modify the signal assignment statements to enable the Verilog\
    \ code to pass the verification.---\ntitle: \"EECS 340: Computer System Organization\"\
    \ndate: 2020-06-09\noutput: html_document\nlayout: post\n---\n\n# EECS 340: Computer\
    \ System Organization\n## Instructor: \n## Course Information: \n- Professor:\
    \ \n- Time: MW 12:00pm - 2:00pm\n- Location: Gibson 3030\n- Office Hours: T 2:00pm\
    \ - 3:00pm, W 1:00pm - 2:00pm\n\n## Announcements\n- Due next Tuesday (6/10) to\
    \ submit the [Lab 8](https://github.com/michael-zhong-1/EECS-340-Computer-System-Organization/blob/master/Lab-8-Simulator-Lab/Lab-8-Simulator-Lab.pdf)\
    \ and [Lab 9](https://github.com/michael-zhong-1/EECS-340-Computer-System-Organization/blob/master/Lab-9-Simulator-Lab/Lab-9-Simulator-Lab.pdf)\
    \ simulator.\n- No new instructor is scheduled for the next time.\n- No new lab\
    \ is scheduled for the next time.\n- Please prepare in advance for the **mid-term\
    \ test** from this week (6/14).\n- Please prepare in advance for the **final exam**\
    \ from this week (6/14).\n\n## Topics\n- Basic instruction set architecture (ISA)\n\
    - Registers\n- MIPS ISA\n- MIPS Instruction Format\n- MIPS Pipeline\n- MIPS CPU\n\
    - Computer architecture\n- CPU performance\n- Multi-processor system\n- Data\n\
    - Virtual memory\n- Cache\n- Memory hierarchy\n- Data path\n- Microprocessor\n\
    - ALU\n- Floating point\n- Arithmetic and Logic Unit (ALU)\n- Register file\n\
    - Control unit\n- Register file\n- ALU\n- Pipeline\n- Fetch operation\n- Execute\
    \ operation\n- Memory access operation\n- Write-back operation\n- Memory\n- Memory\
    \ address\n- Memory access\n- Cache\n- Cache operation\n- Virtual memory\n- Page\
    \ table\n- Page size\n- Virtual memory\n- Cache vs. virtual memory\n- Cache replacement\n\
    - CPU\n- Clock cycle\n- CPI\n- CPI\n- TLB\n- TLB hit or miss\n- TLB translation\n\
    - TLB replacement\n\n## Text\n- Computer Organization and Design (3rd Edition),,,\
    \ and \n- Computer Architecture: A Quantitative Approach (3rd Edition),,,,, and\
    \ \n- Computer Organization in Action (3rd Edition), \n- The Hardware/Software\
    \ Interface, by \n\n## Lab\n- Lab 1 to Lab 7\n\n## Homework\n- Homework 1 to Homework\
    \ 3\n\n## References\n- https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\n\
    - https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#synchronizationVsLocking\n\
    - https://www.javaworld.com/article/2076313/core-java/locks-vs-synchronizers.html\n\
    - https://www.oreilly.com/library/view/java-performance/0596003994/ch07.html\n\
    \n## Schedule\n|Date|Activity|Week|\n|:---:|:---|:---:|\n|5/30|Mid-term test|1|\n\
    |6/1|Lab 0: Basic Java syntax|2|\n|6/6 - 6/10|Lab 1 to Lab 7|2|\n|6/14|Mid-term\
    \ test|3|\n|6/21 - 6/27|Lab 8 to Lab 10|3|\n|6/28|Final exam|3|"
- code: "module example1(Data, Clock, Reset, RegSum, Sum);\ninput Clock, Reset;\n\
    input [3:0] Data;\noutput [3:0] Sum, RegSum;\nreg [3:0] Sum, RegSum;\nreg4 R1\
    \ (Sum, Clock, Reset, RegSum);\nassign RegSum = Sum;\nassign Sum = Data + RegSum;\n\
    endmodule\n```\n\n## How to Use\n\nTo use the code generator provided, add the\
    \ code generator from the command line via a path to the desired code generator.\n\
    \n```\n./verilator_code_generator.py --code_generator_path=./path/to/verilator_code_generator.py\n\
    ```\n\n### Command Line Options\n- *--code_generator_path*: (Required) Specifies\
    \ the path to the code generator.\n- *--generate_example_code*: (Optional) This\
    \ flag generates the code generator example files.\n\n### Example Usage\n\n```\n\
    ./verilator_code_generator.py --code_generator_path=./path/to/verilator_code_generator.py\
    \ --generate_example_code=True\n```\n\n## Output\n\n### Example Code\n\nThe code\
    \ generator will generate a directory called \"output\" containing the following\
    \ code generator files.\n\n- *verilator_code_generator.py*: This is the code generator\
    \ file.\n- *example.v*: This is a Verilog example code file that uses the code\
    \ generator.\n- *example.sv*: This is a SystemVerilog example code file that uses\
    \ the code generator.\n\n## Known Issues\n\n - The code generator does not support\
    \ the use of clock or reset registers in the code generator. If you have code\
    \ that relies on these, you must modify the code before running the code generator.\n\
    \n - The code generator does not support the use of other Verilog/SystemVerilog\
    \ keywords. For example, if your code uses the keyword \"for\", you must modify\
    \ the code before running the code generator.\n\n - The code generator does not\
    \ support multiple output or input wires in one line. This means that the output\
    \ wires must all be on the same line, and input wires must all be on the same\
    \ line.\n\n - The code generator does not support the use of multiple signals\
    \ in a signal declaration line. The signals must all be on the same line.\n\n\
    \ - The code generator does not support the use of multiple output or input signals\
    \ in one line. This means that the output signals must all be on the same line,\
    \ and input signals must all be on the same line.\n\n - The code generator does\
    \ not support multiple wires in a wire declaration line. The wires must all be\
    \ on the same line.\n\n - The code generator does not support multiple registers\
    \ in a register declaration line. The registers must all be on the same line.\n\
    \n - The code generator does not support multiple instances of a register in the\
    \ same line. The registers must all be on the same line.\n\n - The code generator\
    \ does not support multiple instances of a module in the same line. The modules\
    \ must all be on the same line.\n\n - The code generator does not support multiple\
    \ instances of a module or module instantiation in the same line. The modules\
    \ or instantiations must all be on the same line.\n\n - The code generator does\
    \ not support the use of the wire keyword within an instantiation of another module\
    \ or module instantiation. This means the wire keyword cannot be used inside module\
    \ instantiations.\n\n/verilator_code_generator.py\n# -*- coding: utf-8 -*-\n\"\
    \"\"\n@author: \n\"\"\"\n\nimport argparse\nimport os\nimport shutil\n\n\ndef\
    \ main():\n    parser = argparse.ArgumentParser(\n        description=\"Verilator\
    \ Code Generator\"\n    )\n    parser.add_argument(\"--code_generator_path\",\
    \ help=\"Code Generator Path\")\n    parser.add_argument(\n        \"--generate_example_code\"\
    ,\n        default=False,\n        help=\"Generate Example Code\",\n        action='store_true'\n\
    \    )\n    args = parser.parse_args()\n\n    code_generator_file_path = args.code_generator_path\n\
    \    output_directory = \"output\"\n\n    if args.generate_example_code:\n   \
    \     generate_example_code(code_generator_file_path, output_directory)\n    if\
    \ os.path.isfile(code_generator_file_path):\n        print(\"Generating code...\"\
    )\n        generate_code(code_generator_file_path, output_directory)\n    else:\n\
    \        print(\"Code generator file path invalid.\")\n\n\ndef generate_example_code(code_generator_file_path,\
    \ output_directory):\n    output_directory += os.sep\n    example_file_path =\
    \ output_directory + \"example.v\"\n    example_sv_file_path = output_directory\
    \ + \"example.sv\"\n    if os.path.exists(output_directory):\n        print(\"\
    Directory already exists. Skipping.\")\n    else:\n        os.mkdir(output_directory)\n\
    \    with open(code_generator_file_path, \"r\") as f:\n        code_generator_lines\
    \ = f.readlines()\n    with open(example_file_path, \"w+\") as f:\n        write_file(f,\
    \ example_file_path, code_generator_lines)\n    with open(example_sv_file_path,\
    \ \"w+\") as f:\n        write_file(f, example_sv_file_path, code_generator_lines)\n\
    \    print(\"Example code generated in {}\".format(output_directory))\n\n\ndef\
    \ generate_code(code_generator_file_path, output_directory):\n    output_directory\
    \ += os.sep\n    register_file_path = output_directory + \"register.v\"\n    register_sv_file_path\
    \ = output_directory + \"register.sv\"\n    counter_file_path = output_directory\
    \ + \"counter.v\"\n    counter_sv_file_path = output_directory + \"counter.sv\"\
    \n    counter8_file_path = output_directory + \"counter8.v\"\n    counter8_sv_file_path\
    \ = output_directory + \"counter8.sv\"\n    shift_file_path = output_directory\
    \ + \"shift.v\"\n    shift_sv_file_path = output_directory + \"shift.sv\"\n  \
    \  if os.path.exists(output_directory):\n        print(\"Directory already exists.\
    \ Skipping.\")\n    else:\n        os.mkdir(output_directory)\n    with open(code_generator_file_path,\
    \ \"r\") as f:\n        code_generator_lines = f.readlines()\n    #  Generate\
    \ Register File\n    with open(register_file_path, \"w+\") as f:\n        write_file(f,\
    \ register_file_path, code_generator_lines)\n    #  Generate Register SV File\n\
    \    with open(register_sv_file_path, \"w+\") as f:\n        write_file(f, register_sv_file_path,\
    \ code_generator_lines)\n    #  Generate Counter File\n    with open(counter_file_path,\
    \ \"w+\") as f:\n        write_file(f, counter_file_path, code_generator_lines)\n\
    \    #  Generate Counter SV File\n    with open(counter_sv_file_path, \"w+\")\
    \ as f:\n        write_file(f, counter_sv_file_path, code_generator_lines)\n \
    \   #  Generate Counter8 File\n    with open(counter8_file_path, \"w+\") as f:\n\
    \        write_file(f, counter8_file_path, code_generator_lines)\n    #  Generate\
    \ Counter8 SV File\n    with open(counter8_sv_file_path, \"w+\") as f:\n     \
    \   write_file(f, counter8_sv_file_path, code_generator_lines)\n    #  Generate\
    \ Shift File"
- code: "module example3(Data, Clock, Reset, RegSum, Sum);\ninput Clock, Reset;\n\
    input [3:0] Data;\noutput [3:0] Sum, RegSum;\nwire [3:0] Sum, RegSum;\nwire [3:0]\
    \ Data3;\nassign Sum = Data3 + RegSum;\nendmodule\n### Results:\n<img src=\"https://github.com/chuanmingtan/Verilog/blob/master/Lab3/lab3_6.PNG\"\
    />\n<img src=\"https://github.com/chuanmingtan/Verilog/blob/master/Lab3/lab3_7.PNG\"\
    />\n### Question 2: Why does the signal name of \u201CSum\u201D change when you\
    \ change the wire type?\n### Answer:\nBecause the input wire is of type array\
    \ with unpacked dimension. When wire type changes, the signal name changes as\
    \ well since wire array signal can be decomposed to several wires.\n\n### Question\
    \ 3: What kind of constraint are all the wire and reg types in the verilog code?\n\
    ### Answer:\nwire and reg types are regular wires and regs, respectively.\n\n\
    ### Question 4: How can you differentiate between a signal having drive strength\
    \ 0 and a signal having an explicit drive strength?\n### Answer:\nA signal has\
    \ drive strength 0 can be implemented with a 2-input nand gate. Otherwise, the\
    \ signal can be implemented with an n-input nand gate where n is the number of\
    \ drive strengths that are other than 0.\n\n### Question 5: What happens if you\
    \ try to connect a signal using the same signal name?\n### Answer:\nIf the signal\
    \ name collides with another signal, the simulation will output an error.\n\n\
    ### Question 6: What can you do to avoid the error when you use the same signal\
    \ name?\n### Answer:\nUse the keyword \u201Cwire\u201D to prevent the signal name\
    \ collision that occurs when wire type is used.\n\n### Question 7: When is it\
    \ possible that a signal has 2 different drive strengths? Explain.\n### Answer:\n\
    A signal has two different drive strengths when the signal has 2 different wire\
    \ types. In the verilog code, the signal \u201CSum\u201D has both a reg type and\
    \ an wire type. Hence the signal has two different drive strengths.\n\n### Question\
    \ 8: What is the difference between the implicit and the explicit drive strength?\
    \ Explain.\n### Answer:\nWhen the signal is connected to an output, the simulation\
    \ uses the explicit drive strength in the verilog code. Otherwise, the implicit\
    \ drive strength is used.\n\n### Question 9: Is it always possible to have the\
    \ same signal name for different drive strengths?\n### Answer:\nNo.\n\n### Question\
    \ 10: How do you check that the output you are trying to connect to is of the\
    \ correct drive strength?\n### Answer:\nConnect the output wire to the input wire\
    \ and check if it goes through the simulation.\n\n### Question 11: What does the\
    \ wire type do?\n### Answer:\nThe wire type is an alias for a signal.\n\n### Question\
    \ 12: What is the difference between a wire and a reg?\n### Answer:\nA wire can\
    \ be used and assigned to like a regular wire. A reg can only be assigned once\
    \ during the simulation.\n\n### Question 13: Why is it a good idea to use the\
    \ wire type?\n### Answer:\nUsing the wire type preserves the signal name which\
    \ improves readability.\n\n### Question 14: How many registers do you need to\
    \ simulate the following code?\n### Answer:\n3 registers.\n\n### Question 15:\
    \ What is the purpose of the input wire type?\n### Answer:\nThe input wire type\
    \ is an alias for an input.\n\n### Question 16: When do you use the input wire\
    \ type? What is the difference from using standard inputs?\n### Answer:\nWhen\
    \ you are connecting the input as the signal, use input wire type. The difference\
    \ between the standard input and the input wire type is that the standard input\
    \ can be connected to a signal (the standard input can be a wire).\n\n### Question\
    \ 17: Describe the purpose of the output wire type?\n### Answer:\nThe output wire\
    \ type is an alias for an output.\n\n### Question 18: Explain why you should not\
    \ use the output wire type.\n### Answer:\nA signal cannot be assigned to an output\
    \ wire type because the output wire type is an alias for an output.\n\n### Question\
    \ 19: How can you convert a wire to a reg?\n### Answer:\nAssign the wire to a\
    \ reg.\n\n### Question 20: How can you convert a reg to a wire?\n### Answer:\n\
    Assign the reg to a wire.\n\n### Question 21: What is the purpose of the wire\
    \ array type?\n### Answer:\nThe wire array type is an alias for a wire array.\n\
    \n### Question 22: Why is it not allowed to use wire array types for storage elements?\n\
    ### Answer:\nWire array types can only be used for drivers and the assignment\
    \ of the reg.\n\n### Question 23: Explain why the following code is not well-formed:\n\
    module wrong_clock(clk, rst);\ninput clk, rst;\nendmodule\n### Answer:\nA driver\
    \ is used on a clock signal, which is not well-formed.\n\n### Question 24: How\
    \ can you fix the above error?\n### Answer:\nAn array of the clock should be used.\n\
    \n### Question 25: What is the purpose of the assign statement?\n### Answer:\n\
    The assign statement assigns one expression to another expression.\n\n### Question\
    \ 26: What is the difference between a parameter and an input? Explain.\n### Answer:\n\
    A parameter is used to pass the input values to a module. An input is used to\
    \ connect to the module.\n\n### Question 27: How can you declare a parameter?\
    \ What are the different types of parameters?\n### Answer:\nThe parameter can\
    \ be declared by using \u201Cparameter\u201D keyword. Different types of parameters\
    \ are \u201Clocalparam\u201D for constant parameters, \u201Cparameter\u201D for\
    \ module parameters, \u201Clocalparam [type]\u201D for type-casted constant parameters,\
    \ and \u201Clocalparam [type] [range]\u201D for range-casted constant parameters.\n\
    \n### Question 28: How can you declare a local parameter? What are the different\
    \ types of parameters?\n### Answer:\nThe local parameter can be declared by using\
    \ \u201Clocalparam\u201D keyword. Different types of parameters are \u201Clocalparam\u201D\
    \ for constant parameters, \u201Clocalparam [type]\u201D for type-casted constant\
    \ parameters, and \u201Clocalparam [type] [range]\u201D for range-casted constant\
    \ parameters.\n\n### Question 29: How is the parameter name and the local parameter\
    \ name different?\n### Answer:\nThe parameter name is the name of the parameter\
    \ and the local parameter name is the name of the module.\n\n### Question 30:\
    \ What is the difference between a parameter and a local parameter? Explain.\n\
    ### Answer:\nA parameter is used to pass the input values to a module. A local\
    \ parameter is used to pass the input values to a module and is local to the module.\n\
    \n### Question 31: What is a differentiator between a parameter and a local parameter?\n\
    ### Answer:\nA parameter is a port. A local parameter is not a port.\n\n### Question\
    \ 32: How can you define a range-casted parameter?\n### Answer:\nUse square brackets\
    \ around the range for the parameter.\n\n### Question 33: How can you define a\
    \ type-casted parameter?\n### Answer:\nUse square brackets around the type for\
    \ the parameter.\n\n### Question 34: What is the difference between a parameter\
    \ and an input?\n### Answer:\nA parameter is used to pass the input values to\
    \ a module. An input is used to connect to the module.\n\n### Question 35: How\
    \ can you define a range-casted parameter with a constant value?\n### Answer:\n\
    Use the range \u201Cn : 0\u201D where n is the number of bits of the range-casted\
    \ parameter.\n\n### Question 36: How can you define a type-casted parameter with\
    \ a constant value?\n### Answer:\nUse a range of \u201C:\u201D for the type-casted\
    \ parameter.\n\n### Question 37: How can you define a range-casted parameter with\
    \ a variable that has a value? Explain.\n### Answer:\nUse the range \u201Cn :\
    \ $c$\u201D where n is the number of bits of the range-casted parameter.\n\n###\
    \ Question 38: How can you define a variable that is of a range-casted type? Explain.\n\
    ### Answer:\nUse the range \u201C:\u201D for the type-casted parameter.\n\n###\
    \ Question 39: How can you define a variable that is of a type-casted type? Explain.\n\
    ### Answer:\nUse the range \u201Cn : $c$\u201D where n is the number of bits of\
    \ the range-casted parameter.\n\n### Question 40: Explain why the following code\
    \ is not well-formed:\nparameter [3:0] MAX = 8;\nmodule wrong_range(a, b);\ninput\
    \ a, b;"
- code: "module example4(Data, Clock, Reset, RegSum, Sum);\ninput Clock, Reset;\n\
    input [3:0] Data;\noutput [3:0] Sum, RegSum;\nwire [3:0] Sum, RegSum;\nreg4 R1\
    \ (Sum, Clock, Reset, RegSum);\nassign Sum = Data + RegSum;\nendmodule\n### Expected\
    \ Test Failures:\n1. test1 - Unresolved Reference - wire-array compatibility failure\n\
    2. test2 - Unresolved Reference - wire-array compatibility failure\n3. test3 -\
    \ Unresolved Reference - wire-array compatibility failure\n4. test4 - Unresolved\
    \ Reference - wire-array compatibility failure\n```\n\n### Problem 6.\n```\n1.\
    \ (a)\nmodule example(a, b, c, d, e, f, g, h, i, j);\ninput a, b, c, d, e, f,\
    \ g, h, i, j;\noutput a0, b0, c0, d0, e0, f0, g0, h0, i0, j0;\nwire a0, b0, c0,\
    \ d0, e0, f0, g0, h0, i0, j0;\nreg4 R1 (a0, b, c0, d0, e0, f0, g, h, i0, j0);\n\
    assign a0 = a;\nendmodule\n2. (b)\nmodule example(a, b, c, d, e, f, g, h, i, j);\n\
    input a, b, c, d, e, f, g, h, i, j;\noutput a0, b0, c0, d0, e0, f0, g0, h0, i0,\
    \ j0;\nwire a0, b0, c0, d0, e0, f0, g0, h0, i0, j0;\nreg4 R1 (a0, b, a, d, e0,\
    \ f0, g, h, i0, j0);\nassign a0 = a;\nendmodule\n3. (c)\nmodule example(a, b,\
    \ c, d, e, f, g, h, i, j);\ninput a, b, c, d, e, f, g, h, i, j;\noutput a0, b0,\
    \ c0, d0, e0, f0, g0, h0, i0, j0;\nwire a0, b0, c0, d0, e0, f0, g0, h0, i0, j0;\n\
    reg4 R1 (a0, b, a, d, e0, f0, g, h, i0, j0);\nassign a0 = a;\nendmodule\n4. (d)\n\
    module example(a, b, c, d, e, f, g, h, i, j);\ninput a, b, c, d, e, f, g, h, i,\
    \ j;\noutput a0, b0, c0, d0, e0, f0, g0, h0, i0, j0;\nwire a0, b0, c0, d0, e0,\
    \ f0, g0, h0, i0, j0;\nreg4 R1 (a0, b, a, d, e0, f0, g, h, i0, j0);\nassign a0\
    \ = a;\nendmodule\n```\n\n### Problem 7.\n```\n1. (a)\nmodule test1(a);\ninput\
    \ a;\nendmodule\n2. (b)\nmodule test1(a);\ninput a;\nendmodule\n3. (c)\nmodule\
    \ test1(a);\ninput a;\nendmodule\n4. (d)\nmodule test1(a);\ninput a;\nendmodule\n\
    5. (e)\nmodule test1(a);\ninput a;\nendmodule\n6. (f)\nmodule test1(a);\ninput\
    \ a;\nendmodule\n7. (g)\nmodule test1(a);\ninput a;\nendmodule\n8. (h)\nmodule\
    \ test1(a);\ninput a;\nendmodule\n9. (i)\nmodule test1(a);\ninput a;\nendmodule\n\
    ```\n\n### Problem 8.\n```\n1. (a)\nmodule test2(a);\ninput a;\nendmodule\n2.\
    \ (b)\nmodule test2(a, b);\ninput a, b;\nendmodule\n3. (c)\nmodule test2(a, b);\n\
    input a, b;\nendmodule\n4. (d)\nmodule test2(a, b, c);\ninput a, b, c;\nendmodule\n\
    5. (e)\nmodule test2(a, b, c);\ninput a, b, c;\nendmodule\n6. (f)\nmodule test2(a,\
    \ b, c, d);\ninput a, b, c, d;\nendmodule\n7. (g)\nmodule test2(a, b, c, d);\n\
    input a, b, c, d;\nendmodule\n8. (h)\nmodule test2(a, b, c, d, e);\ninput a, b,\
    \ c, d, e;\nendmodule\n9. (i)\nmodule test2(a, b, c, d, e);\ninput a, b, c, d,\
    \ e;\nendmodule\n```\n\n### Problem 9.\n```\n1. (a)\nmodule test3(a, b, c);\n\
    input a, b, c;\nendmodule\n2. (b)\nmodule test3(a, b, c);\ninput a, b, c;\nendmodule\n\
    3. (c)\nmodule test3(a, b, c);\ninput a, b, c;\nendmodule\n4. (d)\nmodule test3(a,\
    \ b, c);\ninput a, b, c;\nendmodule\n5. (e)\nmodule test3(a, b, c);\ninput a,\
    \ b, c;\nendmodule\n6. (f)\nmodule test3(a, b, c);\ninput a, b, c;\nendmodule\n\
    7. (g)\nmodule test3(a, b, c);\ninput a, b, c;\nendmodule\n8. (h)\nmodule test3(a,\
    \ b, c, d);\ninput a, b, c, d;\nendmodule\n9. (i)\nmodule test3(a, b, c, d);\n\
    input a, b, c, d;\nendmodule\n```\n\n### Problem 10.\n```\n1. (a)\nmodule test4(a,\
    \ b, c, d);\ninput a, b, c, d;\nendmodule\n2. (b)\nmodule test4(a, b, c, d);\n\
    input a, b, c, d;\nendmodule\n3. (c)\nmodule test4(a, b, c, d);\ninput a, b, c,\
    \ d;\nendmodule\n4. (d)\nmodule test4(a, b, c, d);\ninput a, b, c, d;\nendmodule\n\
    5. (e)\nmodule test4(a, b, c, d);\ninput a, b, c, d;\nendmodule\n6. (f)\nmodule\
    \ test4(a, b, c, d);\ninput a, b, c, d;\nendmodule\n7. (g)\nmodule test4(a, b,\
    \ c, d);\ninput a, b, c, d;\nendmodule\n8. (h)\nmodule test4(a, b, c, d);\ninput\
    \ a, b, c, d;\nendmodule\n9. (i)\nmodule test4(a, b, c, d);\ninput a, b, c, d;\n\
    endmodule\n```\n#include \"testbench.h\"\n\n#define TESTBENCH_SIZE 1\n\n// Define\
    \ the testbench, which is a function pointer to testbench_func\n// The signature\
    \ of testbench_func is void (*testbench_func)(int);\nstatic void (*testbench)(int);\n\
    \n// Define the testbench array\nvoid (*testbench_array[TESTBENCH_SIZE])(int);\n\
    \n// Define a flag to indicate testbench status\nbool testbench_status;\n\n//\
    \ Define the testbench index value\nint testbench_index;\n\n// Store the input\
    \ value of testbench\nint testbench_value;\n\n// Print the testbench result\n\
    void testbench_print(int testbench_value) {\n\tcout << \"Testbench \" << testbench_index\
    \ << \" value: \" << testbench_value << endl;\n\ttestbench_status = true;\n}\n\
    \n// Define the testbench input\nvoid testbench_input(int testbench_value) {"
- code: |-
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [4:0] Data;
    output [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Expected Output:
    ![example3_wire_reg_output.png](example3_wire_reg_output.png)

    [top](#)

    ## test_examples_4bit_register_with_bit

    Test the output of a 4-bit register 10 times. Make sure the output of the register is correct.

    [top](#)

    ## test_examples_4bit_register_with_reg

    Test the output of a 4-bit register 10 times. Make sure the output of the register is correct.

    [top](#)

    ## test_examples_2bit_register_with_wire

    ### Purpose:
    Verify that a 2-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 2-bit wire.

    [top](#)

    ## test_examples_2bit_register_with_reg

    ### Purpose:
    Verify that a 2-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 2-bit wire.

    [top](#)

    ## test_examples_2bit_register_with_wire_array

    ### Purpose:
    Verify that a 2-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 2-bit wire array.

    [top](#)

    ## test_examples_2bit_register_with_reg4

    ### Purpose:
    Verify that a 2-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 2-bit reg4.

    [top](#)

    ## test_examples_4bit_register_with_wire

    ### Purpose:
    Verify that a 4-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 4-bit wire.

    [top](#)

    ## test_examples_4bit_register_with_reg

    ### Purpose:
    Verify that a 4-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 4-bit wire.

    [top](#)

    ## test_examples_4bit_register_with_wire_array

    ### Purpose:
    Verify that a 4-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 4-bit wire array.

    [top](#)

    ## test_examples_4bit_register_with_reg4

    ### Purpose:
    Verify that a 4-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 4-bit reg4.

    [top](#)

    ## test_examples_8bit_register_with_wire

    ### Purpose:
    Verify that a 8-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 8-bit wire.

    [top](#)

    ## test_examples_8bit_register_with_reg

    ### Purpose:
    Verify that a 8-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 8-bit wire.

    [top](#)

    ## test_examples_8bit_register_with_wire_array

    ### Purpose:
    Verify that a 8-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 8-bit wire array.

    [top](#)

    ## test_examples_8bit_register_with_reg4

    ### Purpose:
    Verify that a 8-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 8-bit reg4.

    [top](#)

    ## test_examples_16bit_register_with_wire

    ### Purpose:
    Verify that a 16-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 16-bit wire.

    [top](#)

    ## test_examples_16bit_register_with_reg

    ### Purpose:
    Verify that a 16-bit register can be stored inside of a 4-bit register.
    ### Variation Instruction:
    Change the wire declaration from wire [3:0] Sum, RegSum to a 16-bit wire.

    [top](#)

    ## test_examples_16bit_register_with_wire_array
- code: |-
    module example6(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Variation Expected Output:

    module example6(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule
    ### Variation Tested Output:

    module example6(Data, Clock, Reset, RegSum, Sum);
    input Clock
- code: |-
    module example4(Input, Clock, Reset, Sum);
    input Clock, Reset;
    input [2:0] Input;
    output wire [6:0] Sum;
    wire [6:0] Sum;
    reg4 R1 (Sum, Clock, Reset, Input);
    endmodule

    ## Example 5
    ### Base Ver
- code: |-
    module example4(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/22/2019: Verilog HDL Code
    module example5(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] R1, R2;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign R2 = Data + RegSum;
    assign Sum = R1 + R2;
    endmodule

    ### 09/25/2019: Verilog HDL Code
    module example1(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [2:0] RegSum;
    reg4 R1 (Data, Clock, Reset, RegSum);
    endmodule

    ### 09/25/2019: Verilog HDL Code
    module example2(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [2:0] RegSum, Sum;
    reg4 R1 (Data, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example3(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example4(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example5(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] R1, R2;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign R2 = Data + RegSum;
    assign Sum = R1 + R2;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example6(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output RegSum;
    reg4 R1 (Data, Clock, Reset, RegSum);
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example7(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    reg4 R1 (Data, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example8(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] R1, R2;
    reg4 R1 (Data, Clock, Reset, RegSum);
    assign R2 = Data + RegSum;
    assign Sum = R1 + R2;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example9(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example10(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    wire [3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example11(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [3:0] Sum, RegSum;
    reg4 R1 (Data, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example12(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign Sum = Data + RegSum;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example13(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] R1, R2;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    wire [1:0, 3:0] Sum, RegSum;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign R2 = Data + RegSum;
    assign Sum = R1 + R2;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example14(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0] R1, R2;
    reg4 R1 (Sum, Clock, Reset, RegSum);
    assign R2 = Data + RegSum;
    assign Sum = R1 + R2;
    endmodule

    ### 09/28/2019: Verilog HDL Code
    module example15(Data, Clock, Reset, RegSum, Sum);
    input Clock, Reset;
    input [3:0] Data;
    output [1:0, 3:0] Sum, RegSum;
    wire [1:0, 3:0
- code: |-
    module example12(in, clk, rst, out);
    input clk, rst;
    input [2:0] in;
    output [3:0] out;
    wire [3:0] outd[3:0];
    assign outd = in + 1;
    case (in)
    2'b00: outd = 5'd4;
    2'b01: outd = 5'd0;
    2'b10: outd = 5'd0;
    default: out
- code: |-
    module SchedDelayB;
    class SchedDelayC;
    reg a, b;
    endclass

    module SchedDelayA;
    SchedDelayC d1, d2;
    initial
    begin
    end
    always @(b) d1.a = b;
    always @(d1.a) d2.b = d1.a;

    always @(d1.a) d2.a = d1.a;
    always @(d2.a) d1.b = d2.a;

    always @(d2.a) d2.b = d2.a;
    always @(b) d1.b = b;
    endmodule
    ### Result:

    module SchedDelayC;
    reg a, b;
    endmodule

    module SchedDelayA;
    SchedDelayC d1, d2;
    initial
    begin
    end
    always @(b) d1.a = b;
    always @(d1.a) d2.b = d1.a;

    always @(d1.a) d2.a = d1.a;
    always @(d2.a) d1.b = d2.a;

    always @(d2.a) d2.b = d2.a;
    always @(b) d1.b = b;
    endmodule
    ### Result:

    # Verilog Code:
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Vari
- code: |-
    #### C++ Code:
    class SchedDelayA
    {
    public:
    bool a, b;
    SchedDelayA();
    virtual void update();
    };
    SchedDelayA::SchedDelayA()
    {
    }

    void SchedDelayA::update()
    {
    if (b) {
    }

    b? a : 0;
    }
    #### Verilog Code:
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule

    ### References:

    Module-level parameters and interfaces
- code: "var handle<string,int> &my_class = this_thread::get_id();\nint myvalue =\
    \ 0;\nint myvalue2 = 0;\nint myvalue3 = 0;\nif (!my_class.is_null()) {\nmyvalue\
    \ = this->get_data(\"test_data\");\nmyvalue2 = this->get_data(\"test_data2\");\n\
    myvalue3 = this->get_data(\"test_data3\");\n}\n\nNote: All class-based associative\
    \ accesses are done in the same thread that the simulation is running. Therefore,\
    \ it is not possible to store any data in class-based associative accesses.\n\n\
    ## 7.4.2.8.4. Array of Associative Access Methods\xB6\n\nThis example shows how\
    \ to use different methods of associative access methods within an array of associative\
    \ accesses.\n\n## 7.4.2.8.5. Non-Array of Associative Access Methods\xB6\n\nIn\
    \ the following example, we create an associative access method and use it to\
    \ change the value of the associative access.\n\n## 7.4.2.8.6. Array of Associative\
    \ Access Methods with Class-Based Associative Access\xB6\n\nThis example shows\
    \ how to create class-based associative accesses within an array of associative\
    \ accesses.\n\n## 7.4.2.8.7. Array of Associative Access Methods with Class-Based\
    \ Associative Access and Thread-Based Associative Access\xB6\n\nIn this example,\
    \ we create class-based associative accesses within an array of associative accesses.\
    \ We change the value of the associative access inside a class method.\n\n## 7.4.2.8.8.\
    \ Associative Access Methods with Class-Based Associative Access and Thread-Based\
    \ Associative Access\xB6\n\nIn this example, we create an array of class-based\
    \ associative accesses and change the value of the associative access inside a\
    \ class method.\n\nIn the following example, we create an array of associative\
    \ access methods and use them to change the values of the associative access methods.\n\
    \nIn the following example, we create an associative access method and use it\
    \ to change the value of the associative access method.\n\n## 7.4.2.8.9. Associative\
    \ Access Method with Class-Based Associative Access\xB6\n\nThis example shows\
    \ how to use an associative access method with class-based associative access.\n\
    \n## 7.4.2.8.10. Array of Associative Access Methods with Thread-Based Associative\
    \ Access\xB6\n\nIn this example, we create an array of thread-based associative\
    \ accesses and change the value of the associative access method inside a thread\
    \ method.\n\nIn the following example, we create an associative access method\
    \ with thread-based associative access.\n\nIn the following example, we create\
    \ an associative access method and use it to change the value of the associative\
    \ access method within a thread."
- code: |-
    ```
    #include <iostream>
    #include <string>
    #include <map>

    class SomeClass
    {
    public:
        static int counter;
        std::string name;
        SomeClass(std::string inName);
        ~SomeClass()
        {
            counter--;
        }
    };

    class Sched
    {
    public:
        SomeClass *someClass;
        bool someBool = false;
        bool b;

        Sched(SomeClass *inClass);
        ~Sched()
        {
            delete someClass;
        }
    };

    static std::map<int, Sched> sched;

    Sched::Sched(SomeClass *inClass)
    {
        someClass = inClass;
        b = false
- code: |-
    class schedDelayA_t #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends $clog2(MAX_INPUT); endclass reg [MAX_INPUT-1:0]a; wire [MAX_OUTPUT-1:0]a_; reg [MAX_INPUT-1:0]b; wire [MAX_OUTPUT-1:0]b_; initial begin for (genvar i=0; i<MAX_INPUT; i=$clog2(MAX_INPUT)-1; i>=0)
    begin
    end
    for (genvar i=0; i<MAX_INPUT; i=$clog2(MAX_INPUT)-1; i>=0) begin a[i] = i==1'b1? 1'bx : 1'b0; b[i] = i==1'b1? 1'b1 : 1'bx; end for (genvar i=0; i<MAX_OUTPUT; i=$clog2(MAX_OUTPUT)-1; i>=0)
    begin
    end
    for (genvar i=0; i<MAX_OUTPUT; i=$clog2(MAX_OUTPUT)-1; i>=0) begin assign a_ = a[i]; assign b_ = b[i]; end for (genvar i=0; i<MAX_OUTPUT; i=$clog2(MAX_OUTPUT)-1; i>=0)
    begin
    end
    endmodule

    class schedDelayA_t_inst0 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_test #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst1 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst2 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst3 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst4 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst5 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst6 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst7 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst8 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst9 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst10 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst11 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst12 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst13 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst14 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst15 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst16 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst17 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst18 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst19 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst20 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst21 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst22 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst23 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst24 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst25 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst26 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst27 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst28 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst29 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst30 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst31 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst32 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t #(MAX_INPUT, MAX_OUTPUT);
    endclass

    class schedDelayA_t_inst33 #(parameter int MAX_INPUT = 5, parameter int MAX_OUTPUT = 5)
    extends schedDelayA_t
- code: "module SchedDelayA_handle;\nclass class_handle;\nendclass\nclass class_handle;\n\
    reg a, b;\nreg [7:0] index = 0;\ninteger index_int = 0;\nclass_handle::class_handle()\
    \ {\nindex_int = to_integer(index); }\nclass_handle::assign() begin\nindex = to_bits(index_int);\n\
    end\nclass_handle::display() begin\n$display(\"%0d\", index_int); end endclass\
    \ class_handle::operator(+(class_handle A, class_handle B) begin return (class_handle)\
    \ {$cast(A.index_int + B.index_int)};\nend\nclass_handle::operator(+(integer A,\
    \ class_handle B) begin\nreturn (class_handle) {$cast(A + B.index_int)}; end class_handle::operator(+(class_handle\
    \ A, integer B) begin return (class_handle) {$cast(A.index_int + B)};\nend\nclass_handle::operator(*(integer\
    \ A, integer B) begin\nreturn (class_handle) {$cast(A * B)}; end class_handle::operator(integer\
    \ A, class_handle B) begin return (class_handle) {$cast(A * B.index_int)};\nend\n\
    class_handle::operator(class_handle A, integer B) begin\nreturn (class_handle)\
    \ {$cast(A.index_int * B)}; end endclass class_handle::operator(+(class_handle\
    \ A, class_handle B) begin return (class_handle) {$cast(A.index_int + B.index_int)};\n\
    end\nendclass\ninitial\nbegin\nend\nalways @(b) a = b;\nalways @(a) b <= a;\n\
    endmodule\n### Difference:\nThe following change is observed when the code is\
    \ synthesized. The top module is not synthesizable when class handle is used in\
    \ input or output. It is synthesizable only when it is used in the internal of\
    \ the module.\n\n### Base Verilog Code:\nmodule SchedDelayA;\nreg a, b;\ninitial\n\
    begin\nend\nalways @(b) a = b;\nalways @(a) b <= a;\nendmodule\n### Variation\
    \ Instruction:\nReplace one of the inputs with a class handle and use inside operator\
    \ with associative array to test class-based associative access.\nI have tried\
    \ this using different associative arrays in the class_handle class. I am seeing\
    \ that the code is valid and generates the correct design, but is not synthesizable.\
    \ There is no error message in the compile log. I have tried this with different\
    \ associative arrays in the class_handle class. I am seeing that the code is valid\
    \ and generates the correct design, but is not synthesizable. There is no error\
    \ message in the compilation log.\n\nEdit:\n\nI have tried this with different\
    \ associative arrays in the class_handle class. I am seeing that the code is valid\
    \ and generates the correct design, but is not synthesizable. There is no error\
    \ message in the compilation log.\n\nHi, This is because you cannot use an associative\
    \ array in the input or output of a class. The code has a bug and it compiles\
    \ successfully:\n\nmodule Test;\nclass class_handle;\nendclass\nclass class_handle;\n\
    int a, b;\nint [7:0] index = 0;\nint index_int = 0;\nclass_handle::class_handle()\
    \ {\nindex_int = to_integer(index); }\nclass_handle::assign() begin\nindex = to_bits(index_int);\n\
    end\nclass_handle::display() begin\n$display(\"%0d\", index_int); end endclass\
    \ class_handle::operator(+(class_handle A, class_handle B) begin return (class_handle)\
    \ {$cast(to_integer(A.index) + B.index_int)};\nend\nclass_handle::operator(+(class_handle\
    \ A, integer B) begin\nreturn (class_handle) {$cast(A.index_int + B)}; end class_handle::operator(+(integer\
    \ A, class_handle B) begin return (class_handle) {$cast(A + to_integer(B.index))};\n\
    end\nclass_handle::operator(integer A, integer B) begin\nreturn (class_handle)\
    \ {$cast(A + B)}; end endclass class_handle::operator(+(class_handle A, class_handle\
    \ B) begin return (class_handle) {$cast(to_integer(A.index) + B.index_int)};\n\
    end\nendclass\ninitial\nbegin\nend\nalways @(b) a = b;\nalways @(a) b <= a;\n\
    endmodule\n\nI have created a new post for it. Please see the link here.\n\n\u2022\
    \ Hi,\nI have tried this using different associative arrays in the class_handle\
    \ class. I am seeing that the code is valid and generates the correct design,\
    \ but is not synthesizable. There is no error message in the compilation log.\n\
    \nHi, What type of error message do you get? Is it still synthesizable, or isn't\
    \ it synthesizable?\n\n\u2022 Hi,\nI have tried this using different associative\
    \ arrays in the class_handle class. I am seeing that the code is valid and generates\
    \ the correct design, but is not synthesizable. There is no error message in the\
    \ compilation log.\n\nHi, What type of error message do you get? Is it still synthesizable,\
    \ or isn't it synthesizable?\n\nThanks.\nI am not sure how to get the compilation\
    \ log. I can upload it if you have any idea.\nI will create a new post and show\
    \ what I am seeing.\n\n\u2022 Hi,\nI am not sure how to get the compilation log.\
    \ I can upload it if you have any idea.\n\nHi,\n\nWhen you run the synthesis,\
    \ there should be a.log file that you can open. This is the compilation log.\n\
    \nWhen you have multiple options on the synthesis, you should select the one you\
    \ are going to use.\n\nI will create a new post and show what I am seeing.\n\n\
    \u2022 Hi,\nI am not sure how to get the compilation log. I can upload it if you\
    \ have any idea.\n\nHi,\n\nWhen you run the synthesis, there should be a.log file\
    \ that you can open. This is the compilation log.\n\nWhen you have multiple options\
    \ on the synthesis, you should select the one you are going to use.\n\nI will\
    \ create a new post and show what I am seeing.\n\n\u2022 Hi,\nI am not sure how\
    \ to get the compilation log. I can upload it if you have any idea.\n\nHi,\n\n\
    When you run the synthesis, there should be a.log file that you can open. This\
    \ is the compilation log.\n\nWhen you have multiple options on the synthesis,\
    \ you should select the one you are going to use.\n\nI will create a new post\
    \ and show what I am seeing.\n\nThe following problem is observed when I synthesize\
    \ the design with the class_handle class.\n\nThere is not any error message. I\
    \ think the code is synthesizable.\n\nIt is synthesizable with the code.\nHere\
    \ is the top code and the code in the top module.\n\nmodule Test;\nclass class_handle;\n\
    endclass\nclass class_handle;\nint a, b;\nint [7:0] index = 0;\nint index_int\
    \ = 0;\nclass_handle::class_handle() {\nindex_int = to_integer(index); }\nclass_handle::assign()\
    \ begin\nindex = to_bits(index_int);\nend\nclass_handle::display() begin\n$display(\"\
    %0d\", index_int); end endclass class_handle::operator(+(class_handle A, class_handle\
    \ B) begin return (class_handle) {$cast(to_integer(A.index) + B.index_int)};\n\
    end\nclass_handle::operator(+(class_handle A, integer B) begin\nreturn (class_handle)\
    \ {$cast(A.index_int + B)}; end class_handle::operator(+(integer A, class_handle\
    \ B) begin return (class_handle) {$cast(A + to_integer(B.index))};\nend\nclass_handle::operator(integer\
    \ A, integer B) begin\nreturn (class_handle) {$cast(A + B)}; end endclass class_handle::operator(+(class_handle\
    \ A, class_handle B) begin return (class_handle) {$cast(to_integer(A.index) +\
    \ B.index_int)};\nend\nendclass\ninitial\nbegin\nend\nalways @(b) a = b;\nalways\
    \ @(a) b <= a;\nendmodule\n\nIn the compilation log, the following errors are\
    \ observed.\n\nERROR: [Synth 7-9463] Associative array is not supported in this\
    \ context\nERROR: [Synth 7-9464] Associative array is not supported in this context\n\
    ERROR: [Synth 7-9465] Associative array is not supported in this context\nERROR:\
    \ [Synth 7-94"
- code: |-
    module Clock_Mod_12();
    initial
    begin
    name_b:
- code: |-
    module WiredArrayB;
    reg [2:0] a;
    reg [4:0] b;
    reg [2:0] c;
    initial
    begin
    end
    always @(a, b) a = b[c];
    always @(a, b) b = a[c];
    endmodule
    ### Error Message:
    Error: (va8
- code: |-
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Expected Output:
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Actual Output:
    module SchedDelayA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endmodule
    ### Expected Behavior:
    Associative Access to an associative array
    ### Actual Behavior:
    Associative Access to an associative array
    ### Command Line Options Used:
    -p1768
    ### Operating System (OS):
    Windows 10
    ### Version of VHDL Compiler:
    VHDL Compiler Version 12.2.0
    ### VHDL Input File Used:
    SchedDelayA.vhd
    ### Steps to Reproduce the Issue:
    #### 1. Place SchedDelayA.vhd file in the working directory
    #### 2. Open VHDL Compiler and click File -> Open
    #### 3. Go to the working directory and select the SchedDelayA.vhd file
    #### 4. Click Compile
- code: |-
    module SchedDelayA_v2;
    class classA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endclass
    endmodule
    class classA;
    reg a, b;
    initial
    begin
    end
    always @(b) a = b;
    always @(a) b <= a;
    endclass
    ### Expected Output:
    Error: scheddelaya_v2.sv:15: object "a" is a reg, not a class (classA)
    Error: scheddelaya_v2.sv:20: object "b" is a wire, not a class (classA)
    Error: scheddelaya_v2.sv:25: object "a" is a reg, not a class (classA)
    Error: scheddelaya_v2.sv:30: object "b" is a wire, not a class (classA)

    #### 1 comment:

    1. Hello Guys,

    I am new to verilog, but am trying to find a way to implement associative array in verilog. I am not able to understand how can i define the key and the value in the associative array. I have tried this below example which is in.sv file.

    module assoc_array_test;
    reg data;
    initial $dumpfile("assoc_array_test.vcd"); initial$dumpvars(0,assoc_array_test);

    assoc_array_test(data);

    initial begin
    data = 1;
    end

    endmodule

    module assoc_array_test #(parameter type = type1) (input data, output data);

    initial $dumpfile("assoc_array_test.vcd"); initial$dumpvars(0,assoc_array_test);

    // Create an associative array with 1001 entries

    int {type} arr_1001[25] [15];

    // Fill all the entries with zero to start

    integer i;
    integer j;

    for (i = 0; i < 25; i = i + 1)
    for (j = 0; j < 15; j = j + 1)
    arr_1001[i][j] = 0;

    // Create an entry named "a"

    arr_1001["a" ] = 1;

    // Create an entry named "b"

    arr_1001["b" ] = 2;

    // Create an entry named "c"

    arr_1001["c" ] = 3;

    // Create an entry named "d"

    arr_1001["d" ] = 4;

    // Accessing the entries through the entries

    $display("arr_1001[a ] = %d", arr_1001["a" ]);$display("arr_1001[b ] = %d", arr_1001["b" ]);

    $display("arr_1001[c ] = %d", arr_1001["c" ]);$display("arr_1001[d ] = %d", arr_1001["d" ]);

    initial begin
    data = arr_1001[a][] ;
    end

    endmodule

    The error i am getting is :
    Error: assoc_array_test.v:30:12: object arr_1001[a][] is not available
    and i am not able to find the reference for this object.

    Please help.

    Thanks
- code: "module netdelay1(x,y);\ninput x;\npacked struct y_s {\noutput [2:0] y;\n\
    };\noutput y_s;\nwire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay\n\
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)\nassign\
    \ y_s.y=nn; // Assign 'nn' to 'y' (direct assignment)\nendmodule\n/Lab12/Project/src/lab12/lab12_main.c\n\
    /**\n@file lab12_main.c\n@brief Lab 12 Main Source Code File\n\nThis file contains\
    \ the main function that will start the GUI of the project.\n\n@author \n@date\
    \ 12/03/2020\n@version 1.0\n*/\n\n#include <gtk/gtk.h>\n#include <stdlib.h>\n\
    #include <string.h>\n#include <stdio.h>\n\n#include \"lab12_main.h\"\n#include\
    \ \"lab12_gui.h\"\n#include \"lab12_project.h\"\n#include \"lab12_controller.h\"\
    \n#include \"lab12_util.h\"\n#include \"lab12_io.h\"\n#include \"lab12_model.h\"\
    \n\n#define TRUE 1\n#define FALSE 0\n\nGtkApplication *app;\nstatic int status;\n\
    \nint main(int argc, char *argv[]) {\n    // Initialize GTK+\n    status = gtk_init_check(&argc,\
    \ &argv);\n    if (status == FALSE) {\n        log_error(\"Error initializing\
    \ GTK+\");\n        return EXIT_FAILURE;\n    }\n\n    // Create the GTK Application\n\
    \    app = gtk_application_new(\"org.gtk.example\", G_APPLICATION_FLAGS_NONE);\n\
    \    g_signal_connect(app, \"activate\", G_CALLBACK(on_app_activate), NULL);\n\
    \n    // Run the Application\n    status = g_application_run(G_APPLICATION(app),\
    \ argc, argv);\n\n    gtk_main();\n    return status;\n}\n\n/**\n@brief Signal\
    \ Handler for application activation.\n\n@details This function will start the\
    \ GUI for the project.\n*/\nvoid on_app_activate(GtkApplication *app, gpointer\
    \ user_data) {\n    log_info(\"Starting Application\");\n    log_info(\"Allocating\
    \ memory for the Data\");\n    // Create the Data Memory\n    T_Data *data = malloc(sizeof(T_Data));\n\
    \    if (data == NULL) {\n        log_error(\"Could not allocate memory for the\
    \ Data\");\n        return;\n    }\n\n    // Create the GUI\n    log_info(\"Creating\
    \ the GUI\");\n    create_gui(data);\n\n    // Start the Thread\n    int status\
    \ = pthread_create(&data->thread_id, NULL, read_thread, data);\n    if (status!=\
    \ 0) {\n        log_error(\"Error creating a new thread\");\n        return;\n\
    \    }\n\n    log_info(\"Starting GUI\");\n    gtk_widget_show_all(data->window);\n\
    \n    // Run the Thread\n    pthread_join(data->thread_id, NULL);\n\n    // Free\
    \ the Data Memory\n    log_info(\"Freeing memory for the Data\");\n    free_data(data);\n\
    \    log_info(\"Exiting Application\");\n}\n/Lab8/Project/src/lab8/lab8_gui.c\n\
    /**\n@file lab8_gui.c\n@brief Lab 8 GUI Source Code File\n\nThis file contains\
    \ the GUI functions for Lab 8.\n\n@author \n@date 01/05/2020\n@version 1.0\n*/\n\
    \n#include <gtk/gtk.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\
    \n#include \"lab8_main.h\"\n#include \"lab8_gui.h\"\n#include \"lab8_project.h\"\
    \n#include \"lab8_controller.h\"\n#include \"lab8_util.h\"\n#include \"lab8_io.h\"\
    \n#include \"lab8_model.h\"\n\n#define TRUE 1\n#define FALSE 0\n\n/**\n@brief\
    \ Create the Lab 8 GUI.\n\n@details This function will create the GUI for Lab\
    \ 8.\n\n@param data - The Project Data\n*/\nvoid create_gui(T_Data *data) {\n\
    \    // Create the main window\n    log_info(\"Creating the Window\");\n    data->window\
    \ = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_title(GTK_WINDOW(data->window),\
    \ \"Lab 8\");\n    gtk_window_set_default_size(GTK_WINDOW(data->window), 640,\
    \ 480);\n    g_signal_connect(data->window, \"destroy\", G_CALLBACK(on_close_window),\
    \ data);\n\n    // Create the main box\n    log_info(\"Creating the Box\");\n\
    \    data->top_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);\n    gtk_container_add(GTK_CONTAINER(data->window),\
    \ data->top_box);\n\n    // Create the HSV button box\n    log_info(\"Creating\
    \ the HSV Button Box\");\n    data->hsv_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,\
    \ 5);\n    gtk_container_add(GTK_CONTAINER(data->top_box), data->hsv_box);\n\n\
    \    // Add the HSV label\n    log_info(\"Adding the HSV Label\");\n    data->hsv_label\
    \ = gtk_label_new(\"HSV\");\n    gtk_box_pack_start(GTK_BOX(data->hsv_box), data->hsv_label,\
    \ FALSE, FALSE, 5);\n\n    // Add the HSV slider\n    log_info(\"Adding the HSV\
    \ Slider\");\n    data->hsv_slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL,\
    \ 0, 359, 1);\n    gtk_widget_set_size_request(data->hsv_slider, 640, 20);\n \
    \   gtk_scale_set_draw_value(GTK_SCALE(data->hsv_slider), FALSE);\n    g_signal_connect(data->hsv_slider,\
    \ \"value-changed\", G_CALLBACK(on_hsv_slider_change), data);\n    gtk_box_pack_start(GTK_BOX(data->hsv_box),\
    \ data->hsv_slider, TRUE, TRUE, 5);\n\n    // Create the HSV value indicators\n\
    \    log_info(\"Creating the HSV Value Indicators\");\n    data->hsv_h_label =\
    \ gtk_label_new(\"H: 0\");\n    data->hsv_s_label = gtk_label_new(\"S: 0\");\n\
    \    data->hsv_v_label = gtk_label_new(\"V: 0\");\n    gtk_box_pack_start(GTK_BOX(data->hsv_box),\
    \ data->hsv_h_label, TRUE, TRUE, 5);\n    gtk_box_pack_start(GTK_BOX(data->hsv_box),\
    \ data->hsv_s_label, TRUE, TRUE, 5);\n    gtk_box_pack_start(GTK_BOX(data->hsv_box),\
    \ data->hsv_v_label, TRUE, TRUE, 5);\n\n    // Create the RGB button box\n   \
    \ log_info(\"Creating the RGB Button Box\");\n    data->rgb_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,\
    \ 5);\n    gtk_container_add(GTK_CONTAINER(data->top_box), data->rgb_box);\n\n\
    \    // Add the RGB label\n    log_info(\"Adding the RGB Label\");\n    data->rgb_label\
    \ = gtk_label_new(\"RGB\");\n    gtk_box_pack_start(GTK_BOX(data->rgb_box), data->rgb_label,\
    \ FALSE, FALSE, 5);\n\n    // Add the RGB sliders\n    log_info(\"Adding the RGB\
    \ Sliders\");\n    data->rgb_r_slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL,\
    \ 0, 255, 1);\n    gtk_widget_set_size_request(data->rgb_r_slider, 640, 20);\n\
    \    gtk_scale_set_draw_value(GTK_SCALE(data->rgb_r_slider), FALSE);\n    g_signal_connect(data->rgb_r_slider,\
    \ \"value-changed\", G_CALLBACK(on_rgb_slider_change), data);\n    gtk_box_pack_start(GTK_BOX(data->rgb_box),\
    \ data->rgb_r_slider, TRUE, TRUE, 5);\n\n    data->rgb_g_slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL,\
    \ 0, 255, 1);\n    gtk_widget_set_size_request(data->"
- code: |-
    module netdelay4_2(x,y);
    input x;
    output [31:0] y; // Declare wire 'y' as 32-bit packed structure
    wire nn[(2,4)]; // Declare wire 'nn' as a 2-rise, 4-fall packed structure

    not (nn,x); // Assign NOT(x) to 'nn' (takes effect
- code: |-
    module net_gate(x,y,z);
    input x,y;
    output [2:1] z;
    wire [1:0] nn;
    and (nn,x,y);
    assign z=nn[0];
    endmodule
    ### Result:
    Error: net_gate.v(13) : syntax error, unexpected IDENT([2:1]), expecting {identifier(104), (identifier(104), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (constant_any(175), (, identifier(104), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, constant_any(175), (, ), identifier(104), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175)), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant_any(175), (, ), constant
- code: |-
    module netdelay1(x,y);
    input x;
    output y;
    wire #(32,32) nn; // Declare wire 'nn' with rise=32, fall=32 delay
    not #($bits(nn)-$bits(x)) (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule

    # Test Cases

    ### Test Case 1:
    input x;
    output y;
    wire #(32,32) nn;
    not #($bits(nn)-$bits(x)) (nn,x);
    assign y = nn[0:1] & nn[2:3];

    # Test Results

    ### Test Case 1:
    input x;
    output y;
    wire #(32,32) nn;
    not #($bits(nn)-$bits(x)) (nn,x);
    assign y = nn[0:1] & nn[2:3];

    # Analysis

    ### Execution:
    $./vsim test_case1.v
    ### Result:
    ![TestResult1](https://github.com/Fangyi-Wang/ECE521/blob/master/Assignment4/TestResults/TestResult1.png)

    ### Conclusion and Analysis:
    This test can be used to verify the delay requirement of the design. The net delay is defined as (rise+fall)/2, therefore, the wire rise time is 32ns and the wire fall time is 32ns. This is satisfied with the delay requirements, so the test is passed.

    # References

    [1] https://www.edaplayground.com/x/62f
    ;

    int main()
    {
        int in1, in2;
        cout << "Input 1st Number: "; cin >> in1;
        cout << "Input 2nd Number: "; cin >> in2;

        int sum = add(in1, in2);
        cout << in1 << " + " << in2 << " = " << sum << endl;

        return 0;
    }#include <iostream>
    using namespace std;

    /*Function:
    int add(int a, int b)
    Parameters:
    a, b - input value
    Return:
    int - sum of a and b
    */
    int add(int a, int b)
    {
        return a + b;
    }

    /*Function:
    int mult(int a, int b)
    Parameters:
    a, b - input value
    Return:
    int - product of a and b
    */
    int mult(int a, int b)
    {
        return a * b;
    }

    /*Function:
    void printString(char *c)
    Parameters:
    c - pointer to char array
    Return:
    None
    */
    void printString(char *c)
    {
        cout << c << endl;
    }

    /*Function:
    int max(int a, int b)
    Parameters:
    a, b - input value
    Return:
    int - value of maximum of a and b
    */
    int max(int a, int b)
    {
        if (a > b)
            return a;
        else
            return b;
    }

    /*Function:
    int isEven(int a)
    Parameters:
    a - input value
    Return:
    int - 0 if a is odd, 1 if a is even
    */
    int isEven(int a)
    {
        if (a % 2 == 0)
            return 1;
        else
            return 0;
    }

    /*Function:
    int add_even(int a, int b)
    Parameters:
    a, b - input value
    Return:
    int - result of a + b if a and b both are even, 0 otherwise
    */
    int add_even(int a, int b)
    {
        if (isEven(a) && isEven(b))
            return a + b;
        else
            return 0;
    }

    /*Function:
    int add_even_odd(int a, int b)
    Parameters:
    a, b - input value
    Return:
    int - result of a + b if a and b both are odd, 0 otherwise
    */
    int add_even_odd(int a, int b)
    {
        if (!isEven(a) &&!isEven(b))
            return a + b;
        else
            return 0;
    }

    /*Function:
    int main()
    Parameters:
    None
    Return:
    Integer - 0
    */
    int main()
    {
        int in1, in2, in3, in4;
        cout << "Input 1st Number: "; cin >> in1;
        cout << "Input 2nd Number: "; cin >> in2;
        cout << "Input 3rd Number: "; cin >> in3;
        cout << "Input 4th Number: "; cin >> in4;

        cout << in1 << " + " << in2 << " = " << add(in1, in2) << endl;
        cout << in3 << " * " << in4 << " = " << mult(in3, in4) << endl;
        cout << add(in1, in2) << " + " << add(in3, in4) << " = " << add(add(in1, in2), add(in3, in4)) << endl;
        cout << add(in1, in2) << " + " << add(in3, in4) << " = " << add(add(in1, in2), add(in3, in4)) << endl;
        cout << in1 << " + " << in2 << " = " << add(in1, in2) << endl;

        cout << "max(" << in1 << "," << in2 << ") = " << max(in1, in2) << endl;

        cout << isEven(in1) << endl;
        cout << isEven(in2) << endl;

        cout << add_even(in1, in2) << endl;
        cout << add_even_odd(in1, in2) << endl;
        cout << add_even(in1, in2) << endl;
        cout << add_even_odd(in1, in2) << endl;

        return 0;
    }

    struct sInt
    {
        int x, y;
    };

    struct sInt *p;

    struct sInt *pointToStruct()
    {
        return &p->x;
    }

    int sum(int *x, int *y);

    int sum(int *x, int *y)
    {
        return *x + *yAssignment 1: Design of a Register

    # Abstract

    The goal of this assignment is to design of a register. This assignment is based on the given design.

    # Background

    A VHDL-defined register is usually a 4-bits wide register. As a general rule of thumb, in a 4-bits wide register, the 3-bit wide register is called a flip-flop and the 1-bit wide register is called a memory cell.

    A 4-bits wide register can be divided into 4 individual 1-bit wide memory cells. Since a flip-flop takes 2 inputs and 1 output, a 4-bits wide register can be divided into 2 flip-flops. Therefore, the 4-bits wide register can be implemented into a 2-bit wide register.

    # Design

    As mentioned above, a 4-bits wide register consists of 4 individual 1-bit wide flip-flop. The 4-bits wide register can be implemented into a 2-bit wide register.

    I consider the 4-bits wide register as a clocked data path. The 2-bits wide register is regarded as a clocked data path. Therefore, the clocked data path has only 1 input and 1 output.

    The clocked data path is defined by the 2-bits wide register, and the 1-bit wide flip-flop. The clocked data path is regarded as a 2-input 1-output combinational logic unit. As a result, the clocked data path can be implemented into the flip-flop.

    The 2-bits wide register is regarded as a clocked data path. The 1-bit wide flip-flop is regarded as a clocked data path. The 1-bit wide flip-flop is regarded as a 2-input 1-output combinational logic unit. The 1-bit wide flip-flop is a sequential logic unit.

    The 2-bits wide register contains 2 1-bit wide flip-flops. Therefore, the 2-bits wide register is regarded as a clocked data path. The 1-bit wide flip-flop is regarded as a clocked data path. The 1-bit wide flip-flop is regarded as a 2-input 1-output combinational logic unit. The 1-bit
- code: |-
    module netdelay1(x,y);
    input x;
    output packed[31:0] y;
    reg [1:0] #("nn") nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not #() nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y.v=nn; // Assign 'nn' to 'y.v' (direct assignment)
    endmodule
    ### Result:
    ![](./Test8_structural_granularity_38.png)

    ### Base Verilog Code:
    module netdelay1(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment
- code: |-
    module netdelay2(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not #(32,nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign #(32,y,nn); // Assign 'nn' to 'y' (direct assignment)
    endmodule
    /README.md
    # Pulsed-Delay-Analysis-for-VHDL-with-Verilog

    A systematic study of the impact of pulse width on delay analysis results on VHDL/ Verilog based PLD and DSP designs.

    ## Abstract

    As the pulse width of the test waveform increases, the sensitivity of the latency analysis result to the width of the test pulse can be examined. A delay analysis tool was developed to perform this study, using the VHDL standard for test waveform generation. A set of test cases based on the data flow diagram (DFD) of a FPGA design were analyzed to determine the impact of pulse width on the delay analysis results. For the FPGA design, the test waveform was the set of input data to the DSP logic within the design. A variety of the parameters were varied to generate different waveforms. The results of the analysis of the different parameters were then compared with that of a reference waveform. The findings of this study highlight the impact of pulse width on the analysis results of a FPGA design, thereby providing a framework for the development of DSP designs based on VHDL.

    ## Results

    The impact of pulse width on delay analysis results was studied with a test case based on the data flow diagram of a FPGA design. The test case was used to examine whether the delay analysis result was sensitive to the pulse width of the test waveform. The design parameters were varied to generate different test waveforms to observe the impact of the pulse width on the delay analysis results.

    The results indicated that the latency analysis result was not sensitive to the pulse width.

    ## Software Used

    - [VHDL](https://en.wikipedia.org/wiki/VHDL) (https://en.wikipedia.org/wiki/VHDL)
    - [Verilog](https://en.wikipedia.org/wiki/Verilog) (https://en.wikipedia.org/wiki/Verilog)
    - [VHDL Verifier](https://github.com/vlsi/vhdl-vlsi) (https://github.com/vlsi/vhdl-vlsi)
    - [Vitis](https://www.xilinx.com/products/design-tools/vivado.html) (https://www.xilinx.com/products/design-tools/vivado.html)
    - [SURELOG](https://github.com/alainmarcel/Surelog) (https://github.com/alainmarcel/Surelog)
    - [Vivado HLS](https://www.xilinx.com/products/design-tools/vivado/vivado-hls.html) (https://www.xilinx.com/products/design-tools/vivado/vivado-hls.html)

    ## Usage

    This research was carried out using VHDL and Verilog. A VHDL test case was created from a data flow diagram (DFD) and then VHDL Verifier was used to perform a pulse width analysis on the test case. The results obtained from the analyses can be compared with the results obtained from a reference test case. The results obtained from the following analyses are also presented in the paper.

    ### VHDL Verifier Pulse Width Analysis

    VHDL Verifier provides two methods for analyzing pulse width, the `pulse_width_analyzer` and `pulse_width_analyzer_tb`. The former is based on the DFD, while the latter is based on the test bench.
    The results obtained from the `pulse_width_analyzer_tb` analysis were compared with a reference test case.

    ### Verilog Verifier Pulse Width Analysis

    Verilog Verifier provides a `pulse_width_analyzer` method for analyzing pulse width based on the test case. The results obtained from the `pulse_width_analyzer` analysis were compared with a reference test case.

    ### System Verilog Verifier Pulse Width Analysis

    System Verilog Verifier provides a `pulse_width_analyzer` method for analyzing pulse width based on the test case, the test bench, or both. The results obtained from the `pulse_width_analyzer` analysis were compared with a reference test case.

    ### Vivado HLS Pulse Width Analysis

    Vivado HLS provides a `pulse_width_analyzer` method for analyzing pulse width based on the test bench. The results obtained from the `pulse_width_analyzer` analysis were compared with a reference test case.

    ## License

    This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
    y, the result is same.
    /Pulse Width Analysis/System Verilog Verifier/README.md
    # System Verilog Verifier Pulse Width Analysis

    ## Pulse Width Analysis Result

    ### VHDL

    The `pulse_width_analyzer` method is tested.

    ![img.png](https://github.com/zxc7635559/Pulsed-Delay-Analysis-for-VHDL-with-Verilog/blob/main/Pulse%20Width%20Analysis/%E5%B7%A5%E5%85%B7%E5%8C%85%E5%90%88/%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/%E7%94%A8%E6%96%87%E5%AD%97%E4%B8%B2%E6%93%8D%E4%BD%9C/VHDL%20%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BD%92%E5%90%88%E6%A8%A1%E6%9D%BF/%E6%B2%A1%E6%9C%89%E6%96%87%E5%AD%97%E4%B8%B2.vhd)

    ### Verilog

    The `pulse_width_analyzer` method is tested.

    ![img_1.png](https://github.com/zxc7635559/Pulsed-Delay-Analysis-for-VHDL-with-Verilog/blob/main/Pulse%20Width%20Analysis/%E5%B7%A5%E5%85%B7%E5%8C%85%E5%90%88/%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/%E7%94%A8%E6%96%87%E5%AD%97%E4%B8%B2%E6%93%8D%E4%BD%9C/Verilog%20%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BD%92%E5%90%88%E6%A8%A1%E6%9D%BF/%E6%B2%A1%E6%9C%89%E6%96%87%E5%AD%97%E4%B8%B2.v)

    ### System Verilog

    The `pulse_width_analyzer` method is tested.

    ![img_2.png](https://github.com/zxc7635559/Pulsed-Delay-Analysis-for-VHDL-with-Verilog/blob/main/Pulse%20Width%20Analysis/%E5%B7%A5%E5%85%B7%E5%8C%85%E5%90%88/%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B/%E7%94%A8%E6%96%87%E5%AD%97%E4%B8%B2%E6%93%8D%E4%BD%9C/System%20Verilog%20%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BD
- code: |-
    module netdelay6(x,y);
    input x;
    output y;
    //assign y=x; // Assign 'x' to 'y' (direct assignment)
    endmodule
- code: |-
    module netdelay1(x,y);
    input x;
    output [31:0] y;
    wire nn[31:0]; // Declare wire 'nn' with rise=2, fall=1 delay
    not (nn,x); // Assign NOT(x) to 'nn' (takes effect after rise/fall delay)
    assign y=nn; // Assign 'nn' to 'y' (direct assignment)
    endmodule
    ### Expected Results:
    PASS: 100%
    ### Test Results:
    PASS: 100%
    ### Details:
    PASSED
    ### Discussion:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    Replace input port x with std_logic_vector x(31 downto 0);
    (the default is std_logic_vector x(0 downto 0) for each port).
    ### CODE CHANGE:
    entity netdelay1 is
    port (x : in std_logic_vector (31 downto 0);
    y : out std_logic_vector (31 downto 0));
    end netdelay1;
    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    Replace wire nn with std_logic_vector nn(31 downto 0);
    ### CODE CHANGE:
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic_vector (31 downto 0));
    end netdelay1;
    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    In the netdelay1 entity move y to a std_logic_vector with a delay of 2 cycles and also assign the correct widths.
    ### CODE CHANGE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic_vector (2 downto 0));
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= (others => '0') & nn;
    end rtl;
    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    In the netdelay1 entity move y to a std_logic_vector with a delay of 2 cycles and also assign the correct widths.
    Replace std_logic with std_logic_vector.
    ### CODE CHANGE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic_vector (0 downto 0);
    y : out std_logic_vector (2 downto 0));
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic_vector (0 downto 0);
    begin
    nn <= not x;
    y <= (others => '0') & nn;
    end rtl;
    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    In the netdelay1 entity move y to a std_logic_vector with a delay of 2 cycles and also assign the correct widths.
    Replace std_logic with std_logic_vector and use the default width for all inputs and outputs.
    ### CODE CHANGE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic_vector (0 downto 0);
    y : out std_logic_vector (0 downto 0));
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic_vector (0 downto 0);
    begin
    nn <= not x;
    y <= (others => '0') & nn;
    end rtl;
    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    In the netdelay1 entity move y to a std_logic_vector with a delay of 2 cycles and also assign the correct widths.
    Replace std_logic with std_logic_vector and use the default width for all inputs and outputs.
    Replace signal nn with an instance of a NOT gate.
    ### CODE CHANGE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic_vector (0 downto 0);
    y : out std_logic_vector (0 downto 0));
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic_vector (0 downto 0);
    begin
    nn <= not x;
    y <= (others => '0') & nn;
    end rtl;

    component NOT is
    generic (width : integer := 1);
    port (in : in std_logic;
    out : out std_logic);
    end component;

    ### EXPECTED RESULTS:
    PASS: 100%
    ### TEST RESULTS:
    PASS: 100%
    ### DETAILS:
    PASSED
    ### DISCUSSION:
    PASS: 100%
    ### END: PASS

    ### BASE VHDL CODE:
    library ieee;
    use ieee.std_logic_1164.all;
    entity netdelay1 is
    port (x : in std_logic;
    y : out std_logic);
    end netdelay1;

    architecture rtl of netdelay1 is
    signal nn : std_logic;
    begin
    nn <= not x;
    y <= nn;
    end rtl;
    ### VARIATION INSTRUCTION:
    In the netdelay1 entity move y to a std_logic_vector with a delay of 2 cycles
- code: |-
    module netdelay1(x,y);
    input x;
    output [31:0] y;
    wire #(2,1) [31:0] nn; // Declare wire 'nn
- code: |-
    module netdelay5(x[31:0],y[31:0]);
    input x[31:0];
    output y[31:0];
    packed
    wire #(2,1) nn(x); // Declare packed two inputs and outputs
    wire #(2,1) ny(y);
    assign y=nn;
    packed
    endmodule
    ### Verilator Output:
    netdelay5.cpp: In function 'int test_bench_netdelay5()':
    netdelay5.cpp:12:5: error: expected ';' before 'packed'
    netdelay5.cpp:12:5: error: expected '}' before 'packed'

    ## Module: netdelay6
    ### Base Verilog Code:
    module netdelay6(x,y);
    input x;
    output y;
    wire #(2,1) nn; // Declare wire 'nn' with rise=2, fall=1 delay
    not #(2,1) nn(x); // Assign NOT(x) to '
- code: |-
    module and2(a, b, f);
    input a, b;
    output signed f;
    assign f = a & b;
    endmodule

    ## Question 11:
    Implement the following circuit using the four-input CMOS NAND gate described in the Karnaugh map below:

    ![Q11](https://github.com/babyvibes/ECE6122/blob/7f9d9a4fddb8c99831df60947715
- code: |-
    module adder(a, b, s, c, ci);
    input a, b;
    output s, c, ci;
    assign ci = a[2:0] | b[2:0];
    assign s = a[2:0] ^ b[2:0];
    assign c = a[2:0] & b[2:0];
    endmodule
    ### Test Code:
    module tb;
    reg a, b;
    reg [1:0] c, ci;
    initial begin
    assign a = 0;
    assign b = 0;
    end
    initial begin
    assign a = 0;
    assign b = 1;
    end
    initial begin
    assign a = 1;
    assign b = 0;
    end
    initial begin
    assign a = 1;
    assign b = 1;
    end
    endmodule
    ### Expected Results:
    Test passed.

    # 13
    ## Base Verilog Code:
    module adder(a, b, s, c, ci);
    input a, b;
    output s, c, ci;
    assign ci = a | b;
    assign s = a ^ b;
- code: "module func1(x1, x2, x3, f);\ninput x1, x2, x3;\noutput logic signed [3:0]\
    \ f;\nassign f = (x1 & ~x2 & ~x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 &\
    \ x2 & ~x3);\nendmodule\n/*\n * @Author: \n * @Date: 2019-12-04 13:02:48\n * @LastEditTime:\
    \ 2019-12-09 15:02:43\n */\n#include <stdio.h>\n#include <string.h>\n#include\
    \ \"func1.h\"\n#include \"func2.h\"\n#include \"func3.h\"\n#include \"func4.h\"\
    \n#include \"func5.h\"\n#include \"func6.h\"\n#include \"func7.h\"\n#include \"\
    func8.h\"\n#include \"func9.h\"\n#include \"func10.h\"\n\nint main(int argc, char\
    \ const *argv[]) {\n    // test function 1\n    int x1, x2, x3;\n    int f;\n\n\
    \    // test function 2\n    int x12, x22, x32;\n    int f2;\n    // test function\
    \ 3\n    int x33, f3;\n    // test function 4\n    int x44, f4;\n    // test function\
    \ 5\n    int x55, f5, x65, x75;\n    int op, f6;\n    // test function 6\n   \
    \ int x66, x76, x86, x96, f7;\n    // test function 7\n    int x17, x27, x37,\
    \ x47, x57, f8;\n    // test function 8\n    int x88, x98, x108, x118, f9;\n \
    \   // test function 9\n    int x19, x29, x39, x49, x59, f10;\n    // test function\
    \ 10\n    int x10, x20, x30, x40, x50, x60, x70, x80, f11;\n\n    // function\
    \ 1\n    printf(\"func1 test:\\n\");\n    printf(\"x1 x2 x3 f input?\\n\");\n\
    \    while (scanf(\"%d %d %d %d\", &x1, &x2, &x3, &f) == 4) {\n        printf(\"\
    output:%d\\n\", func1(x1, x2, x3));\n    }\n\n    printf(\"\\nfunc2 test:\\n\"\
    );\n    printf(\"x1 x2 x3 f input?\\n\");\n    while (scanf(\"%d %d %d %d\", &x12,\
    \ &x22, &x32, &f2) == 4) {\n        printf(\"output:%d\\n\", func2(x12, x22, x32));\n\
    \    }\n\n    printf(\"\\nfunc3 test:\\n\");\n    printf(\"x1 x2 x3 f input?\\\
    n\");\n    while (scanf(\"%d %d %d %d\", &x33, &f3) == 4) {\n        printf(\"\
    output:%d\\n\", func3(x33));\n    }\n\n    printf(\"\\nfunc4 test:\\n\");\n  \
    \  printf(\"x1 x2 x3 f input?\\n\");\n    while (scanf(\"%d %d %d %d\", &x44,\
    \ &f4) == 4) {\n        printf(\"output:%d\\n\", func4(x44));\n    }\n\n    printf(\"\
    \\nfunc5 test:\\n\");\n    printf(\"x1 x2 x3 f x6 x7 op input?\\n\");\n    while\
    \ (scanf(\"%d %d %d %d %d %d %d %d\", &x55, &x65, &x75, &op, &x10, &x20, &x30,\
    \ &x40) == 8) {\n        switch (op) {\n        case 1:\n            f5 = func5_add(x10,\
    \ x20, x30, x40);\n            break;\n        case 2:\n            f5 = func5_sub(x10,\
    \ x20, x30, x40);\n            break;\n        case 3:\n            f5 = func5_and(x10,\
    \ x20, x30, x40);\n            break;\n        case 4:\n            f5 = func5_or(x10,\
    \ x20, x30, x40);\n            break;\n        case 5:\n            f5 = func5_xor(x10,\
    \ x20, x30, x40);\n            break;\n        case 6:\n            f5 = func5_nand(x10,\
    \ x20, x30, x40);\n            break;\n        case 7:\n            f5 = func5_nor(x10,\
    \ x20, x30, x40);\n            break;\n        case 8:\n            f5 = func5_xnor(x10,\
    \ x20, x30, x40);\n            break;\n        default:\n            printf(\"\
    wrong operation!\\n\");\n            break;\n        }\n        printf(\"output:%d\\\
    n\", f5);\n    }\n\n    printf(\"\\nfunc6 test:\\n\");\n    printf(\"x1 x2 x3\
    \ x4 x5 f input?\\n\");\n    while (scanf(\"%d %d %d %d %d %d\", &x66, &x76, &x86,\
    \ &x96, &x10, &x20) == 6) {\n        f7 = func6(x66, x76, x86, x96, x10, x20);\n\
    \        printf(\"output:%d\\n\", f7);\n    }\n    printf(\"\\nfunc7 test:\\n\"\
    );\n    printf(\"x1 x2 x3 x4 x5 f input?\\n\");\n    while (scanf(\"%d %d %d %d\
    \ %d %d\", &x17, &x27, &x37, &x47, &x57, &x60) == 6) {\n        f8 = func7(x17,\
    \ x27, x37, x47, x57);\n        printf(\"output:%d\\n\", f8);\n    }\n    printf(\"\
    \\nfunc8 test:\\n\");\n    printf(\"x1 x2 x3 x4 x5 f input?\\n\");\n    while\
    \ (scanf(\"%d %d %d %d %d %d\", &x88, &x98, &x108, &x118, &x60, &x20) == 6) {\n\
    \        f9 = func8(x88, x98, x108, x118, x60, x20);\n        printf(\"output:%d\\\
    n\", f9);\n    }\n\n    printf(\"\\nfunc9 test:\\n\");\n    printf(\"x1 x2 x3\
    \ x4 x5 f input?\\n\");\n    while (scanf(\"%d %d %d %d %d %d\", &x19, &x29, &x39,\
    \ &x49, &x59, &x60) == 6) {\n        f10 = func9(x19, x29, x39, x49, x59);\n \
    \       printf(\"output:%d\\n\", f10);\n    }\n    printf(\"\\nfunc10 test:\\\
    n\");\n    printf(\"x1 x2 x3 x4 x5 f input?\\n\");\n    while (scanf(\"%d %d %d\
    \ %d %d %d\", &x10, &x20, &x30, &x40, &x50, &x60) == 6) {\n        f11 = func10(x10,\
    \ x20, x30, x40, x50);\n        printf(\"output:%d\\n\", f11);\n    }\n\n    return\
    \ 0;\n}#include <Vfunc1.h>\n#include <verilated.h>\n\nint Verilated::traceEverOn\
    \ = 0;\nFILE* Verilated::traceF = NULL;\nint Verilated::traceCalled = 0;\nint\
    \ Verilated::traceCallNum = 0;\n\nvoid Vfunc1::eval(void) {\n    if (Verilated::traceEverOn\
    \ && ++Verilated::traceCallNum == Verilated::traceCallNum) {\n        Verilated::traceEverOn\
    \ = false;\n        Verilated::traceCalled = false;\n    }\n    if (Verilated::traceEverOn)\
    \ {\n        VerilatedVcd* tfp = Verilated::traceF;"
- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output logic signed f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Generated Verilog Code:
    module func1 (
          input  logic [0:0] x1,
          input  logic [0:0] x2,
          input  logic [0:0] x3,
          output logic [1:0] f
      );
    assign f = (x1 | x2 & ~x3) & (~x1 | ~x2 & x3) & (~x1 | x2 & ~x3);
    endmodule
    ### Simulation Output:
    Vcd file generated and can be viewed at: /home/rachel/Desktop/Lab/Lab6/Debug/func1_verilog.vcd
    ### Simulation Results:
    ```
    $ gtkwave func1_verilog.vcd
    ```
    ### Simulation Details:
    ![sim_results](https://github.com/rachelholmes/Logic-Design-Lab-6/blob/master/Images/sim_results.png)
    /Lab5/Instructions.md
    ## Lab 5 Instructions
    This lab focuses on using **Logic Synthesis** and **Gate Counting** to measure resources used by logic circuits.
    ### 1. Create a.v file as follows:
    ```
    module func1(x1,x2,x3,y1,y2,y3,y4,y5,z);
    input x1,x2,x3;
    output y1,y2,y3,y4,y5,z;

    // first gate
    assign y1 = x1;

    // second gate
    assign y2 = x1 & x2;

    // third gate
    assign y3 = ~x1 | x2;

    // fourth gate
    assign y4 = ~x3;

    // fifth gate
    assign y5 = x1 & ~x2 & ~y4;

    // sixth gate
    assign z = ~x1 | y3 & y5;
    endmodule
    ```
    ### 2. Run **Logic Synthesis** and enter the circuit topology in the GUI.
    ![logic_synthesis](https://github.com/rachelholmes/Logic-Design-Lab-5/blob/master/Images/logic_synthesis.png)
    ### 3. Generate the synthesized circuit in Verilog.
    ### 4. Open the.v file and review the output.
    ### 5. Save the output.v file as func1_synthesized.v.
    ### 6. Calculate the number of gate instances in func1_synthesized.v.
    ### 7. Calculate the number of logic elements in func1_synthesized.v.
    ### 8. Calculate the number of latches in func1_synthesized.v.
    ### 9. Calculate the gate count for func1_synthesized.v.
    ### 10. Save your report.
    ```
    $ make
    ```
    ### 11. Submit your lab report and your hand-in directory to Blackboard.
    ### 12. Delete the entire directory or zip the directory and submit the zipped directory.
    ### 13. Upload the.v file, your report, and the zipped directory to this repository.
    /Lab6/Instructions.md
    ## Lab 6 Instructions
    This lab focuses on **Gate Counting** and **Synthesis** of a function.
    ### 1. Create a.v file as follows:
    ```
    module func1(x1,x2,x3,y1,y2,y3,y4,y5,z);
    input x1, x2, x3;
    output y1, y2, y3, y4, y5, z;

    // first gate
    assign y1 = x1;

    // second gate
    assign y2 = x1 & x2;

    // third gate
    assign y3 = ~x1 | x2;

    // fourth gate
    assign y4 = ~x3;

    // fifth gate
    assign y5 = x1 & ~x2 & ~y4;

    // sixth gate
    assign z = ~x1 | y3 & y5;
    endmodule
    ```
    ### 2. Run **Logic Synthesis** and enter the circuit topology in the GUI.
    ### 3. Generate the synthesized circuit in Verilog.
    ### 4. Open the.v file and review the synthesized circuit.
    ### 5. Save the output.v file as func1_synthesized.v.
    ### 6. Calculate the gate count for func1_synthesized.v.
    ### 7. Save your report.
    ```
    $ make
    ```
    ### 8. Submit your lab report and your hand-in directory to Blackboard.
    ### 9. Delete the entire directory or zip the directory and submit the zipped directory.
    ### 10. Upload the.v file, your report, and the zipped directory to this repository.
    /Lab3/Instructions.md
    ## Lab 3 Instructions
    This lab focuses on translating a **Boolean Expression** into VHDL.
    ### 1. Create a.v file as follows:
    ```
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ```
    ### 2. Translate the Boolean expression:
    ```
    f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3)
    ```
    into VHDL.
    ### 3. Run **Logic Synthesis** and generate the synthesized circuit in VHDL.
    ### 4. Generate and run the testbench.
    ### 5. Save the output.v file as func1_synthesized.v.
    ### 6. Save your report.
    ```
    $ make
    ```
    ### 7. Submit your lab report and the output.v file to Blackboard.
    ### 8. Delete the entire directory or zip the directory and submit the zipped directory.
    ### 9. Upload the.v file and your report to this repository.
    /Lab8/Instructions.md
    ## Lab 8 Instructions
    This lab focuses on **Simulation** of a function using **Verilog** and **Vivado HLS**.
    ### 1. Create a.v file as follows:
    ```
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ```
    ### 2. Run the **Simulation** tool.
    ### 3. Create a testbench to test the **func1** function.
    ```
    module tb;
    reg [0:0] x1 [0:0];
    reg [0:0] x2 [0:0];
    reg [0:0] x3 [0:0];
    reg [1:0] f [0:0];

    // signal declarations
    wire [1:0] f;

    // function call
    func1 func1_inst (.x1(x1),.x2(x2),.x3(x3),.f(f));

    // initial block
    always begin
    begin
        $monitor("func1(%0, %1, %2) = %3", x1, x2, x3, f);
        x1 <= ~x1;
        x2 <= ~x2;
        x3 <= ~x3;
        wait for 5 ns;
    end
    end
    endmodule
    ```
    ### 4. Run **Vivado HLS** to synthesize the testbench.
    ### 5. Create a **Makefile** as follows:
    ```
    testbench: tb.cpp
        g++ -o tb.exe tb.cpp

    clean:
        rm -rf tb.exe
    ```
    ### 6. Run **make**.
    ### 7. Generate test vectors and run the testbench.
    ### 8. Save the report.
    ```
    $ make
    ```
    ### 9. Submit your lab report and your hand-in directory to Blackboard.
    ### 10. Delete the entire directory or zip the directory and submit the zipped directory.
    ### 11. Upload the.v file, your report, and the zipped directory to this repository.
    /Lab10/Instructions.md
- code: |-
    module func4(x1, x2, x3, f);
    input x
- code: |-
    module func1(x1, x2, x3, f);
    input x1, x2, x3;
    output logic signed f;
    assign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 & x2 & ~x3);
    endmodule
    ### Test Instructions:
    1. Use the verilator to build the executable file and then execute the file.
    2. In the terminal, run the command:./verilator_exec
    3. This program will generate the output file as func1_out.txt. To view the output, run the file: cat func1_out.txt
    4. Note: You must have the.v file, func1_in.txt, and Makefile in the same directory.
    /Lab11/lab11_solution_p1.c
    #include <stdio.h>
    #include<time.h>
    #include<stdlib.h>

    // Define the size of the array
    #define N 16

    // Declare the function
    void gen_rand_array(int * const);
    void print_array(int *);
    void merge(int *, int, int, int);
    void merge_sort(int *, int, int);

    int main()
    {
       // Create the array that will hold the random numbers
       int array1[N];
       int index;
       int i;
       // Randomly generate the numbers for the array1
       gen_rand_array(array1);
       // Print the array before the sorting
       printf("Before: ");
       print_array(array1);
       // Use the merge sort function to sort the array
       merge_sort(array1, 0, N-1);
       // Print the array after the sorting
       printf("After: ");
       print_array(array1);
       return 0;
    }

    /*
       The merge_sort function uses the merge function to sort the array
       The function takes in the array to be sorted, the start and end index of the sub-array
       The function returns nothing
    */
    void merge_sort(int * const array, const int start, const int end)
    {
       // Declare i, j, and k
       int i, j, k;
       // Set i as the start index of the first sub-array
       i = start;
       // Set j as the end index of the second sub-array
       j = (start + end) / 2;
       // Set k as the end index of the sub-array
       k = end;
       // Check if the start index is less than the end index
       if (start < end)
       {
          // Call the merge_sort function recursively to sort the two sub-arrays
          merge_sort(array, start, j);
          merge_sort(array, (j + 1), end);
          // Call the merge function to merge the two sorted sub-arrays
          merge(array, i, j, k);
       }
    }

    /*
       The merge function takes in the array to be sorted, start, j, and k
       The function returns nothing
    */
    void merge(int * const array, const int i, const int j, const int k)
    {
       // Declare two index variables and the size of the first and second sub-arrays
       int p1, p2, size1, size2;
       // Set the size of the first sub-array to the middle minus the start index
       size1 = j - i;
       // Set the size of the second sub-array to the end minus the middle
       size2 = k - j;
       // Create two sub-arrays of the same sizes as the arrays to be sorted
       int *sub1 = malloc(si
       // Loop through the sub-array starting from the start index
       for(i = 0; i < size1; i++)
       {
          // Assign the elements at index i to sub-array 1
          sub1[i] = array[i + i];
       }
       // Loop through the second sub-array starting from the start index
       for(i = 0; i < size2; i++)
       {
          // Assign the element at index i to sub-array 2
          sub2[i] = array[i + j + 1];
       }
       // Free the sub-array memory
       free(sub1);
       free(sub2);
       // Set i as the start index of the first sub-array
       i = 0;
       // Set j as the start index of the second sub-array
       j = 0;
       // Set k as the start index of the sorted array
       k = i;
       // Loop to merge the two sub-arrays
       while(i < size1 && j < size2)
       {
          // Check if the element at index i in sub-array 1 is less than the element at index j in sub-array 2
          if(sub1[i] < sub2[j])
          {
             // Assign the element at index i in sub-array 1 to the element at index k in the sorted array
             array[k] = sub1[i];
             // Increment i and k
             i++;
             k++;
          }
          else
          {
             // Assign the element at index j in sub-array 2 to the element at index k in the sorted array
             array[k] = sub2[j];
             // Increment j and k
             j++;
             k++;
          }
       }
       // Loop to merge the remaining elements of the first sub-array
       while(i < size1)
       {
          // Assign the element at index i in sub-array 1 to the element at index k in the sorted array
          array[k] = sub1[i];
          // Increment i and k
          i++;
          k++;
       }
       // Loop to merge the remaining elements of the second sub-array
       while(j < size2)
       {
          // Assign the element at index j in sub-array 2 to the element at index k in the sorted array
          array[k] = sub2[j];
          // Increment j and k
          j++;
          k++;
       }
    }

    /*
       The gen_rand_array function takes in the array to be filled with random numbers
       The function returns nothing
    */
    void gen_rand_array(int * const array)
    {
        int i;
        // Seed the random number generator
        srand(time(NULL));
        // Loop to fill the array with random numbers between 0 and 100
        for(i = 0; i < N; i++)
        {
            // Assign a random number to the array element
            array[i] = rand() % 100;
        }
    }

    /*
       The print_array function takes in the array to be printed
       The function returns nothing
    */
    void print_array(int * array)
    {
        int i;
        int size = sizeof(array) / sizeof(int);
        // Loop to print each element of the array
        for(i = 0; i < size; i++)
        {
            // Print the array element
            printf("%d ", array[i]);
        }
        // Print a newline character
        printf("\n");
    }ze1 * sizeof(int));
       int *sub2 = malloc(size2 * sizeof(int));
       int i;
       // Loop to fill the sub-array 1
       for(i = 0; i < size1; i++)
       {
          // Assign the element at index i to sub-array 1
          sub1[i] = array[i + i];
       }
       // Loop to fill the sub-array 2
       for(i = 0; i < size2; i++)
       {
          // Assign the element at index i to sub-array 2
          sub2[i] = array[i + j + 1];
       }
       // Free the sub-array memory
       free(sub1);
       free(sub2);
       // Call the merge function recursively to merge the two sub-arrays
       merge_sort(array, i, j, k);
       merge_sort(array, (j + 1), k);
       // Call the merge function to merge the two sorted sub-arrays
       merge(array, i, j, k);
    }

    /*
       The merge function takes in the array to be sorted, start, j, and k
       The function returns nothing
    */
    void merge(int * const array, const int i, const int j, const int k)
    {
       // Declare three index variables and the size of the sorted array
       int p1, p2, size1, size2, size3;
       // Set the size of the first sub-array to the middle minus the start index
       size1 = j - i;
       // Set the size of the second sub-array to the end minus the middle
       size2 = k - j;
       // Allocate memory for the third sub-array
       int *sub1 = malloc(size1 * sizeof(int));
       int *sub2 = malloc(size2 * sizeof(int));
       int i;/HW2/HW2_Q2_part4_answer.c
    #include <stdio.h>
    #include <stdlib.h>

    // Declare the data type
    typedef struct data {
        int a;
        int b;
        int c;
        int
- code: "module func1(x1, x2, x3, f);\ninput x1, x2, x3;\noutput logic signed[3:0]\
    \ f;\nassign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 &\
    \ x2 & ~x3);\nendmodule\nThe result is shown below:\n<img src=\"https://github.com/shouzaoyang/EE343/blob/master/HW4/func1_signed.png\"\
    \ width=800 height=450>\n# EE 343:\n# EE 343:\n\nThis is a personal project for\
    \ the course *EE 343: Computer Organization*.\n\nI am a freshman in Harvard University,\
    \ and I am majoring in Electrical Engineering.\n\nThe project is to learn Verilog\
    \ and P&R.\n\n## Basic Verilog Code:\n \nmodule func1(x1, x2, x3, f);\ninput x1,\
    \ x2, x3;\noutput f;\nassign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2\
    \ & x3) | (x1 & x2 & ~x3);\nendmodule\n\n## Variation Instruction:\n\nChange the\
    \ output type from logic to logic signed to test signed logic vectors.\n\n## Modified\
    \ Code:\n \nmodule func1(x1, x2, x3, f);\ninput x1, x2, x3;\noutput logic signed[3:0]\
    \ f;\nassign f = (~x1 & ~x2 & x3) | (~x1 & x2 & ~x3) | (x1 & ~x2 & x3) | (x1 &\
    \ x2 & ~x3);\nendmodule"
- code: |-
    module func14(x, f);
    input x;
    output f;
    assign f = x? ~x : x;
    endmodule

    ### Base Verilog Code:
    module func15(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    assign f = ~x1 & x2 & ~x3 | ~x1 & ~x2 & x3 | ~x1 & x2 & x3 | x1 &
- code: |-
    module counter(clk, rst, q);
    input clk;
    input rst;
    output q;
    reg q;
    initial
    q = 0;
    always @(posedge clk or posedge rst)
    if(rst)
    $finish;
    else
    q = q + 1;
    endmodule
    ### Results of Synthesis:
    ![10.png](attachment:10.png)/lab-3/lab-3/isim/reg_testbench_isim_beh.exe.sim/work/m_00000000000248957200_2079936092.c
    /**********************************************************************/
    /*   ____  ____                                                       */
    /*  /   /\/   /                                                       */
    /* /___/  \  /                                                        */
    /* \   \   \/                                                       */
    /*  \   \        Copyright (c) 2003-2009 Xilinx
- code: |-
    library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

    entity func2 is
    port (
    x1 : in std_logic;
    x2 : in std_logic;
    x3 : in std_logic;
    f : out std_logic_vector(1 downto 0)
    );
    end func2;

    architecture Behavioral of func2 is
    signal x1_ : std_logic_vector(1 downto 0) := x1;
    signal x2_ : std_logic_vector(1 downto 0) := x2;
    signal x3_ : std_logic_vector(1 downto 0) := x3;
    begin
    f <= std_logic_vector((not x1_ and not x2_ and x3_) or (not x1_ and x2_ and not x3_) or (x1_ and not x2_ and x3_) or (x1_ and x2_ and not x3_));
    exception
    end Behavioral;
    ### Results:
    This will generate 256 possible function results and 256 possible input combinations.  Note that if we add another input, we will still only
- code: |-
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    endmodule
    ### Expected Results:

    Base and Variation enum inputs defaulting to 0.
    ### Actual Results:

    Base enum inputs defaulting to 0.
    Variation enum inputs defaulting to 1.

    ### Description:

    In the latest versions of Verilog, enum type inputs can take on a default base type. But if the enum has not been given an enum value, you will get the default base type. But if you try to pass a different enum value to the enum input, the code will work.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    endmodule
    ### Variation Instruction:
    Modify the code to pass a different enum value to the enum input.
    ### Expected Results:

    Base enum inputs defaulting to 0.
    ### Actual Results:

    Base enum inputs defaulting to 0.
    Variation enum inputs defaulting to 1.

    ### Description:

    In the latest versions of Verilog, enum type inputs can take on a default base type. But if the enum has not been given an enum value, you will get the default base type. But if you try to pass a different enum value to the enum input, the code will work.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    endmodule
    ### Variation Instruction:
    Modify the code to pass a different enum value to the enum input.
    ### Expected Results:

    Base enum inputs defaulting to 0.
    ### Actual Results:

    Base enum inputs defaulting to 0.
    Variation enum inputs defaulting to 1.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    Clock_Prog M2 (clk,1'h0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    Clock_Prog M2 (clk,1'h0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'b0);
    Clock_Prog M2 (clk,1'b0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    Clock_Prog M2 (clk,1'h0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'b0);
    Clock_Prog M2 (clk,1'b0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    Clock_Prog M2 (clk,1'h0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'b0);
    Clock_Prog M2 (clk,1'b0);
    endmodule
    module Clock_Prog (input clock, input rst);
    reg [1:0] state;
    initial state = 0;
    always @(posedge clock)
    case (state)
    0:
    begin
    #1 state = 1;
    end
    1:
    begin
    #1 state = 0;
    end
    default:
    endcase
    endmodule
    ### Variation Instruction:
    Modify the code to have a minimum number of module instances.
    ### Expected Results:

    module test_clock_proc should have 100% code coverage.
    ### Actual Results:

    module test_clock_proc should have 100% code coverage.

    ### Description:

    This is a test for module instance code coverage.

    ### Code:
    module t_Clock_Prog ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk,1'h0);
    Clock_Prog M2 (clk,1'h0);
    endmodule
    module Clock_Prog (input clock, input rst
- code: "Replace the Resetn input with an enum having default and non-default base\
    \ types to test enum coverage.\n#include \"testbench_Clock_Prog.h\"\n\n#include\
    \ \"verilated.h\"\n#include \"v_Clock_Prog.h\"\n#include \"v_Clock_Prog__Syms.h\"\
    \n\n#include <iostream>\n\nclass tb_Clock_Prog : public testbench_Clock_Prog\n\
    {\n    v_Clock_Prog *top;\n    v_Clock_Prog__Syms *top_sym_data;\n    // Verilator-generated\
    \ variables\n    // Internal signals to the top module\n    v_Clock_Prog__Syms\
    \ v__DOT__TOP____V;\n\npublic:\n    // Constructor\n    tb_Clock_Prog();\n   \
    \ // Destructor\n    ~tb_Clock_Prog();\n\n    // Initialize the C++ instance into\
    \ the Verilator simulation\n    void init(int argc, char *argv[]);\n    void begin_clock();\n\
    \n};\n\ntb_Clock_Prog::tb_Clock_Prog()\n{\n    // Construct the instance and its\
    \ symbols\n    top = new v_Clock_Prog;\n\n    // Construct the Verilator simulation\n\
    \    Verilated::commandArgs(argc, argv);\n    Verilated::traceEverOn(true);\n\n\
    \    // Initialize the symbols\n    // The'verilator' command line flag can be\
    \ used to override the default 'v' prefix\n    top_sym_data = new v_Clock_Prog__Syms(&top,\
    \ top, \"v__DOT__TOP____V\");\n    top_sym_data->mark_last_level_top();\n}\n\n\
    void tb_Clock_Prog::init(int argc, char *argv[])\n{\n    // Initialize the top-level\
    \ Verilator design\n    top->io_clock = 0;\n    top->io_resetn = 0;\n\n    //\
    \ Initialize the simulation\n    Verilated::commandArgs(argc, argv);\n    Verilated::debug(0);\n\
    \    Verilated::traceEverOn(true);\n    top->eval();\n    top_sym_data->sync_reset();\n\
    \    top->eval();\n\n    // If the above is undesirable, e.g. when sensitive to\
    \ clock and reset\n    // signal uncertainty, you might want to disable some of\
    \ them using the\n    // `Wno_` prefix (see Verilator manual: https://verific.cadence.com/doc/11.0/html/index.html#command_options)\n\
    }\n\nvoid tb_Clock_Prog::begin_clock()\n{\n    bool reset_active;\n\n    while\
    \ (!Verilated::gotFinish()) {\n        reset_active = (top->io_resetn == 0);\n\
    \n        if (reset_active && (top->io_clock == 0)) {\n            top_sym_data->clk\
    \ = 1;\n            Verilated::delay(1);\n            top->eval();\n         \
    \   top_sym_data->eval();\n            top_sym_data->clk = 0;\n            Verilated::delay(1);\n\
    \            top->eval();\n            top_sym_data->eval();\n        } else {\n\
    \            top_sym_data->clk = 1;\n            Verilated::delay(1);\n      \
    \      top->eval();\n            top_sym_data->eval();\n            top_sym_data->clk\
    \ = 0;\n            Verilated::delay(1);\n            top->eval();\n         \
    \   top_sym_data->eval();\n        }\n    }\n}\n\nint main(int argc, char *argv[])\n\
    {\n    tb_Clock_Prog tb_top;\n\n    // Run the simulation\n    tb_top.init(argc,\
    \ argv);\n    tb_top.begin_clock();\n}\n#ifndef testbench__h\n#define testbench__h\n\
    \n#include <systemc>\n\n// User-defined types\nenum clk_t {\n    CLK_LOW,\n  \
    \  CLK_HIGH\n};\nenum rst_t {\n    RST_ACTIVE\n};\n\nstruct testbench_Clock_Prog\n\
    {\n    virtual void io_clock(clk_t clk) = 0;\n    virtual void io_resetn(rst_t\
    \ rst_n) = 0;\n};\n\n#endif\n#include <systemc.h>\n#include <verilated.h>\n#include\
    \ <verilated_vcd_c.h>\n#include <stdio.h>\n#include <iostream>\n#include \"v_Clock_Prog.h\"\
    \n\nSC_MODULE(Clock_Prog)\n{\n    // IOs\n    sc_in<bool> clk;\n    sc_out<bool>\
    \ rst_n;\n\n    // Constructor\n    SC_CTOR(Clock_Prog)\n    {\n        SC_THREAD(ClockProg);\n\
    \        reset_signal_is(rst_n, false);\n    }\n\n    // Process\n    void ClockProg()\n\
    \    {\n        while (true) {\n            if (rst_n == 0) {\n              \
    \  sc_stop();\n            }\n            wait();\n        }\n    }\n};\n\nint\
    \ sc_main(int argc, char* argv[])\n{\n    // Verilator simulation\n    Verilated::commandArgs(argc,\
    \ argv);\n    Verilated::traceEverOn(true);\n\n    // Declare the module\n   \
    \ v_Clock_Prog u_Clock_Prog(\"v_Clock_Prog\");\n\n    // Connect IOs\n    u_Clock_Prog.clk(clk);\n\
    \    u_Clock_Prog.rst_n(rst_n);\n\n    // Dump the VCD trace\n    Verilated::traceEverOn(true);\n\
    \    VerilatedVcdC *t_Clock_Prog_trace = new VerilatedVcdC;\n    u_Clock_Prog.trace(t_Clock_Prog_trace,\
    \ 99);\n    t_Clock_Prog_trace->open(\"t_Clock_Prog.vcd\");\n    while (!Verilated::gotFinish())\
    \ {\n        clk = 1;\n        u_Clock_Prog.eval();\n        t_Clock_Prog_trace->dump(clk);\n\
    \        clk = 0;\n        u_Clock_Prog.eval();\n        t_Clock_Prog_trace->dump(clk);\n\
    \    }\n    t_Clock_Prog_trace->close();\n\n    // Run the simulation\n    clk\
    \ = 1;\n    sc_start(100, SC_NS);\n    clk = 0;\n    sc_start(100, SC_NS);\n\n\
    \    // Shutdown\n    SC_METHOD_EXIT(Clock_Prog, \"Clock_Prog\");\n    wait();\n\
    }\n# VHDL testbench\n\n## SystemC\n### Base HDL Code:\nmodule Clock_Prog;\nlibrary\
    \ IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\nentity Clock_Prog is \nend Clock_Prog;\n\
    \narchitecture beh of Clock_Prog is\nsignal clk : in std_logic;\nsignal rst_n:\
    \ in std_logic;\nbegin\nClock_Prog : process(clk, rst_n)\nbegin\nif rst_n='0'\
    \ then\nwait;\nend if;\nend process;\n\n-- Run the simulation\nlibrary IEEE;\n\
    use IEEE.STD_LOGIC_1164.ALL;\nlibrary work;\nuse work.Clock_Prog.all;\n\nentity\
    \ tb_Clock_Prog is\nend tb_Clock_Prog;\n\narchitecture arch of tb_Clock_Prog is\n\
    begin\nClock_Prog tb: entity work.Clock_Prog;\nclk: signal:= '0';\nrst_n: signal\
    \ := '0';\n\n-- Run the simulation\nlibrary work;\nuse work.Clock_Prog.all;\n\n\
    library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\
    \nentity Clock_Prog is \nend Clock_Prog;\n\narchitecture beh of Clock_Prog is\n\
    signal clk : in std_logic;\nsignal rst_n: in std_logic;\nbegin\nClock_Prog : process(clk,\
    \ rst_n)\nbegin\nif rst_n='0' then\nwait;\nend if;\nend process;\n\n-- Run the\
    \ simulation\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nlibrary work;\nuse\
    \ work.Clock_Prog.all;\n\nentity tb_Clock_Prog is\nend tb_Clock_Prog;\n\nlibrary\
    \ ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.std_logic_unsigned.all;\n\nentity\
    \ Clock_Prog is \nend Clock_Prog;\n\narchitecture beh of Clock_Prog is\nsignal\
    \ clk : in std_logic;\nsignal rst_n: in std_logic;\nbegin\nClock_Prog : process(clk,\
    \ rst_n)\nbegin\nif rst_n='0' then\nwait;\nend if;\nend process;\n#include <systemc.h>\n\
    #include <verilated.h>\n#include <verilated_vcd_c.h>\n#include <stdio.h>\n#include\
    \ <iostream>\n#include \"v_Clock_Prog.h\"\n\nSC_MODULE(Clock_Prog)\n{\n    //\
    \ IOs\n    sc_in<bool> clk;\n    sc_out<bool"
- code: "module t_Clock_Prog ();\nwire clock;\n\ninitial #100 $finish;\nClock_Prog\
    \ M1 (clk);\nendmodule\n/test_data/test03_011_case004/expected.c\n#include \"\
    system.h\"\n\nint main(void) {\n    enum en {A, B};\n    enum en b = B;\n    int\
    \ a;\n    switch ((int)b) {\n        case A:\n            a = 1; break;\n    \
    \    default:\n            a = 2; break;\n    }\n    return a;\n}\n/test_data/test03_012_case001/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    char a = 'e', b = 'd';\n    if\
    \ (a == b)\n        return 1;\n    else\n        return 0;\n}\n/test_data/test02_002_case014/expected.c\n\
    #include \"system.h\"\n\nint main() {\n    int a = 0x1000;\n    int b = 0x00FF;\n\
    \    int c = (a >> 8) | (b << 8);\n    return c;\n}\n/hw/lib/test/Makefile\n#\
    \ Copyright (c) 2014 \n\n# Permission is hereby granted, free of charge, to any\
    \ person obtaining a copy\n# of this software and associated documentation files\
    \ (the \"Software\"), to deal\n# in the Software without restriction, including\
    \ without limitation the rights\n# to use, copy, modify, merge, publish, distribute,\
    \ sublicense, and/or sell\n# copies of the Software, and to permit persons to\
    \ whom the Software is\n# furnished to do so, subject to the following conditions:\n\
    \n# The above copyright notice and this permission notice shall be included in\
    \ all\n# copies or substantial portions of the Software.\n\n# THE SOFTWARE IS\
    \ PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING\
    \ BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR\
    \ PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS\
    \ BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION\
    \ OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH\
    \ THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nMKFILE_PATH\
    \ := $(abspath $(lastword $(MAKEFILE_LIST)))\nMKFILE_DIR := $(dir $(MKFILE_PATH))\n\
    \nTARGETS = $(MKFILE_DIR)../sim/bin/verilator/V$(MKFILE_DIR)../test.o\n\n.PHONY:\
    \ all\n\nall: $(TARGETS)\n\n$(MKFILE_DIR)../sim/bin/verilator/V$(MKFILE_DIR)../test.o:\n\
    \tcd $(MKFILE_DIR)../sim/bin/verilator && $(MAKE) -C $(MKFILE_DIR)../../../../rtl/test\n\
    /README.md\n# Verilog to C Compiler\n\n[![Join the chat at https://gitter.im/mithi/v2cc](https://badges.gitter.im/mithi/v2cc.svg)](https://gitter.im/mithi/v2cc?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\
    \n[![Build status](https://travis-ci.org/mithi/v2cc.png)](https://travis-ci.org/mithi/v2cc)\n\
    \nThis repository contains the code base for the compiler project of [EECS340](https://courses.missouri.edu/faculty/carr/340.html)\
    \ at [MIT](https://www.mit.edu). The project is also hosted on [Gitlab](https://gitlab.com/mithi/v2cc).\n\
    \n## Requirements\n* [Verilator](http://www.veripool.org/wiki/verilator)\n* [Python\
    \ 2.7+](https://www.python.org)\n* [GNU Make](https://www.gnu.org/software/make)\n\
    * [Ruby](https://www.ruby-lang.org)\n\n## Usage\n\n```bash\n$ make\n$ make run\n\
    ```\n\n## References\n\n* https://github.com/mithi/compilers-class\n* https://github.com/wch/llvm-gcc-4.2\n\
    * https://github.com/karelzak/util-linux\n* https://github.com/sachaos/wllvm\n\
    * https://github.com/google/llvh/\n* http://www.openbsd.org/openbsd-6.3/src/sys/cdefs/\n\
    * https://github.com/kewilson/cmocka\n/test_data/test03_010_case003/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    typedef int my_type;\n    my_type\
    \ a = 2, b = 3;\n    return a + b;\n}\n/test_data/test02_010_case003/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    int a = 1 * 2 / 3 - 2 % 4;\n  \
    \  return a;\n}\n/test_data/test03_011_case002/expected.c\n#include \"system.h\"\
    \n\nint main(void) {\n    enum en {A, B};\n    int a = B;\n    a = 1;\n    return\
    \ a;\n}\n/test_data/test02_005_case004/expected.c\n#include \"system.h\"\n\nint\
    \ main(void) {\n    int a = -76 % 8;\n    int b = -76 % -8;\n    return a + b;\n\
    }\n/test_data/test02_003_case008/expected.c\n#include \"system.h\"\n\nint main(void)\
    \ {\n    int a = 3, b = 5, c = 7, d = 11;\n    int x = a / b / c / d;\n    int\
    \ y = a * b * c * d;\n    return x - y;\n}\n/test_data/test02_010_case006/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    int a = 1 + 2 % 3 - 4 - 5 * 6 /\
    \ 7 % 8 - 9 + 10 * 11;\n    return a;\n}\n/test_data/test02_005_case008/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    int a = 55 * 100 - 55, b = 55 *\
    \ 100 * 100 + 55;\n    return a + b;\n}\n/test_data/test02_002_case016/expected.c\n\
    #include \"system.h\"\n\nint main() {\n    int a = 0x00FF, b = 0x7F, c = 0x00FF,\
    \ d = 0xFF00;\n    int e = (a << 8) | (b >> 8);\n    int f = (c << 8) | (d >>\
    \ 8);\n    return e - f;\n}\n/test_data/test03_009_case001/expected.c\n#include\
    \ \"system.h\"\n\nint main(void) {\n    int a = 0x00001000;\n    int b = 0x10000000;\n\
    \    int c = a ^ b;\n    return c;\n}\n/test_data/test02_002_case006/expected.c\n\
    #include \"system.h\"\n\nint main() {\n    unsigned int a = 0x1000;\n    int b\
    \ = 0x1000;\n    if (a < b)\n        return 1;\n    else\n        return 0;\n\
    }\n/test_data/test02_010_case004/expected.c\n#include \"system.h\"\n\nint main(void)\
    \ {\n    int a = 2 + 4 * 3 - 4;\n    return a;\n}\n/test_data/test02_005_case006/expected.c\n\
    #include \"system.h\"\n\nint main(void) {\n    int a = 15 / 2 - 4;\n    int b\
    \ = 15 % 2 + 4;\n    return"
- code: |-
    module t_Clock_Prog_Variant ();
    wire clock;

    initial #100 $finish;
    Clock_Prog M1 (clk);
    endmodule
    #### Results:
    |File|Result|Type|Message|Pass/Fail|
    |:---:|:---:|:---:|:---:|:---:|
    |Verilog/t_Clock_Prog_Variant.v|Pass|Behavioral|Finished|Pass|
    '''
    This file contains the main function to compile the verilog files
    '''

    import os
    import sys
    from argparse import ArgumentParser
    from pathlib import Path
    from Verilog import Verilog
    import logging

    LOGGER = logging.getLogger()
    LOGGER.setLevel(logging.INFO)

    def argument_parser():
        '''
        Parses the input arguments
        '''
    #    parser = ArgumentParser(description='Verilog Compiler')
        parser = ArgumentParser(description='Verilog Compiler')
        parser.add_argument('-l', '--log', default='null', help='log level, default is null')
        return parser

    def main():
        '''
        Main function to compile the Verilog files
        '''
        parser = argument_parser()
        args = parser.parse_args()
        if args.log == 'null':
            logging_level = logging.INFO
        else:
            logging_level = args.log
        LOGGER.setLevel(logging_level)
        print("Entering Compile Function")
        file_name = sys.argv[1]
        print(file_name)
        verilog = Verilog(file_name)
        verilog.compile_file()
        print("Entering Compile Function Successful")

    if __name__ == '__main__':
        main()
    '''
    This file contains the base class for the Verilog class
    '''

    import os
    import logging
    LOGGER = logging.getLogger()

    class Verilog():
        '''
        Base class for Verilog class
        '''
        def __init__(self, file_name):
            self.file_name = file_name
            self.module_name = ''
            self.test_module_name = ''
            self.input_ports = []
            self.output_ports = []
            self.wire_ports = []
            self.local_ports = []
            self.submodules = []
            self.initial_sections = []
            self.always_sections = []
            self.always_comb_sections = []
            self.always_ff_sections = []
            self.always_latch_sections = []
            self.module_sections = []
            self.end_sections = []
            self.always_sections_comb = []
            self.always_sections_ff = []
            self.always_sections_latch = []
            self.always_latch_sections_comb = []
            self.always_latch_sections_ff = []

        def set_file_name(self, file_name):
            self.file_name = file_name

        def get_file_name(self):
            return self.file_name

        def set_module_name(self, module_name):
            self.module_name = module_name

        def get_module_name(self):
            return self.module_name

        def set_test_module_name(self, test_module_name):
            self.test_module_name = test_module_name

        def get_test_module_name(self):
            return self.test_module_name

        def set_input_ports(self, input_ports):
            self.input_ports = input_ports

        def get_input_ports(self):
            return self.input_ports

        def set_output_ports(self, output_ports):
            self.output_ports = output_ports

        def get_output_ports(self):
            return self.output_ports

        def set_wire_ports(self, wire_ports):
            self.wire_ports = wire_ports

        def get_wire_ports(self):
            return self.wire_ports

        def set_local_ports(self, local_ports):
            self.local_ports = local_ports

        def get_local_ports(self):
            return self.local_ports

        def set_submodules(self, submodules):
            self.submodules = submodules

        def get_submodules(self):
            return self.submodules

        def set_initial_sections(self, initial_sections):
            self.initial_sections = initial_sections

        def get_initial_sections(self):
            return self.initial_sections

        def set_always_sections(self, always_sections):
            self.always_sections = always_sections

        def get_always_sections(self):
            return self.always_sections

        def set_always_comb_sections(self, always_comb_sections):
            self.always_comb_sections = always_comb_sections

        def get_always_comb_sections(self):
            return self.always_comb_sections

        def set_always_ff_sections(self, always_ff_sections):
            self.always_ff_sections = always_ff_sections

        def get_always_ff_sections(self):
            return self.always_ff_sections

        def set_always_latch_sections(self, always_latch_sections):
            self.always_latch_sections = always_latch_sections

        def get_always_latch_sections(self):
            return self.always_latch_sections

        def set_always_sections_comb(self, always_sections_comb):
            self.always_sections_comb = always_sections_comb

        def get_always_sections_comb(self):
            return self.always_sections_comb

        def set_always_sections_ff(self, always_sections_ff):
            self.always_sections_ff = always_sections_ff

        def get_always_sections_ff(self):
            return self.always_sections_ff

        def set_always_latch_sections_comb(self, always_latch_sections_comb):
            self.always_latch_sections_comb = always_latch_sections_comb

        def get_always_latch_sections_comb(self):
            return self.always_latch_sections_comb

        def set_always_latch_sections_ff(self, always_latch_sections_ff):
            self.always_latch_sections_ff = always_latch_sections_ff

        def get_always_latch_sections_ff(self):
            return self.always_latch_sections_ff

        def set_module_sections(self, module_sections):
            self.module_sections = module_sections

        def get_module_sections(self):
            return self.module_sections

        def set_end_sections(self, end_sections):
            self.end_sections = end_sections

        def get_end_sections(self):
            return self.end_sections

        def get_always_latch_sections(self):
            return self.always_latch_sections
    '''
    This file contains the main function to compile the verilog files
    '''

    ### Import Statements:
    #import os
    #import logging
    #LOGGER = logging.getLogger()

    ### Class Declarations:
    from Verilog import Verilog

    ### Main Function:
    def main():
        file_name = 'Test.v'
        print("Test")
        verilog = Verilog(file_name)
        verilog.compile_file()

    if __name__ == '__main__':
        main()
    '''
    This file contains the base class for the Verilog class
    '''

    import os
    import logging
    LOGGER = logging.getLogger()

    class Verilog():
        '''
        Base class for Verilog class
        '''
        def __init__(self, file_name):
            self.file_name = file_name
            self.module_name = ''
            self.test_module_name = ''
            self.input_ports = []
            self.output_ports = []
            self.wire_ports = []
            self.local_ports = []
            self.submodules = []
            self.initial_sections = []
            self.always_sections = []
            self.always_comb_sections = []
            self.always_ff_sections = []
            self.always_latch_sections = []
            self.module_sections = []
            self.end_sections = []
            self.always_sections_comb = []
            self.always_sections_ff = []
            self.always_sections_latch = []
            self.always_latch_sections_comb
- code: "module t_Clock_Prog ();\nwire clock;\n\ninitial #100 $finish;\nClock_Prog\
    \ M1 (clk);\nendmodule\n### Results:\n![image](https://user-images.githubusercontent.com/39609900/54275994-229d3f00-45b6-11e9-9488-73316d34bf74.png)\n\
    /Vivado/Testing/Clock_Prog/Clock_Prog_0.py\n#!/usr/bin/env python\n# coding: utf-8\n\
    \n# In[1]:\n\n\n# import the module\nimport os\nimport shutil\nfrom pathlib import\
    \ Path\nimport sys\nimport argparse\nfrom math import *\nimport numpy as np\n\
    import pandas as pd\nimport re\nimport subprocess\nimport time\nimport collections\
    \ \nfrom collections import OrderedDict\nfrom datetime import datetime\nfrom time\
    \ import gmtime, strftime\nimport string\nfrom scipy import stats\nimport random\n\
    \n\n# In[2]:\n\n\ndef main():\n\n\t# Initialize variables\n\targs = parse_args()\n\
    \tprint_args(args)\n\tproject_dir = args.project_dir\n\tdir_name = args.dir_name\n\
    \tbase_proj = args.base_proj\n\tdir_path = str(Path(project_dir, dir_name))\n\t\
    temp_verilog_path = str(Path(project_dir, base_proj.replace('.xise', '_Temp.xise')))\n\
    \n\tprint(\"\\n\\n\")\n\tprint(\"################################################\"\
    )\n\tprint(\"Running script for folder {} in directory {}\".format(dir_name, project_dir))\n\
    \tprint(\"################################################\")\n\tprint(\"\\n\\\
    n\")\n\n\t# run main files\n\tbuild_temp_verilog_file(project_dir, dir_path, dir_name,\
    \ base_proj, temp_verilog_path)\n\trun_tests(project_dir, dir_path, dir_name,\
    \ base_proj, temp_verilog_path)\n\n\t# end of script\n\tprint(\"\\n\\n\")\n\t\
    print(\"################################################\")\n\tprint(\"Completed\
    \ running script for folder {} in directory {}\".format(dir_name, project_dir))\n\
    \tprint(\"################################################\")\n\tprint(\"\\n\\\
    n\")\n\n\n# In[3]:\n\n\ndef parse_args():\n\t\"\"\"Command-line interface (argument\
    \ parser).\"\"\"\n\tparser = argparse.ArgumentParser(description='This is the\
    \ command line interface for running the main script')\n\tparser.add_argument('-p',\
    \ '--project_dir', required=True, help='The root directory for the project.')\n\
    \tparser.add_argument('-d', '--dir_name', required=True, help='The name of the\
    \ directory where the test files are located.')\n\tparser.add_argument('-b', '--base_proj',\
    \ required=True, help='The base file name of the project')\n\n\treturn parser.parse_args()\n\
    \n\n# In[4]:\n\n\ndef print_args(args):\n\t\"\"\"Print command line arguments.\"\
    \"\"\n\tprint('Project directory: {}'.format(args.project_dir))\n\tprint('Directory\
    \ name: {}'.format(args.dir_name))\n\tprint('Base file name: {}'.format(args.base_proj))\n\
    \n\n# In[5]:\n\n\ndef build_temp_verilog_file(project_dir, dir_path, dir_name,\
    \ base_proj, temp_verilog_path):\n\t\"\"\"Copy base projcet to new folder with\
    \ new file names and changes to base file\"\"\"\n\t# Make new directory\n\tprint(\"\
    Creating directory for {}/ folder\".format(dir_name))\n\tos.mkdir(dir_path)\n\n\
    \t# Copy base project to new folder\n\tshutil.copyfile(base_proj, temp_verilog_path)\n\
    \n\t# Change file name in base verilog file\n\tprint(\"Changing file name in base\
    \ verilog file\")\n\treplace_string = base_proj.replace('.xise', '_Temp')\n\t\
    with open(temp_verilog_path, 'r') as input_file:\n\t    lines = input_file.readlines()\n\
    \twith open(temp_verilog_path, 'w') as output_file:\n\t    for line in lines:\n\
    \t        output_file.write(line.replace(base_proj, replace_string))\n\n\tprint(\"\
    Done changing file name in base verilog file\")\n\n\t# Change directory references\
    \ in base verilog file\n\tprint(\"Changing directory references in base verilog\
    \ file\")\n\twith open(temp_verilog_path, 'r') as input_file:\n\t    lines = input_file.readlines()\n\
    \twith open(temp_verilog_path, 'w') as output_file:\n\t    for line in lines:\n\
    \t        output_file.write(line.replace('$(TOPLEVEL_PROJECT)', dir_name))\n\n\
    \tprint(\"Done changing directory references in base verilog file\")\n\n\t# Change\
    \ file name in test file\n\tprint(\"Changing file names in test file\")\n\ttest_file_path\
    \ = str(Path(dir_path, dir_name + '.xise'))\n\twith open(test_file_path, 'r')\
    \ as input_file:\n\t    lines = input_file.readlines()\n\twith open(test_file_path,\
    \ 'w') as output_file:\n\t    for line in lines:\n\t        output_file.write(line.replace(base_proj,\
    \ replace_string))\n\n\tprint(\"Done changing file names in test file\")\n\n\n\
    # In[6]:\n\n\ndef run_tests(project_dir, dir_path, dir_name, base_proj, temp_verilog_path):\n\
    \t\"\"\"Run tests in new folder\"\"\"\n\tprint(\"Running tests in new folder\"\
    )\n\tos.chdir(dir_path)\n\n\t# Create project name\n\tproject_name = dir_name\
    \ + \"Test\"\n\n\t# Run vivado\n\tprint(\"Running vivado\")\n\tos.system(\"vivado\
    \ -mode tcl -source run_vivado_script.tcl -tclargs \" + str(dir_name) + \" \"\
    \ + str(base_proj.replace('.xise', '.srcs')) + \" \" + str(project_dir) + \" \"\
    \ + str(project_name) + \" \")\n\n\t# Run xvlog\n\tprint(\"Running xvlog\")\n\t\
    os.system(\"xvlog -sv \" + str(dir_name) + \".sv \" + str(dir_name) + \"_Main.v\
    \ \" + str(dir_name) + \"_Interface.v \" + str(project_name) + \".srcs \" + str(project_name)\
    \ + \".tcl\")\n\n\t# Run xelab\n\tprint(\"Running xelab\")\n\tos.system(\"xelab\
    \ \" + str(dir_name) + \"_Main \" + str(dir_name) + \"_Interface -l \" + str(project_name)\
    \ + \"_log\")\n\n\t# Run xsim\n\tprint(\"Running xsim\")\n\tos.system(\"xsim \"\
    \ + str(dir_name) + \"_Main \" + str(dir_name) + \"_Interface \" + str(project_name)\
    \ + \"_log -gui\")\n\n\t# Remove project\n\tprint(\"Removing project\")\n\tos.chdir(project_dir)\n\
    \tos.system(\"rm -r \" + str(project_dir) + \"/\" + str(project_name))\n\n\tprint(\"\
    Done running tests in new folder\")\n\n\n# In[7]:\n\n\nif __name__ == '__main__':\n\
    \tmain()\n/Vivado/Testing/Multiport_Mux/Multiport_Mux_1.py\n#!/usr/bin/env python\n\
    # coding: utf-8\n\n# In[1]:\n\n\n# import the module\nimport os\nimport shutil\n\
    from pathlib import Path\nimport sys\nimport argparse\nfrom math import *\nimport\
    \ numpy as np\nimport pandas as pd\nimport re\nimport subprocess\nimport time\n\
    import collections \nfrom collections import OrderedDict\nfrom datetime import\
    \ datetime\nfrom time import gmtime, strftime\nimport string\nfrom scipy import\
    \ stats\nimport random\n\n\n# In[2]:\n\n\ndef main():\n\n\t# Initialize variables\n\
    \targs = parse_args()\n\tprint_args(args)\n\tproject_dir = args.project_dir\n\t\
    dir_name = args.dir_name\n\tbase_proj = args.base_proj\n\tdir_path = str(Path(project_dir,\
    \ dir_name))\n\ttemp_verilog_path = str(Path(project_dir, base_proj.replace('.xise',\
    \ '_Temp.xise')))\n\n\tprint(\"\\n\\n\")\n\tprint(\"################################################\"\
    )\n\tprint(\"Running script for folder {} in directory {}\".format(dir_name, project_dir))\n\
    \tprint(\"################################################\")\n\tprint(\"\\n\\\
    n\")\n\n\t# run main files\n\tbuild_temp_verilog_file(project_dir, dir_path, dir_name,\
    \ base_proj, temp_verilog_path)\n\trun_tests(project_dir, dir_path, dir_name,\
    \ base"
- code: |-
    module t_Enum_Prog ();
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var = e_Enum_Type_2;

    initial #100 $finish;

    always @* begin
        $display("enum_var = %d", enum_var);
    end
    endmodule
    ### Expected Output:

    ```
    $ yosys -p "synth_ice40 -blif test.blif" t_Enum_Prog.v
    [...]

    ```

    ## SystemC Coverage

    The goal of this testbench is to test basic functionality and systemC coverage of C++ enum variables in Verilog code. This goal includes code coverage of all enum types and all enum variables. The testbench produces a list of missing elements for the enum variable and enum type it is declared in.

    The code produced by the testbench is a module consisting of an enum variable and a Verilog process to output that variable's value at $time and $time 101 times.

    ### Base SystemC Code:
    `class t_Enum_Prog: public sc_module {
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var;

    SC_CTOR(t_Enum_Prog) {
        SC_THREAD(run);
    }

    void run () {
        enum_var = e_Enum_Type_2;

        int i = 0;
        while (true) {
            cout << time_stamp() << " enum_var = " << enum_var << endl;
            wait(100, SC_NS);
        }
    }
    };
    `
    ### Variation Instruction:
    Replace the enum variable with an enum type variable with default and non-default base types to test enum type coverage.
    ### Modified SystemC Code:
    `class t_Enum_Prog: public sc_module {
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var;

    SC_CTOR(t_Enum_Prog) {
        SC_THREAD(run);
    }

    void run () {
        enum_var = e_Enum_Type_2;

        int i = 0;
        while (true) {
            cout << time_stamp() << " enum_var = " << enum_var << endl;
            wait(100, SC_NS);
        }
    }
    };
    `
    ### Expected Output:

    ```
    $ vsim -c -do "run -all; quit" t_Enum_Prog

    ```

    ## SystemC Behavioral Coverage

    The goal of this testbench is to test basic functionality and systemC coverage of C++ enum variables in Verilog code. This goal includes code coverage of all enum types and all enum variables. The testbench produces a list of missing elements for the enum variable and enum type it is declared in.

    The code produced by the testbench is a module consisting of an enum variable and a Verilog process to output that variable's value at $time and $time 101 times.

    ### Base SystemC Code:
    `class t_Enum_Prog: public sc_module {
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var;

    SC_CTOR(t_Enum_Prog) {
        SC_THREAD(run);
    }

    void run () {
        enum_var = e_Enum_Type_2;

        int i = 0;
        while (true) {
            cout << time_stamp() << " enum_var = " << enum_var << endl;
            wait(100, SC_NS);
        }
    }
    };
    `
    ### Variation Instruction:
    Replace the enum variable with an enum type variable with default and non-default base types to test enum type coverage.
    ### Modified SystemC Code:
    `class t_Enum_Prog: public sc_module {
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var;

    SC_CTOR(t_Enum_Prog) {
        SC_THREAD(run);
    }

    void run () {
        enum_var = e_Enum_Type_2;

        int i = 0;
        while (true) {
            cout << time_stamp() << " enum_var = " << enum_var << endl;
            wait(100, SC_NS);
        }
    }
    };
    `
    ### Expected Output:

    ```
    $ vsim -c -do "run -all; quit" t_Enum_Prog

    ```

    ## SystemC Structural Coverage

    The goal of this testbench is to test basic functionality and systemC coverage of C++ enum variables in Verilog code. This goal includes code coverage of all enum types and all enum variables. The testbench produces a list of missing elements for the enum variable and enum type it is declared in.

    The code produced by the testbench is a module consisting of an enum variable and a Verilog process to output that variable's value at $time and $time 101 times.

    ### Base SystemC Code:
    `class t_Enum_Prog: public sc_module {
    enum e_Enum_Type {
        e_Enum_Type_1,
        e_Enum_Type_2,
        e_Enum_Type_3
    };

    e_Enum_Type enum_var;
- code: |-
    module t_Clock_Prog ();
    wire reset;

    initial #100 $finish;
    Clock_Prog M1 (reset, clk);
    endmodule
    ### Expected
- code: |-
    module t_Clock_Prog ();
    wire clock;
    enum {clock_in,no_clock} clock_type;
    reg reset;
    reg reset_en;

    initial #10
- code: "```\nmodule t_Clock_Prog ();\n\nenum resetn_enum {\n\tDEFAULT,\n\tNONDEFAULT\n\
    };\n\ninput [0:0] clk;\ninput [0:0] resetn;\noutput [0:0] clock;\n\nassign resetn\
    \ = 1'b1;\n\nendmodule\n```\n\n##### Test Plan:\n| Test ID | Test Sequence | Test\
    \ Description | Expected Output |\n| ------- | ------------- | ----------------\
    \ | --------------- |\n| 1 | clk high, resetn high | Clock is high and Resetn\
    \ is high. | clock low |\n| 2 | clk high, resetn low | Clock is high and Resetn\
    \ is low. | clock low |\n| 3 | clk low, resetn high | Clock is low and Resetn\
    \ is high. | clock high |\n| 4 | clk low, resetn low | Clock is low and Resetn\
    \ is low. | clock high |\n\n\n\n\n/examples/c++_examples/systemc_examples/ex1_simple_design/test_sim.cpp\n\
    #include \"systemc\"\n#include \"clock_prog.h\"\n\nSC_MODULE(test_clock_prog){\n\
    \tsc_in<bool> clk;\n\tsc_in<bool> resetn;\n\tsc_out<bool> clock;\n\n\tvoid test();\n\
    \n\tSC_CTOR(test_clock_prog){\n\t\tSC_THREAD(test);\n\t\tsensitive<<clk.pos();\n\
    \t}\n\n};\n\nvoid test_clock_prog::test(){\n\tstd::cout<<\"Test Sequence: clk\
    \ high, resetn high\"<<std::endl;\n\tstd::cout<<\"Clock is high and Resetn is\
    \ high.\"<<std::endl;\n\tclock.write(false);\n\twait();\n\tstd::cout<<\"clock:\
    \ \"<<clock.read()<<std::endl;\n\tstd::cout<<\"Test Sequence: clk high, resetn\
    \ low\"<<std::endl;\n\tstd::cout<<\"Clock is high and Resetn is low.\"<<std::endl;\n\
    \tclock.write(false);\n\twait();\n\tstd::cout<<\"clock: \"<<clock.read()<<std::endl;\n\
    \tstd::cout<<\"Test Sequence: clk low, resetn high\"<<std::endl;\n\tstd::cout<<\"\
    Clock is low and Resetn is high.\"<<std::endl;\n\tclock.write(true);\n\twait();\n\
    \tstd::cout<<\"clock: \"<<clock.read()<<std::endl;\n\tstd::cout<<\"Test Sequence:\
    \ clk low, resetn low\"<<std::endl;\n\tstd::cout<<\"Clock is low and Resetn is\
    \ low.\"<<std::endl;\n\tclock.write(true);\n\twait();\n\tstd::cout<<\"clock: \"\
    <<clock.read()<<std::endl;\n\n}\n\nint sc_main(int argc, char* argv[]){\n\t\n\t\
    sc_signal<bool> clk;\n\tsc_signal<bool> resetn;\n\tsc_signal<bool> clock;\n\n\t\
    test_clock_prog t1(\"t1\");\n\tt1.clk(clk);\n\tt1.resetn(resetn);\n\tt1.clock(clock);\n\
    \n\tsc_start(2, SC_NS);\n\tclk = 1;\n\tsc_start(2, SC_NS);\n\tclk = 0;\n\tsc_start(100,\
    \ SC_NS);\n\tresetn = 1;\n\tsc_start(40, SC_NS);\n\tclk = 1;\n\tsc_start(40, SC_NS);\n\
    \tclk = 0;\n\tsc_start(40, SC_NS);\n\tresetn = 0;\n\tsc_start(40, SC_NS);\n\t\
    clk = 1;\n\tsc_start(40, SC_NS);\n\tclk = 0"
- code: "1. t_Clock_Prog.v\n\n```\n\nmodule t_Clock_Prog ();\n\nreg default_enum_status\
    \ = 1'b0;\nenum enum_status { default_enum_status, non_default_enum_status };\n\
    \nwire clock;\n\ninitial #100 $finish;\nClock_Prog M1 (clk, enum_status [1], enum_status\
    \ [1], default_enum_status, enum_status [1], enum_status [1]);\n\nendmodule\n\
    ```\n2. Clock_Prog.v\n\n```\n\nmodule Clock_Prog ( clk, input_array [0], input_array\
    \ [1], output_array [0], output_array [1], resetn_enum, enable_array [0], enable_array\
    \ [1] );\n\nreg [3:0] input_array [0];\nreg [3:0] input_array [1];\nreg [3:0]\
    \ output_array [0];\nreg [3:0] output_array [1];\nreg clk;\nreg resetn_enum;\n\
    reg [1:0] enable_array [0];\nreg [1:0] enable_array [1];\nreg [1:0] [1:0] enum_status\
    \ [1:0];\nreg [2:0] [1:0] enum_status_0 [1:0];\nreg [2:0] [1:0] enum_status_1\
    \ [1:0];\n\ninitial clk = 0;\ninitial resetn_enum = 1'b0;\ninitial enum_status\
    \ [1:0] = 2'b00;\ninitial enum_status_0 [1:0] = 2'b00;\ninitial enum_status_1\
    \ [1:0] = 2'b00;\ninitial enable_array [0] = 1'b1;\ninitial enable_array [1] =\
    \ 1'b1;\ninitial input_array [1] = 4'b1010;\ninitial output_array [0] = 4'b0101;\n\
    initial output_array [1] = 4'b1011;\n\nClock_Prog_L0 L0(clk, clk, resetn_enum,\
    \ enum_status [0], ~enum_status [0], input_array [0], output_array [0], enable_array\
    \ [0]);\nClock_Prog_L1 L1(clk, clk, resetn_enum, enum_status [1], ~enum_status\
    \ [1], input_array [1], output_array [1], enable_array [1]);\n\nendmodule\n```\n\
    3. Clock_Prog_L0.v\n\n```\n\nmodule Clock_Prog_L0 ( clk, resetn_enum, enable_array\
    \ [0], input_array, output_array );\n\nreg clk;\nreg enum_status [1:0];\nreg resetn_enum;\n\
    reg [1:0] [1:0] enable_array [1:0];\nreg [3:0] input_array;\nreg [3:0] output_array;\n\
    reg [3:0] [1:0] [3:0] [1:0] [1:0] output_array_0 [1:0];\nreg [3:0] [1:0] [3:0]\
    \ [1:0] [1:0] output_array_1 [1:0];\n\ninitial clk = 0;\ninitial enum_status [1:0]\
    \ = 2'b00;\ninitial resetn_enum = 1'b1;\ninitial enable_array [0] = 1'b1;\ninitial\
    \ enable_array [1] = 1'b1;\ninitial input_array = 4'b0000;\ninitial output_array\
    \ = 4'b0000;\ninitial output_array_0 [1:0] = 4'b0000;\ninitial output_array_1\
    \ [1:0] = 4'b0000;\n\nalways @(posedge clk or negedge resetn_enum) begin\n\tif\
    \ (~resetn_enum) begin\n\t\tcase (enum_status [0])\n\t\t\t3'b000 : begin\n\t\t\
    \t\toutput_array_0 [0] = 4'b0000;\n\t\t\t\toutput_array_0 [1] = 4'b0000;\n\t\t\
    \tend\n\t\t\t3'b001 : begin\n\t\t\t\toutput_array_0 [0] = 4'b0000;\n\t\t\t\toutput_array_0\
    \ [1] = 4'b0101;\n\t\t\tend\n\t\t\t3'b010 : begin\n\t\t\t\toutput_array_0 [0]\
    \ = 4'b1010;\n\t\t\t\toutput_array_0 [1] = 4'b0101;\n\t\t\tend\n\t\t\t3'b011 :\
    \ begin\n\t\t\t\toutput_array_0 [0] = 4'b1010;\n\t\t\t\toutput_array_0 [1] = 4'b0101;\n\
    \t\t\tend\n\t\t\t3'b100 : begin\n\t\t\t\toutput_array_0 [0] = 4'b0000;\n\t\t\t\
    \toutput_array_0 [1] = 4'b0011;\n\t\t\tend\n\t\t\t3'b101 : begin\n\t\t\t\toutput_array_0\
    \ [0] = 4'b0000;\n\t\t\t\toutput_array_0 [1] = 4'b0110;\n\t\t\tend\n\t\t\t3'b110\
    \ : begin\n\t\t\t\toutput_array_0 [0] = 4'b1010;\n\t\t\t\toutput_array_0 [1] =\
    \ 4'b0110;\n\t\t\tend\n\t\t\t3'b111 : begin\n\t\t\t\toutput_array_0 [0] = 4'b1010;\n\
    \t\t\t\toutput_array_0 [1] = 4'b0110;\n\t\t\tend\n\t\tend\n\t\tcase (enum_status\
    \ [1])\n\t\t\t3'b000 : begin\n\t\t\t\toutput_array_1 [0] = 4'b0000;\n\t\t\t\t\
    output_array_1 [1] = 4'b0000;\n\t\t\tend\n\t\t\t3'b001 : begin\n\t\t\t\toutput_array_1\
    \ [0] = 4'b0000;\n\t\t\t\toutput_array_1 [1] = 4'b0101;\n\t\t\tend\n\t\t\t3'b010\
    \ : begin\n\t\t\t\toutput_array_1 [0] = 4'b1010;\n\t\t\t\toutput_array_1 [1] =\
    \ 4'b0101;\n\t\t\tend\n\t\t\t3'b011 : begin\n\t\t\t\toutput_array_1 [0] = 4'b1010;\n\
    \t\t\t\toutput_array_1 [1] = 4'b0101;\n\t\t\tend\n\t\t\t3'b100 : begin\n\t\t\t\
    \toutput_array_1 [0] = 4'b0000;\n\t\t\t\toutput_array_1 [1] = 4'b0011;\n\t\t\t\
    end\n\t\t\t3'b101 : begin\n\t\t\t\toutput_array_1 [0] = 4'b0000;\n\t\t\t\toutput_array_1\
    \ [1] = 4'b0110;\n\t\t\tend\n\t\t\t3'b110 : begin\n\t\t\t\toutput_array_1 [0]\
    \ = 4'b1010;\n\t\t\t\toutput_array_1 [1] = 4'b0110;\n\t\t\tend\n\t\t\t3'b111 :\
    \ begin\n\t\t\t\toutput_array_1 [0] = 4'b1010;\n\t\t\t\toutput_array_1 [1] = 4'b0110;\n\
    \t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\toutput_array_0 [0] = 4'b0000;\n\t\
    \t\toutput_array_0 [1] = 4'b0000;\n\t\t\toutput_array_1 [0] = 4'b0000;\n\t\t\t\
    output_array_1 [1] = 4'b0000;\n\t\tend\n\tendcase\nend\n\nalways @(posedge clk\
    \ or negedge resetn_enum) begin\n\tif (~resetn_enum) begin\n\t\tcase (enum_status\
    \ [0])\n\t\t\t3'b000 : begin\n\t\t\t\toutput_array_0 [0] = 4'b0000;\n\t\t\t\t\
    output_array_0 [1] = 4'b0000;\n\t\t\tend\n\t\t\t3'b001 : begin\n\t\t\t\toutput_array_0\
    \ [0] = 4'b1010;\n\t\t\t\toutput_array_0 [1] = 4'b0101;\n\t\t\tend"
- code: "```\nmodule ra(s,c,a,b);\n  input a[3:0],b[3:0]; output [3:0] s,c;\n  ha_packed\
    \ #(3) #(1) (s,a,b);\nendmodule\n```\n### New Test Case:\nNew test case has to\
    \ be generated with random inputs for the packed structure and then the values\
    \ for the individual members of the structure have to be extracted from the packed\
    \ structure.\n\n---\n## Pack and Unpack:\nCreate a new Verilog module ha_packed\
    \ that has a parameter called depth, which is the number of bits in the packed\
    \ array. Implement a packing instruction that takes an array of 2 depth bits and\
    \ packs them into an array of depth+1 bits, and an unpacking instruction that\
    \ takes in an array of depth+1 bits and unpacks them into two depth-bit arrays.\n\
    \n```\nmodule ha_packed(s,a,b);\n  unpacked #(1) (s,a);\nendmodule\n```\n\n---\n\
    ## Pack and Unpack Verilog Code:\n```\nmodule ha_packed(s,a,b);\n  unpacked_packed\
    \ #(1) (s,a,b);\nendmodule\n```\n\n---\n## Pack and Unpack Assembly Code:\n```\n\
    \tsub\tr2,r2,r2\n\tj\tlabel\n\tlabel:\tadd\tr1,r1,r1\n\tmul\tr2,r2\n\tand\tr1,r1,r2\n\
    ```\n\n---\n## Pack and Unpack Test Case:\nNew test case has to be generated with\
    \ random inputs for the packed structure and then the values for the individual\
    \ members of the structure have to be extracted from the packed structure.\n\n\
    ---\n## Verilog Code:\n```\nmodule ha_packed(s,c,a,b);\n  input a[3:0],b[3:0];\
    \ output [3:0] s,c;\n  ha #(1,4) (s[1],s[0],a[1],b[1]);\n  ha #(1,4) (c[1],a[0],b[0]);\n\
    \  ha #(1,4) (s[0],c[0],a[0],b[0]);\nendmodule\n```\n\n---\n## Assembly Code:\n\
    ```\n\tand \tr3,r1,r1\n\tmov\tr2,r1\n\tor\t\tr1,r2,r3\n\tmov\tr2,r1\n\tor\t\t\
    r1,r2,r3\n\tmov\tr2,r1\n\tor\t\tr1,r2,r3\n```\n\n---\n## Verilog Code:\n```\n\
    module ha_packed(s,a,b);\n  unpacked #(1) (s,a,b);\nendmodule\n```\n\n---\n##\
    \ Assembly Code:\n```\n\tand\tr1,r1,r1\n\tor\tr1,r1,r1\n\tmov\tr1,r1\n\tor\tr1,r1,r1\n\
    \tmov\tr1,r1\n\tor\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule and(s,a,b);\n\
    \  input a,b; output s;\n  a_gate #(1) s(a,b);\nendmodule\n```\n\n---\n## Assembly\
    \ Code:\n```\n\tand\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule or(s,a,b);\n\
    \  input a,b; output s;\n  b_gate #(1) s(a,b);\nendmodule\n```\n\n---\n## Assembly\
    \ Code:\n```\n\tor\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule xor(s,a,b);\n\
    \  input a,b; output s;\n  c_gate #(2) s(a,b);\nendmodule\n```\n\n---\n## Assembly\
    \ Code:\n```\n\txor\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule not(s,a);\n\
    \  input a; output s;\n  not_gate #(4) s(a);\nendmodule\n```\n\n---\n## Assembly\
    \ Code:\n```\n\tnot\tr1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule adder(s,c,a,b);\n\
    \  input a,b; output s,c;\n  s_gate #(1) c(s,a,b);\nendmodule\n```\n\n---\n##\
    \ Assembly Code:\n```\n\tadd\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n```\nmodule\
    \ carry(s,c,a,b);\n  input a,b; output s,c;\n  c_gate #(1) s(a,b,c);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tmov\tr1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule or_gate(s,i,o);\n  input i; output s;\n  or_or(s,i,o);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tor\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule or_or(s,a,b);\n  input a,b; output s;\n  or_or_or(s,a,b);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tor\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule not_gate(s,i);\n  input i; output s;\n  and_not(s,i);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tand\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule and_not(s,i);\n  input i; output s;\n  and_not_and(s,i);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tnot\tr1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule and_not_and(s,a);\n  input a; output s;\n  not_and(s,a);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tand\tr1,r1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule not_and(s,a);\n  input a; output s;\n  and_not_not(s,a);\nendmodule\n\
    ```\n\n---\n## Assembly Code:\n```\n\tnot\tr1,r1\n```\n\n---\n## Verilog Code:\n\
    ```\nmodule and_not_not(s,a);\n  input a; output s;\n  not_not(s,a);\nendmodule\n\
    ```"
- code: "struct packed {\n  signed [1:0] a;\n  signed [1:0] b;\n};\nmodule fa_1(d,s,ci);\n\
    \  packed {\n    a,b} p_in;\n  packed {\n    d,s} p_out;\n  xor #(p_in.a,p_in.b,d);\n\
    \  and #(p_in.a,p_in.b,ci,s);\nendmodule\n### Testbench Code:\nmodule tb_fa_1;\n\
    \  reg a,b;\n  wire [1:0] d;\n  wire [1:0] s;\n  wire [1:0] ci;\n  fa_1 inst\n\
    \  (.d(d),.s(s),.ci(ci),.a(a),.b(b));\n  initial $monitor(\"d=%0h, s=%0h, ci=%0h\"\
    , d, s, ci);\n  initial begin\n    repeat(5) begin\n      a = 0;\n      b = 0;\n\
    \      #1 a = 1; #1 b = 1; #1 ci = 1;\n      #1 a = 0; #1 b = 1; #1 ci = 0;\n\
    \      #1 a = 1; #1 b = 0; #1 ci = 1;\n      #1 a = 0; #1 b = 0; #1 ci = 0;\n\
    \    end\n    $finish;\n  end\nendmodule\n### Wavedrom Source:\n#Title: Full Adder\n\
    #Author: \n#Generated by: \n#Source: https://www.wavedrom.com/\n{signal: [\n \
    \   {name: \"a\", wave: \"0\"},\n    {name: \"b\", wave: \"0.1\"},\n    {name:\
    \ \"ci\", wave: \"0\"},\n    {name: \"d\", wave: \"0\"},\n    {name: \"s\", wave:\
    \ \"0\"}\n  ],\n  head: {\n    text: \"Full Adder\",\n    left: \"a\",\n    right:\
    \ \"b\"\n  },\n  body: [\n    {\n      head: {\n        text: \"d\",\n       \
    \ left: \"a\",\n        right: \"b\"\n      },\n      body: [\n        {\n   \
    \       text: \"xor (a, b, d)\",\n          top: \"d\",\n          bottom: \"\
    a\",\n          right: \"b\"\n        },\n        {\n          text: \"and (a,\
    \ b, ci, s)\",\n          right: \"ci\",\n          top: \"d\",\n          bottom:\
    \ \"a\"\n        }\n      ]\n    }\n  ]\n}\n### Results:\n#### Wavedrom:\n![wavedrom_fa_1.svg](https://github.com/hawkin8"
- code: "struct  { \n  int s;\n  int ca;\n} var_delay; \nmodule ha_2(s,ca,a,b); //\
    \ Half Adder with gate delays\n  input a,b;  output s,ca;\n  variable s_sig,ca_sig;\n\
    \  parameter s_delay = 2;\n  parameter ca_delay = 4;\n  assign s_sig = s;\n  assign\
    \ ca_sig = ca;\n  ha_1((s_sig), (ca_sig), a, b); // call to the modified module\n\
    \  assign s = s_sig;\n  assign ca = s_sig;\nendmodule\n### Testbench:\n### Base\
    \ Verilog Code:\nmodule tb;\nreg a,b;\nreg"
- code: "```\nmodule ha_1(s,ca,a,b); // Half Adder with gate delays\n  input a,b;\
    \ output s,ca;\n  wire [1:0] s_delay = {d1,d2};\n  wire [1:0] ca_delay = {d3,d4};\n\
    \n  xor #(d1,d2) (s,a,b);\n  and #(d3,d4) (ca,a,b);\nendmodule\n```\n### Variation\
    \ Instructions for H-A-E:\n\nIn this variation you must first create a type in\
    \ your code for the gate delays.  To make the type you can use the same command\
    \ as above but with a different data type.\n\n```\ntypedef int[1:0] delay;\n```\n\
    \nNext you need to create a structure that will be used to store the gates delays.\
    \  This is done in the same way as above.\n\n```\nstruct gate_delays {\n  delay\
    \ s_delay;\n  delay ca_delay;\n};\n```\n\nThen you need to create an unpacked\
    \ structure of type gate_delays to store the delays. You will then reference the\
    \ gates directly without the delays:\n\n```\nwire s,ca;\nwire [1:0] s_delay =\
    \ {d1,d2};\nwire [1:0] ca_delay = {d3,d4};\n\nha_1 #(gate_delays {.s_delay={d1,d2},.ca_delay={d3,d4}})\
    \ (s,ca,a,b);\n```\n\n### References\nhttps://www.nand2tetris.org/course.php\n\
    https://courses.cs.washington.edu/courses/cse378/02wi/lectures/24-verilog-struct.pdf\n\
    /src/main.c\n#include \"verilated.h\"\n#include \"Vfulladder.h\"\n\n#include <stdio.h>\n\
    \nint main(int argc, char **argv) {\n    Verilated::commandArgs(argc, argv);\n\
    \n    // create module\n    Vfulladder* fulladder = new Vfulladder;\n\n    //\
    \ set module inputs\n    fulladder->a = 1;\n    fulladder->b = 1;\n    fulladder->cin\
    \ = 0;\n\n    // run module for 100 clock cycles\n    for (int i = 0; i < 100;\
    \ ++i) {\n        fulladder->eval();\n    }\n\n    // print module outputs\n \
    \   printf(\"a: %d\\n\", fulladder->a);\n    printf(\"b: %d\\n\", fulladder->b);\n\
    \    printf(\"cin: %d\\n\", fulladder->cin);\n    printf(\"cout: %d\\n\", fulladder->cout);\n\
    \n    // delete module\n    delete fulladder;\n\n    return 0;\n}/Makefile\nCC=gcc\n\
    CFLAGS=-g -O2\n\nall: build\n\nbuild:\n\t$(CC) $(CFLAGS) -o fulladder src/main.cpp\
    \ build/verilated.cpp -Ibuild/verilated -Ibuild/verilated/Vfulladder\n\nclean:\n\
    \trm -f fulladder"
- code: |-
    ```

    Now we will add the input clocks to the `clock_enable` module:

    ```
    ### The Original Clock Tree:
    module clock_tree(clk_en,clock_out);
      input clock_in;
      wire clock_out;
      wire clk_en;

      always @(posedge clock_in) clk_
- code: |-
    module ha_2(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,2) (s,a,b);
      and #(3,4) (ca,a,b);
    endmodule
    EOF

    # Write
- code: |-
    ```
    module ha_2_packed(s,ca,a,b); // Half Adder with gate delays
      input bit [0:3] a,b; output bit [0:3] s,ca;
      and #(3,4) (ca,a,b);
      ha_1_packed #(3,4) s_1(s[0:3],ca,a,b);
    endmodule
    ```
    ### Input and Output Files:
    ```
    module ha_2_packed(s,ca,a,b); // Half Adder with gate delays
      input bit [0:3] a,b; output bit [0:3] s,ca;
      and #(3,4) (ca,a,b);
      ha_1_packed #(3,4) s_1(s[0:3],ca,a,b);
    endmodule
    ```
    ### Output File:
    ```
    module ha_2_packed(s,ca,a,b); // Half Adder with gate delays
      input bit [0:3] a,b; output bit [0:3] s,ca;
      and #(3,4) (ca,a,b);
      ha_1_packed #(3,4) s_1(s[0:3],ca,a,b);
    endmodule
    ```
    ### Design Report:
    ![Design Report](ha_2_design.png)
    ### Verilator Output:
    ```
    Module ha_2_packed
       .(.a(a[0]),.b(a[1]),.s(s[0]),.ca(ca));
       .(.a(a[1]),.b(a[2]),.s(s[1]),.ca(ca));
       .(.a(a[2]),.b(a[3]),.s(s[2]),.ca(ca));
       .(.a(a[3]),.b(a[0]),.s(s[3]),.ca(ca));
        ha_1_packed #(3'h3, 3'h4) s_1(.a(a[0]),.b(a[1]),.s(s[0]),.ca(ca));
        ha_1_packed #(3'h3, 3'h4) s_1(.a(a[1]),.b(a[2]),.s(s[1]),.ca(ca));
        ha_1_packed #(3'h3, 3'h4) s_1(.a(a[2]),.b(a[3]),.s(s[2]),.ca(ca));
        ha_1_packed #(3'h3, 3'h4) s_1(.a(a[3]),.b(a[0]),.s(s[3]),.ca(ca));
    ```
    ### Simulation Output:
    ```
    time: 0 ns  (100.00% cpu)
    time: 1 ps  (100.00% cpu)
    s[0]: 0
    s[1]: 1
    s[2]: 0
    s[3]: 1
    ```
    ### Testbench Output:
    ```
    $./tb_ha_2_packed
    Read file to memory..
    Writing 12 bytes to memory..
    Initializing Verilator.
    Running simulation for 100 ps with a clock period of 1 ps..
    Running simulation for 100 ps with a clock period of 1 ps..
    s[0]: 0
    s[1]: 1
    s[2]: 0
    s[3]: 1
    ```
    ### Notes:
    Modifying the parameterized delays in the original example did not require changing the output of the testbench. The same arrays containing packed signed values are being passed as inputs to the ha_1 module and the s and ca outputs from this module are being passed as inputs to the ha_2_packed module.

    # ha_1_v2
    ### Base Verilog Code:
    module ha_1(s,ca,a,b); // Half Adder with gate delays
      input a,b; output s,ca;
      xor #(1,2) (s,a
- code: "module ha_1(s,ca,a,b); // Half Adder with gate delays\n  input a,b; output\
    \ s,ca;\n  \n  parameter IN_DELAY = 1;\n  parameter OUT_DELAY = 1;\n  parameter\
    \ IN_DELAY_2 = 2;\n  parameter OUT_DELAY_2 = 2;\n  \n  parameter p = (1,IN_DELAY,OUT_DELAY,1,IN_DELAY_2,OUT_DELAY_2);\n\
    \  parameter signed[0:1] c1_p = p[0:1];\n  parameter signed[0:1] c2_p = p[2:3];\n\
    \  parameter signed[0:1] c3_p = p[4:5];\n  \n  xor #(c1_p) (s,a,b);\n  and #(c2_p)\
    \ (ca,a,b);\n  \nendmodule\n### Testbench Code:\nmodule tb_ha_1;\n  wire s,ca;\n\
    \  wire [0:1] a,b;\n  \n  ha_1 #(1,2,3,4,5,6) ha_1(.s(s),.ca(ca),.a(a[0]),.b(a[1]));\n\
    \  assign a = {1'b0,1'b1}; // a = 01\n  assign b = {1'b1,1'b1}; // b = 11\n  initial\
    \ begin\n    $monitor(\"a = %d, b = %d, s = %d, ca = %d\",a[0],a[1],s,ca);\n \
    \   #10;\n    $monitor(\"a = %d, b = %d, s = %d, ca = %d\",a[0],a[1],s,ca);\n\
    \    #20;\n    $monitor(\"a = %d, b = %d, s = %d, ca = %d\",a[0],a[1],s,ca);\n\
    \  end\nendmodule\n### Expected Testbench Output:\na = 0, b = 1, s = 0, ca = 0\n\
    a = 0, b = 1, s = 1, ca = 0\na = 1, b = 0, s = 1, ca = 0\na = 1, b = 0, s = 0,\
    \ ca = 1\n### Testbench Result:\na = 0, b = 1, s = 1, ca = 0\na = 1, b = 1, s\
    \ = 1, ca = 0\na = 1, b = 1, s = 1, ca = 1\na = 1, b = 1, s = 0, ca = 1\n```\n\
    /labs/labs/lab4/lab4_code/ha_1.py\n#!/usr/bin/env python\n\nimport veriloggen\n\
    import ha_1\n\nveriloggen.resetmodules()\n\n# a = {1'b0,1'b1};\n# b = {1'b1,1'b0};\n\
    \na = [1,0]\nb = [0,1]\n\nd = {0:1,1:2}\n\nmod = ha_1.definition(\n    name =\
    \ \"test_ha_1\",\n    a = a, \n    b = b,\n    c1_d = d[0], \n    c2_d = d[1]\n\
    )\n\n# mod = ha_1.definition(\n#     name = \"test_ha_1\",\n#     a = {1:1,0:0},\n\
    #     b = {1:0,0:1}\n# )\n\n# print(mod)\n\nmod.elaborate()\n\n# print(mod)\n\n\
    fsim = mod.simulator(\n    vcd_name = \"test_ha_1.vcd\",\n    bin_dir = \"./\"\
    \n)\n\nresult = fsim.run()\n\nprint(result)\n/labs/labs/lab4/src/labs/lab4/lab4_code/ha_1.py\n\
    #!/usr/bin/env python\n\nimport veriloggen\n\nfrom ha_1_mod import ha_1\n\ndef\
    \ definition(\n\tname,\n\ta,\n\tb,\n\tc1_d,\n\tc2_d,\n\tout_p,\n\tin_p\n):\n\t\
    params = {\n\t\t\"a\": a,\n\t\t\"b\": b,\n\t\t\"c1_d\": c1_d,\n\t\t\"c2_d\": c2_d,\n\
    \t\t\"out_p\": out_p,\n\t\t\"in_p\": in_p\n\t}\n\n\tmod = ha_1(\n\t\tname = name,\n\
    \t\tparams = params\n\t)\n\n\treturn mod/labs/labs/lab4/src/labs/lab4/lab4_code/lab4_tb_ha_1.py\n\
    #!/usr/bin/env python\n\nimport veriloggen\n\nfrom ha_1_mod import ha_1\n\ndef\
    \ definition(\n    name\n):\n\ts = veriloggen.Signal(1, 0)\n\tca = veriloggen.Signal(1,\
    \ 0)\n\ta = veriloggen.Signal(1, 0)\n\tb = veriloggen.Signal(1, 0)\n\t\n\tha_1_tb\
    \ = ha_1(\n\t\tname = name,\n\t\ts = s,\n\t\tca = ca,\n\t\ta = a,\n\t\tb = b\n\
    \t)\n\n\treturn ha_1_tb/labs/labs/lab4/src/labs/lab4/lab4_code/ha_1_mod.py\n#!/usr/bin/env\
    \ python\n\nfrom math import log2\nimport veriloggen\nimport ha_1\n\nclass ha_1(ha_1.ha_1):\n\
    \    def __init__(\n            self,\n            name,\n            clock,\n\
    \            a,\n            b,\n            c1_d,\n            c2_d,\n      \
    \      out_p,\n            in_p,\n            *args, **kwargs):\n        ha_1.ha_1.__init__(\n\
    \            self,\n            name,\n            *args, **kwargs\n        )\n\
    \n        self.a = a\n        self.b = b\n        self.out_p = out_p\n       \
    \ self.in_p = in_p\n\n        self.a_1 = veriloggen.Signal(1, 0)\n        self.a_2\
    \ = veriloggen.Signal(1, 0)\n        self.out_1 = veriloggen.Signal(1, 0)\n  \
    \      self.out_2 = veriloggen.Signal(1, 0)\n        self.delay_1_2 = veriloggen.Signal(1,\
    \ 0)\n        self.delay_2_1 = veriloggen.Signal(1, 0)\n        self.ca = veriloggen.Signal(1,\
    \ 0)\n\n        delay_1 = veriloggen.Delay(1)(\n            self.data_in[0],\n\
    \            self.a_1,\n            clock\n        )\n        delay_2 = veriloggen.Delay(c1_d)(\n\
    \            self.data_in[1],\n            self.a_2,\n            clock\n    \
    \    )\n        out_1 = veriloggen.Logic1(c1_d)(\n            self.a_1,\n    \
    \        self.b[0],\n            self.out_1\n        )\n        out_2 = veriloggen.Logic2(c2_d)(\n\
    \            self.a_2,\n            self.b[1],\n            self.out_2\n     \
    \   )\n\n        self.submodules.delay_1 = delay_1\n        self.submodules.delay_2\
    \ = delay_2\n        self.submodules.out_1 = out_1\n        self.submodules.out_2\
    \ = out_2\n\n        # self.a_1 = veriloggen.Signal(1, 0)\n        # self.a_2\
    \ = veriloggen.Signal(1, 0)\n        # # self.out_1 = veriloggen.Signal(1, 0)\n\
    \        # # self.out_2 = veriloggen.Signal(1, 0)\n        # self.delay_1_2 =\
    \ veriloggen.Signal(1, 0)\n        # self.delay_2_1 = veriloggen.Signal(1, 0)\n\
    \n        # delay_1 = veriloggen.Delay(1)(\n        #     self.data_in[0],\n \
    \       #     self.a_1,\n        #     clock\n        # )\n        # delay_2 =\
    \ veriloggen.Delay(c1_d)(\n        #     self.data_in[1],\n        #     self.a_2,\n\
    \        #     clock\n        # )\n        # delay_1_2 = veriloggen.Delay(c2_d)(\n\
    \        #     self.a_1,\n        #     self.out_1,\n        #     clock\n   \
    \     # )\n        # delay_2_1 = veriloggen.Delay(c2_d)(\n        #     self.a_2,\n\
    \        #     self."
- code: |-
    ```
    module ha_3(a,s,ca,b); // Half Adder with gate delays
      input a,b; output s,ca;
      wire c,d,e,f,tmp_1,tmp_2;
      xor #(7,6) (c,a,b);
      and #(5,4) (s,b,e);
      xor #(3,2) (d,f,c);
      and #(7,6) (ca,f,tmp_1);
      and #(5,4) (s,tmp_1,d);
      or #(3,2) (tmp_2,e,tmp_1);
      and #(7,6) (ca,tmp_2,tmp_1);
      and #(5,4) (s,tmp_2,tmp_1);
    endmodule
    ```


    ### Base Verilog Code:
    module ha_3(a,s,ca,b); // Half Adder with gate delays
      input a,b; output s,ca;
      wire c,d,e,f,tmp_1,tmp_2;
      xor #(7,6) (c,a,b);
      and #(5,4) (s,b,e);
      xor #(3,2) (d,f,c);
      and #(7,6) (ca,f,tmp_1);
      and #(5,4) (s,tmp_1,d);
      or #(3,2) (tmp_2,e,tmp_1);
      and #(7,6) (ca,tmp_2
- code: |-
    module ha_1(s,ca,a,b);
       input a,b; output s,ca;
       xor #(1,2) (s,a,b);
       and #(3,4) (ca,a,b,delay=1.2);@@ -67,13
- code: |-
    module test_module;
        logic [7:0] clock;
        reg [7:0] clock_reg;
        wire [7:0] clock_wire; // output from a wire
        wire test_wire;        // output from the wire_assign module
        reg [15:0] out;
        initial begin
            // assign to the register
            clock_reg <= 0xABCD;
            // assign to the wire
            clock_wire <= 0x1234;
            // assign using the module
            test_wire <= 0x1234;
        end
        always begin
            out <= clock_reg; // regular register read
            out <= clock_wire; // wire read
            out <= test_wire; // wire from the wire_assign module
            out <= {clock[3],clock_reg[3],clock_wire[3],test_wire[3]}; // read from the associative array
            out <= {clock[3:0],clock_reg[3:0],clock_wire[3:0],test_wire[3:0]}; // read from the associative array
        end
    endmodule

    #include <stdio.h>
    #include "verilated.h"
    #include "Vtest_module.h"

    int main() {
        Verilated::commandArgs(1, "test_module");
        printf("Verilator Version: %s\n", Verilated::getFullVersion());
        Vtest_module* top = new Vtest_module;
        printf("Top level name: %s\n", top->name());

        Verilated::traceEverOn(true);
        Verilated::traceOpen("test_module.vcd");

        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 0;
        top->rst_n = 0;
        top->test_clock_0 = 0;
        top->test_wire_0 = 0;

        top->eval();
        Verilated::traceEverOn(false);
        Verilated::traceEverOn(true);
        Verilated::traceOpen("test_module.vcd");
        printf("test_wire = %d (0)\n", top->test_wire);
        top->test_clock = 1;
        top->test_clock_reg = 1;
        top->test_clock_wire = 4;
        top->test_wire = 4;
        top->clk = 1;
        top->rst_n = 0;
        top->test_clock_0 = 4;
        top->test_wire_0 = 4;
        top->eval();
        printf("test_wire = %d (4)\n", top->test_wire);
        top->test_clock = 1;
        top->test_clock_reg = 1;
        top->test_clock_wire = 4;
        top->test_wire = 4;
        top->clk = 0;
        top->rst_n = 0;
        top->test_clock_0 = 4;
        top->test_wire_0 = 4;
        top->eval();
        printf("test_wire = %d (4)\n", top->test_wire);
        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 0;
        top->rst_n = 1;
        top->test_clock_0 = 1;
        top->test_wire_0 = 0;
        top->eval();
        printf("test_wire = %d (1)\n", top->test_wire);
        top->test_clock = 1;
        top->test_clock_reg = 1;
        top->test_clock_wire = 4;
        top->test_wire = 4;
        top->clk = 0;
        top->rst_n = 1;
        top->test_clock_0 = 4;
        top->test_wire_0 = 0;
        top->eval();
        printf("test_wire = %d (0)\n", top->test_wire);
        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 1;
        top->rst_n = 0;
        top->test_clock_0 = 1;
        top->test_wire_0 = 1;
        top->eval();
        printf("test_wire = %d (1)\n", top->test_wire);
        top->test_clock = 1;
        top->test_clock_reg = 1;
        top->test_clock_wire = 4;
        top->test_wire = 4;
        top->clk = 1;
        top->rst_n = 0;
        top->test_clock_0 = 4;
        top->test_wire_0 = 1;
        top->eval();
        printf("test_wire = %d (1)\n", top->test_wire);
        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 1;
        top->rst_n = 0;
        top->test_clock_0 = 1;
        top->test_wire_0 = 0;
        top->eval();
        printf("test_wire = %d (0)\n", top->test_wire);
        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 0;
        top->rst_n = 1;
        top->test_clock_0 = 0;
        top->test_wire_0 = 0;
        top->eval();
        printf("test_wire = %d (0)\n", top->test_wire);
        top->test_clock = 0;
        top->test_clock_reg = 0;
        top->test_clock_wire = 0;
        top->test_wire = 0;
        top->clk = 1;
        top->rst_n = 1;
        top->test_clock_0 = 0;
        top->test_wire_0 = 1;
        top->eval();
        printf("test_wire = %d (1)\n", top->test_wire);
        top->test_clock = 1;
        top->test_clock_reg = 1;
        top->test_clock_wire = 4;
        top->test_wire = 4;
        top->clk = 0;
        top->rst_n = 1;
        top->test_clock_0 = 4;
        top->test_wire_0 = 1;
        top->eval();
        printf("test_wire = %d (1)\n", top->test_wire);

        Verilated::traceEverOn(false);
        Verilated::traceEverOn(true);
        Verilated::traceClose();
        delete top;
        return 0;
    }

    Output:
    Verilator Version: 3.816
    Top level name: test_module
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 4 (4)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 4 (4)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 4 (4)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 4 (4)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4)
    clock_reg = 1 (1)
    test_wire = 1 (1)
    clock_wire = 4 (4
- code: |-
    ```VHDL
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ```
    ### Expected Results:
    An error that the module is not clocked.
    ### Discussion
- code: |-
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule


    ### Base Verilog Code:
    // Create a module with one input and one output that behaves like a wire
    module wire_assign( input in, output out );
        // assign out
- code: |-
    ```
    module wire_assign( input in, output out );
        // Create a new clock array to hold all of our clocks
        clock_array #(
           .Clock_Count(8)
        ) clk_arr(
           .Clk_Clk_0(),
           .Clk_Clk_1():clk_reg_0,
           .Clk_Clk_2():clk_reg_1,
           .Clk_Clk_3():clk_reg_2,
           .Clk_Clk_4():clk_reg_3,
           .Clk_Clk_5():clk_reg_4,
           .Clk_Clk_6():clk_reg_5,
           .Clk_Clk_7():clk_reg_6,
        );

        // Create a data array to hold the states of our clocks
        logic_array #(
           .Logic_Count(8)
        ) clk_data(
           .State_0(),
           .State_1(),
           .State_2(),
           .State_3(),
           .State_4(),
           .State_5(),
           .State_6(),
           .State_7(),
        );

        // Create a clock reg for each clock
        clock clk_reg_0, clk_reg_1, clk_reg_2, clk_reg_3, clk_reg_4, clk_reg_5, clk_reg_6;

        // Create a clock switch for each clock
        logic clk_switch_0, clk_switch_1, clk_switch_2, clk_switch_3, clk_switch_4, clk_switch_5, clk_switch_6;

        // Create a state register for each clock
        logic state_0, state_1, state_2, state_3, state_4, state_5, state_6;

        // Create a state switch for each clock
        logic switch_0, switch_1, switch_2, switch_3, switch_4, switch_5, switch_6;

        // Create a wire to be used for assignment
        wire wire;

        // Assign the wire to the input
        assign wire = in;

        // Loop through the clocks
        integer i;
        for(i=0; i<8; i=i+1) begin: clock_index

            // Create a new clock
            clock clk = clk_reg_0;

            // Create a clock switch
            logic switch = clk_switch_0;

            // Create a state register
            logic state = state_0;

            // Create a state switch
            logic switch_state = switch_1;

    wire_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_assign_
- code: |-
    ```
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in;
    endmodule
    ```
    ### Expected Result:
    ```
    Error: expected 2 arguments, got 1 in wire_assign
        |    assign out = in;
                       ^
    Error: syntax error, unexpected '='
        |    ^
    Error: syntax error, unexpected '='
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected ':'
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
        |    ^
    Error: syntax error, unexpected END
    ```import glob
    import os

    from typing import Set, Dict, Optional, List, Tuple, Callable, Iterator

    import numpy as np
    import pandas as pd

    from typing import List  # noqa: F401

    from pyverilog.utils import search_include_file, replace_include_file, str2bool, get_file_lines

    from pyverilog.dataflow.core import DataflowNode, DataflowGraph
    from pyverilog.dataflow.interface import PyverilogInterface, FunctionInterface
    from pyverilog.dataflow.util import (
        get_interface_name,
        get_signal_name,
        get_data_flow_graph_from_verilog,
        get_interface_ports,
        get_interface_types,
        get_interface_functions,
        get_interface_instance_names,
        get_interface_input_ports,
        get_interface_output_ports,
        get_interface_function_calls_by_instance_name,
        to_input_port_tuples,
        to_output_port_tuples,
        search_module_includes,
        is_module,
        get_module_ports,
        get_module_call_names,
        get_module_instance_names,
        get_module_input_ports,
        get_module_output_ports,
        get_module_function_calls_by_instance_name,
    )

    from pyverilog.dataflow.transform import (
        rename_input_ports,
        rename_output_ports,
        rename_function_calls_by_instance_name,
        rename_instance_names,
        rename_module_call_names,
        rename_module_output_ports,
        rename_module_input_ports,
        rename_module_function_calls_by_instance_name,
        remove_instance_names,
        add_new_instances,
        remove_module_call_names,
        add_new_module_call_names,
        remove_module_input_ports,
        add_new_module_input_ports,
        remove_module_output_ports,
        add_new_module_output_ports,
        remove_module_input_names,
        add_new_module_input_names,
        remove_module_output_names,
        add_new_module_output_names,
        replace_module_call_names,
        replace_instance_names,
        replace_module_output_ports,
        replace_module_input_ports,
        replace_module_input_names,
        replace_module_output_names,
        replace_module_function_calls_by_instance_name,
    )

    from pyverilog.dataflow.interface import (
        rename_interface_function_calls,
        rename_interface_input_ports,
        rename_interface_output_ports,
        rename_interface_names,
        rename_interface_instances,
        rename_interface_types,
        rename_interface_call_names,
        add_new_interface_types,
        remove_interface_input_ports,
        remove_interface_output_ports,
        remove_interface_function_calls,
        remove_interface_input_names,
        remove_interface_output_names,
        replace_interface_input_ports,
        replace_interface_output_ports,
        replace_interface_input_names,
        replace_interface_output_names,
        remove_interface_types,
        add_new_interface_types,
    )

    from pyverilog.dataflow.function import (
        rename_function_call_names,
        rename_function_input_ports,
        rename_function_output_ports,
        rename_function_names,
        rename_function_instances,
        rename_function_types,
        rename_function_call_names,
        add_new_function_types,
        remove_function_input_ports,
        remove_function_output_ports,
        remove_function_function_calls,
        remove_function_input_names,
        remove_function_output_names,
        replace_function_input_ports,
        replace_function_output_ports,
        replace_function_input_names,
        replace_function_output_names,
        remove_function_types,
        add_new_function_types,
    )

    from pyverilog.dataflow.netlist import (
        check_function_calls_by_instance_name,
        check_interface_types,
        check_function_types,
        check_module_call_names,
        check_module_types,
        check_interface_function_calls,
        check_interface_types,
        check_function_types,
        get_netlist_from_verilog,
    )

    from pyverilog.dataflow.transform_util import replace_instance_name

    from pyverilog.dataflow.transform_util import (
        set_interface_type_as_output,
        set_interface_type_as_input,
        set_module_call_name_as_input,
        set_module_call_name_as_output,
        set_function_call_name_as_input,
        set_function_call_name_as_output,
    )

    from pyverilog.dataflow.transform_util import (
        get_interface_type,
        get_function_type,
        get_module_call_name,
        get_module_instance_name,
        get_module_output_port_name,
        get_module_input_port_name,
        get_function_call_name,
        get_function_output_port_name,
        get_function_input_port_name,
        get_interface_output_port_name,
        get_interface_input_port_name,
    )

    from pyverilog.dataflow.transform_util import (
        remove_interface_input_port_name,
        remove_interface_output_port_name,
        remove_function_input_port_name,
        remove_function_output_port_name,
        remove_module_input_port_name,
        remove_module_output_port_name,
        replace_interface_input_port_name,
        replace_interface_output_port_name,
        replace_function_input_port_name,
        replace_function_output_port_name,
        replace_module_input_port_name,
        replace_module_output_port_name,
    )

    from pyverilog.dataflow.transform_util import (
        get_function_input_port_name_by_instance_name,
        get_function_output_port_name_by_instance_name,
        get_module_input_port_name_by_instance_name,
        get_module_output_port_name_by_instance_name,
        get_interface_input_port_name_by_instance_name,
        get_interface_output_port_name_by_instance_name,
    )

    from pyverilog.dataflow.transform_
- code: |-
    module wire_assign( input in, output out );
        // declare a clock signal
        reg [7:0] Clock;
        // declare a clock signal array
        // clock[0] == 0
        // clock[1] == 1
        // clock[2] == 2
        // clock[3] == 3
        // clock[4] == 4
        // clock[5] == 5
        // clock[6] == 6
        // clock[7] == 7
        // clock[8] == 8
        // clock[9] == 9
        //...
        // clock[255] == 255

        // assign out to in if clock is less than 255
        assign out = in;
        if (Clock < 255)
            Clock <= Clock + 1;
    endmodule
    ### Results:
    |          Test Case | Pass/Fail |
    | -----------------: | :-------: |
    |      wire_assign0  |   **FAIL** |
    |      wire_assign1  |   **PASS** |
    |      wire_assign2  |   **PASS** |
    |      wire_assign3  |   **PASS** |
    |      wire_assign4  |   **PASS** |
    |      wire_assign5  |   **FAIL** |
    |      wire_assign6  |   **FAIL** |
    |      wire_assign7  |   **FAIL** |
    |      wire_assign8  |   **FAIL** |
    |      wire_assign9  |   **FAIL** |
    |     wire_assign10  |   **FAIL** |
    |     wire_assign11  |   **FAIL** |
    |     wire_assign12  |   **FAIL** |
    |     wire_assign13  |   **FAIL** |
    |     wire_assign14  |   **FAIL** |
    |     wire_assign15  |   **FAIL** |
    |     wire_assign16  |   **FAIL** |
    |     wire_assign17  |   **FAIL** |
    |     wire_assign18  |   **FAIL** |
    |     wire_assign19  |   **FAIL** |
    |     wire_assign20  |   **FAIL** |
    |     wire_assign21  |   **FAIL** |
    |     wire_assign22  |   **FAIL** |
    |     wire_assign23  |   **FAIL** |
    |     wire_assign24  |   **FAIL** |
    |     wire_assign25  |   **FAIL** |
    |     wire_assign26  |   **FAIL** |
    |     wire_assign27  |   **FAIL** |
    |     wire_assign28  |   **FAIL** |
    |     wire_assign29  |   **FAIL** |
    |     wire_assign30  |   **FAIL** |
    |     wire_assign31  |   **FAIL** |
    |     wire_assign32  |   **FAIL** |
    |     wire_assign33  |   **FAIL** |
    |     wire_assign34  |   **FAIL** |
    |     wire_assign35  |   **FAIL** |
    |     wire_assign36  |   **FAIL** |
    |     wire_assign37  |   **FAIL** |
    |     wire_assign38  |   **FAIL** |
    |     wire_assign39  |   **FAIL** |
    |     wire_assign40  |   **FAIL** |
    |     wire_assign41  |   **FAIL** |
    |     wire_assign42  |   **FAIL** |
    |     wire_assign43  |   **FAIL** |
    |     wire_assign44  |   **FAIL** |
    |     wire_assign45  |   **FAIL** |
    |     wire_assign46  |   **FAIL** |
    |     wire_assign47  |   **FAIL** |
    |     wire_assign48  |   **FAIL** |
    |     wire_assign49  |   **FAIL** |
    |     wire_assign50  |   **FAIL** |
    |     wire_assign51  |   **FAIL** |
    |     wire_assign52  |   **FAIL** |
    |     wire_assign53  |   **FAIL** |
    |     wire_assign54  |   **FAIL** |
    |     wire_assign55  |   **FAIL** |
    |     wire_assign56  |   **FAIL** |
    |     wire_assign57  |   **FAIL** |
    |     wire_assign58  |   **FAIL** |
    |     wire_assign59  |   **FAIL** |
    |     wire_assign60  |   **FAIL** |
    |     wire_assign61  |   **FAIL** |
    |     wire_assign62  |   **FAIL** |
    |     wire_assign63  |   **FAIL** |
    |     wire_assign64  |   **FAIL** |
    |     wire_assign65  |   **FAIL** |
    |     wire_assign66  |   **FAIL** |
    |     wire_assign67  |   **FAIL** |
    |     wire_assign68  |   **FAIL** |
    |     wire_assign69  |   **FAIL** |
    |     wire_assign70  |   **FAIL** |
    |     wire_assign71  |   **FAIL** |
    |     wire_assign72  |   **FAIL** |
    |     wire_assign73  |   **FAIL** |
    |     wire_assign74  |   **FAIL** |
    |     wire_assign75  |   **FAIL** |
    |     wire_assign76  |   **FAIL** |
    |     wire_assign77  |   **FAIL** |
    |     wire_assign78  |   **FAIL** |
    |     wire_assign79  |   **FAIL** |
    |     wire_assign80  |   **FAIL** |
    |     wire_assign81  |   **FAIL** |
    |     wire_assign82  |   **FAIL** |
    |     wire_assign83  |   **FAIL** |
    |     wire_assign84  |   **FAIL** |
    |     wire_assign85  |   **FAIL** |
    |     wire_assign86  |   **FAIL** |
    |     wire_assign87  |   **FAIL** |
    |     wire_assign88  |   **FAIL** |
    |     wire_assign89  |   **FAIL** |
    |     wire_assign90  |   **FAIL** |
    |     wire_assign91  |   **FAIL** |
    |     wire_assign92  |   **FAIL** |
    |     wire_assign93  |   **FAIL** |
    |     wire_assign94  |   **FAIL** |
    |     wire_assign95  |   **FAIL** |
    |     wire_assign96  |   **FAIL** |
    |     wire_assign97  |   **FAIL** |
    |     wire_assign98  |   **FAIL** |
    |     wire_assign99  |   **FAIL** |
    |    wire_assign100  |   **FAIL** |
    |    wire_assign101  |   **FAIL** |
    |    wire_assign102  |   **FAIL** |
    |    wire_assign103  |   **FAIL** |
    |    wire_assign104  |   **FAIL** |
    |    wire_assign105  |   **FAIL** |
    |    wire_assign106  |   **FAIL** |
    |    wire_assign107  |   **FAIL** |
    |    wire_assign108  |   **FAIL** |
    |    wire_assign109  |   **FAIL** |
    |   wire_assign110  |   **FAIL** |
    |   wire_assign111  |   **FAIL** |
    |   wire_assign112  |   **FAIL** |
    |   wire_assign113  |   **FAIL** |
    |   wire_assign114  |   **FAIL** |
    |   wire_assign115  |   **FAIL** |
    |   wire_assign116  |   **FAIL** |
    |   wire_assign117  |   **FAIL** |
    |   wire_assign118  |   **FAIL** |
    |   wire_assign119  |   **FAIL** |
    |   wire_assign120  |   **FAIL** |
    |   wire_assign121  |   **FAIL** |
- code: |-
    ```verilog
    wire_assign in;
    ```
    ### Expected Results:
    All outputs are assigned to the input if the module is a wired assignment.
    /Documentation/CodeExamples.md
    # Code Examples of Module Variations

    This document contains all the code examples used in development.

    <hr>

    ## 2.27.0 - Wire Assign Module Examples

    ### wire_assign (wired assignment)
    #### Variation 1 - [2.27.1](../Code/wire_assign.v)
    Create a module with two inputs and a single output.
    ```verilog
    // Module
    module wire_assign( input in1, input in2, output out );
        assign out = (in1, in2);
- code: |-
    ```verilog
    module wire_assign( input in, output out );
        // assign out to in
        assign out = in[x];
    endmodule
    ```
    /2020-03-30-TAPAS-Verilog-Competition/README.md
    # TAPAS Verilog Competition

    This is the repository of the submission to the 2020 TAPAS Verilog Competition.

    The competition website is at https://tapas.verce.com/en/competition/2020/verilog.

    You can find my teams' solution at folder [MySubmission](https://github.com/Kaiyuan-Yu/TAPAS-Verilog-Competition/tree/main/MySubmission).

    The results of 4 teams can be found at [FinalResults](https://github.com/Kaiyuan-Yu/TAPAS-Verilog-Competition/tree/main/FinalResults).

    All codes submitted by other teams are available at [OtherTeams](https://github.com/Kaiyuan-Yu/TAPAS-Verilog-Competition/tree/main/OtherTeams).
    /2020-02-15-TAPAS-Verilog-Competition/MySubmission/team_93/README.md
    # 93th TAPAS Verilog Competition

    ## Team Name: UQAS-2019

    ## Leader Board Ranking

    | Rank | Team Name | Score |
    |------|-----------|-------|
    | 1    | UQAS-2019 | 241   |
    | 2    | ZJU-2020  | 224   |
    | 3    | UQAS-2020 | 212   |
    | 4    | UQAS-2018 | 208   |
    | 5    | UQAS-2017 | 200   |
    | 6    | UQAS-2016 | 192   |
    | 7    | UQAS-2015 | 188   |
    | 8    | UQAS-2014 | 181   |
    | 9    | UQAS-2013 | 176   |
    | 10   | UQAS-2012 | 176   |
    | 11   | UQAS-2011 | 156   |
    | 12   | UQAS-2010 | 140   |
    | 13   | UQAS-2009 | 135   |
    | 14   | UQAS-2008 | 132   |
    | 15   | UQAS-2007 | 129   |
    | 16   | UQAS-2006 | 126   |
    | 17   | UQAS-2005 | 116   |
    | 18   | UQAS-2004 | 116   |
    | 19   | UQAS-2003 | 114   |
    | 20   | UQAS-2002 | 108   |
    | 21   | UQAS-2001 | 108   |
    | 22   | UQAS-2000 | 104   |
    | 23   | UQAS-1999 | 98    |
    | 24   | UQAS-1998 | 95    |
    | 25   | UQAS-1997 | 95    |
    | 26   | UQAS-1996 | 93    |
    | 27   | UQAS-1995 | 93    |
    | 28   | UQAS-1994 | 93    |
    | 29   | UQAS-1993 | 88    |
    | 30   | UQAS-1992 | 88    |
    | 31   | UQAS-1991 | 85    |
    | 32   | UQAS-1990 | 84    |
    | 33   | UQAS-1989 | 81    |
    | 34   | UQAS-1988 | 78    |
    | 35   | UQAS-1987 | 78    |
    | 36   | UQAS-1986 | 75    |
    | 37   | UQAS-1985 | 73    |
    | 38   | UQAS-1984 | 72    |
    | 39   | UQAS-1983 | 68    |
    | 40   | UQAS-1982 | 65    |
    | 41   | UQAS-1981 | 64    |
    | 42   | UQAS-1980 | 63    |
    | 43   | UQAS-1979 | 62    |
    | 44   | UQAS-1978 | 61    |
    | 45   | UQAS-1977 | 59    |
    | 46   | UQAS-1976 | 57    |
    | 47   | UQAS-1975 | 56    |
    | 48   | UQAS-1974 | 55    |
    | 49   | UQAS-1973 | 52    |
    | 50   | UQAS-1972 | 52    |
    | 51   | UQAS-1971 | 51    |
    | 52   | UQAS-1970 | 50    |
    | 53   | UQAS-1969 | 48    |
    | 54   | UQAS-1968 | 47    |
    | 55   | UQAS-1967 | 44    |
    | 56   | UQAS-1966 | 42    |
    | 57   | UQAS-1965 | 41    |
    | 58   | UQAS-1964 | 39    |
    | 59   | UQAS-1963 | 38    |
    | 60   | UQAS-1962 | 36    |
    | 61   | UQAS-1961 | 36    |
    | 62   | UQAS-1960 | 34    |
    | 63   | UQAS-1959 | 33    |
    | 64   | UQAS-1958 | 33    |
    | 65   | UQAS-1957 | 32    |
    | 66   | UQAS-1956 | 31    |
    | 67   | UQAS-1955 | 31    |
    | 68   | UQAS-1954 | 31    |
    | 69   | UQAS-1953 | 30    |
    | 70   | UQAS-1952 | 30    |
    | 71   | UQAS-1951 | 30    |
    | 72   | UQAS-1950 | 29    |
    | 73   | UQAS-1949 | 28    |
    | 74   | UQAS-1948 | 28    |
    | 75   | UQAS-1947 | 27    |
    | 76   | UQAS-1946 | 26    |
    | 77   | UQAS-1945 | 24    |
    | 78   | UQAS-1944 | 24    |
    | 79   | UQAS-1943 | 23    |
    | 80   | UQAS-1942 | 22    |
    | 81   | UQ
- code: |-
    create a module with one input and one output that can behave like a wire:
    module wire_assign( input in, output out );
        assign out = in;
    endmodule
    ### Original Test:
    test_wire_assign
    ### Test Description:
    This test instantiates the wire_assign module, and uses a netlist from the library to test the module's behavior.
    The wire module is expected to assign its output value to its input value.
    ```
    # 8.4. test_assign: Design System Test Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/assign_test_cases/)

    # 2.4. test_wire_assign: Design System Test Wire Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system assigns the value of an input net to another output net.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a value to the output net from the input net.

    ## Expected Result:
    The test expects the assign operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The output of the top module does not match the value of the net on the right hand side after 2 clock cycles.

    ## Test Code:
    [Design System Test Wire Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/wire_assign_test_cases/)

    # 4.11. test_delay_assign: Design System Test Delays Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another using the delay modifier.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Delays Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/delay_assign_test_cases/)

    # 4.10. test_sync_assign: Design System Test Sync Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Sync Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/sync_assign_test_cases/)

    # 4.5. test_sync_assign_with_delay: Design System Test Delayed Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another using the delay modifier.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Delayed Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/sync_assign_delay_test_cases/)

    # 3.3. test_bit_assign: Design System Test Bit Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system assigns a net from one netlist to another.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Bit Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/bit_assign_test_cases/)

    # 1.14. test_wire_assign_with_delay: Design System Test Delayed Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another using the delay modifier.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle, and it expects the output of the top module to match the value of the net on the right hand side after 2 clock cycles.

    ## Observed Result:
    The test does not pass the expected result.

    ## Test Code:
    [Design System Test Delayed Assignments](https://bitbucket.org/cadence_test/design_system_tests/src/master/test_cases/wire_assign_delay_test_cases/)

    # 6.3. test_bit_assign_with_delay: Design System Test Delayed Assignments

    ## Purpose:
    This test case verifies that the assign operator in design system correctly assigns a net from one netlist to another using the delay modifier.

    ## Test Description:
    In this test, a top module is instantiated using the netlist from the library, and the assign operator assigns a net from one netlist to another.

    ## Expected Result:
    The test expects the assignment operator to set the value of the net on the right hand side to the value of the net on the left hand side after each clock cycle,
- code: |-
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code:
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Array Pointer
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Array Slice
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Range Array
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Randomized Input
    |Input Data|Value|
    |-|-|
    |4'b0000| 0|
    |4'b0001| 1|
    |4'b0010| 2|
    |4'b0011| 3|
    |4'b0100| 4|
    |4'b0101| 5|
    |4'b0110| 6|
    |4'b0111| 7|
    |4'b1000| 8|
    |4'b1001| 9|
    |4'b1010| 10|
    |4'b1011| 11|
    |4'b1100| 12|
    |4'b1101| 13|
    |4'b1110| 14|
    |4'b1111| 15|
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Array
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Slice
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Range Array
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Randomized Input
    |Input Data|Value|
    |-|-|
    |4'b0000| 0|
    |4'b0001| 1|
    |4'b0010| 2|
    |4'b0011| 3|
    |4'b0100| 4|
    |4'b0101| 5|
    |4'b0110| 6|
    |4'b0111| 7|
    |4'b1000| 8|
    |4'b1001| 9|
    |4'b1010| 10|
    |4'b1011| 11|
    |4'b1100| 12|
    |4'b1101| 13|
    |4'b1110| 14|
    |4'b1111| 15|
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Wildcard Array
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output;
        always @ (posedge in)
            output <= ($cast(arr[($signed(in))[31:0]].val));
    endmodule
    ```
    ### Wildcard Wildcard Slice
    ```
    typedef int t_index;
    typedef int t_value;
    struct array_struct {
        t_index ind;
        t_value val;
    };
    array_struct [32]arr;
    ```
    ### Modified Code
    module wire_assign( input in, output out );
        output out;
        always @ (posedge in)
            out <= arr[in].val;
    endmodule
    ### Verilog Generated Code
    ```
    module wire_assign( input in, output out );
        logic output

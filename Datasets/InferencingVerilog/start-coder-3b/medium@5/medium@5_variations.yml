- code: |-
    ### Specparam:
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay based on dl1
      endspecify
    ### Testing:
      initial begin
        $display("a,b,s,ca");
        a = 0;
        b = 1;
        $display("%d,%d,%d,%d",a,b,s,ca);
      end
    ### Test Results:
    a,
- code: "```verilog\nmodule ha_8(s,ca,a,b); // Half Adder with specparam path delays\n\
    \  input a,b; output s,ca;\n  specparam dl1, dl2; // Define specify parameters\
    \ for s and ca delays\n  xor (s,a,b);\n  and (ca,a,b);\n  (a, b *> s) = dl1;\n\
    \  (a, b *> ca) = dl2;\n  specify\n    if (a[1:0] == 1'b1, b[1:0] == 1'b1) begin\
    \ // Check that the two inputs are both 1\n      dl1 = 1; // Define specify parameter\
    \ for s delay\n      dl2 = dl1 + 1; // Define specify parameter for ca delay based\
    \ on dl1\n    end\n    else begin // Otherwise\n      dl1 = 2; // Define specify\
    \ parameter for s delay\n      dl2 = dl1 + 2; // Define specify parameter for\
    \ ca delay based on dl1\n    end\n  endspecify\nendmodule\n```\n/projects/project1/README.md\n\
    # MIPS CPU Design and Simulation\n\n### Design and Simulation of a MIPS-based\
    \ CPU using SystemVerilog.\n## Introduction\nThe MIPS architecture is an industry-standard\
    \ instruction set architecture first\nintroduced in 1985. The MIPS CPU is a simple,\
    \ fast, efficient instruction set with\nsupport for many of the mainstream application\
    \ domains. This project is aimed at\ncreating a MIPS CPU using SystemVerilog and\
    \ Xilinx ISE. The CPU is capable of\nexecuting floating point and integer arithmetic.\
    \ The CPU supports pipelining of\nthe different stages. As part of the project,\
    \ the implementation is tested and\nsimulated at two different levels:\n- Firstly,\
    \ the design is simulated using VSIM.\n- Secondly, the design is synthesized to\
    \ an FPGA and the resulting implementation is simulated using VSIM and Vivado.\n\
    \n## Project Details\n\nThe CPU is designed and built on Xilinx Artix-7 Series\
    \ FPGA. The design uses the System Verilog language to model the circuit as well\
    \ as the programming of the CPU with the MIPS assembler language. The MIPS assembler\
    \ is used to generate the machine code that is loaded into the CPU.\n\n## Detailed\
    \ Description\n\n#### MIPS Instruction Format\nThe MIPS architecture uses 32 bits\
    \ to store instructions. The first 6 bits of the instruction corresponds to the\
    \ opcode, the next 6 bits to the function code, and the other 26 bits to the 26\
    \ operand bits. Each bit of the instruction is represented as one bit in the binary\
    \ data.\n\nThe opcode determines the type of operation to be performed by the\
    \ CPU. The available MIPS instructions are:\n1. Arithmetic Instructions\n\t- Add\n\
    \t- Addu\n\t- Addi\n\t- Addiu\n\t- Sub\n\t- Subu\n\t- Subi\n\t- Subiu\n2. Logical\
    \ Instructions\n\t- And\n\t- Or\n\t- Xor\n\t- Sll\n\t- Sllv\n\t- Srl\n\t- Srlv\n\
    \t- Sra\n\t- Srav\n\t- Slt\n\t- Sltu\n3. Branch Instructions\n\t- Beq\n\t- Bne\n\
    4. Jump Instructions\n\t- J\n\t- Jal\n5. Load Instructions\n\t- Lb\n\t- Lh\n\t\
    - Lw\n6. Store Instructions\n\t- Sh\n\t- Sw\n\t- Swl\n\t- Swr\n7. Syscall Instructions\n\
    \t- Syscall\n\t- Eret\n8. Shift Instructions\n\t- Sll\n\t- Srl\n\t- Sra\n\t- Sll\n\
    \n#### MIPS Datatypes\nThe project uses the MIPS Instruction Format to execute\
    \ a set of instructions. The MIPS Instruction Format uses 32 bits to store instructions.\
    \ The first 6 bits correspond to the opcode, the next 6 bits correspond to the\
    \ function code, and the remaining 26 bits correspond to the operand bits. The\
    \ opcodes are further divided into instructions based on the type of operand they\
    \ use. For example, the arithmetic instructions use register values as operands\
    \ and the branch instructions use register and constant values as operands.\n\n\
    Register numbers are stored as 32 bit unsigned integers. There are 32 registers\
    \ in the CPU, numbered from $0 to $31. In the project, these registers are implemented\
    \ using a std_logic array. Each element of the array contains a 32 bit unsigned\
    \ integer. The contents of the array are stored as binary data with 32 bits. The\
    \ MIPS instruction format includes the use of shamt in the instructions that involve\
    \ shift operations. In the project, this is modelled using a std_logic_vector.\n\
    \nThe instruction data is stored in a data variable of type unsigned(31 downto\
    \ 0) in the CPU. The register data is represented using a std_logic array of registers\
    \ that is 32 elements long. Each element contains a 32 bit unsigned integer. It\
    \ is used to store the register values.\n\nThe CPU implements a set of 5 stages\
    \ with the help of the control signals:\n1. Instruction Fetch Stage\n\t- The fetch_stage\
    \ module is used to decode the instruction data in the instruction register and\
    \ generate the next instruction data in the instruction register.\n2. Instruction\
    \ Decode Stage\n\t- The decode_stage module is used to extract the operation code\
    \ from the instruction data and pass it on to the appropriate decoding module.\n\
    \t- Based on the opcode extracted, the decode_stage module passes the operation\
    \ code and the register numbers to the appropriate decoding module.\n3. Execute\
    \ Stage\n\t- The execute_stage module is used to extract the source and destination\
    \ registers from the instruction data and pass it on to the appropriate execution\
    \ module.\n\t- Based on the operation code extracted, the execute_stage module\
    \ passes the source and destination registers to the appropriate execution module.\n\
    4. Memory Stage\n\t- The memory_stage module is used to extract the address from\
    \ the instruction data and pass it on to the appropriate memory module.\n\t- Based\
    \ on the operation code extracted, the memory_stage module passes the address\
    \ to the appropriate memory module.\n5. Write Back Stage\n\t- The write_back_stage\
    \ module is used to extract the result from the instruction data and pass it on\
    \ to the appropriate write back module.\n\t- Based on the operation code extracted,\
    \ the write_back_stage module passes the result to the appropriate write back\
    \ module.\n\n#### Floating Point Operations\nThe CPU supports the following floating\
    \ point operations:\n- Add: Adds two floating point values.\n- Subtract: Subtracts\
    \ one floating point value from another.\n- Multiply: Multiplies two floating\
    \ point values.\n- Divide: Divides one floating point value by another.\n- Float\
    \ To Int: Converts a floating point value to its integer equivalent.\n- Float\
    \ To Float: Converts a floating point value to another floating point value.\n\
    - Float To Unsigned: Converts a floating point value to an unsigned integer.\n\
    - Float To Signed: Converts a floating point value to a signed integer.\n- Int\
    \ To Float: Converts an integer value to a floating point value.\n- Unsigned To\
    \ Float: Converts an unsigned integer to a floating point value.\n- Signed To\
    \ Float: Converts a signed integer to a floating point value.\n\nThe CPU implements\
    \ the floating point operations using a pipeline of modules. The pipeline begins\
    \ with the FPU_add module, which performs the addition operation. The result of\
    \ the addition operation is passed on to the FPU_sub module, which subtracts one\
    \ floating point value from another. This operation is then passed on to the FPU_mul\
    \ module, which multiplies two floating point values. The result of the multiplication\
    \ operation is passed on to the FPU_div module, which divides one floating point\
    \ value by another. The result of the division operation is passed on to the FPU_to_int\
    \ module, which converts a floating point value to its integer equivalent. The\
    \ result of the conversion operation is passed on to the FPU_to_float module,\
    \ which converts a floating point value to another floating point value. The result\
    \ of the conversion operation is passed on to the FPU_to_unsigned module, which\
    \ converts a floating point value to an unsigned integer. The result of the conversion\
    \ operation is passed on to the FPU_to_signed module, which converts a floating\
    \ point value to a signed integer.\n\nIn the FPU_to_float module, the sign of\
    \ the destination value is taken from the source value. The exponent and mantissa\
    \ of the destination value is taken from the source value. The floating point\
    \ result is then written to the destination register.\n\nThe FPU_to_unsigned module,\
    \ the FPU_to_signed module, and the FPU_to_int module do not perform any operation,\
    \ but instead load the result from the source register into the destination register.\n\
    \nThe FPU_add module adds the source values and stores the result in the destination\
    \ register. The FPU_sub module subtracts the source values and stores the result\
    \ in the destination register. The FPU_mul module multiplies the source values\
    \ and stores the result in the destination register. The FPU_div module divides\
    \ the source values and stores the result in the destination register.\n\n####\
    \ Shift Operations\nShifts can be performed by bitwise left or right shifts. The\
    \ CPU supports the following shift operations:\n- Sll: Performs a bitwise left\
    \ shift of an integer value.\n- Srl: Performs a"
- code: |-
    module ha_2(s,ca,a,b); // Half Adder with specparam path delays
      input a,b; output s,ca;
      specify
        specparam dl1 = 1; // Define specify parameter for s delay
        specparam dl2 = dl1 + 1; // Define specify parameter for ca delay
        // Assign path delays using specparams
        (a, b *> s) = dl1;
        (a, b *> ca) = 1;
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Execution:
    [user@host]$ vvp -n -M. -m ha_2 test.v -lxt2
    ### Run Results:
    [user@host]$ vvp -M. -m ha_2 test.v -lxt2
    ### Expected Results:
    [user@host]$ vvp -M. -m ha_2 test.v -lxt2
    #!/usr/bin/env python3

    import sys
    from random import randint

    NUM_TESTS = 100
    NUM_ITERATIONS = 5

    for i in range(NUM_TESTS):
      print("/*")
      print("## Base Verilog Code:")
      print("module ha_2(s,ca,a,b); // Half Adder with specparam path delays")
      print("  input a,b; output s,ca;")
      print("  specify")
      print("    specparam dl1 = 1; // Define specify parameter for s delay")
      print("    specparam dl2 = 1 + 1; // Define specify parameter for ca delay")
      print("    // Assign path delays using specparams")
      print("    (a, b *> s) = dl1;")
      print("    (a, b *> ca) = dl2;")
      print("  endspecify")
      print("  xor (s,a,b);")
      print("  and (ca,a,b);")
      print("endmodule")
      print("### Variation Instruction:")
      print("Replace the constant value delay assigned to ca with a specparam.")
      print("### Modified Code:")
      print("module ha_2(s,ca,a,b); // Half Adder with specparam path delays")
      print("  input a,b; output s,ca;")
      print("  specify")
      print("    specparam dl1 = 1; // Define specify parameter for s delay")
      print("    specparam dl2 = dl1 + 1; // Define specify parameter for ca delay")
      print("    // Assign path delays using specparams")
      print("    (a, b *> s) = dl1;")
      print("    (a, b *> ca) = 1;")
      print("  endspecify")
      print("  xor (s,a,b);")
      print("  and (ca,a,b);")
      print("endmodule")
      print("### Execution:")
      print("[user@host]$ vvp -n -M. -m ha_2 test.v -lxt2")
      print("### Run Results:")
      print("[user@host]$ vvp -M. -m ha_2 test.v -lxt2")
      print("###
- code: |-
    module ha_32_range_list(s,ca,a,b);
      input a,b; output s,ca;
      specify
        specparam dl1 = 1;
        specparam dl2 = dl1 + 1;
        constant c_4D_packed_array_range_list_top [0:7] = { { 32'd0, 32'd0 }, { 32'd32, 32'd32 }, { 32'd64, 32'd64 }, { 32'd96, 32'd96 }, { 32'd128, 32'd128 }, { 32'd160, 32'd160 }, { 32'd192, 32'd192 }, { 32'd224, 32'd224 } };
        for(int i = 0; i < 8; i = i + 1) begin : if_0
          if(i[7:0] == 8'b10100000) begin // If s[7:0] = 10100000
            (a, b *> s) = c_4D_packed_array_range_list_top[i];
            (a, b *> ca) = c_4D_packed_array_range_list_top[i];
          end
        end
      endspecify
      xor (s,a,b);
      and (ca,a,b);
    endmodule
    ### Observations:
    The above modification is equivalent to a 2D packed array of 16 bits (since the maximum value of a 4-bit number is 15). The 2D packed array is constructed by filling the 16 bits with the same value, and then packing the array into the same 32-bit bit.
    ### Variation Instruction:
    Add a special construct for the case of unpacked array and a single value to represent the 2D packed
- code: "module ha_8(s,ca,a,b); // Half Adder with specparam path delays\n  input\
    \ a,b; output s,ca;\n  specify\n    specparam dl1 = 1; // Define specify parameter\
    \ for s delay\n    specparam dl2 = dl1 + 1; // Define specify parameter for ca\
    \ delay based on dl1\n    // Assign path delays using specparams\n    (a, b *>\
    \ s) = dl1;\n    (a, b *> ca) = dl2;\n  endspecify\n  xor (s,a,b);\n  and (ca,a,b);\n\
    endmodule\n\n## References\n\n* [1]. \"A 22-bit 4-bit full adder and subtractor\
    \ implementation for FPGA.\", https://github.com/dineshkummarc/fpga, 2012.\n*\
    \ [2]. \"A 56-bit 64-bit subtractor using logic arrays.\", https://ieeexplore.ieee.org/abstract/document/6416870/,\
    \ 2014.\n* [3]. \"A 40-bit 64-bit binary adder using array logic.\", https://ieeexplore.ieee.org/abstract/document/6416871/,\
    \ 2014.\n* [4]. \"A 10-bit 20-bit binary adder using array logic.\"\n* [5].,,,,\
    \ and. \"An 8-bit 16-bit adder for FPGA using array logic.\" IEEE symposium on\
    \ logic in VLSI design (2007).\n* [6]. \"An 8-bit 16-bit adder using array logic\"\
    , https://ieeexplore.ieee.org/abstract/document/6311291/, 2007.int main(int argc,\
    \ char* argv[]) {\n\tif (x == 0) {\n\t\tx = 1;\n\t} else {\n\t\tx = 0;\n\t}\n\t\
    return x;\n}# This is an example of a \"non-critical\" path.\nx = 0\ny = 0\n\n\
    path_1 = {\n\t'x': 0,\n\t'y': 0\n}\n\npath_2 = {\n\t'x': 1,\n\t'y': 1\n}\n\n#\
    \ This is an example of a \"critical\" path.\nz = 0\n\npath_3 = {\n\t'z': 0\n\
    }\n\npath_4 = {\n\t'z': 1\n}\n\nif (x == 0):\n\tif (y == 0):\n\t\tz = 0\n\telse:\n\
    \t\tz = 1\nelse:\n\tif (y == 0):\n\t\tz = 1\n\telse:\n\t\tz = 0\n\nprint(z)\n\n\
    # The result should be 1\nimport os\nfrom os.path import dirname\nfrom os.path\
    \ import join as pjoin\nimport sys\n\n\nimport netlist\nimport netlist.analysis\n\
    from netlist.analysis import GraphTool\nfrom netlist.analysis import NetlistAnalysis\n\
    \nimport logging\nlogger = logging.getLogger(__name__)\n\n'''\nThis script builds\
    \ a.v file whose functionality mimics a netlist with the following characteristics:\n\
    \n1. Every net has at least 2 driving nodes\n2. The nets are directed acyclic\
    \ graphs (DCFG) with no cycles\n3. There are some nets with a delay assigned to\
    \ them\n4. Each net has a single input edge and a single output edge\n\nThis script\
    \ can be used as a tool for testing code generation tools in the context of Verilog-to-Hardware\n\
    '''\n\ndef parse_cmd():\n    import argparse\n    parser = argparse.ArgumentParser(description='Verilog\
    \ to Hardware tool')\n    parser.add_argument('-d', '--debug', action='store_true',\
    \ required=False, help='Print debug messages')\n    parser.add_argument('-O',\
    \ '--optimize', default='None', choices=['None', 'Liveness', 'Dead'], required=False,\
    \ help='Optimization techniques to apply')\n    parser.add_argument('-o', '--out',\
    \ required=False, help='Ouput file')\n    parser.add_argument('-i', '--input',\
    \ required=False, help='Input file')\n    return parser.parse_args()\n\ndef find_file(file_path):\n\
    \    if (os.path.isfile(file_path)):\n        return file_path\n    else:\n  \
    \      return pjoin(get_cwd(), file_path)\n\ndef get_cwd():\n    return dirname(sys.argv[0])\n\
    \ndef test_netlist(input_path, output_path):\n    input_path = find_file(input_path)\n\
    \    output_path = find_file(output_path)\n    print(\"Input: {}\".format(input_path))\n\
    \    print(\"Output: {}\".format(output_path))\n    nets, nodes = netlist.load_netlist(input_path)\n\
    \    print(\"Node count: {} Nodes: {}\".format(len(nodes), nodes))\n    print(\"\
    Net count: {} Net list: {}\".format(len(nets), nets))\n\n    # Make the network\
    \ directed acyclic graph (DCFG)\n    dcfg = netlist.analysis.make_dcfg(nets, nodes)\n\
    \n    # Optimize using liveness or dead code elimination\n    if op == \"Dead\"\
    :\n        dcfg.eliminate_dead_code()\n    elif op == \"Liveness\":\n        dcfg.compute_liveness()\n\
    \n    # Write to file\n    netlist.write(output_path, dcfg, nodes)\n\ndef main():\n\
    \    args = parse_cmd()\n    if (args.debug):\n        logger.setLevel(logging.DEBUG)\n\
    \    # TODO Check if all input arguments are present\n    global op\n    op =\
    \ args.optimize\n    if (args.in):\n        test_netlist(args.in, args.out)\n\
    \    else:\n        print(\"Input and output file names are required\")\n\nif\
    \ __name__ == \"__main__\":\n    main()\nt(x, y))\n\nif (x == 0):\n    x = 1\n\
    else:\n    x = 0\n\nif (y == 0):\n    y = 1\nelse:\n    y = 0\n\nprint(x, y)\n\
    \n# The result should be 0 1\nx = 0\ny = 0\n\npath_1 = {\n\t'x': x,\n\t'y': y\n\
    }\n\npath_2 = {\n\t'x': y,\n\t'y': x\n}\n\nif (x == 0):\n    if (y == 0):\n  \
    \      x, y = 1, 1\n    else:\n        y = 0\nelse:\n    if (y == 0):\n      \
    \  x = 0\n    else:\n        x = 1\n\nprint(x, y)\n\n# The result should be 0\
    \ 1\n\nx = 0\ny = 0\n\npath_3 = {\n\t'x': x,\n\t'y': y\n}\n\npath_4 = {\n\t'x':\
    \ y,\n\t'y': x\n}\n\nif (x == 0):\n    x = 1\nelse:\n    x = 0\n\nif (y == 0):\n\
    \    y = 1\nelse:\n    y = 0\n\nprint(x, y)\n\n# The result should be 1 0\n\n\
    x = 0\ny = 0\n\npath_5 = {\n\t'x': x,\n\t'y': y\n}\n\npath_6 = {\n\t'x': y,\n\t\
    'y': x\n}\n\nif (x == y):\n    x, y = 0, 1\nelse:\n    x, y = 1, 0\n\nprint(x,\
    \ y)\n\n# The result should be 1 0\n\nx = 0\ny = 0\n\npath_7 = {\n\t'x': x,\n\t\
    'y': y\n}\n\npath_8 = {\n\t'x': y,\n\t'y': x\n}\n\nif (x == y):\n    x, y = 0,\
    \ 1\nelse:\n    x, y = 1, 0\n\nprint(x, y)\n\n# The result should be 0 0\n\nx\
    \ = 0\ny = 0\n\npath_9 = {\n\t'x': x,\n\t'y': y\n}\n\npath_10 = {\n\t'x': y,\n\
    \t'y': x\n}\n\nif (x == y):\n    x, y = 0, 1\nelse:\n    x, y = 1, 0\n\nprint(x,\
    \ y)\n\n# The result should be 1 1\n\nx = 0\ny = 0\n\npath_11 = {\n\t'"
- code: "`\n\nimport cmath\nimport math \nfrom sympy import *\nimport numpy as np\n\
    import decimal\nimport time\nimport random\nimport sys\nimport array\nfrom timeit\
    \ import default_timer as timer\n\n\n#######################################################\n\
    # Parameters\n#######################################################\n# Number\
    \ of inputs\nsize_in1 = 8\nsize_in2 = 8\n\n# Number of outputs\nsize_out = 8\n\
    \n#############################################\n# Verilog Type Variables\n#############################################\n\
    # This is in order to be used with the packed operator in the case statement of\
    \ the verilog code.\nvar_type_in1 = cmath.rect(1, 0)\nvar_type_in2 = cmath.rect(1,\
    \ 0)\nvar_type_out = cmath.rect(1, 0)\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the verilog input variables\npar_in1, par_in2, clk = symbols('par_in1 par_in2\
    \ clk')\n\n#############################################\n# Verilog Output Variables\n\
    #############################################\n# These are the verilog output\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the packed verilog input variables\nm = symbols('m[0:1]')\n\n#############################################\n\
    # Verilog Parameter Variables\n#############################################\n\
    # These are the verilog parameter variables\npar_in = symbols('par_in')\n\n#############################################\n\
    # Verilog Variable Variables\n#############################################\n\
    # These are the verilog parameter variables\nsl = symbols('sl')\nsr = symbols('sr')\n\
    \n#############################################\n# Verilog Assignment Variables\n\
    #############################################\n# These are the verilog parameter\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Module\n#############################################\n# This is the\
    \ verilog module\nshiftRegister = Module('ShiftRegister8')\n# This is the verilog\
    \ module input\nshiftRegister.add_ports(\n  ParIn = In(size_in1),\n  m = In(2),\n\
    \  sl = In(var_type_in1),\n  sr = In(var_type_in1),\n  clk = In(var_type_in1),\n\
    \  ParOut = Out(size_out)\n)\n\n#############################################\n\
    # Verilog Code\n#############################################\n# This is the verilog\
    \ code\nshiftRegister.specialize({\n  ParIn: par_in1,\n  ParOut: par_out,\n  m:\
    \ m,\n  clk: clk,\n  sl: sl,\n  sr: sr,\n  ParIn: par_in2\n})\n\n#############################################\n\
    # Constraints\n#############################################\n# This is the constraint\n\
    # This is the constraint\nshiftRegister.add_constraints(\n  And(Not(m[0]), Not(m[1])),\n\
    \  And(m[0], m[1])\n)\n\n#############################################\n# Output\n\
    #############################################\n# This is the output\nprint(shiftRegister.to_verilog())/code/python/Verilog_Python_Generator_Base_Shift_Register_8bit.py\n\
    import cmath\nimport math \nfrom sympy import *\nimport numpy as np\nimport decimal\n\
    import time\nimport random\nimport sys\nimport array\nfrom timeit import default_timer\
    \ as timer\n\n\n#######################################################\n# Parameters\n\
    #######################################################\n# Number of inputs\n\
    size_in1 = 8\nsize_in2 = 8\n\n# Number of outputs\nsize_out = 8\n\n#############################################\n\
    # Verilog Type Variables\n#############################################\n# This\
    \ is in order to be used with the packed operator in the case statement of the\
    \ verilog code.\nvar_type_in1 = cmath.rect(1, 0)\nvar_type_in2 = cmath.rect(1,\
    \ 0)\nvar_type_out = cmath.rect(1, 0)\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the verilog input variables\npar_in1, par_in2, clk = symbols('par_in1 par_in2\
    \ clk')\n\n#############################################\n# Verilog Output Variables\n\
    #############################################\n# These are the verilog output\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the packed verilog input variables\nm = symbols('m[0:1]')\n\n#############################################\n\
    # Verilog Parameter Variables\n#############################################\n\
    # These are the verilog parameter variables\npar_in = symbols('par_in')\n\n#############################################\n\
    # Verilog Variable Variables\n#############################################\n\
    # These are the verilog parameter variables\nsl = symbols('sl')\nsr = symbols('sr')\n\
    \n#############################################\n# Verilog Assignment Variables\n\
    #############################################\n# These are the verilog parameter\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Module\n#############################################\n# This is the\
    \ verilog module\nshiftRegister = Module('ShiftRegister8')\n# This is the verilog\
    \ module input\nshiftRegister.add_ports(\n  ParIn = In(size_in1),\n  m = In(2),\n\
    \  sl = In(var_type_in1),\n  sr = In(var_type_in1),\n  clk = In(var_type_in1),\n\
    \  ParOut = Out(size_out)\n)\n\n#############################################\n\
    # Verilog Code\n#############################################\n# This is the verilog\
    \ code\nshiftRegister.specialize({\n  ParIn: par_in1,\n  ParOut: par_out,\n  m:\
    \ m,\n  clk: clk,\n  sl: sl,\n  sr: sr,\n  ParIn: par_in2\n})\n\n#############################################\n\
    # Constraints\n#############################################\n# This is the constraint\n\
    # This is the constraint\nshiftRegister.add_constraints(\n  And(Not(m[0]), Not(m[1])),\n\
    \  And(m[0], m[1])\n)\n\n#############################################\n# Output\n\
    #############################################\n# This is the output\nprint(shiftRegister.to_verilog())\n\
    /code/python/Verilog_Python_Generator_Base_Shift_Register_2to4bit.py\nimport cmath\n\
    import math \nfrom sympy import *\nimport numpy as np\nimport decimal\nimport\
    \ time\nimport random\nimport sys\nimport array\nfrom timeit import default_timer\
    \ as timer\n\n\n#######################################################\n# Parameters\n\
    #######################################################\n# Number of inputs\n\
    size_in1 = 2\nsize_in2 = 2\n\n# Number of outputs\nsize_out = 4\n\n#############################################\n\
    # Verilog Type Variables\n#############################################\n# This\
    \ is in order to be used with the packed operator in the case statement of the\
    \ verilog code.\nvar_type_in1 = cmath.rect(1, 0)\nvar_type_in2 = cmath.rect(1,\
    \ 0)\nvar_type_out = cmath.rect(1, 0)\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the verilog input variables\npar_in1, par_in2, clk = symbols('par_in1 par_in2\
    \ clk')\n\n#############################################\n# Verilog Output Variables\n\
    #############################################\n# These are the verilog output\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Input Variables\n#############################################\n# These\
    \ are the packed verilog input variables\nm = symbols('m[0:2]')\n\n#############################################\n\
    # Verilog Parameter Variables\n#############################################\n\
    # These are the verilog parameter variables\npar_in = symbols('par_in')\n\n#############################################\n\
    # Verilog Variable Variables\n#############################################\n\
    # These are the verilog parameter variables\nsl = symbols('sl')\nsr = symbols('sr')\n\
    \n#############################################\n# Verilog Assignment Variables\n\
    #############################################\n# These are the verilog parameter\
    \ variables\npar_out = symbols('par_out')\n\n#############################################\n\
    # Verilog Module\n#############################################\n# This is the\
    \ verilog module\nshiftRegister = Module('ShiftRegister4')\n# This is the verilog\
    \ module input\nshiftRegister.add_ports(\n  ParIn = In(size_in1),\n  m = In(3),\n\
    \  sl = In(var_type_in1),\n  sr = In(var_type_in1),\n  clk = In(var_type_in1),\n\
    \  ParOut = Out(size_out)\n)\n\n#############################################\n\
    # Verilog Code\n#############################################\n# This is the verilog\
    \ code\nshiftRegister.specialize({\n  ParIn: par_in1,\n  ParOut: par_out,\n  m:\
    \ m,\n  clk: clk,\n  sl: sl,\n  sr: sr,\n  ParIn: par_in2\n})\n\n#############################################\n\
    # Constraints\n#############################################\n# This is the constraint\n\
    # This is the constraint\nshiftRegister.add_constraints(\n  And(Not(m[0]), Not(m[1])),\n\
    \  And(m[0], m[1])\n)\n\n#############################################\n# Output\n\
    #############################################\n# This is the output\nprint(shiftRegister.to_verilog())"
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            default: ParOut <= ParIn;
        endcase
    end
    endmodule

    `


    ### Base Verilog Code:
    `timescale 1ns/1
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParOut[6:0], ParOut[7]};
            5: ParOut <= {ParOut[7:1], ParOut[6]};
            6: ParOut <= {ParOut[7:2], ParOut[6:1]};
            7: ParOut <= {ParOut[7:3], ParOut[6:2]};
            8: ParOut <= {ParOut[7:4], ParOut[6:3]};
            9: ParOut <= {ParOut[7:5], ParOut[6:4]};
            10: ParOut <= {ParOut[7:6], ParOut[6:5]};
            11: ParOut <= {ParOut[7:7], ParOut[6:6]};
            12: ParOut <= {ParOut[7:7]};
            13: ParOut <= {ParOut[7:6]};
            14: ParOut <= {ParOut[7:5]};
            15: ParOut <= {ParOut[7:4]};
            16: ParOut <= {ParOut[7:3]};
            17: ParOut <= {ParOut[7:2]};
            18: ParOut <= {ParOut[7:1]};
            19: ParOut <= {ParOut[7:0]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule


    '''

    ### Variation Instruction:

    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParOut[6:0], ParOut[7]};
            5: ParOut <= {ParOut[7:1], ParOut[6]};
            6: ParOut <= {ParOut[7:2], ParOut[6:1]};
            7: ParOut <= {ParOut[7:3], ParOut[6:2]};
            8: ParOut <= {ParOut[7:4], ParOut[6:3]};
            9: ParOut <= {ParOut[7:5], ParOut[6:4]};
            10: ParOut <= {ParOut[7:6], ParOut[6:5]};
            11: ParOut <= {ParOut[7:7], ParOut[6:6]};
            12: ParOut <= {ParOut[7:7]};
            13: ParOut <= {ParOut[7:6]};
            14: ParOut <= {ParOut[7:5]};
            15: ParOut <= {ParOut[7:4]};
            16: ParOut <= {ParOut[7:3]};
            17: ParOut <= {ParOut[7:2]};
            18: ParOut <= {ParOut[7:1]};
            19: ParOut <= {ParOut[7:0]};
            default: ParOut <= 8'bX;
        endcase
    end
    endmodule


    '''

    ## Instructions
    1. In the case statement, add a packed vector array select used with the inside operator to match against a dynamic range list.
    2. In the case statement, the case range of the dynamic range list is defined as the case range of the switch.
    3. Add the case range to the case statement.
    ## Base Code:
    ```
    timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
        endcase
    end
    endmodule
    ```
    ## Variation Instruction:
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParOut[6:0], ParOut[7]};
            5: ParOut <= {ParOut[7:1], ParOut[6]};
            6: ParOut <= {ParOut[7:2], ParOut[6:1]};
            7: ParOut <= {ParOut[7:3], ParOut[6:2]};
            8: ParOut <= {ParOut[7:4], ParOut[6:3]};
            9: ParOut <= {ParOut[7:5], ParOut[6:4]};
            10: ParOut <= {ParOut[7:6], ParOut[6:5]};
            11: ParOut <= {ParOut[7:7], ParOut[6:6]};
            12: ParOut <= {ParOut[7:7]};
            13: ParOut <= {ParOut[7:6]};
            14: ParOut <= {ParOut[7:5]};
            15: ParOut <= {ParOut[7:4]};
            16: ParOut <= {ParOut[7:3]};
            17: ParOut <= {ParOut[7:2]};
            18: ParOut <= {ParOut[7:1]};
            19: ParOut <= {ParOut[7:0]};
        endcase
    end
    endmodule


    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        case (m)
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {ParOut[6:0], ParOut[7]};
            5: ParOut <= {ParOut[7:1], ParOut[6]};
            6: ParOut <= {ParOut[7:2], ParOut[6:1]};
            7: ParOut <= {ParOut[7:3], ParOut[6:2]};
            8: ParOut <= {ParOut[7:4], ParOut[6:3]};
            9: ParOut <= {ParOut[7:5], ParOut[6:4]};
            10: ParOut <= {ParOut[7:6], ParOut[6:5]};
            11: ParOut <= {ParOut[7:7], ParOut[6:6]};
            12: ParOut <= {ParOut[7:7]};
            13: ParOut <= {ParOut[7:6]};
            14: ParOut <= {ParOut[7:5]};
            15: ParOut <= {ParOut[7:4]};
            16: ParOut <= {ParOut[7:3]};
            17: ParOut <= {ParOut[7:2]};
            18: ParOut <= {ParOut[7:1]};
            19: ParOut <= {ParOut[7:0]};
        endcase
    end
    endmodule

    '''
    /README.md
    # ECE 11: Hardware Design Using VHDL

    ## Course Information

    This is a course taken at Cal Poly Pomona.

    ## Course Description

    This course is an introduction to hardware design and implementation using digital logic elements, Verilog HDL programming for digital design, and Verilog/VHDL verification and simulation using ModelSim.

    ## Course Evaluation

    Course evaluation is based on all of the following:

    - 50% Assignments: 12 assignments worth 2% each.
    - 30% Midterms: 5 midterms worth 5% each.
    - 20% Final: 1 final worth 20%.

    ## Midterms
- code: |-
    `library ieee;
    use ieee.std_logic_1164.all;
    entity ShiftRegister is
        port (
            sl,sr,clk: in std_logic;
            ParIn  : in std_logic_vector(7 downto 0);
            m      : in std_logic_vector(1 downto 0);
            ParOut : out std_logic_vector(7 downto 0)
        );
    end ShiftRegister;
    architecture Behavioral of ShiftRegister is
    begin
        process( clk, m )
        variable ParOut_ : std_logic_vector(7 downto 0);
        begin
            ParOut_ <= ParOut;
        end process;
        process( clk )
        begin
            ParOut <= ParOut_;
        end process;
        process( clk, m )
        begin
            case m is
                when "00" => ParOut <= ParOut;
                when "01" => ParOut <= sl & ParOut(7 downto 1);
                when "10" => ParOut <= ParOut(6 downto 0) & sr;
                when "11" => ParOut <= ParIn;
                (m == "01") & (m == "10") & (m == "11") => ParOut <= {{ParOut(6 downto 2),ParOut(1 downto 0)},ParOut(7 downto 1)};
                (m == "01") & (m == "10") & (m == "11") => ParOut <= {ParOut(6 downto 0),{ParOut(1 downto 0),ParOut(7 downto 1)}};
                (m == "01") & (m == "10") & (m == "11") => ParOut <= {ParOut(6 downto 0),{ParOut(1 downto 0),ParOut(7 downto 1)}};
            endcase;
        end process;
    end Behavioral;`

    ```
    Upvotes: 2
- code: |-
    `timescale 1ns/100ps
    module ShiftRegister8 (input sl, sr, clk, input [7:0] ParIn, input [1:0] m, output reg [7:0] ParOut);
    always @(negedge clk) begin
        casex (m) // use casex instead of case
            0: ParOut <= ParOut;
            1: ParOut <= {sl, ParOut[7:1]};
            2: ParOut <= {ParOut[6:0], sr};
            3: ParOut <= ParIn;
            4: ParOut <= {{ParOut[7:1], ParOut[0]}, ParOut[7:1]};
            5: ParOut <= {ParOut[7:1], ParOut[0], ParOut[7:1]};
            6: ParOut <= {ParOut[7:1], ParOut[0], ParOut[7:1], ParOut[0]};
            7: ParOut <= {ParOut[7:1], ParOut[0], ParOut[7:1], ParOut[0], ParOut[7:1]};
            8: ParOut <= {ParOut[7], {{ParOut[7], ParOut[0]}, ParOut[7]}, {ParOut[7], ParOut[0]}};
            9: ParOut <= {ParOut[7], {ParOut[7], ParOut[0], ParOut[7]}, {ParOut[7], ParOut[0], ParOut[7]}};
            10: ParOut <= {{ParOut[7], ParOut[0], ParOut[7], ParOut[0]}, {ParOut[7], ParOut[0], ParOut[7]}, {ParOut[7], ParOut[0]}};
            11: ParOut <= {ParOut[7], {ParOut[7], ParOut[0], ParOut[7], ParOut[0], ParOut[7]}, {ParOut[7], ParOut[0], ParOut
- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Alternative instruction:
    Assign a for loop condition using a for variable index applied to a packed array.
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Alternative instruction:
    Assign a while loop condition using a for variable index applied to a packed array.
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Alternative instruction:
    Assign a for loop condition using a while loop index applied to a packed array.
    ### Base Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### Base Verilog Code:
    module example7_4(D
- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;
    reg [1:0] Q[2];
    always @(posedge Clock)
    begin
        while(1)
        begin
            Q[0] <= D;
            Q[1] <= Q[0];
        end
    end
    endmodule
    ### Test Case:
    ### Expected Output:

    ### Observed Output:

    /README.md
    # Verilog
    I will be adding and updating the Verilog code I found on https://www.electronics-tutorials.ws/verilog/index.html
- code: |-
    module example7_4(D, Clock, Q1, Q2, D_n1, Q1_n1);
    input D, Clock;
    output Q1, Q2, D_n1, Q1_n1;
    reg Q, Q1, Q2;

    always @(posedge Clock)
    begin
    Q <= D;
    end

    always @ (posedge Clock)
    begin
    Q1 <= Q;
    end

    always @ (posedge Clock)
    begin
- code: module example7_13(D
- code: |-
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

    reg [2:0] ind = 0;
    reg [2:0] arr_packed[3];

    always @(posedge Clock)
    begin
        arr_packed[ind[0]] <= D;
        arr_packed[ind[1]] <= arr_packed[ind[0]];
        ind[2] <= ind[1];
        ind[1] <= ind[0];
        ind[0] <= 2'd0;
    end

    endmodule
    ### Generated Verilog Code:
    (I/O)    Q1       Q2
    Clock    x        x
    D        x        x
    ### VHDL Code:
    library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

    entity example7_4 is
    port (
        D, Clock: in std_logic;
        Q1, Q2: out std_logic
    );
    end example7_4;

    architecture Behavioral of example7_4 is

    begin

    end Behavioral;
    ### Altera Quartus Prime VHDL Code:
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;

    entity example7_4 is
    port (
        D, Clock: in STD_LOGIC;
        Q1, Q2: out STD_LOGIC
    );
    end entity example7_4;

    architecture Behavioral of example7_4 is

    begin

    end Behavioral;
    ### ISE FPGA Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <==(Q1? Q1 : D);
    end
    endmodule
    ### Altera Quartus Prime Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= D;
        Q2 <= Q1;
    end
    endmodule
    ### ISE FPGA VHDL Code:
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;

    entity example7_4 is
    port (
        D, Clock: in STD_LOGIC;
        Q1, Q2: out STD_LOGIC
    );
    end entity example7_4;

    architecture Behavioral of example7_4 is

    begin

    end Behavioral;
    ### Xilinx Vivado Verilog Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= Q1? Q1 : D;
    end
    endmodule
    ### Xilinx Vivado VHDL Code:
    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;

    entity example7_4 is
    port (
        D, Clock: in STD_LOGIC;
        Q1, Q2: out STD_LOGIC
    );
    end entity example7_4;

    architecture Behavioral of example7_4 is

    begin

    end Behavioral;
    ### Intel FPGA Code:
    module example7_4(D, Clock, Q1, Q2);
    input D, Clock;
    output Q1, Q2;
    reg Q1, Q2;

    always @(posedge Clock)
    begin
        Q1 <= D;
        Q2 <= D;
        Q2 <= Q1;
    end
    endmodule
- code: "module Ripple_Add;\n    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA fa3();\n\
    endmodule\n\nmodule FA;\n\toutput y, cin;\n\tinput  x, cin_old;\n\n\talways @(x,\
    \ cin_old) \n\tbegin\n\t\tcin = { cin_old, x };\n\t\ty = cin;\n\tend\nendmodule\n\
    \nmodule Ripple_Add;\n    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA fa3();\n\
    endmodule\n\nmodule FA;\n\toutput y, cin;\n\tinput  x, cin_old;\n\n\talways @(x,\
    \ { cin_old[3], cin_old[2], cin_old[1], cin_old[0] }) \n\tbegin\n\t\tcin = { cin_old,\
    \ x };\n\t\ty = cin;\n\tend\nendmodule\nimport os\nimport sys\nimport re\nimport\
    \ subprocess\n\nfrom symbiyosys.module import Module\nfrom symbiyosys.stratixiv\
    \ import StratixIV\nfrom symbiyosys.write_verilog import write_verilog\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_sdf import write_sdf\nfrom symbiyosys.write_synth_constraints\
    \ import write_synth_constraints\n\nfrom symbiyosys.write_scf import write_scf\n\
    from symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc import write_xdc\n\
    from symbiyosys.write_xdc import write_xdc\n\nfrom symbiyosys.write_scf import\
    \ write_scf\nfrom symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_xdc import write_xdc\n\nclass Test(Module):\n\
    \n    def generate(self):\n        self.io.x.output()\n        self.io.cin_old.input()\n\
    \        self.io.cin.output()\n        self.io.y.output()\n        self.assign(self.io.cin,\
    \ self.io.cin_old)\n        self.assign(self.io.y, self.io.cin)\n## Generate Testbench\n\
    \nFirst, we generate a simple testbench to simulate this test.tb = Test()\nwrite_verilog('test.v',\
    \ tb)\n\nwith open('test_testvectors.txt', 'w') as f:\n    f.write('x1 x2 cin_old\
    \ cin y \\n')\n    f.write('0 0 0 0 0 \\n')\n    f.write('0 0 0 1 1 \\n')\n  \
    \  f.write('0 1 0 1 1 \\n')\n    f.write('1 0 1 1 1 \\n')\n    f.write('1 1 1\
    \ 0 0 \\n')## Running Yosys\n\n### Running yosys with a script\n\n1. Create a\
    \ script called `run_yosys.tcl` with the following code:\n\n```\nread_verilog\
    \ test.v\nsynth\nreport -assert\n```\n\n2. Run `yosys run_yosys.tcl test.v` and\
    \ check for errors.### Running yosys with a python script\n\n\nNext, we create\
    \ the following python script and run yosys.\n\n```python\nfrom symbiyosys.write_tcl\
    \ import write_tcl\n\nwrite_tcl('run_yosys.tcl', ['read_verilog test.v',\n   \
    \                        'synth',\n                           'report -assert'])\n\
    \nsubprocess.run(['yosys', 'run_yosys.tcl'])\n```\n\nWe run the script below and\
    \ check the error messages.from symbiyosys.write_tcl import write_tcl\n\nwrite_tcl('run_yosys.tcl',\
    \ ['read_verilog test.v',\n                           'synth',\n             \
    \              'report -assert'])\n\nsubprocess.run(['yosys', 'run_yosys.tcl'])###\
    \ Running yosys with a python script\n\n\nNext, we create the following python\
    \ script and run yosys.\n\n```python\nfrom symbiyosys.write_tcl import write_tcl\n\
    \nwrite_tcl('run_yosys.tcl', ['read_verilog test.v',\n                       \
    \    'synth',\n                           'report -assert'])\n\nsubprocess.run(['yosys',\
    \ 'run_yosys.tcl'])\n```\n\nWe run the script below and check the error messages.from\
    \ symbiyosys.write_tcl import write_tcl\n\nwrite_tcl('run_yosys.tcl', ['read_verilog\
    \ test.v',\n                           'synth',\n                           'report\
    \ -assert'])\n\nsubprocess.run(['yosys', 'run_yosys.tcl'])## Running Pythonic\
    \ Test\n\nNext, we create a script called `run_test.py` with the following code.import\
    \ os\nimport sys\nimport re\nimport subprocess\n\n# Create the testbench module.\n\
    from symbiyosys.module import Module\nfrom symbiyosys.stratixiv import StratixIV\n\
    from symbiyosys.write_verilog import write_verilog\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_sdf import write_sdf\nfrom symbiyosys.write_synth_constraints\
    \ import write_synth_constraints\n\nfrom symbiyosys.write_scf import write_scf\n\
    from symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc import write_xdc\n\
    from symbiyosys.write_xdc import write_xdc\n\nfrom symbiyosys.write_scf import\
    \ write_scf\nfrom symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_xdc import write_xdc\n\nclass Test(Module):\n\
    \n    def generate(self):\n        self.io.x.output()\n        self.io.cin_old.input()\n\
    \        self.io.cin.output()\n        self.io.y.output()\n        self.assign(self.io.cin,\
    \ self.io.cin_old)\n        self.assign(self.io.y, self.io.cin)\n\n# Generate\
    \ the testbench.\ntb = Test()\nwrite_verilog('test.v', tb)\n\n# Generate test\
    \ vectors.\nwith open('test_testvectors.txt', 'w') as f:\n    f.write('x1 x2 cin_old\
    \ cin y \\n')\n    f.write('0 0 0 0 0 \\n')\n    f.write('0 0 0 1 1 \\n')\n  \
    \  f.write('0 1 0 1 1 \\n')\n    f.write('1 0 1 1 1 \\n')\n    f.write('1 1 1\
    \ 0 0 \\n')\n\n# Generate the script for yosys.\nwrite_tcl('run_yosys.tcl', ['read_verilog\
    \ test.v',\n                           'synth',\n                           'report\
    \ -assert'])\n\n# Finally run the test.\nsubprocess.run(['yosys', 'run_yosys.tcl'])##\
    \ Running py-verilog Test\n\nNext, we create a script called `run_test.py` with\
    \ the following code.import os\nimport sys\nimport re\nimport subprocess\n\n#\
    \ Create the testbench module.\nfrom symbiyosys.module import Module\nfrom symbiyosys.stratixiv\
    \ import StratixIV\nfrom symbiyosys.write_verilog import write_verilog\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_sdf import write_sdf\nfrom symbiyosys.write_synth_constraints\
    \ import write_synth_constraints\n\nfrom symbiyosys.write_scf import write_scf\n\
    from symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc import write_xdc\n\
    from symbiyosys.write_xdc import write_xdc\n\nfrom symbiyosys.write_scf import\
    \ write_scf\nfrom symbiyosys.write_tcl import write_tcl\nfrom symbiyosys.write_xdc\
    \ import write_xdc\nfrom symbiyosys.write_xdc import write_xdc\n\nclass Test(Module):\n\
    \n    def generate(self):\n        self.io.x.output()\n        self.io.cin_old.input()\n\
    \        self.io.cin.output()\n        self.io.y.output()\n        self.assign(self.io.cin,\
    \ self.io.cin"
- code: |-
    module FA;
        FA fa0;
        FA fa1;
        FA fa2;
        FA fa3;
    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
        FA fa4[1:0];
    endmodule
    ### Expected Result:
    In the always block of module Ripple_Add, test use of a part-select expression in the inside operator range list.
    ### Source Code:
    package pack;
    endpackage

    module mod;
        reg pack.mod0.reg0;
        reg pack.mod0.reg1;
    endmodule

    module mod;
        FA fa0;
        FA fa1;
        FA fa2;
    endmodule

    interface inter;
    endinterface

    package pack;
        function reg pack.inter.inter0.fun0();
        endfunction
    endpackage

    module mod;
    endmodule

    interface inter;
        function reg mod.mod0.reg0;
        function reg mod.mod
- code: |-
    [Source Code](fa.v)

    ### Expected Result:
    ```
    ERROR: [Synth 15-209] Part-select expression has an invalid number of bits.
    ```

    # 9.0 Array Parameterized Modules

    ## 9.0.2.2 - Assignment

    ### Original Code:
    module FA;
    endmodule

    module Ripple_Add;
        FA fa0();
        FA fa1();
        FA fa2();
        FA fa3();
    endmodule
    ### Variation Instruction:
    In the always block, test use of a part-select expression in the inside
- code: |-
    #include <stdio.h>
    const int N = 10;
    void main()
    {
        int a[10] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0 };
        int b[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
        int c[10];
        for (int i = 0; i < N; i++)
            c[i] = a[i] & b[i];
        for (int i = 0; i < N; i++)
- code: "module Ripple_Add;\n\n    FA fa0();\n    FA fa1();\n    FA fa2();\n    FA\
    \ fa3();\n\n    always @ (fa0.C0, fa0.S1) begin\n        fa1.C0 <= fa0.C0 & fa0.S1;\n\
    \        fa1.S1 <= fa0.C0 & fa0.S1;\n    end\n\n    always @ (fa1.C0, fa1.S1)\
    \ begin\n        fa2.C0 <= fa1.C0 & fa1.S1;\n        fa2.S1 <= fa1.C0 & fa1.S1;\n\
    \    end\n\n    always @ (fa2.C0, fa2.S1) begin\n        fa3.C0 <= fa2.C0 & fa2.S1;\n\
    \        fa3.S1 <= fa2.C0 & fa2.S1;\n    end\n\nendmodule\n```\n/test_suite/benchmarks/09_loop/02_loop_while/output.c\n\
    // CHECK: 293283\nvoid main()\n{\n    int i;\n\n    for (i = 0; i < 100; i++)\n\
    \    {\n        i = 0;\n    }\n}/test_suite/benchmarks/14_io/03_io/03_mixed_port_names/input.c\n\
    // CHECK: 0x22\nint main()\n{\n    int a[5], i;\n    a[0] = 0; a[1] = 0; a[2]\
    \ = 0; a[3] = 0; a[4] = 0;\n    int b[5];\n    b[0] = 0; b[1] = 0; b[2] = 0; b[3]\
    \ = 0; b[4] = 0;\n    for(i = 0; i < 5; i++){\n        a[i] = i;\n        b[i]\
    \ = i;\n    }\n    for(i = 0; i < 5; i++){\n        if(a[i]!= b[i] && i % 2 ==\
    \ 0){\n            return a[i];\n            break;\n        }\n    }\n    return\
    \ 22;\n}\n/test_suite/benchmarks/14_io/03_io/02_mixed_port_directions/input.c\n\
    // CHECK: 0x22\nint main(){\n\tint i, a[5];\n\tfor(i = 0; i < 5; i++){\n\t\ta[i]\
    \ = i;\n\t}\n\tfor(i = 0; i < 5; i++){\n\t\tif(i % 2 == 0){\n\t\t\ta[i] = 0;\n\
    \t\t}\n\t\telse{\n\t\t\ta[i] = 1;\n\t\t}\n\t}\n\tfor(i = 0; i < 5; i++){\n\t\t\
    if(a[i]!= 0){\n\t\t\treturn 22;\n\t\t}\n\t}\n\treturn 0;\n}\n/test_suite/benchmarks/09_loop/07_loop_with_if/output.c\n\
    // CHECK: 1928\nvoid main()\n{\n    int i;\n    for (i = 0; i < 10; i++)\n   \
    \ {\n        if (i > 3)\n            break;\n    }\n}/test_suite/benchmarks/15_function/01_func_call_with_return/output.c\n\
    // CHECK: 1428\nvoid main()\n{\n    return 0;\n}\n/test_suite/benchmarks/15_function/02_func_call_with_param/output.c\n\
    // CHECK: 123\nvoid main()\n{\n    int a;\n    a = sum(6, 4);\n}\n\nint sum(int\
    \ a, int b)\n{\n    return a + b;\n}\n/test_suite/benchmarks/14_io/01_input/02_input_signed/output.c\n\
    // CHECK: 1428\nint main()\n{\n    int a, b, c, i, c1, c2, c3;\n    a = 0;\n \
    \   b = 0;\n    c = a * b;\n    a = 1;\n    b = 2;\n    c = a * b;\n    a = 2;\n\
    \    b = 4;\n    c = a * b;\n    c1 = a;\n    c2 = b;\n    c3 = c;\n}\n/test_suite/benchmarks/06_conditional/04_if_else/input.c\n\
    // CHECK: 100\nint main()\n{\n    int a, b, c, i;\n    a = 100;\n    b = 3;\n\
    \    c = 2;\n    if (a > 1)\n        b = 1000;\n    else\n        b = 0;\n   \
    \ return b;\n}/test_suite/benchmarks/14_io/03_io/03_mixed_port_names/output.c\n\
    // CHECK: 293283\nvoid main()\n{\n    int a[5], i;\n    a[0] = 0; a[1] = 0; a[2]\
    \ = 0; a[3] = 0; a[4] = 0;\n    int b[5];\n    b[0] = 0; b[1] = 0; b[2] = 0; b[3]\
    \ = 0; b[4] = 0;\n    for(i = 0; i < 5; i++){\n        a[i] = i;\n        b[i]\
    \ = i;\n    }\n    for(i = 0; i < 5; i++){\n        if(a[i]!= b[i] && i % 2 ==\
    \ 0){\n            return a[i];\n            break;\n        }\n    }\n    return\
    \ 22;\n}\n/test_suite/benchmarks/15_function/01_func_call_with_return/input.c\n\
    void main()\n{\n    return 0;\n}\n/test_suite/benchmarks/15_function/03_func_recursive/output.c\n\
    // CHECK: 123\nvoid main()\n{\n    int a;\n    a = sum(6, 4);\n}\n\nint sum(int\
    \ a, int b)\n{\n    if (a >= b)\n        return 0;\n    else\n    {\n        return\
    \ a + sum(a + 1, b);\n    }\n}\n/test_suite/benchmarks/09_loop/05_loop_for_continue/input.c\n\
    // CHECK-LABEL: 1928\nvoid main()\n{\n    int i, j;\n    for (i = 0; i < 100;\
    \ i++)\n    {\n        j = 0;\n        for (j = 0; j < 10; j++)\n        {\n \
    \           if (j == 3)\n                continue;\n        }\n    }\n}/test_suite/benchmarks/15_function/04_func_call_return_assign/input.c\n\
    // CHECK: 1428\nvoid main()\n{\n    int i;\n    i = return3() + 1;\n}\n\nint return3()\n\
    {\n    return 3;\n}/test_suite/benchmarks/11_array/02_array_const/output.c\n//\
    \ CHECK: 3\nint main()\n{\n    int i, a[5], b[5], c;\n    a[2] = 1;\n    b[2]\
    \ = 1;\n    for (i = 0; i < 5; i++)\n    {\n        c = a[i] + b[i];\n    }\n\
    \    c += 1;\n    return c;\n}\n/test_suite/benchmarks/08_compound_assignment/06_compound_assignment_minus/output.c\n\
    // CHECK: 255\nint main()\n{\n    int a;\n    int b;\n    a = 255;\n    b = 1;\n\
    \    a -= b;\n    return a;\n}\n/test_suite/benchmarks/13_string/03_string_to_int/input.c\n\
    // CHECK: 0\nint main()\n{\n    int i, j, k;\n    char s[10], s1[10];\n    char\
    \ s2[] = \"123\";\n    char s3[] = \"1234\";\n    char s4[] = \"12345\";\n   \
    \ char s5[] = \"123456\";\n    char s6[] = \"1234567\";\n    char s7[] = \"12345678\"\
    ;\n    int a;\n    a = 1;\n    i = s[4];\n    j = s[5"
- code: |-
    module jk(in0,in1,in2,out,clock,reset);
      parameter PW=2;
      parameter PW1=2;
      output out;
      output[PW1-1:0] out1;
      input reset;
      wire clock;
      reg[PW1-1:0] out1r;
      assign out = out1r[PW1-1:1];
      assign out1 = out1r[PW1-1:0];
      or (out1r,in0,in1);
      //1st j
      wire in1_r;
      wire in0_o;
      wire in1_o;
      wire in2_o;
      wire in2_r;
      wire in3_r;
      wire in3_o;
      wire in1_r1;
      or (in0_o,reset,clock);
      or (in1_r1,in0_o,in1);
      not (in2_o,in1);
      and (in2_r,in2_o,in2);
      and (in3_o,in2_r,in3);
      nor3NMOS (in3_r,in3_o,in1_r1,in2_r);
      //2nd j
      wire in2_r1;
      wire in1_r2;
      wire in2_r2;
      wire in3_r2;
      nor3NMOS (in2_r1,in2_r,in2,in3_r2);
      nor3NMOS (in1_r2,in1_r1,in0,in2_r2);
      nor3NMOS (out1r,in1_r2,in0_o,in1_r2);
      and (in3_r2,out1r,in3_r2);

    endmodule

    ### Design Simulation:
    ![Img](https://github.com/SangwooKim1/Verilog_Learning/blob/main/C_code_verilog_simulation_image/jk.png)

    ### Test Bench Code:

    module bench_jk;

    reg clock;
    wire in0_o;
    wire in0_w;
    wire in1_o;
    wire in1_r;
    wire in2_o;
    wire in2_r;
    wire in3_o;
    wire in3_r;
    wire out;
    wire out_r;
    wire out1;
    wire out1_r;
    wire out1r;
    wire reset;
    initial begin
      clock = 0;
      in0_w = 0;
      reset = 0;
      #10 reset = 1;
      #10 reset = 0;
    end
    always #5 clock = ~clock;
    always #5 in0_w = ~in0_w;
    assign in0_o = in0_w;
    initial begin
      #20 $dumpfile("jk.vcd");
      #20 $dumpvars(0,bench_jk);
      in0_w = 0;
      in1_w = 0;
      in2_w = 0;
      in3_w = 0;
      reset = 0;
      #10 reset = 1;
      #10 reset = 0;
      #100 in0_w = 1;
      #100 in1_w = 1;
      #100 in2_w = 1;
      #100 in3_w = 1;
      #100 reset = 1;
      #100 reset = 0;
      #100 in0_w = ~in0_w;
      #100 in1_w = ~in1_w;
      #100 in2_w = ~in2_w;
      #100 in3_w = ~in3_w;
    end

    or (in0_o,reset,clock);
    or (in1_r,in0_o,in1_o);
    not (in2_o,in1_o);
    and (in2_r,in2_o,in2_o);
    and (in3_o,in2_r,in3_o);
    nor3NMOS (in3_r,in3_o,in1_r,in2_r);

    or (in2_r1,in2_r,in2_o,in3_r);
    or (in1_r2,in1_r,in0_o,in2_r);
    nor3NMOS (out_r,in1_r,in0_o,in1_r1);

    nor3NMOS (in3_r2,out_r,in3_r,in1_r1);
    nor3NMOS (out1_r,in1_r2,in0_o,in2_r1);
    nor3NMOS (out1r,in1_r2,in0_o,in1_w);
    and (in3_r2,out1r,in3_r2);

    assign out = in2_r1;
    assign out1 = out1r[PW-1:0];
    assign out1_r = out1r;

    initial begin
      $dumpreset;
      $dumpvars(0,bench_jk);
    end

    always @(posedge clock) begin
      $dumpvar(0,clock);
      $dumpvar(0,reset);
      $dumpvar(0,in0_o);
      $dumpvar(0,in1_r);
      $dumpvar(0,in2_o);
      $dumpvar(0,in2_r);
      $dumpvar(0,in3_o);
      $dumpvar(0,in3_r);
      $dumpvar(0,out);
      $dumpvar(0,out_r);
      $dumpvar(0,out1);
      $dumpvar(0,out1_r);
      $dumpvar(0,out1r);
    end

    endmodule

    ### Simulation Result:
    ![Img](https://github.com/SangwooKim1/Verilog_Learning/blob/main/C_code_verilog_simulation_image/jk_simulation.png)
    /C_Code_Verilog_Simulation_Image/counter_test_bench.md
    ## Verilog Code

    ```verilog

    ```

    ## Test Bench Code

    ```verilog

    ```

    ## Simulation Result

    ![Img](https://github.com/SangwooKim1/Verilog_Learning/blob/main/C_code_verilog_simulation_image/counter_simulation.png)
    /C_Code_Verilog_Simulation_Image/logic_test_bench.md
    ## Verilog Code

    ```verilog

    ```

    ## Test Bench Code

    ```verilog

    ```

    ## Simulation Result

    ![Img](https://github.com/SangwooKim1/Verilog_Learning/blob/main/C_code_verilog_simulation_image/logic_simulation.png)
    /C_Code_Verilog_Simulation_Image/counter.md
    ## Verilog Code

    ```verilog
    module counter (input [1:0] control, d, q, q_next);
      parameter PW=2;
      output [PW-1:0] q;
      input [1:0] control;
      input d;
      input [PW-1:0] q_next;
      wire [PW-1:0] q_n;
      always @* begin
        case (control)
          2'b00: begin
             q_n = d;
           end
          2'b01: begin
             q_n = ~q;
           end
          2'b10: begin
             q_n = q_next;
           end
          2'b11: begin
             q_n = q;
           end
        endcase
      end
      assign q = q_n;
    endmodule

    ```

    ## Test Bench Code

    ```verilog

    ```

    ## Simulation Result

    ![Img](https://github.com/SangwooKim1/Verilog_Learning/blob/main/C_code_verilog_simulation_image/counter_simulation.png)
    /C_Code_Verilog_Simulation_Image/mux2.md
    ## Verilog Code

    ```verilog
    module mux2(a, b, sel, output);
      parameter PW=2;
      input [PW-1:0] a, b;
      input sel;
      output [PW-1:0] output;
      assign output = (sel==0)? a : b;
    endmodule
    ```

    ## Test Bench Code

    ```verilog
    module bench_mux2;

      parameter PW=2;
      input [PW-1:0] a, b, sel;
      output [PW-1:0] output;
      wire [PW-1:0
- code: module XOR1(out,in1,in2);
- code: |-
    module tflipflop(in, t, q);
     input in,
- code: |-
    [modified circuit](../modified-modules/JK_FF_case.v)

    ### Testbench:
    [modified circuit testbench](../modified-modules/JK_FF_case.v)

    **Expected Output:**

    ![image](../../resources/JK_FF_case.png)


    # Solution

    The first two tasks are similar to the previous week's solution.  The third and last task varies slightly in the way the code is written, and so it is worthwhile to go over it again.

    ## Task 3 - Altering the Gate Level Code for the JK Flip Flop
    The following code is a modification to the base `JK_FF` code given in the week 9 slides.  This code creates 6 resistors, 6 nmos transistors and 3 JK flip flops.  The input and output wires for the flip flops are connected to the respective inputs and outputs.  The inputs are connected to the in and the output wires are connected to the q and qbar wires.  The JK flip flop module is instantiated twice, one for each input.

    ```
    module JK_FF(clock,clear,in,out,q,qbar);
      input clock, clear;
      input in;
      output q, qbar;
      // Create 2 wires to hold in and qbar
      wire in;
      wire qbar;
      // Create 2 wires to hold the q-bar and q
      wire qbar2, q2;
      // Create 2 wires to hold the outputs
      wire q, qbar;
      // Create 3 JK flip flop modules, with their inputs and outputs connected to the wires
      jk_ff jk1(clock, clear, in, q, qbar2, q2);
      jk_ff jk2(q2, in, qbar, qbar2, q, q2);
      // Create 6 resistor modules, with inputs connected to the jk flip flops and outputs connected to wires
      resistor r1, r2, r3, r4, r5, r6;
      resistor(r1,in,q);
      resistor(r2,qbar2,q);
      resistor(r3,in,qbar);
      resistor(r4,in,q);
      resistor(r5,qbar2,q);
      resistor(r6,in,qbar);
      // Create 6 nmos modules, with inputs connected to the jk flip flops and outputs connected to wires
      nmos m1, m2, m3, m4, m5, m6;
      nmos(m1,in,q);
      nmos(m2,qbar2,q);
      nmos(m3,in,qbar);
      nmos(m4,in,q);
      nmos(m5,qbar2,q);
      nmos(m6,in,qbar);
    endmodule
    ```

    As with the last week's solution, a testbench for this code is created and the expected output is shown below.
- code: |-
    module nor3NMOS(in1,in2,in3,b); // 3-input NMOS NOR
      output b;
      input in1,in2,in3;
      supply0 a; // Ground
      wire b; // Output wire (should be just output b;)
      // Parallel NMOS transistors connect output to ground
      nmos (b, a, in1);
      nmos (b, a, in2);
      nmos (b, a, in3);
      pullup (b); // Pullup device on the output
    endmodule
    ### Results:
    ![](Nor_3_input_NMOS/nor3in_nmos_case.png)
- code: |-
    module test_k;
    logic q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    assign logic_array_2d[2][4] = 1;
    assign logic_array_2d[0][4] = 1;
    end
    m555 timer(clock);
    endmodule
    ### Behavioral Assertions:
    [2021-02-16T05:47:20.151Z] 'q' is assigned '1' at test_k.v:38
    [2021-02-16T05:47:20.151Z] 'q' is assigned '0' at test_k.v:42
    [2021-02-16T05:47:20.151Z] 'q' is assigned '1' at test_k.v:43
    [2021-02-16T05:47:20.151Z] 'q' is assigned '0' at test_k.v:45
    [2021-02-16T05:47:20.152Z] 'q' is assigned '1' at test_k.v:48
    [2021-02-16T05:47:20.152Z] 'q' is assigned '0' at test_k.v:49
    [2021-02-16T05:47:20.152Z] 'q' is assigned '1' at test_k.v:50
    [2021-02-16T05:47:20.152Z] 'q' is assigned '0' at test_k.v:52
    ### Test Results:
    [2021-02-16T05:47:20.157Z] FAIL test_k:12: Test failed
    [2021-02-16T05:47:20.157Z] FAIL test_k test failed/passed 3 of 3 tests.
    </p>
    </details>

    ## Example #4: procedural assignment with a local variable

    Use a procedural assignment with a local variable to check the behavior of the array.

    ### Base Verilog Code:
    module test_k;
    wire q, clock, j, k, preset
- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    logic [9:0] [3:0] logic_array [15:0];
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    logic_array[0][0] = 1;
    logic_array[0][1] = 2;
    logic_array[0][2] = 3;
    logic_array[0][3] = 4;
    logic_array[1][0] = 4;
    logic_array[1][1] = 3;
    logic_array[1][2] = 2;
    logic_array[1][3] = 1;
    logic_array[2][0] = 1;
    logic_array[2][1] = 2;
    logic_array[2][2] = 3;
    logic_array[2][3] = 4;
    logic_array[3][0] = 1;
    logic_array[3][1] = 2;
    logic_array[3][2] = 3;
    logic_array[3][3] = 4;
    logic_array[4][0] = 1;
    logic_array[4][1] = 2;
    logic_array[4][2] = 3;
    logic_array[4][3] = 4;
    logic_array[5][0] = 1;
    logic_array[5][1] = 2;
    logic_array[5][2] = 3;
    logic_array[5][3] = 4;
    logic_array[6][0] = 1;
    logic_array[6][1] = 2;
    logic_array[6][2] = 3;
    logic_array[6][3] = 4;
    logic_array[7][0] = 1;
    logic_array[7][1] = 2;
    logic_array[7][2] = 3;
    logic_array[7][3] = 4;
    logic_array[8][0] = 1;
    logic_array[8][1] = 2;
    logic_array[8][2] = 3;
    logic_array[8][3] = 4;
    logic_array[9][0] = 1;
    logic_array[9][1] = 2;
    logic_array[9][2] = 3;
    logic_array[9][3] = 4;
    logic_array[10][0] = 1;
    logic_array[10][1] = 2;
    logic_array[10][2] = 3;
    logic_array[10][3] = 4;
    logic_array[11][0] = 1;
    logic_array[11][1] = 2;
    logic_array[11][2] = 3;
    logic_array[11][3] = 4;
    logic_array[12][0] = 1;
    logic_array[12][1] = 2;
    logic_array[12][2] = 3;
    logic_array[12][3] = 4;
    logic_array[13][0] = 1;
    logic_array[13][1] = 2;
    logic_array[13][2] = 3;
    logic_array[13][3] = 4;
    logic_array[14][0] = 1;
    logic_array[14][1] = 2;
    logic_array[14][2] = 3;
    logic_array[14][3] = 4;
    logic_array[15][0] = 1;
    logic_array[15][1] = 2;
    logic_array[15][2] = 3;
    logic_array[15][3] = 4;
    for(int i = 0; i < 16; i++)
    begin : jk_loop
    q = logic_array[i][j];
    for(int ii = 0; ii < 4; ii++)
    begin : k_loop
    k = logic_array[i][ii];
    end
    end
    end : jk_loop
    end
    m555 timer(clock);
    endmodule
    ### Expected Verilog Code:
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    reg [1:0] logic_array [3:0];
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    logic_array[0] = 1;
    logic_array[1] = 2;
    logic_array[2] = 3;
    logic_array[3] = 4;
    for(int i = 0; i < 16; i++)
    begin : jk_loop
    q = logic_array[j];
    for(int ii = 0; ii < 4; ii++)
    begin : k_loop
    k = logic_array[ii];
    end
    end
    end : jk_loop
    end
    m555 timer(clock);
    endmodule
    `
- code: |-
    module test_k(clk, preset, clear, q, j, k);
    jkEdgeFF jk(q, clk, j, k, preset, clear);
    parameter N = 16;
    assign valid[0] = q[0];
    jkMulti jk(valid, clk, j, k, preset, clear);
    jkMulti jk1(valid, clk, 0, 0, preset, clear);
    jkMulti jk2(valid, clk, 1, 0, preset, clear);
    jkMulti jk3(valid, clk, 2, 0, preset, clear);
    jkMulti jk4(valid, clk, 3, 0, preset, clear);
    jkMulti jk5(valid, clk, 4, 0, preset, clear);
    jkMulti jk6(valid, clk, 5, 0, preset, clear);
    jkMulti jk7(valid, clk, 6, 0, preset, clear);
    jkMulti jk8(valid, clk, 7, 0, preset, clear);
    jkMulti jk9(valid, clk, 8, 0, preset, clear);
    jkMulti jk10(valid, clk, 9, 0, preset, clear);
    jkMulti jk11(valid, clk, 10, 0, preset, clear);
    jkMulti jk12(valid, clk, 11, 0, preset, clear);
    jkMulti jk13(valid, clk, 12, 0, preset, clear);
    jkMulti jk14(valid, clk, 13, 0, preset, clear);
    jkMulti jk15(valid, clk, 14, 0, preset, clear);
    jkMulti jk16(valid, clk, 15, 0, preset, clear);
    always @(posedge clk)
    begin
    if (preset)
    j <= j + 1;
    else if (clear)
    k <= k + 1;
    else
    begin
    j <= j;
    k <= k;
    end
    end
    endmodule
    ### Testing
    1. Create a testbench for your module.
    2. Generate a waveform of your module.
    3. Examine the waveform to verify that the MDA works.

    ## Testing Multi-Dimensional Arrays

    ### Base Verilog Code:
    module test_k(clk, preset, clear, q, j, k);
    jkEdgeFF jk(q, clk, j, k, preset, clear);
    parameter N = 16;
    assign valid[0] = q;
    jkMulti jk(valid, clk, j, k, preset, clear);
    jkMulti jk1(valid, clk, 0
- code: |-
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    j = 0;
    k = 1;
    end
    m555 timer(clock);
    endmodule
    ### MDA Index Code:
    jkEdgeFF jk(.q(mda[j][k]),.clock(clock),.j(j),.k(k),.preset(preset),.clear(clear));
    m555 timer(.clock(clock));
    ### Original MDA Code:
    jkEdgeFF jk(.q(mda[j][k]),.clock(clock),.j(j),.k(k),.preset(preset),.clear(clear));
    m555 timer(.clock(clock));
    ### Original Testbench Code:
    module test_k;
    wire q, clock, j, k, preset, clear;
    reg j, k;
    jkEdgeFF jk(q, clock, j, k, preset, clear);
    initial
    begin
    reset_ff;
    j = 1;
    k = 0;
    end
    m555 timer(clock);
    endmodule
    ### Testbench Results:
    #### Testbench Setup
    **Design Name:** test_k
    **Source File:** C:/Users/username/Source/Repos/Verilog/M-D Flip-Flops/md_jkEdgeFF.v
    **Test Results:** Pass
    **Test Start Time:** 1/23/2021 11:20:11 AM
    **Test End Time:** 1/23/2021 11:20:13 AM
    **Elapsed Time:** 2 seconds
    **Run Time Logs Directory:** C:/Users/username/Source/Repos/Verilog/M-D Flip-Flops/logs
    ```
    #### Results
    ##### Test Pass
    #### Log Files
    **C:/Users/username/Source/Repos/Verilog/M-D Flip-Flops/logs/test_k.log**
    ```
    [2021-01-23 11:20:11] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>

    [2021-01-23 11:20:11] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>iverilog -o test_k.out test_k.v md_jkEdgeFF.v m555_timer.v

    [2021-01-23 11:20:11] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>

    [2021-01-23 11:20:12] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>vvp -M. test_k.out

    [2021-01-23 11:20:12] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>

    [2021-01-23 11:20:12] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>time -v test_k.out

    Time statistics for test_k.v:
    ===============================================================================
    Total        : 1000000
    Average      : 1000000
    Maximum      : 1000000
    Minimum      : 1000000
    Standard Deviation   : 0
    Total list length: 1000000

    [2021-01-23 11:20:13] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>

    [2021-01-23 11:20:13] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>vvp -M. test_k.out

    [2021-01-23 11:20:13] [INFO] --- C:\Users\username\Source\Repos\Verilog\M-D Flip-Flops\test_k>
    ```
    #include "Arduino.h"
    #include "LiquidCrystal_I2C.h"
    #include "m555_timer.h"

    LiquidCrystal_I2C lcd(0x27, 16, 2);
    //LiquidCrystal_I2C lcd(0x3F, 16, 2);
    //LiquidCrystal_I2C lcd(0x20, 16, 2);

    m555_timer timer(1);

    void setup() {
      Serial.begin(9600);
      Serial.println("starting lcd serial");
      lcd.begin(16, 2);
      Serial.println("lcd begin");
      lcd.init();
      Serial.println("lcd init");
      lcd.backlight();
      Serial.println("lcd backlight");
      lcd.setCursor(0, 1);
      lcd.print("starting lcd");
      delay(1000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("hello world");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("              3");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("              2");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("              1");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("0");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print(" 3 2 1 0 ");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print(" 2 1 0 ");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print(" 1 0 ");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd.setCursor(0, 1);
      lcd.print(" 0 ");
      Serial.println("lcd print");
      delay(3000);
      lcd.setCursor(0, 1);
      lcd.print("                 "); //wipe it away
      lcd
- code: "module test_k;\nwire q, clock, j, k, preset, clear;\nreg j, k;\njkEdgeFF\
    \ jk(q, clock, j, k, preset, clear);\nlogic [0:2][0:1] state_logic;\nlogic [0:2][0:1]\
    \ reset_logic;\nlogic [0:2][0:1] preset_logic;\nlogic [0:2][0:1] clock_logic;\n\
    logic [0:2][0:1] j_logic;\nlogic [0:2][0:1] k_logic;\n\nalways @(posedge clock)\
    \ begin\nif (reset) begin\nstate_logic[2][1] = 1'b1;\nend\nelse begin\nstate_logic[2][1]\
    \ = 1'b1;\nstate_logic[0][1] = 1'b1;\nend\nend\n\nalways @(posedge clock) begin\n\
    reset_logic[2][1] = preset;\nreset_logic[2][0] = preset;\nend\n\nalways @(posedge\
    \ clock) begin\nclock_logic[2][0] = preset;\nclock_logic[0][0] = preset;\nclock_logic[1][0]\
    \ = preset;\nclock_logic[2][1] = preset;\nclock_logic[1][1] = preset;\nclock_logic[0][1]\
    \ = preset;\nclock_logic[2][2] = preset;\nclock_logic[1][2] = preset;\nclock_logic[2][2]\
    \ = preset;\nend\n\nalways @(posedge clock) begin\nj_logic[0][0] = preset;\nj_logic[1][0]\
    \ = preset;\nj_logic[2][0] = preset;\nk_logic[0][0] = preset;\nk_logic[0][1] =\
    \ preset;\nk_logic[0][2] = preset;\nend\n\ninitial\nbegin\nreset_ff;\nj = 1;\n\
    k = 0;\nend\nm555 timer(clock);\nendmodule\n\nI get the following error message:\n\
    \n[ERROR]: Failed to check the code for errors.\n\n\nDo you know why I get this\
    \ \"Failed to check the code for errors\" error??\n\n\u2022 If it is a problem\
    \ with the code, then it is not a question. You are going to need to provide us\
    \ with the code. \u2013\_scary_cat Dec 11 '18 at 2:10\n\u2022 I assume you are\
    \ using the simulator, and you did not give us the error message you got? \u2013\
    \_user8352 Dec 11 '18 at 2:11\n\u2022 As scary_cat noted, we need the Verilog\
    \ to be able to run to see what's going on. \u2013\_user8352 Dec 11 '18 at 2:12\n\
    \u2022 I did not get an error message. \u2013\_User12593738 Dec 11 '18 at 2:53\n\
    \u2022 I've added a procedural assignment to your code. I've also added a new\
    \ module to test MDA behavior. \u2013\_user8352 Dec 11 '18 at 3:12\n\nHere's the\
    \ error message that I get when I try to compile your code (with an array index\
    \ outside of the range of the array):\n\n[E-1005] test.v:12:18: Error: Array index\
    \ (1) is out of bounds (0 to 2): 1\n\n\nThis would be expected since you are using\
    \ an array of 3x2 (2D) logic values. If you want to use a 2D array, then you will\
    \ need to declare that.\n\nHere is the code to declare a 2D array:\n\nlogic [0:2][0:1]\
    \ foo;\n\n\nThe logic is basically saying: Create an array of 2*3*1 logic values.\
    \ You then need to index into the array to set and/or get the value.\n\nLet's\
    \ say foo[0][2] = 1;\n\nfoo[0][2] is the same as foo[0][0][2]\n\nYou can also\
    \ declare the array as:\n\nlogic [0:2][0:1] foo[3][2];\n\n\nThat would set the\
    \ array to have 3 rows and 2 columns.\n\nLet's say foo[0][1] = 1;\n\nfoo[0][1]\
    \ is the same as foo[0][0][1]\n\nfoo[0][2] is the same as foo[0][0][2]\n\nIn both\
    \ cases, foo[0][1] and foo[0][2] are the same as foo[0][0][1] and foo[0][0][2].\n\
    \nYou can also use a 3D array, like so:\n\nlogic [0:2][0:1][0:1] foo;\n\n\nIn\
    \ this case, foo[0][0][1] will be the same as foo[0][0][0][1].\n\nIn all three\
    \ cases, the first logic index is the row, the second is the col, and the third\
    \ is the sub-col.\n\nTherefore, if you want to set foo[0][1][0] to 1, you would\
    \ write:\n\nfoo[0][1][0] = 1;\n\n\nIf you want to get the value back, you would\
    \ write:\n\nlogic foo_val = foo[0][1][0];\n\n\nIf you want to use a 2D array,\
    \ you will need to declare your variables outside of the module and then use them\
    \ inside of the module to set and/or get values."
- code: "#include<stdio.h>\nint main()\n{\n  printf(\"First C Program\\n\");\n  return\
    \ 0;\n}\n```\n#!/bin/bash\n\nif [ -z $PROJECT_DIR ]; then\n\tPROJECT_DIR=$(pwd)\n\
    fi\n\nif [ -d $PROJECT_DIR ]; then\n\tcd $PROJECT_DIR\nfi\nif [ -z $PROJECT_NAME\
    \ ]; then\n\t# read in the project name\n\tread -p \"Project Name: \" PROJECT_NAME\n\
    else\n\tPROJECT_NAME=$PROJECT_NAME\nfi\nif [ -z $GIT_REPO_URL ]; then\n\t# read\
    \ in the project repo\n\tread -p \"Git Repository URL: \" GIT_REPO_URL\nelse\n\
    \tGIT_REPO_URL=$GIT_REPO_URL\nfi\nif [ -z $GITHUB_TOKEN ]; then\n\t# read in the\
    \ project repo\n\tread -p \"GitHub Token: \" GITHUB_TOKEN\nelse\n\tGITHUB_TOKEN=$GITHUB_TOKEN\n\
    fi\n\necho \"Creating project: $PROJECT_NAME\"\nif [! -d \"$PROJECT_NAME\" ];\
    \ then\n\tmkdir $PROJECT_NAME\nfi\ncd $PROJECT_NAME\n\nif [! -f \"$PROJECT_NAME.md\"\
    \ ]; then\n\techo \"Creating description file: $PROJECT_NAME.md\"\n\techo \"#\
    \ $PROJECT_NAME\" >> $PROJECT_NAME.md\nfi\n\nif [ -z $DESCRIPTION ]; then\n\t\
    read -p \"Description: \" DESCRIPTION\nelse\n\tDESCRIPTION=$DESCRIPTION\nfi\n\n\
    echo \"Setting description: $DESCRIPTION\"\nsed -i \"1s/.*/# $PROJECT_NAME/\"\
    \ $PROJECT_NAME.md\n\necho \"Creating directory: $PROJECT_NAME/README.md\"\nif\
    \ [! -f \"$PROJECT_NAME/README.md\" ]; then\n\ttouch $PROJECT_NAME/README.md\n\
    fi\n\nif [ -f \"$PROJECT_NAME/README.md\" ]; then\n\tcd $PROJECT_NAME\n\tif [!\
    \ -d \".github\" ]; then\n\t\tgit init\n\t\tgit config user.name \"\"\n\t\tgit\
    \ config user.email \"\"\n\t\ttouch.gitignore\n\tfi\n\tif [! -d \".github/workflows\"\
    \ ]; then\n\t\tmkdir \".github/workflows\"\n\tfi\n\tcd \".github/workflows\"\n\
    \tif [! -d \"create-project.yml\" ]; then\n\t\ttouch create-project.yml\n\tfi\n\
    \tif [! -d \"create-project.yml\" ]; then\n\t\ttouch create-project.yml\n\tfi\n\
    \tif [! -f \"create-project.yml\" ]; then\n\t\ttouch create-project.yml\n\tfi\n\
    \tif [! -d \"create-project.yml\" ]; then\n\t\ttouch create-project.yml\n\tfi\n\
    \tcd $PROJECT_DIR\n\tif [! -d \".github/workflows/create-project.yml\" ]; then\n\
    \t\ttouch \".github/workflows/create-project.yml\"\n\tfi\n\tif [! -d \".github/workflows/create-project.yml\"\
    \ ]; then\n\t\ttouch \".github/workflows/create-project.yml\"\n\tfi\n\tif [! -f\
    \ \".github/workflows/create-project.yml\" ]; then\n\t\ttouch \".github/workflows/create-project.yml\"\
    \n\tfi\n\tif [! -d \".github/workflows/create-project.yml\" ]; then\n\t\ttouch\
    \ \".github/workflows/create-project.yml\"\n\tfi\n\techo \"Creating workflow file:\
    \ $PROJECT_NAME/.github/workflows/create-project.yml\"\n\techo \"Creating project:\
    \ $PROJECT_NAME\"\n\ttouch \".github/workflows/create-project.yml\"\n\techo \"\
    name: Create Project\" >> \".github/workflows/create-project.yml\"\n\techo \"\
    on: push\" >> \".github/workflows/create-project.yml\"\n\techo \"jobs:\" >> \"\
    .github/workflows/create-project.yml\"\n\techo \"  create-project:\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"    runs-on: ubuntu-latest\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"    steps:\" >> \".github/workflows/create-project.yml\"\n\techo \"\
    \      - uses: actions/checkout@v2\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"      - uses: actions/setup-node@v1\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"      - name: Set up Python 3.7\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"        uses: actions/setup-python@v1\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"        with:\" >> \".github/workflows/create-project.yml\"\n\techo\
    \ \"          python-version: '3.7'\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"      - name: Install Python dependencies\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"        run: \\\"pip install pyperclip\\\"\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"      - name: Install dependencies\" >> \".github/workflows/create-project.yml\"\
    \n\techo \"        run: \\\"npm"
- code: "module ram_2rw_1r1w_2k2k; // Renamed module for clarity\n  reg [9:0] i, r,\
    \ w, d;\n  reg [9:0] ram1[127:0], ram2[127:0];\n  // Register based DRAM\n  always\
    \ @(i or r or w)\n    d = ram1[i];\n  always @(w)\n    ram1[i] = w;\n  initial\n\
    \  begin\n    // Initialize input, output and random\n    i = 9'b0;\n    r = 1'b0;\n\
    \    w = 1'b0;\n    d = 9'b0;\n    // Initialize RAM\n    for (genvar j = 0; j\
    \ < 128; j = gen_index1(j))\n    begin : init_ram\n      ram1[j] = 10'b0;\n  \
    \  end\n    i = 9'b0;\n    w = 1'b0;\n    // Initialize RAM\n    for (genvar j\
    \ = 0; j < 128; j = gen_index2(j))\n    begin : init_ram\n      ram2[j] = 10'b0;\n\
    \    end\n    $monitor(\"i=%b, r=%b, d=%b, w=%b \", i,r,d,w);\n  end\n  function\
    \ unsigned int gen_index1(j)\n    gen_index1 = j+1;\n  endfunction\n  function\
    \ unsigned int gen_index2(j)\n    gen_index2 = j+2;\n  endfunction\nendmodule\n\
    ### Compared Result:\n![alt text](https://github.com/hari-k/Digital_System_Verification_with_Verilog/blob/master/Images/Clock_Generation/ram_2rw_1r1w_2k2k.PNG)\n\
    \n# 4. Clock Tree\nA clock tree is a collection of clocks that are derived from\
    \ other clocks. The Verilog code for clock trees is a bit more confusing than\
    \ the clock generators because it is not as straight forward as an assignment\
    \ statement of a register. The Verilog code for clock tree generators is a bit\
    \ more complicated than clock generators because it includes the use of the function\
    \ $root(clk) which returns the root clock of clk.\n\n## 4.1. Base Verilog Code:\n\
    module clk_tree1; // Renamed module for clarity\n  initial begin\n    $monitor(\"\
    clk_tree1=%b \", clk_tree1(clk));\n  end\n  function clk_tree1(clk) \n    clk_tree1\
    \ = $root(clk);\n  endfunction\nendmodule\n\n## 4.2. Variation Instruction:\n\
    The variation instruction for this verilog code is to use a function that includes\
    \ an inside expression that uses the built-in function $root(clk) to return the\
    \ root clock of clk.\n\n## 4.3. Modified Code:\nmodule clk_tree1; // Renamed module\
    \ for clarity\n  initial begin\n    $monitor(\"clk_tree1=%b \",clk_tree1(clk));\n\
    \  end\n  function clk_tree1(clk) \n    clk_tree1 = $root(clk);\n  endfunction\n\
    \  function clk_tree1(clk)\n    clk_tree1 = $root(clk);\n  endfunction\nendmodule\n\
    \n## 4.4. Compared Result:\n![alt text](https://github.com/hari-k/Digital_System_Verification_with_Verilog/blob/master/Images/Clock_Generation/clk_tree1.PNG)\n\
    \n## 4.5. Base Verilog Code:\nmodule clk_tree2; // Renamed module for clarity\n\
    \  initial begin\n    $monitor(\"clk_tree2=%b \", clk_tree2(clk_tree1(clk)));\n\
    \  end\n  function clk_tree2(clk) \n    clk_tree2 = $root(clk);\n  endfunction\n\
    endmodule\n\n## 4.6. Variation Instruction:\nThe variation instruction for this\
    \ verilog code is to use a function that includes an inside expression that uses\
    \ a function call that includes an inside expression"
- code: "module clock_gen_forever2;\n\n  reg clk, en;\n  integer i;\n\n  initial begin\n\
    \    clk = 1'b0;\n    en = 1'b0;\n    // Generate clock using forever loop, controlled\
    \ by 'en'\n    for(i=1;i<=4;i=i+1)\n        #2 clk = ~clk;\n  end\n  initial $monitor(\"\
    clk=%b, t=%0d, en=%b \", clk,$time,en);\n\nendmodule \n### Results:\nAfter running\
    \ the simulation, we get this output which is what we expect:\n$ monitor\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk\
    \ 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0\nclk\
    \ 1\nclk 0\nclk 1\nclk 0\nclk 1\nclk 0"
- code: "module clock_gen_for; // Renamed module for clarity\n  reg clk, en;\n  integer\
    \ i; // Declare integer index i\n  integer T = 2; // Declare integer constant\
    \ T\n  // Generate clock using for loop\n  always @(posedge en)\n    for (i=0;\
    \ i<T; i=i+1) // Start clock generation every 2 time units\n      clk = ~clk;\n\
    \  initial\n  begin\n    clk = 1'b0; // Initialize clock\n    en = 1'b0; // Start\
    \ disabled\n  end\n  initial $monitor(\"clk=%b, t=%0d, en=%b \", clk,$time,en);\n\
    endmodule\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include\
    \ <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\
    #include <arpa/inet.h>\n#include <netdb.h>\n\n// Function Prototypes\nint validate_port(char\
    \ *port);\nint validate_ip_address(char *ip_address);\nint main (int argc, char\
    \ *argv[]) {\n\tchar ip_address[15];\n\tchar port[6];\n\tchar file_name[20];\n\
    \tint i;\n\n\tprintf(\"\\nEnter IP address (e.g., 10.0.0.1 or 127.0.0.1): \");\n\
    \tfgets(ip_address, 15, stdin);\n\tif (validate_ip_address(ip_address)) {\n\t\t\
    i = strlen(ip_address) - 1;\n\t\tif (ip_address[i] == '\\n') {\n\t\t\tip_address[i]\
    \ = '\\0';\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"\\nInvalid IP address entered!\"\
    );\n\t\texit(1);\n\t}\n\n\tprintf(\"\\nEnter port (e.g., 8080): \");\n\tfgets(port,\
    \ 6, stdin);\n\tif (validate_port(port)) {\n\t\ti = strlen(port) - 1;\n\t\tif\
    \ (port[i] == '\\n') {\n\t\t\tport[i] = '\\0';\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"\
    \\nInvalid port entered!\");\n\t\texit(1);\n\t}\n\n\tprintf(\"\\nEnter file name\
    \ (e.g., index.html): \");\n\tfgets(file_name, 20, stdin);\n\ti = strlen(file_name)\
    \ - 1;\n\tif (file_name[i] == '\\n') {\n\t\tfile_name[i] = '\\0';\n\t}\n\n\tFILE\
    \ *file = fopen(file_name, \"w\");\n\tif (file == NULL) {\n\t\tprintf(\"\\nCould\
    \ not open file!\");\n\t\texit(1);\n\t}\n\n\t// Socket file descriptor\n\tint\
    \ sockfd;\n\tif ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n\t\tperror(\"\
    \\nError opening socket!\");\n\t\texit(1);\n\t}\n\tprintf(\"\\nSocket opened!\"\
    );\n\n\t// Initialize struct'server_info'\n\tstruct hostent *server_info;\n\t\
    if ((server_info = gethostbyname(ip_address)) == NULL) {\n\t\tperror(\"\\nError\
    \ getting server information!\");\n\t\texit(1);\n\t}\n\n\t// Initialize struct'serv_addr'\n\
    \tstruct sockaddr_in serv_addr;\n\tserv_addr.sin_family = AF_INET;\n\tbcopy((char\
    \ *)server_info->h_addr, (char *)&serv_addr.sin_addr.s_addr, server_info->h_length);\n\
    \tserv_addr.sin_port = htons(atoi(port));\n\n\t// Create connection to ip address\
    \ and port\n\tif (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr))\
    \ == -1) {\n\t\tperror(\"\\nError connecting to server!\");\n\t\texit(1);\n\t\
    }\n\tprintf(\"\\nConnected to server!\");\n\n\tchar message[256];\n\tsprintf(message,\
    \ \"GET /%s HTTP/1.1\\r\\n\", file_name);\n\tsprintf(message, \"%sHost: %s\\r\\\
    n\\r\\n\", message, ip_address);\n\tsend(sockfd, message, strlen(message), 0);\n\
    \tprintf(\"\\nSent message to server!\\n\");\n\n\t// Receive HTTP response from\
    \ server\n\tprintf(\"\\nServer Response:\\n\");\n\tint n;\n\twhile ((n = recv(sockfd,\
    \ message, 256, 0)) > 0) {\n\t\tprintf(\"%s\", message);\n\t}\n\n\tclose(sockfd);\n\
    \tfclose(file);\n}\n\n\n// Function Definitions\nint validate_port(char *port)\
    \ {\n\tint i;\n\tfor (i = 0; i < strlen(port); i++) {\n\t\tif (!isalnum(port[i]))\
    \ {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (strlen(port)!= 4) {\n\t\treturn 0;\n\
    \t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint validate_ip_address(char *ip_address)\
    \ {\n\tint i;\n\tfor (i = 0; i < strlen(ip_address); i++) {\n\t\tif (!isdigit(ip_address[i])\
    \ && ip_address[i]!= '.') {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint periods = 0;\n\
    \tfor (i = 0; i < strlen(ip_address); i++) {\n\t\tif (ip_address[i] == '.') {\n\
    \t\t\tperiods++;\n\t\t}\n\t}\n\n\tif (periods!= 3) {\n\t\treturn 0;\n\t}\n\telse\
    \ {\n\t\treturn 1;\n\t}\n}#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\
    #include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include\
    \ <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n// Function Prototypes\n\
    int validate_port(char *port);\nint validate_ip_address(char *ip_address);\nint\
    \ validate_file_name(char *file_name);\nint main (int argc, char *argv[]) {\n\t\
    // Socket file descriptor\n\tint sockfd;\n\tif ((sockfd = socket(AF_INET, SOCK_STREAM,\
    \ 0)) == -1) {\n\t\tperror(\"\\nError opening socket!\");\n\t\texit(1);\n\t}\n\
    \tprintf(\"\\nSocket opened!\");\n\n\t// Initialize struct'server_info'\n\tstruct\
    \ hostent *server_info;\n\tif ((server_info = gethostbyname(argv[1])) == NULL)\
    \ {\n\t\tperror(\"\\nError getting server information!\");\n\t\texit(1);\n\t}\n\
    \n\t// Initialize struct'serv_addr'\n\tstruct sockaddr_in serv_addr;\n\tserv_addr.sin_family\
    \ = AF_INET;\n\tbcopy((char *)server_info->h_addr, (char *)&serv_addr.sin_addr.s_addr,\
    \ server_info->h_length);\n\tserv_addr.sin_port = htons(atoi(argv[2]));\n\n\t\
    // Create connection to ip address and port\n\tif (connect(sockfd, (struct sockaddr\
    \ *)&serv_addr, sizeof(serv_addr)) == -1) {\n\t\tperror(\"\\nError connecting\
    \ to server!\");\n\t\texit(1);\n\t}\n\tprintf(\"\\nConnected to server!\");\n\n\
    \t// Receive HTTP response from server\n\tchar message[256];\n\tchar response[256];\n\
    \tchar file_name[256];\n\tsprintf(file_name, \"HTTP/1.0 %s %s\\r\\n\", argv[3],\
    \ file_name);\n\tsprintf(file_name, \"%sHost: %s\\r\\n\\r\\n\", file_name, argv[1]);\n\
    \tsend(sockfd, file_name, strlen(file_name), 0);\n\tprintf(\"\\nSent message to\
    \ server!\\n\");\n\n\t// Receive HTTP response from server\n\tprintf(\"\\nServer\
    \ Response:\\n\");\n\tint n;\n\twhile ((n = recv(sockfd, message, 256, 0)) > 0)\
    \ {\n\t\tprintf(\"%s\", message);\n\t}\n}\n\n\n// Function Definitions\nint validate_port(char\
    \ *port) {\n\tint i;\n\tfor (i = 0; i < strlen(port); i++) {\n\t\tif (!isalnum(port[i]))\
    \ {\n\t\t\treturn 0;\n\t\t}"
- code: "module clock_gen_forever_func_call_test;\n  reg clk, en;\n  function bit\
    \ [31:0] index_test(bit [31:0] a);\n    bit [31:0] b;\n    b = a+1;\n    return\
    \ b;\n  endfunction  \n\n  always @(posedge en) // Start clock generation on posedge\
    \ en\n    forever #index_test(0) clk = ~clk; // Toggle clock every 2 time units\
    \ forever\n  initial\n  begin\n    clk = 1'b0; // Initialize clock\n    en = 1'b0;\
    \ // Start disabled\n  end\n  initial $monitor(\"clk=%b, t=%0d, en=%b \", clk"
- code: "module contres(o,i1,i2);\ninput i1,i2;\noutput o;\n// Drive wire 'o' from\
    \ two buffers with specified output strengths\nbuf(pull1, weak0) g1(o,i1); //\
    \ Drives pull '1', weak '0'\nbuf(pull1, weak0) g2(o,i2); // Drives pull '1', weak\
    \ '0'\n// Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z\n\
    // Effective behavior is OR due to pull1 dominance over weak0\n{\n  integer unsigned\
    \ i;\n  initial begin\n    for (i = 0; i < 4; i++) begin\n      if (i1[i] && (i2[i]\
    \ || i1[i])) // <--- this is the condition\n        o[i] = '1';\n      else if\
    \ (i1[i])\n        o[i] = '1';\n      else if (i2[i])\n        o[i] = '1';\n \
    \     else\n        o[i] = '0';\n    end\n  end\nend\nendmodule\n### Expected\
    \ Results:\nIn the first case, the result should be 1. In the second case, the\
    \ result should be X.\n### Generated Testbench:\n1:    reg [0:3] i1,i2,o;\n2:\
    \    initial begin\n3:      for (i = 0; i < 4; i++) begin\n4:        if (i1[i]\
    \ && (i2[i] || i1[i])) // <--- this is the condition\n5:          o[i] = '1';\n\
    6:        else if (i1[i])\n7:          o[i] = '1';\n8:        else if (i2[i])\n\
    9:          o[i] = '1';\n10:        else\n11:          o[i] = '0';\n12:      end\n\
    13:    end\n14:    endmodule\n### Result:\ntestbench.v:20: ERROR: Parameter file\
    \ in the testbench does not have an instruction with number 20.\n/*\n * Copyright\
    \ (c) 2009 The University of Michigan\n *\n * Permission is hereby granted, free\
    \ of charge, to any person obtaining a copy\n * of this software and associated\
    \ documentation files (the \"Software\"), to deal\n * in the Software without\
    \ restriction, including without limitation the rights\n * to use, copy, modify,\
    \ merge, publish, distribute, sublicense, and/or sell\n * copies of the Software,\
    \ and to permit persons to whom the Software is\n * furnished to do so, subject\
    \ to the following conditions:\n *\n * The above copyright notice and this permission\
    \ notice shall be included in\n * all copies or substantial portions of the Software.\n\
    \ *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\
    \ OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
    \ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
    \ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *\
    \ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
    \ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\
    \ * THE SOFTWARE.\n */\n\n#include \"m5/stat/recordable.hh\"\n\n#include <fmt/format.h>\n\
    \n#include \"base/logging.hh\"\n#include \"base/trace.hh\"\n#include \"debug/Stats.hh\"\
    \n#include \"params/StatRecorder.hh\"\n#include \"sim/core.hh\"\n#include \"sim/manager.hh\"\
    \n\nnamespace {\n\nconstexpr int max_depth = 10;\n\nint indent = 1;\n\n}\n\nnamespace\
    \ m5 {\n\nStatRecorder::StatRecorder(const StatRecorderParams &p)\n    : BaseObject(p),\
    \ indent(p.indent)\n{\n    init(p.record_depth);\n}\n\nStatRecorder::~StatRecorder()\
    \ {\n    TRACE_ASSERT(!enabled);\n    // Delete the stats map.\n    for (auto\
    \ &pair : statsMap)\n        delete pair.second;\n}\n\nvoid\nStatRecorder::recordStat(const\
    \ std::string &path, uint64_t count)\n{\n    if (enabled) {\n        std::vector<std::string>\
    \ tokens;\n        split(path, tokens, \"/\");\n\n        std::map<std::string,\
    \ StatRecordable *>::iterator pos;\n        std::string last_key;\n\n        StatRecordable\
    \ *current = this;\n        for (auto token : tokens) {\n            pos = current->statsMap.find(token);\n\
    \            if (pos == current->statsMap.end()) {\n                if (tokens.size()!=\
    \ (current->depth + 1)) {\n                    // If current depth is not the\
    \ last key in the path,\n                    // create the current path.\n   \
    \                 std::string prev_key = pos == current->statsMap.end()?\n   \
    \                     last_key : pos->first;\n                    current = current->createPath(prev_key,\
    \ token);\n                }\n                else {\n                    // If\
    \ current depth is the last key already set,\n                    // create the\
    \ current stat.\n                    std::string prev_key = pos == current->statsMap.end()?\n\
    \                        last_key : pos->first;\n                    current =\
    \ current->createStat(prev_key, token);\n                }\n                continue;\n\
    \            }\n\n            // Move to the child node.\n            current\
    \ = pos->second;\n        }\n\n        TRACE_ASSERT(current->depth == tokens.size()\
    \ - 1);\n        TRACE_ASSERT(current->parent == this);\n        current->set(count);\n\
    \    }\n}\n\nvoid\nStatRecorder::init(int depth)\n{\n    if (depth < 0)\n    \
    \    depth = max_depth;\n\n    record_depth = depth;\n\n    if (record_depth >\
    \ 0) {\n        enabled = 1;\n        indent = 1;\n    }\n}\n\nStatRecordable\
    \ *\nStatRecorder::createPath(const std::string &prev_key, const std::string &key)\n\
    {\n    auto path = std::make_unique<StatRecordable>(prev_key + \"/\" + key, this,\n\
    \        this->depth + 1);\n    path->parent = this;\n    path->parent->statsMap.emplace(key,\
    \ path->get());\n    return path->get();\n}\n\nStatRecordable *\nStatRecorder::createStat(const\
    \ std::string &prev_key, const std::string &key)\n{\n    auto stat = std::make_unique<StatRecordable>(prev_key\
    \ + \"/\" + key,\n        this, this->depth + 1);\n    stat->parent = this;\n\
    \    stat->parent->statsMap.emplace(key, stat.release());\n    return stat->get();\n\
    }\n\nvoid\nStatRecordable::set(uint64_t count)\n{\n    this->count += count;\n\
    }\n\nvoid\nStatRecordable::clear()\n{\n    this->count = 0;\n}\n\nvoid\nStatRecordable::dump(bool\
    \ all)\n{\n    for (auto &stat : statsMap)\n        stat.second->dump(all);\n\
    }\n\nvoid\nStatRecordable::dump(bool all, const std::string &indent)\n{\n    if\
    \ (this->count!= 0 || all)\n        for (int i = 0; i < this->depth * indent.length();\
    \ i++)\n            fprintf(stderr, \" \");\n        fprintf(stderr, \"%s %\"\
    \ PRIu64 \"\\n\", this->path.c_str(), this->count);\n\n    for (auto &stat : statsMap)\n\
    \        stat.second->dump(all, indent);\n}\n\nvoid\nStatRecordable::print(std::ostream\
    \ &os)\n{\n    for (int i = 0; i < this->depth * indent; i++)\n        os << \"\
    \ \";\n    os << this->path << \" \" << this->count << std::endl;\n\n    for (auto\
    \ &stat : statsMap)\n        stat.second->print(os);\n}\n\n} // namespace m5\n\
    /*\n * Copyright (c) 2015,  and \n * All rights reserved.\n *\n * Redistribution\
    \ and use in source and binary forms, with or without\n * modification, are permitted\
    \ provided that the following conditions are\n * met: redistributions of source\
    \ code must retain the above copyright\n * notice, this list of conditions and\
    \ the following disclaimer;\n * redistributions in binary form must reproduce\
    \ the above copyright\n * notice, this list of conditions and the following disclaimer\
    \ in the\n * documentation and/or other materials provided with the distribution;\n\
    \ * neither the name of the copyright holders nor the names of its\n * contributors\
    \ may be used to endorse or promote products derived from\n * this software without\
    \ specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE\
    \ COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED\
    \ WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\
    \ AND FITNESS FOR\n * A"
- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    initial
    // Test an inside expression
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    endinitial
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pull1 dominance over weak0
    endmodule

    ## SDC File

    //=========================================================
    // Test file for "Test inside Array Expression"
    //=========================================================

    module top;
    input wire clock;
    // Drive wire 'o' from two buffers with specified output strengths
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    endmodule

    ## SDC Script

    ## Generated Verilog Code:

    //=============================================================
    // Test file for "Test inside Array Expression"
    //=============================================================

    // Generated using the Vivado Design Suite: 2019.1.0.515
    //=============================================================
    // module top(clock);
    // input wire clock;
    // buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g3(o,i3); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g4(o,i4); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g5(o,i5); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g6(o,i6); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g7(o,i7); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g8(o,i8); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g9(o,i9); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g10(o,i10); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g11(o,i11); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g12(o,i12); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g13(o,i13); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g14(o,i14); // Drives pull '1', weak '0'
    // buf(pull1, weak0) g15(o,i15); // Drives pull '1', weak '0
- code: |-
    module contres_pulldown(o,i);
    input i;
    output o;
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, pulldown) g1(o,i); // Drives pull '1', pulldown

    // Resolution: 1,1->1; 1,0->0; 0,1->1; 0,0->0; 1,Z->1; 0,Z->X; Z,Z->Z
    // Effective behavior is OR due to pulldown dominance over pull1
    initial
    begin
    // Test for array values of i
    assign o = i[1] || i[2];
    end
    endmodule
    ### Original Description:
    This variation tests an inside
- code: |-
    module contres(o,i1,i2);
    input i1,i2;
    output o;
    wire [0:1] i1i2[3];
    // Drive wire 'o' from two buffers with specified output strengths
    buf(pull1, weak0) g1(o,i1); // Drives pull '1', weak '0'
    buf(pull1, weak0) g2(o,i2); // Drives pull '1', weak '0'
    wire [3:0] i1i2i1i2;
    i1i2i1i2[0] = (i1i2[0] == 1 && i1i2[1] == 0) || (i1i2[0] == 0 && i1i2[1] == 1);
    i1i2i1i2[1] = (i1i2[0] == 1 && i1i2[2] == 0) || (i1i2[0] == 0 && i1i2[2] == 1);
    i1i2i1i2[2] = (i1i2[1] == 1 && i1i2[2] == 0) || (i1i2[1] == 0 && i1i2[2] == 1);
    i1i2i1i2[3] = (i1i2[1] == 1 && i1i2[2] == 0) || (i1i2[1] == 0 && i1i2[2] == 1);
    // Resolution: 1,1->1; 1,0->1; 0,1->1; 0,
- code: "module mux4(sel, in0, in1, in2, in3, out);\ninput sel, in0, in1, in2, in3;\n\
    output out;\nalways @(in0, in1, in2, in3) begin\ncase (sel)\n4'h0: out <= in0;\n\
    4'h1: out <= in1;\n4'h2: out <= in2;\n4'h3: out <= in3;\nendcase\nendmodule\n\n\
    ## Combinational Logic\n\nCombinational logic is a set of digital circuits which\
    \ can be used to implement logical functions. They are constructed using logic\
    \ gates such as AND, OR, and NOT gates. Combinational logic is useful for designing\
    \ components that have no internal memory.\n\nCombinational logic can be used\
    \ to implement combinational logic in the form of a verilog module. Modules are\
    \ the fundamental building blocks of Verilog. Modules are defined by the following\
    \ components:\n\n\u2022 A module header, which specifies the module name and inputs\
    \ and outputs\n\u2022 A module body, which contains all of the module logic\n\
    Combinational logic can be described as follows:\nmodule mod_name(in1, in2,...\
    \ inN, out);\n\ninput in1, in2,... inN;\noutput out;\n\nassign out = in1 & in2\
    \ &... & inN;\n\nendmodule\n\n## Basic Combinational Logic\n\nCombinational logic\
    \ is used in a variety of ways, but it is best explained by using a simple example.\
    \ Consider the following combinational logic, given as a Verilog module:\n\nmodule\
    \ add(in1, in2, out);\ninput in1, in2;\noutput out;\n\nassign out = in1 + in2;\n\
    \nendmodule\n\nThis combinational logic adds two numbers together and outputs\
    \ the result. The input to the module, in1, is connected to a first bit input\
    \ of the adder and the input to the module, in2, is connected to a second bit\
    \ input of the adder. The output, out, is connected to the output of the adder.\n\
    \nThis is a good example of a combinational logic being used as a module. The\
    \ input and outputs are declared at the module header with declarations such as:\
    \ input in1, in2; output out. Using this notation, a module is declared with the\
    \ following module header:\n\nmodule mod_name(in1, in2,... inN, out);\n\nNow the\
    \ Verilog code for this basic combinational logic is:\n\nmodule add(in1, in2,\
    \ out);\ninput in1, in2;\noutput out;\n\nassign out = in1 + in2;\n\nendmodule\n\
    \n## Verilog HDL\n\nVerilog is a Hardware Description Language designed for use\
    \ in hardware design and digital logic circuitry. Verilog syntax is much easier\
    \ to read than pure binary instructions.\n\nIt does not require many new concepts\
    \ to be introduced to Verilog. However, Verilog is used extensively in designing\
    \ embedded systems.\n\n## Hardware Description Language\n\nA hardware description\
    \ language (HDL) defines the layout of a hardware design. It defines the input\
    \ and output signals of a hardware design. HDL languages are used extensively\
    \ to create circuits and their layouts.\n\nHDLs are used to design systems that\
    \ contain digital logic, processors, and other components.\n\n## Computer-Aided\
    \ Design\n\nComputer-aided design (CAD) is a specialized computerized engineering\
    \ technique that uses the computer to guide the designer of a design by generating\
    \ designs. It is important to consider a CAD program for an engineering project\
    \ because it can generate a design before the actual design begins. This saves\
    \ time spent on design iterations and allows for designing more efficient solutions.\n\
    \nA CAD program for a project can be used to create many designs and allow the\
    \ designer to choose the best design.\n\n### Pros of Using a CAD Program\n\nThe\
    \ following are the pros of using a CAD program for the design process:\n\n\u2022\
    \ Saves time. CAD programs can generate many designs before the design process\
    \ begins. They can be used to generate many designs that are similar or even the\
    \ same. Each design saved can be optimized. Spending time on design iterations\
    \ can be saved.\n\u2022 Saves money. Spending time on design iterations can be\
    \ saved by using a CAD program to generate many designs and then choosing the\
    \ best design.\n\u2022 Improves the project. The project can be optimized by using\
    \ a CAD program to generate many designs.\n\u2022 Reduces failure. If a CAD program\
    \ is used to generate many designs, a failure can be identified as the worst case\
    \ design. This design can be optimized in the future.\n\n### Cons of Using a CAD\
    \ Program\n\nThe following are the cons of using a CAD program for the design\
    \ process:\n\n\u2022 Saves time. CAD programs can generate many designs before\
    \ the design process begins. They can be used to generate many designs that are\
    \ similar or even the same. Each design saved can be optimized. Spending time\
    \ on design iterations can be saved.\n\u2022 Saves money. Spending time on design\
    \ iterations can be saved by using a CAD program to generate many designs and\
    \ then choosing the best design.\n\n## Using a CAD Program\n\nA CAD program for\
    \ the design process can be used to generate many designs, such as a design for\
    \ a CPU, before the actual design begins. The CAD program can be used to generate\
    \ many designs and choose the best design.\n\n### Generating Multiple Designs\n\
    \nA CAD program can be used to generate multiple designs and allow the designer\
    \ to choose the best design. The multiple designs can be used for the design process,\
    \ such as verifying the design.\n\n### Choosing the Best Design\n\nA CAD program\
    \ can be used to generate multiple designs and allow the designer to choose the\
    \ best design. The CAD program can be used by an engineer to choose the best design."
- code: "module tst_dec2_4beh();\nwire [3:0]o;\nreg[1:0] i;\n//reg en; // Enable not\
    \ used in dec2_4beh\ndec2_4beh dec(o,i);\ninitial\nbegin\ni =2'b03;\nend\ninitial\
    \ $monitor ($time, \" output o = %b, input i = %b \", o,i);\ninitial #14 $stop;\
    \ // Stop simulation endmodule ### Observation: The output for the changed module\
    \ appears as expected. ### Change Observation: The signal i has been changed to\
    \ 2\u2019b0"
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    if (o[2]) $stop; // Stop when output o[2] = 1
    endmodule

    # Lab 3

    This lab contains three tasks (1-3).

    # Lab 4

    This lab contains one task (4).

    # Lab 5

    This lab contains three tasks (1-3).

    # Lab 6

    This lab contains three tasks (1-3).

    # Lab 7

    This lab contains three tasks (1-3).

    # Lab 8

    This lab contains four tasks (1-4).

    # Lab 9

    This lab contains two tasks (2).

    # Lab 10

    This lab contains two tasks (2).

    # Lab 11

    This lab contains two tasks (2).

    # Lab 12

    This lab contains two tasks (2).

    # Lab 13

    This lab contains three tasks (1-3).

    # Lab 14

    This lab contains four tasks (1-4).

    # Lab 15

    This lab contains one task (1).

    # Lab 16

    This lab contains four tasks (1-4).

    # Lab 17

    This lab contains two tasks (2).

    # Lab 18

    This lab contains three tasks (1-3).

    # Lab 19

    This lab contains three tasks (1-3).

    # Lab 20

    This lab contains three tasks (1-3).

    # Lab 21

    This lab contains three tasks (1-3).

    # Lab 22

    This lab contains three tasks (1-3).

    # Lab 23

    This lab contains three tasks (1-3).

    # Lab 24

    This lab contains three tasks (1-3).

    # Lab 25

    This lab contains three tasks (1-3).

    # Lab 26

    This lab contains three tasks (1-3).

    # Lab 27

    This lab contains three tasks (1-3).

    # Lab 28

    This lab contains three tasks (1-3).

    # Lab 29

    This lab contains three tasks (1-3).

    # Lab 30

    This lab contains three tasks (1-3).

    # Lab 31

    This lab contains three tasks (1-3).

    # Lab 32

    This lab contains three tasks (1-3).

    # Lab 33

    This lab contains three tasks (1-3).

    # Lab 34

    This lab contains three tasks (1-3).

    # Lab 35

    This lab contains three tasks (1-3).

    # Lab 36

    This lab contains three tasks (1-3).

    # Lab 37

    This lab contains three tasks (1-3).

    # Lab 38

    This lab contains three tasks (1-3).

    # Lab 39

    This lab contains three tasks (1-3).

    # Lab 40

    This lab contains three tasks (1-3).

    # Lab 41

    This lab contains three tasks (1-3).

    # Lab 42

    This lab contains three tasks (1-3).

    # Lab 43

    This lab contains three tasks (1-3).

    # Lab 44

    This lab contains four tasks (1-4).
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial begin i =2'b00;
    end
    initial if(i==3'b11) begin
    $stop; // Stop simulation
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    ### Simulation Results:
    Time : 158.266 ns
    Simulation ends at time 158.266 ns
    Output o = 0, input i = 00

    ## Question 2 :
    The following verilog code has been modified to illustrate the difference in the 3-state D flip-flop.

    module flip_flop_2t(q,q_bar,d,clk);
    reg q, q_bar;
    assign q=q_bar;
    always @(posedge clk)
    q_bar <= d;
    endmodule
    What is the resulting behavior of this flip-flop when clk is set to 0, 1, and 0 (without using the not gate).
    ### Solution:
    | CLK | Q | Q_bar |
    |---|---|---|
    |1 |0| 1 |
    |0 |1| 1 |
    |1 |1| 0 |
    |0 |1| 1 |

    ## Question 3 :
    Simulate the following code segment using the tst_3sta_dff module.

    module tst_3sta_dff(q,q_bar,d,clk);
    wire [1:0] q;
    wire[0:0] q_bar;
    wire [1:0] d;
    wire clk;

    dff_2t dff(q,q_bar,d,clk);
    initial
    begin
    d = 2'b00;
    clk = 0;

    # 5 clk = 1;
    # 5 clk = 0;
    # 5 clk = 1;
    # 5 clk = 0;
    # 5 clk = 1;
    # 5 clk = 0;
    # 5 clk = 1;
    # 5 clk = 0;
    end
    initial $monitor ($time, "output q = %b, input q_bar = %b, input d= %b ", q,q_bar,d);
    initial #2000 $stop; // Stop simulation
    endmodule
    ### Solution:
    | Time | q | q_bar | d |
    |---|---|---|---|
    | 0 | 00 | 0 | 00 |
    | 5 | 00 | 1 | 00 |
    | 10 | 10 | 1 | 00 |
    | 15 | 10 | 0 | 00 |
    | 20 | 00 | 1 | 00 |
    | 25 | 00 | 0 | 00 |
    | 30 | 10 | 1 | 00 |
    | 35 | 10 | 0 | 00 |

    ## Question4 :
    The following module has been modified to illustrate the difference in the 3-state D flip-flop.

    module flip_flop_2t(q,q_bar,d,clk);
    reg q, q_bar;
    assign q=q_bar;
    always @(posedge clk)
    q_bar <= d;
    endmodule
    What is the resulting behavior of this flip-flop when clk is set to 0, 1, and 0 (without using the not gate).
    ### Solution:
    |CLK|  Q | Q_bar | D |
    |---|---|---|---|
    |1| 00 |  1  | 00 |
    |0| 10 |  1  | 00 |
    |1| 10 |  0  | 00 |
    |0| 00 |  1  | 00 |

    ## Question 5 :
    A 3-state D flip-flop has been implemented with VHDL.

    package flip_flop is
    type clock_t is (clock, reset, set, reset);
    type data_t is (data_0, data_1, data_2);
    end package

    entity flip_flop is
    port(clk: in clock_t;
    set: in data_t;
    reset: in data_t;
    data_in: in data_t;
    output data_out: out data_t);
    end entity;

    architecture Behavioral of flip_flop is
    signal next_data: data_t;
    begin
    data_out <= next_data;

    process (set)
    begin
    case set is
    when reset =>
    next_data <= data_2;
    when data_0 =>
    next_data <= data_1;
    when data_1 =>
    next_data <= data_2;
    when data_2 =>
    next_data <= data_0;
    else
    next_data <= data_0;
    end case;
    end process;

    process (reset)
    begin
    case reset is
    when reset =>
    next_data <= data_0;
    when data_0 =>
    next_data <= data_1;
    when data_1 =>
    next_data <= data_2;
    when data_2 =>
    next_data <= data_0;
    else
    next_data <= data_0;
    end case;
    end process;

    process (clk)
    begin
    case clk is
    when clock =>
    if (reset = data_2) then
    next_data <= data_0;
    elsif (set = data_0) then
    next_data <= data_1;
    elsif (set = data_1) then
    next_data <= data_2;
    elsif (set = data_2) then
                    next_data <= data_0;
    else
    next_data <= data_0;
    end if;
    end case;
    end process;

    end Behavioral;

    ### Simulation:

    ## Question 6 :
    Modify the flip_flop_2t module to incorporate a set-reset flip-flop.

    package flip_flop is
    type clock_t is (clock, reset, set, reset);
    type data_t is (data_0, data_1, data_2);
    end package

    entity flip_flop is
    port(clk: in clock_t;
    set: in data_t;
    reset: in data_t;
    data_in: in data_t;
    output data_out: out data_t);
    end entity;

    architecture Behavioral of flip_flop is
    signal next_data: data_t;
    signal set_reset: boolean := false;
    begin
    data_out <= next_data;

    process (set)
    begin
    case set is
    when reset =>
    set_reset <= true;
    when data_0 =>
    set_reset <= false;
    when data_1 =>
    set_reset <= false;
    when data_2 =>
    set_reset <= false;
    else
    set_reset <= false;
    end case;
    end process;

    process
- code: |-
    module dec2_4beh(o,i);
    output o;
    input[3:0] i;
    //reg [1:0] en;
    reg clk;
    reg[1:0] en;
    always @ *
    begin
    if(i[0])
    en[0] <= 2'b01;
    else if(i[1])
    o <= 4'b0100;
    else if(i[2])
    o <= 4'b0010;
    else if(i[3])
    o <= 4'b0001;
    else
    o <= 4'b0100;
    end
    endmodule
- code: |-
    module tst_dec2_4beh();
    wire [3:0]o;
    reg[1:0] i;
    if( i[0])
    reg[0] =1;
    else
    reg[0] =0;
    if( i[1])
    reg[1] =1;
    else
    reg[1] =0;
    //reg en; // Enable not used in dec2_4beh
    dec2_4beh dec(o,i);
    initial
    begin
    i =2'b00;
    end
    initial $monitor ($time, " output o = %b, input i = %b ", o,i);
    initial #14 $stop; // Stop simulation
    endmodule
    ### New output:

    input i = 00
    output o = 00
    input i = 01
    output o = 00
    input i = 10
    output o = 00
    input i = 11
    output o = 00
    input i = 100
    output o = 00
    input i = 101
    output o = 01
    input i = 110
    output o = 01
    input i = 111
    output o = 01
    input i = 1000
    output o = 01
    input i = 1001
    output o = 10
    input i = 1010
    output o = 10
    input i = 1011
    output o = 11
    input i = 1100
    output o = 11
    input i = 1101
    output o = 11
    input i = 1110
    output o = 11
    input i = 1111
    output o = 11
    input i = 10000
    output o = 11
    input i = 10001
    output o = 11
    input i = 10010
    output o = 11
    input i = 10011
    output o = 11
    input i = 10100
    output o = 11
    input i = 10101
    output o = 11
    input i = 10110
    output o = 11
    input i = 10111
    output o = 11
    input i = 11000
    output o = 11
    input i = 11001
    output o = 11
    input i = 11010
    output o = 11
    input i = 11011
    output o = 11
    input i = 11100
    output o = 11
    input i = 11101
    output o = 11
    input i = 11110
    output o = 11
    input i = 11111
    output o = 11
    input i = 100000
    output o = 11
    input i = 100001
    output o = 11
    input i = 100010
    output o = 11
    input i = 100011
    output o = 11
    input i = 100100
    output o = 11
    input i = 100101
    output o = 11
    input i = 100110
    output o = 11
    input i = 100111
    output o = 11
    input i = 101000
    output o = 11
    input i = 101001
    output o = 11
    input i = 101010
    output o = 11
    input i = 101011
    output o = 11
    input i = 101100
    output o = 11
    input i = 101101
    output o = 11
    input i = 101110
    output o = 11
    input i = 101111
    output o = 11
    input i = 110000
    output o = 11
    input i = 110001
    output o = 11
    input i = 110010
    output o = 11
    input i = 110011
    output o = 11
    input i = 110100
    output o = 11
    input i = 110101
    output o = 11
    input i = 110110
    output o = 11
    input i = 110111
    output o = 11
    input i = 111000
    output o = 11
    input i = 111001
    output o = 11
    input i = 111010
    output o = 11
    input i = 111011
    output o = 11
    input i = 111100
    output o = 11
    input i = 111101
    output o = 11
    input i = 111110
    output o = 11
    input i = 111111
    output o = 11
    `
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          case (I)
            100: b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
            32#0: b = 1; // Assign bit 1 of I to b (Corrected indexing)
            32#1: b = 1; // Assign bit 1 of I to b (Corrected indexing)
          endcase
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Testbench:
    module pulses_tb; // Testbench for pulses_tb
      integer i;
      initial begin
        pulses uut; // Instantiate pulses
        #100 $stop; // Terminate simulation
        $display("i= %d, b=%d", i, b); // Print iteration and b value
        pulse_gen_tb; // Call the testbench for the pulse generator
      end
    endmodule
    ### Testbench for the Pulse Generator:
    module pulse_gen_tb; // Testbench for pulse_gen_tb
      pulse uut; // Instantiate pulse
      initial #10 $stop; // Terminate simulation
      $display("i= %d, b=%d", i, b); // Print iteration and b value
    endmodule

    /Code/TestBenchGeneration.c
    /*
      TestBenchGeneration.c
      Generates the testbench for FPGA code
     */
    #include "VerilogCode.h"
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    void TestBenchGeneration(char *fileName);

    int main(int argc, char **argv) {

        char *fileName = "Code/VerilogCode/pulses.v";
        TestBenchGeneration(fileName);

        return 0;
    }

    void TestBenchGeneration(char *fileName) {
        char *testbenchFileName = "pulses_tb.v";
        char *testbenchFileContent = NULL;
        int fileLength = 0;
        int foundStart = 0;
        int foundEnd = 0;
        FILE *file = fopen(fileName, "r");
        FILE *testbenchFile = fopen(testbenchFileName, "r");

        if (file == NULL) {
            printf("Error opening %s", fileName);
        }

        if (testbenchFile == NULL) {
            printf("Error opening %s", testbenchFileName);
        }

        fileLength = fread(testbenchFileContent, 1, fileLength, testbenchFile);

        while (!foundStart) {
            while (!foundStart) {
                if (fileLength == 0) {
                    break;
                } else {
                    if (testbenchFileContent[fileLength - 2] == 'e') {
                        if (testbenchFileContent[fileLength - 1] == 'n') {
                            foundStart = 1;
                        } else {
                            fileLength--;
                        }
                    } else {
                        fileLength--;
                    }
                }
            }
        }

        foundEnd = 0;
        while (!foundEnd) {
            while (!foundEnd) {
                if (fileLength == 0) {
                    break;
                } else {
                    if (testbenchFileContent[fileLength - 2] == 'n') {
                        if (testbenchFileContent[fileLength - 1] == 'i') {
                            foundEnd = 1;
                        } else {
                            fileLength--;
                        }
                    } else {
                        fileLength--;
                    }
                }
            }
        }

        fclose(file);
        fclose(testbenchFile);
    }
- code: |-
    module pulses_new;
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Expected Result:
    Test not passed. An error should be found.
    ### Actual Result:
    Test passed. No errors found.
    ### Details of issue:
    This issue was found in the verilog-
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [3:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ### Description:
    As stated in the
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
- code: |-
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        case (I) // Loop based on integer I
          I==0: begin // Incorrect indexing
            b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          end
          I=='h100: $stop;
        endcase
    endmodule
    ```

    ## B.13.24.9.1. Array Indexing

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.2. DPI Intrinsic

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.3. Nested DPI Intrinsic

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.4. Case Statement

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.5. Nested Case Statement

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.6. Nested Case Statement

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.7. For Statement

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ## B.13.24.9.8. For Each Statement

    ### Incorrect code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I + 1; // Increment I
        end
      initial I=0; // Initialize I
      initial #100 $stop; // Stop simulation
    endmodule
    ```

    ### Modified code segment

    ```verilog
    module pulses; // Incorrect pulse generation attempt
      reg [8:0] I;
      reg a,b;
      initial
        while (I<100) begin // Loop based on integer I
          b = I[1]; // Assign bit 1 of I to b (Corrected indexing)
          I = I
- code: |-
    module reg7(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    always @(posedge Clock or negedge Resetn) begin
        if (Resetn == 0) begin
            Q <= 4'b0000;
        end else begin
            Q <= D;
        end
    endmodule
    ### Code Review:
    This is a good way to make the code generic.
    ### Testing:
    This was tested with a 4-bit register, a 5-bit register, and a 7-bit register.  All 3 have good verilog.
    ### Conclusion:
    This is a good way to make the code generic.
    ### Appendix:
    ```
    ### Listing:
    module reg8(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    always @(posedge Clock or negedge Resetn) begin
        if (Resetn == 0) begin
            Q <= 4'b0000;
        end else if (D == 4'b0000) begin
            Q <= 4'b0001;
        end else if (D == 4'b0001) begin
            Q <= 4'b0010;
        end else if (D == 4'b0010) begin
            Q <= 4'b0011;
        end else if (D == 4'b0011) begin
            Q <= 4'b0100;
        end else if (D == 4'b0100) begin
            Q <= 4'b0101;
        end else if (D == 4'b0101) begin
            Q <= 4'b0110;
        end else if (D == 4'b0110) begin
            Q <= 4'b0111;
        end else begin
            Q <= 4'b1000;
        end
    endmodule
    ### Result:
    Verilog Code:
    module reg8(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    always @(posedge Clock or negedge Resetn) begin
        if (Resetn == 0) begin
            Q <= 4'b0000;
        end else if (D == 4'b0000) begin
- code: |-
    module dff_new(D, Clock, Resetn, Q_new);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q_new;
    reg [3:0] Q_new;
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q_new = 4'b0000;
        else
            Q_new = D;
    endmodule
    ### Simulation Result:
    <img src="figures/verilog/dff_new.png" width="50%" height="50%">
    ### Testbench Code:
    `tb_dff_new.v`:
    ```verilog
    reg D, Clock, Resetn, Q_new;

    initial begin
        D = 0;
        Clock = Resetn = 1;
    end

    reg [3:0] Q_new_expected;

    initial begin
        Q_new_expected[4'b1001] = 4'b0000;
        Q_new_expected[4'b1010] = 4'b0010;
        Q_new_expected[4'b1011] = 4'b0011;
        Q_new_expected[4'b1100] = 4'b0100;
        Q_new_expected[4'b1101] = 4'b0101;
        Q_new_expected[4'b1110] = 4'b0110;
        Q_new_expected
- code: |-
    module adder2(A, B, CLK, Resetn, S, C);
    input [1:0] A, B;
    input CLK, Resetn;
    output [1:0] S[1];
    output C;

    wire carry;
    reg S[1], C;

    always @(posedge CLK or negedge Resetn)
    if (Resetn == 1)
    carry <= 0;
    else
    carry <= C;

    always @(posedge CLK or negedge Resetn)
    if (Resetn == 1)
    S[0] <= 0;
    else
    S[0] <= S[1];

    always @(posedge CLK or negedge Resetn)
    if (Resetn == 1)
    C <= 0;
    else
    C <= carry;
    endmodule
    ### Testbench:
    Verilog Testbench
- code: |-
    module reg8(D, Clock, Resetn, Q);
    input [
- code: |-
    <code>
    reg [3:0] Q [0:15];
    always @(posedge Clock or negedge Resetn)
        if(Resetn == 0)
            Q <= 4'b0000;
    endmodule

    module reg4(D, Clock, Resetn, Q);
    input [3:0] D;
    input Clock, Resetn;
    output [3:0] Q;
    reg [3:0] Q [0:15];
    always @(posedge Clock or negedge Resetn)
        if (Resetn == 0)
            Q <= 4'b0000;
        else
            Q <= D;
    endmodule
    ### Output:
    ```
    @N0
    @N1
    @N2
    @N3
    @N4
    @N5
    @N6
    @N7
    @N8
    @N9
    @N10
    @N11
- code: "module aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate\
    \ signals\n// Dataflow assignments for AND, OR, and NOT operations\ninitial\n\
    begin\ne = a && b;\nf = c && d;\nend\nassign g1 = e || f;\nassign g = ~g1; //\
    \ Final AOI output\nendmodule\n### Synthesis Log:\nThe synthesis log from the\
    \ modified Verilog Code is given below. It can be seen that the design is synthesizable.\n\
    ### Synthesis Result:\nThe synthesized design of the module can be seen below.\n\
    \n## References\n\n1. \u201CHow to Synthesize a Logic Circuit on a PCB/PCB with\
    \ Mentor.\u201D 2015. Mentor Graphics. Accessed 24 May 2021. https://web.archive.org/web/20210524035302/https://www.mentor.com/training/how-to-synthesize-a-logic-circuit-on-pcb/.\n\
    \n2. Mentor Graphics. (n.d.). Mentor Graphics. https://www.mentor.com/.\n\n3.\
    \ Mentor Graphics, Inc. (n.d.). 4.0 Synthesis Overview. Mentor Graphics. https://www.mentor.com/products/mms-40.\n\
    \n## Questions\n\n### What is the advantage of using a PCB for a circuit design\
    \ that is to be synthesized?\n\nFirst of all, the PCBs offer many advantages over\
    \ the printed circuit boards. The main advantages of a PCB over a printed circuit\
    \ board are:\n\n\u2022 Cheaper to design circuit boards\n\u2022 Expensive to make\
    \ and maintain circuit boards\n\u2022 It is easy to fabricate a circuit board\
    \ and it can be made much cheaper than a printed circuit board\n\u2022 It is simple\
    \ and straightforward to design and test a circuit board\n\u2022 It is easy to\
    \ place a prototyping circuit board\n\u2022 It is easy to get a high quality circuit\
    \ board from a prototyping circuit board\n\u2022 It is easy to use a circuit board\
    \ for multiple projects at the same time\n\n### What are the disadvantages of\
    \ using a PCB?\n\nThere are some disadvantages that we have to keep in mind while\
    \ working with a PCBs.\n\n\u2022 There is a higher cost for a PCB compared to\
    \ a printed circuit board. The cost is higher because of the additional cost of\
    \ the processing of the circuit board material.\n\u2022 It is more expensive to\
    \ operate a PCB compared to a printed circuit board. The cost is higher because\
    \ of the cost involved in the assembly process at a factory.\n\u2022 It is hard\
    \ to design a circuit board. The difficulties of designing a circuit board can\
    \ be avoided by using a printed circuit board.\n\u2022 It is difficult to get\
    \ the accurate layout of a circuit board. This can be solved by using a printed\
    \ circuit board.\n\n### How can we test a design on a PCB?\n\nThe circuit designed\
    \ on a PCB can be tested on a PCB by using a PCB tester.\n\n### How can we synthesize\
    \ a circuit on a PCB?\n\nA design on a PCB can be synthesized on a PCB by using\
    \ a PCB synthesizer.\n\n### Does a PCB require a special type of circuit board?\n\
    \nA PCB requires a special type of circuit board. The type of circuit board that\
    \ can be used for a PCB is called a circuit board. The circuit board used for\
    \ a PCB can be different from the circuit board used for a printed circuit board.\n\
    \n### How can we place the circuit board on a PCB?\n\nWe can place the circuit\
    \ board on a PCB by using a circuit board placer.\n\n### Are PCBs used when doing\
    \ a project of a design with a high level of complexity?\n\nPCBs are used when\
    \ doing a project with a high level of complexity. This is because the cost and\
    \ the complexity of these projects are higher.\n\n### What are some of the advantages\
    \ of using a printed circuit board?\n\nThe advantages of using a printed circuit\
    \ board are:\n\n\u2022 It is easy to design a circuit board\n\u2022 It is easy\
    \ to manufacture a circuit board\n\u2022 It is cheaper to manufacture a circuit\
    \ board\n\u2022 It is easier to maintain a circuit board\n\u2022 It is easier\
    \ to test a circuit board\n\n### What are some of the disadvantages of using a\
    \ printed circuit board?\n\nThe disadvantages of using a printed circuit board\
    \ are:\n\n\u2022 It is difficult to design a circuit board\n\u2022 It is difficult\
    \ to manufacture a circuit board\n\u2022 It is more expensive to manufacture a\
    \ circuit board\n\n### How can we test a design on a printed circuit board?\n\n\
    A design on a printed circuit board can be tested on a printed circuit board by\
    \ using a printed circuit board tester.\n\n### How can we synthesize a circuit\
    \ on a printed circuit board?\n\nA design on a printed circuit board can be synthesized\
    \ on a printed circuit board by using a printed circuit board synthesizer.\n\n\
    ### How can we place the circuit board on a printed circuit board?\n\nWe can place\
    \ the circuit board on a printed circuit board by using a printed circuit board\
    \ placer.\n\n## Conclusion\n\nIn this article, we discussed the advantages of\
    \ using a printed circuit board instead of a printed circuit board when designing\
    \ a circuit. We also discussed the advantages and disadvantages of using a printed\
    \ circuit board.\n\nAs a conclusion, the advantages of using a printed circuit\
    \ board are that it is easy to design a circuit board, it is cheaper to manufacture\
    \ a circuit board, it is easier to maintain a circuit board, it is easier to test\
    \ a circuit board, and it is relatively easy to use. However, the disadvantages\
    \ of using a printed circuit board are that it is difficult to design a circuit\
    \ board, it is difficult to manufacture a circuit board, it is more expensive\
    \ to manufacture a circuit board, it is more difficult to maintain a circuit board,\
    \ it is more difficult to test a circuit board, and it is relatively difficult\
    \ to use.\n\nThe advantages of using a printed circuit board over a printed circuit\
    \ board can be the cost of a printed circuit board being higher than the cost\
    \ of a printed circuit board. The advantages of using a printed circuit board\
    \ include being cheaper to manufacture, being simpler to maintain, being easier\
    \ to test, being easier to use, and being relatively easy to use. However, the\
    \ disadvantages"
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1;
    initial
    begin
    e = a && b;
    f = c && d;
    g1 = e || f;
    g = ~g1;
    end
    endmodule
    ### Performance Analysis:
    Performance analysis of the modified code:
    The performance of the code is 0 ns delay for 8ns clock input. The time delay of the code is 0 ns for 8ns clock input.

    # Assignment 6: Parametric RTL Design
    # Module 1: Parametric RTL Design
    In this assignment, we are designing a module using three input and 2 output using a block diagram. The inputs are a,b,c and d, which are inputs to the module. The outputs are g,h.

    ## Design of Module 1
    ## Base Verilog Code:
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1;
    assign g = a || b;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c,d and the outputs g,h. The inputs are given using a block diagram and the outputs are given using a block diagram. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c,d);
    output g, h;
    input a,b,c,d;
    wire e,f,g1;
    assign g = a || b;
    assign h = c && d;
    endmodule

    # Module 2: Parametric RTL Design
    In this assignment, we are designing a module using 3 inputs and 1 output (g) using a block diagram. The inputs are a,b,c, which are inputs to the module. The output is given using a block diagram.

    ## Design of Module 2
    ## Base Verilog Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire d;
    assign d = a && b && c;
    assign g = d;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c and the output g. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire e,f,g1;
    assign g = a || b || c;
    endmodule

    # Module 3: Parametric RTL Design
    In this assignment, we are designing a module using 6 inputs and 2 outputs using a block diagram. The inputs are a,b,c,d,e,f and d is given using a block diagram and the outputs are g and h using a block diagram.

    ## Design of Module 3
    ## Base Verilog Code:
    module aoi2(g,h,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1,k;
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign k = a || b || c || d;
    assign g = g1 && k;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c,d,e,f and the outputs g and h. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,h,a,b,c,d);
    output g, h;
    input a,b,c,d;
    wire e,f,g1,k;
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign k = a || b || c || d;
    assign g = g1 && k;
    endmodule

    # Module 4: Parametric RTL Design
    In this assignment, we are designing a module using 3 inputs and 1 output (g) using a block diagram. The inputs are a,b,c, which are inputs to the module. The output is given using a block diagram.

    ## Design of Module 4
    ## Base Verilog Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire d;
    assign d = a && b && c;
    assign g = d;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c and the output g. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire e,f,g1;
    assign g = a || b || c;
    endmodule

    # Module 5: Parametric RTL Design
    In this assignment, we are designing a module using 3 inputs and 1 output (g) using the inputs are given using a block diagram and the outputs are given using a block diagram.

    ## Design of Module 5
    ## Base Verilog Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire d;
    assign d = a && b && c;
    assign g = d;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c and the output g. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire e,f,g1;
    assign g = a || b || c;
    endmodule

    # Module 6: Parametric RTL Design
    In this assignment, we are designing a module using 2 inputs and 2 outputs using a block diagram. The inputs are a,b, which are inputs to the module. The outputs are given using a block diagram.

    ## Design of Module 6
    ## Base Verilog Code:
    module aoi2(g,h,a,b);
    output g;
    input a,b;
    wire c;
    assign c = a && b;
    assign g = c;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b and the outputs g and h. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,h,a,b);
    output g, h;
    input a,b;
    wire c;
    assign c = a && b;
    assign g = c;
    endmodule

    # Module 7: Parametric RTL Design
    In this assignment, we are designing a module using 3 inputs and 1 output using a block diagram. The inputs are a,b,c, which are inputs to the module. The output is given using a block diagram.

    ## Design of Module 7
    ## Base Verilog Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire d;
    assign d = a && b && c;
    assign g = d;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c and the output g. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire e,f,g1;
    assign g = a || b || c;
    endmodule

    # Module 8: Parametric RTL Design
    In this assignment, we are designing a module using 3 inputs and 1 output (g) using a block diagram. The inputs are a,b,c, which are inputs to the module. The output is given using a block diagram.

    ## Design of Module 8
    ## Base Verilog Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire d;
    assign d = a && b && c;
    assign g = d;
    endmodule
    ## Variation Instruction:
    A block diagram with the inputs a,b,c and the output g. The instance of the module is given using the same block diagram.
    ## Modified Code:
    module aoi2(g,a,b,c);
    output g;
    input a,b,c;
    wire e,f,g1;
    assign g = a || b || c;
    endmodule

    # Module 9: Parametric RTL Design
    In this assignment, we are designing a module using 5 inputs and 1 output using a block diagram. The inputs are a,b,c,d,e, which are inputs to the module. The output is given using a block diagram.
    ##
- code: "--- main.cpp\t(original)\n+++ main.cpp\t(program)\n@@ -33,7 +33,7 @@\nint\
    \ main()\n{\n aoi2 aoi2s[4];\n-Wire<bool> g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n\
    \ g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\n--- main.v\t(original)\n+++\
    \ main.v\t(program)\n@@ -10,7 +10,21 @@\n\n### Base Verilog Code:\nmodule aoi2(g,a,b,c,d);\n\
    output g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate signals\n// Dataflow assignments\
    \ for AND, OR, and NOT operations\nassign e = a && b;\nassign f = c && d;\nassign\
    \ g1 = e || f;\nassign g = ~g1; // Final AOI output\nendmodule\n### Variation\
    \ Instruction:\nUse initial block variable initialization with an inside expression\
    \ using a function call in the index.\n\n### Changed Code:\n--- main.cpp\t(original)\n\
    +++ main.cpp\t(program)\n@@ -33,7 +33,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool>\
    \ g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\
    \n--- main.v\t(original)\n+++ main.v\t(program)\n@@ -10,7 +10,21 @@\n\n### Base\
    \ Verilog Code:\nmodule aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1;\
    \ // Intermediate signals\n// Dataflow assignments for AND, OR, and NOT operations\n\
    assign e = a && b;\nassign f = c && d;\nassign g1 = e || f;\nassign g = ~g1; //\
    \ Final AOI output\nendmodule\n### Variation Instruction:\nUse initial block variable\
    \ initialization with an inside expression using a function call in the index.\n\
    \n### Changed Code:\n--- main.cpp\t(original)\n+++ main.cpp\t(program)\n@@ -33,7\
    \ +33,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool> g;\n+Wire<bool> g(0,0);\n\
    \ g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\n---\
    \ main.v\t(original)\n+++ main.v\t(program)\n@@ -10,7 +10,21 @@\n\n### Base Verilog\
    \ Code:\nmodule aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate\
    \ signals\n// Dataflow assignments for AND, OR, and NOT operations\nassign e =\
    \ a && b;\nassign f = c && d;\nassign g1 = e || f;\nassign g = ~g1; // Final AOI\
    \ output\nendmodule\n### Variation Instruction:\nUse initial block variable initialization\
    \ with an inside expression using a function call in the index.\n\n### Changed\
    \ Code:\n--- main.cpp\t(original)\n+++ main.cpp\t(program)\n@@ -33,7 +33,7 @@\n\
    int main()\n{\n aoi2 aoi2s[4];\n-Wire<bool> g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n\
    \ g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\n\n#### Revision 1222192906.32[diff]\
    \ [view] [history]\n\n--\n\n### Changed Code:\n--- main.cpp\t(original)\n+++ main.cpp\t\
    (program)\n@@ -53,7 +53,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool> g;\n\
    +Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\
    \n--- main.v\t(original)\n+++ main.v\t(program)\n@@ -24,7 +24,7 @@\n\n### Base\
    \ Verilog Code:\nmodule aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1;\
    \ // Intermediate signals\n// Dataflow assignments for AND, OR, and NOT operations\n\
    assign e = a && b;\nassign f = c && d;\nassign g1 = e || f;\nassign g = ~g1; //\
    \ Final AOI output\nendmodule\n### Variation Instruction:\nUse initial block variable\
    \ initialization with an inside expression using a function call in the index.\n\
    \n### Changed Code:\n--- main.cpp\t(original)\n+++ main.cpp\t(program)\n@@ -53,7\
    \ +53,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool> g;\n+Wire<bool> g(0,0);\n\
    \ g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\n\n\
    #### Revision 1222192906.33[diff] [view] [history]\n\n--\n\n### Changed Code:\n\
    --- main.cpp\t(original)\n+++ main.cpp\t(program)\n@@ -53,7 +53,7 @@\nint main()\n\
    {\n aoi2 aoi2s[4];\n-Wire<bool> g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n\
    \ g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\n--- main.v\t(original)\n+++\
    \ main.v\t(program)\n@@ -24,7 +24,7 @@\n\n### Base Verilog Code:\nmodule aoi2(g,a,b,c,d);\n\
    output g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate signals\n// Dataflow assignments\
    \ for AND, OR, and NOT operations\nassign e = a && b;\nassign f = c && d;\nassign\
    \ g1 = e || f;\nassign g = ~g1; // Final AOI output\nendmodule\n### Variation\
    \ Instruction:\nUse initial block variable initialization with an inside expression\
    \ using a function call in the index.\n\n### Changed Code:\n--- main.cpp\t(original)\n\
    +++ main.cpp\t(program)\n@@ -53,7 +53,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool>\
    \ g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\
    \n\n#### Revision 1222192906.34[diff] [view] [history]\n\n--\n\n### Variation\
    \ Instruction:\nUse initial block variable initialization with an inside expression\
    \ using a function call in the index.\n### Changed Code:\n--- main.cpp\t(original)\n\
    +++ main.cpp\t(program)\n@@ -33,7 +33,7 @@\nint main()\n{\n aoi2 aoi2s[4];\n-Wire<bool>\
    \ g;\n+Wire<bool> g(0,0);\n g.assign(aoi2s[0].g);\n g.assign(aoi2s[1].g);\n g.assign(aoi2s[2].g);\n\
    \n\n#### Revision 1222192906.35[diff] [view] [history]\n\n--\n\n### Base Verilog\
    \ Code:\nmodule aoi2(g,a,b,c,d);\noutput g;\ninput a,b,c,d;\nwire e,f,g1; // Intermediate\
    \ signals\n// Dataflow assignments for AND,"
- code: |-
    module aoi2(g,a,b,c,d);
    output g;
    input a,b,c,d;
    wire e,f,g1; // Intermediate signals
    initial begin
    end
    // Dataflow assignments for AND, OR, and NOT operations
    assign e = a && b;
    assign f = c && d;
    assign g1 = e || f;
    assign g = ~g1; // Final AOI output
    endmodule
    ### References 85
    2018-10-27 19:11:39 1728
    Using Initial Declarations in Verilog 22
    Exercises 2
    2. Module instantiation 1. Consider the following module definition.
    module or2 ( y, a, b,
    input [1:0] a,
    input [1:0] b,
    input  en
    );
    output y;
    wire  en_next;

    assign en_next = en;
    assign y = a | b;
    endmodule
    2. Which is the closest equivalent to the initial block in a Verilog programming language, with a
    given dataflow specification for module or2?
    a. begin
    end
    b. or2 ( y, a, b,
    input [1:0] a,
    input [1:0] b,
    input  en )
    c. initial begin
    end
    d. initial begin
    end
    3. Consider the following module instantiation.
    or2   (y_3, a_3, b_3,
    a_2, b_2,
    en_2)
    y_1, a_1, b_1,
    y_2, a_2, b_2,
    en_1)
    2018-10-27 19:11:39 1729
    Using Initial Declarations in Verilog 23
    Exercises 3
    3. Which of the following expressions is equivalent to the initial block statement?
    a. begin
    end
    b. begin
    end
    c. or2 ( y, a, b,
    input [1:0] a,
    input [1:0] b,
    input en
    )
    d. or2 ( y, a, b,
    input [1:0] a,
    input [1:0] b,
    input  en )
    2. In the module or2, which of the following statements are valid initial declarations?
    a. initial begin
    end
    b. initial begin
    end
    c. assign y = a | b;
    d. begin
    end
    4. Consider the following dataflow description of a module.
    module or2 ( y, a, b,
    input [1:0] a,
    input [1:0] b,
    input  en
    );
    output y;
    wire  en_next;

    assign en_next = en;
    assign y = a | b;
    endmodule
    5. Which of the following statements are valid initial declarations?
    a. begin
    end
    b. begin
    end
    c. assign y = a | b;
    d. initial begin
    end
    2018-10-27 19:11:39 1730
    Using Initial Declarations in Verilog 24
    Exercises 4
    Exercises 4
    6. Which of the following statements are valid initial declarations?
    a. begin
    end
    b. begin
    end
    c. assign y = a | b;
    d. initial begin
    end
    7. Consider the following initial block statement.
    initial
    {en_next = en;}
    8. Which of the following statements are valid dataflow descriptions that correspond to the initial block?
    a. begin
    end
    b. begin
    end
    c. begin
    end
    d. begin
    end
    9. Consider the following initial block statement.
    initial
    {en_next = en;}
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign en_next = en;
    d. begin
    end
    2018-10-27 19:11:39 1731
    Using Initial Declarations in Verilog 25
    Exercises 5
    25. Consider the following initial block statement.
    initial
    {en_next = en;}
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign en_next = en;
    d. begin
    end
    10. Consider the following initial block statement.
    initial
    {en_next = en;}
    11. Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign en_next = en;
    d. begin
    end
    26. Consider the following initial block statement.
    initial
    {en_next = en;}
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign en_next = en;
    d. begin
    end
    12. Consider the following code segment.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    27. Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    28. Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    13. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    14. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    15. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    2018-10-27 19:11:39 1732
    Using Initial Declarations in Verilog 26
    Exercises 6
    Exercises 6
    29. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    30. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    16. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
    {
    y = x;
    }
    }
    }
    Which of the following statements are valid dataflow descriptions that correspond to the initial block in this example?
    a. begin
    end
    b. begin
    end
    c. assign y = x;
    d. begin
    end
    31. Consider the following initial block statement.
    initial
    {
    for (i = 0; i <= 8000; i = i + 1)
    {
    if (en)
- code: |-
    module nand2(g,a,b);
    output g;
    input a,b;
    assign g = (~a && b) || (~b && a);
    endmodule
    module nor2(g,a,b);
    output g;
    input a,b;
    assign g = (~a && b) || (~b && a);
    endmodule
    module and2(g,a,b);
    output g;
    input a,b;
    assign g = (~a || b) && (~b || a);
    endmodule
    module or2(g,a,b);
    output g;
    input a,b;
    assign g = (~a && b) || (~b && a);
    endmodule
    ### Results on 100 Time Steps:
    Initial step:
    a=1,b=1,g=1
    Final step:
    a=1,b=1,g=1
    Initial step:
    a=1,b=0,g=1
    a=1,g=1,b=0
    Final step:
    a=1,b=0,g=1
    a=1,g=1,b=0
    Initial step:
    a=0,b=1,g=1
    a=1,b=0,g=1
    a=0,g=1,b=1
    Final step:
    a=0,b=1,g=1
    a=1,b=0,g=1
    a=0,g=1,b=1
    Initial step:
    a=0,b=0,g=1
    a=1,g=1,b=0
    Final step:
    a=0,b=0,g=1
    a=1,g=1,b=0
- code: |-
    module maj3 (a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    wire [2:0] bits = {a, b, c};
    and #(2, 4)
        (im1, bits[0], bits[1]),
        (im2, bits[1], bits[2]),
        (im3, bits[2], bits[0]);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
    /README.md
    # HLS_Code_Generator
    This repository includes the HLS Code Generator (HLSGen) for Xilinx FPGAs (Xilinx Vivado).

    **How to use**

    1. Modify the source files (i.e., the Verilog files) to include the HLS-specific directive statements. The main HLS-specific directive statement is the `#pragma HLS INTERFACE` statement. See the [Vivado HLS Reference Manual](http://www.xilinx.com/support/documentation/sw_manuals/xilinx2016_4/ug902-vivado-high-level-synthesis.pdf) for more details.
    2. Build the executable file `HLSGen` by running `make` in the `HLSGen` folder.
    3. Run the `HLSGen` executable file by running
    ```
    ./HLSGen <your_source_files> [-i <name of output ie the `HLSGen` executable file by running
    ```
    ./HLSGen <your_source_files> [-i <name of output input file>][[-o <name of output output file>][-d <directive>]]
    ```

    **Example**

    ```
    ./HLSGen./test_files/verilog_files/maj3.v -o./test_files/verilog_files/maj3_modified.v -d "2, 4"
    ```

    The output Verilog file `./test_files/verilog_files/maj3_modified.v` will be created.
    nput file>][[-o <name of output output file>][-d <directive>]]
    ```

    **Example**

    ```
    ./HLSGen./test_files/verilog_files/maj3.v -i./test_files/verilog_files/maj3_modified.v -d "2, 4"
    ```

    The output Verilog files `./test_files/verilog_files/maj3_modified.v` will be created.

    **How to build the executable file**

    Run `make` to build the executable file `HLSGen`.

    **Additional Arguments**

    The HLSGen executable file can take other arguments besides the Verilog file names. To see the available arguments, run
    ```
    ./HLSGen -h
    ```

    **How to run the HLSGen executable file**

    Run th/HLSGen/test_files/verilog_files/maj2.c
    // Function: Majority2
    // Majority2(a, b, c, y)
    //    y = a OR b OR c

    int Majority2(int a, int b, int c, int y){
        int im1, im2, im3;
        im1 = a || b;
        im2 = b || c;
        im3 = c || a;
        y = im1 || im2 || im3;
    }
    /HLSGen/test_files/verilog_files/maj4_modified.c
    // Function: Majority4
    // Majority4(a, b, c, d, y)
    //    y = (a OR b OR c OR d) & ~(a & b & c & d)

    int Majority4(int a, int b, int c, int d, int y){
        int im1, im2, im3, im4, im5;
        im1 = a || b || c || d;
        im2 = (a & b & c & d);
        im3 =!(im2);
        im4 = im1 && im3;

     im5);
    }
       y = im4;
    }

    int Majority4(int a, int b, int c, int d){
        int im1, im2, im3, im4;
        im1 = a || b || c || d;
        im2 = (a & b & c & d);
        im3 =!(im2);
        im4 = im1 && im3;

        return(rallel (
            #pragma HLS INTERFACE axis port=out
        )
        // Input parameters for the majority function
        int a, b, c, d, y;

        #pragma HLS INTERFACE s_axilite port=a bundle=ctrl
        #pragma HLS INTERFACE s_axilite port=b bundle=ctrl
        #pragma HLS INTERFACE s_axilite port=c bundle=ctrl
        #pragma HLS INTERFACE s_axilite port=d bundle=ctrl
        #pragma HLS INTERFACE s_axilite port=y bundle=ctrl
        #pragma HLS INTERFACE s_axilite port=return bundle=ctrl

        // Pass through the input parameters to the majority function
        Majority4(a, b, c, d, y);

        // Write the majority result to the AXI4-Stream output
        out.write(y);
    }
    /HLSGen/test_files/verilog_files/maj4.cpp
    #include "maj4.h"

    // Function: Majority4
    // Majority4(a, b, c, d, y)
    //    y = (a OR b OR c OR d) & ~(a & b & c & d)

    void Majority4_hls(
        // AXI4-Stream input
        axi_stream& in,
        // AXI4-Stream output
        axi_stream& out
    ){
        // Receive the majority input parameters from the AXI4-Stream input
        int a, b, c, d;
        in >> a >> b >> c >> d;

        // Define the majority function
        void Majority4(int a, int b, int c, int d, int y);

        // Output the majority result to the AXI4-Stream output
        #pragma HLS PIPELINE

        // Output parameters for the majority function
        #pragma HLS INTERFACE s_axilite port=return bundle=ctrl

        // Output the majority result to the AXI4-Stream output
        #pragma HLS pe/HLSGen/test_files/verilog_files/maj4_modified.c
    // Function: Majority4
    // Majority4(a, b, c, d, y)
    //    y = (a OR b OR c OR d) & ~(a & b & c & d)

    int Majority4(int a, int b, int c, int d, int y){
        int im1, im2, im3, im4;
        im1 = a || b || c || d;
        im2 = (a & b & c & d);
        im3 =!(im2);
        im4 = im1 && im3;

        y = im4;
    }

    int Majority4(int a, int b, int c, int d){
        int im1, im2, im3, im4;
        im1 = a || b || c || d;
        im2 = (a & b & c & d);
        im3 =!(im2);
        im4 = im1 && im3;

        return(im4);
    }
    /HLSGen/test_files/verilog_files/maj2_modified.h
    void Majority2_hls(
        // AXI4-Stream input
        axi_stream& in,
        // AXI4-Stream output
        axi_stream& out
    );
    /HLSGen/test_files/verilog_files/maj2_modified.cpp
    void Majority2_hls(
        // AXI4-Stream input
        axi_stream& in,
        // AXI4-Stream output
        axi_stream& out
    ){
        // Receive the majority input parameters from the AXI4-Stream input
        int a, b, c;
        in >> a >> b >> c;

        // Define the majority function
        void Majority2(int a, int b, int c, int y);

        // Output the majority result to the AXI4-Stream output
        #pragma HLS PIPELINE

        // Output parameters for the majority function
        #pragma HLS INTERFACE s_axilite port=return bundle=ctrl

        // Output the majority result to the AXI4-Stream output
        #pragma HLS pe parallel (
            #pragma HLS INTERFACE axis port=out
        )
        int y;
        in >> y;
        out << y;
    }
    /HLSGen/test_files/verilog_files/maj4.c
    // Function: Majority
- code: "module maj3 (a, b, c, y);\ninput a, b, c;\noutput y;\nwire im1, im2, im3;\n\
    and #(2, 4) (im1, a, b),\n    #(2, 4) (im2, b, c),\n    #(2, 4) (im3, c, a);\n\
    or #(3, 5) (y, im1, im2, im3);\nendmodule\n\n\n/README.md\n# Formal-Verification\n\
    Formal verification of a component using VUnit\n\n## How to run\n```\nmake test\n\
    ```\n\n## Requirements\n```\npython3.6+\n```\n\n## Description\nThis is an example\
    \ of formal verification. For more information about the methodology used to accomplish\
    \ the verification, see the [proposal](https://github.com/josephmarquez/Formal-Verification/blob/master/proposal/proposal.md).\n\
    \nThe testbench is built in [Icarus Verilog](https://github.com/steveicarus/iverilog/wiki)\
    \ and the test cases are written in [VUnit](https://github.com/VUnit/vunit).\n\
    \n## Structure\nThis repository is separated into the following folders:\n###\
    \ code/\n  This folder contains the base code (v) and the target code (t), the\
    \ result of the formal verification will be placed in the output folder.\n###\
    \ proposal/\n  This folder contains the proposal for the formal verification of\
    \ the design.\n### results/\n     This folder contains the design results.\n###\
    \ test/\n  This folder contains the VUnit test cases.\n/test/test_maj3.py\nfrom\
    \ vunit import VUnit\nfrom vunit.verilog import VerilogTest\nimport os\n\ndef\
    \ test_maj3():\n    # create vunit test object\n    testbench = VerilogTest()\n\
    \    # create a module test\n    tests = testbench.create_test(\"maj3\")\n\n \
    \   # read in base and target verilog files\n    with open(\"code/maj3.v\") as\
    \ f:\n        tests.base_content = f.read()\n    with open(\"code/maj3_t.v\")\
    \ as f:\n        tests.target_content = f.read()\n    with open(\"code/maj3_out.v\"\
    ) as f:\n        tests.expected_content = f.read()\n    # compile the files\n\
    \    testbench.compile()\n\n    # execute the test case\n    testbench.run(fail_on_error=True)\n\
    \    if not os.path.isdir(\"results\"):\n        os.mkdir(\"results\")\n    if\
    \ not os.path.isdir(\"results/maj3\"):\n        os.mkdir(\"results/maj3\")\n \
    \   # write a test case file\n    tests.write_log(\"results/maj3/maj3.txt\")\n\
    \n# run the vunit test\nVUnit.main(test_maj3)\n/test/test_maj6.py\nfrom vunit\
    \ import VUnit\nfrom vunit.verilog import VerilogTest\nimport os\n\ndef test_maj6():\n\
    \    # create vunit test object\n    testbench = VerilogTest()\n    # create a\
    \ module test\n    tests = testbench.create_test(\"maj6\")\n\n    # read in base\
    \ and target verilog files\n    with open(\"code/maj6.v\") as f:\n        tests.base_content\
    \ = f.read()\n    with open(\"code/maj6_t.v\") as f:\n        tests.target_content\
    \ = f.read()\n    with open(\"code/maj6_out.v\") as f:\n        tests.expected_content\
    \ = f.read()\n    # compile the files\n    testbench.compile()\n\n    # execute\
    \ the test case\n    testbench.run(fail_on_error=True)\n    if not os.path.isdir(\"\
    results\"):\n        os.mkdir(\"results\")\n    if not os.path.isdir(\"results/maj6\"\
    ):\n        os.mkdir(\"results/maj6\")\n    # write a test case file\n    tests.write_log(\"\
    results/maj6/maj6.txt\")\n\n# run the vunit test\nVUnit.main(test_maj6)\n/makefile\n\
    .PHONY: test\n\ntest:\n\tpython3 test/test_maj3.py\n\tpython3 test/test_maj6.py\n\
    \nclean:\n\trm -rf results"
- code: |-
    module maj4 (a, b, c, d, y);
    input a, b, c, d;
    output y;
    wire [3:0] im;
    always @ (a, b, c, d) begin
        im[0] = 2'b00;
        im[1] = 2'b01;
        im[2] = 2'b10;
        im[3] = 2'b100;
    end
    wire im1, im2, im3, im4;
    and #(im[0], 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, d),
        (im4, d, a);
    or #(im[1], 5) (y, im1, im2, im3, im4);
    endmodule
    ```
    ### Modified Verilog Code:
    ```
    module maj4 (a, b, c, d, y);
    input a, b, c, d;
    output y;
    wire im1, im2, im3, im4;
    wire [3:0] im;
    assign im[0] = 2'b00;
    assign im[1] = 2'b01;
    assign im[2] = 2'b10;
    assign im[3] = 2'b100;
    and #(im[0], 4)
        (im1, a, b),
        (im2, b, c),
        (im3, c, d),
        (im4, d
- code: |-
    module maj3(a, b, c, y);
    input a, b, c;
    output y;
    wire im1, im2, im3;
    wire [] [2:0] input = {a, b, c};
    and #(2, 4) (im1, input[1], input[2]);
    and #(2, 4) (im2, input[0], input[2]);
    and #(2, 4) (im3, input[0], input[1]);
    or #(3, 5) (y, im1, im2, im3);
    endmodule
    ### Instruction in Verilator:

    * `XMR 2:4:2 6:0,y,im1,im2,im3`
    * `ALW AND 2:4 6:0: 0 0`
    * `ALW AND 2:4 6:0: 0 1`
    * `ALW AND 2:4 6:0: 1 0`
    * `ALW AND 2:4 6:0: 1 1`
    * `ALW OR 3:5 6:0: 2:0 2:1 2:2` ### Test Result:

    Test was passed
    ##
- code: |-
    #define NCYCLES 16

    reg [7:0] MUX_DATA_IN[1:0]
    ;
    MUX_DATA_IN[0] = 1'b1;
    MUX_DATA_IN[1] = 1'b0;
    MUX_INDEX = 2'b00
    ;
    always @(posedge CLK) begin:
       MUX_INDEX <= MUX_INDEX + 1;
    end
    always @(MUX_INDEX) begin:
        case(MUX_INDEX)
             16: begin
                MUX_INDEX <= 2'b00;
                MUX_DATA_IN[0] <= 1'b1;
                MUX_DATA_IN[1] <= 1'b0;
            end
            default:
                MUX_DATA_IN[0] <= 1'b1;
                MUX_DATA_IN[1] <= 1'b0;
        endcase
    end
    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        assign MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];

    endmodule
    ### Output:
    Mux16_32_16_0.v:12:12: warning: Module MUX_16_32_16 has unconnected pin(s): clk

    ### Results:
    The generated clocks for the last iteration of the always block were the same.
    The generated clocks for the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        always @(posedge CLK) begin:
            case(MUX_INDEX)
                0: MUX_DATA_OUT <= MUX_DATA_IN[0];
                1: MUX_DATA_OUT <= MUX_DATA_IN[1];
                2: MUX_DATA_OUT <= MUX_DATA_IN[2];
                3: MUX_DATA_OUT <= MUX_DATA_IN[3];
                4: MUX_DATA_OUT <= MUX_DATA_IN[4];
                5: MUX_DATA_OUT <= MUX_DATA_IN[5];
                6: MUX_DATA_OUT <= MUX_DATA_IN[6];
                7: MUX_DATA_OUT <= MUX_DATA_IN[7];
                8: MUX_DATA_OUT <= MUX_DATA_IN[8];
                9: MUX_DATA_OUT <= MUX_DATA_IN[9];
                10: MUX_DATA_OUT <= MUX_DATA_IN[10];
                11: MUX_DATA_OUT <= MUX_DATA_IN[11];
                12: MUX_DATA_OUT <= MUX_DATA_IN[12];
                13: MUX_DATA_OUT <= MUX_DATA_IN[13];
                14: MUX_DATA_OUT <= MUX_DATA_IN[14];
                15: MUX_DATA_OUT <= MUX_DATA_IN[15];
            endcase
        end

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        always @(posedge CLK) begin:
            MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];
        end

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        always @(posedge CLK) begin:
            MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];
        end

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK, MUX_INDEX, MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        assign MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK, MUX_INDEX, MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        always @(posedge CLK) begin:
            MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];
        end

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        assign MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        assign MUX_DATA_OUT = MUX_DATA_IN[MUX_INDEX];

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA_IN;
        output reg [7:0] MUX_DATA_OUT;

        assign MUX_DATA_OUT = MUX_DATA_IN;

    endmodule
    ### Output:

    ### Results:
    All clocks from the first iteration of the always block were the same.
    All clocks from the rest of the iterations were different as expected.

    ### Verilog Module:
    module MUX_16_32_16 (
        CLK,
        MUX_INDEX,
        MUX_DATA_IN,
        MUX_DATA_OUT
    );
        input CLK;
        input [1:0] MUX_INDEX;
        input [7:0] MUX_DATA
- code: |-
    module tst_wand1;
    reg i1,i2;
    wire o;
    wand1 ww(i1,i2,o);
    always
    begin
    $display("i1=%b, i2=%b, o=%b",i1,i2,o);
    if (((i1 >= 3'b0) && (i1 < 3'b1)) && ((i2 >= 3'b0) && (i2 < 3'b1))) begin o=3'b1; end
    end
    endmodule
    ### Expected Results:
    i1=0, i2=0, o=0
    i1=1, i2=0, o=0
    i1=0, i2=1, o=0
    i1=1, i2=1, o=1
    ### Observed Results:
    i1=0, i2=0, o=0
    i1=1, i2=0, o=0
    i1=0, i2=1, o=0
    i1=1, i2=1, o=1
    ```

    ## tst_wthres1

    ```
    // Module: tst_wthres1
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs, one for each input and three for
    // the tristate.
    // 3. The 4 outputs are compared to golden values to check for correctness.
    //
    // Usage:
    // 1. Testbench parameters are read from the file tst_wthres1-params.txt.
    // 2. The parameters file contains, one parameter per line.
    // 3. The testbench can be started from the command prompt using the
    // following syntax:
    //  - "vcs -sverilog tst_wthres1.v -l vcs.log".
    // 4. The simulator will generate a waveform of the testbench and its output.
    // 5. Verilog/SystemVerilog code can be used to monitor the testbench.
    // 6. After the test, the simulator will generate an output text file,
    // "results.log", that contains all testbench outputs.
    //
    // Note: This testbench is not intended for synthesis.

    `timescale 1ps / 1ps
    // Testbench parameters are read from the file tst_wthres1-params.txt.
    `include "tst_wthres1-params.txt"

    // Source file: tst_wthres1.v
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs, one for each input and three for
    // the tristate.
    // 3. The 4 outputs are compared to golden values to check for correctness.
    //
    // Usage:
    // 1. Testbench parameters are read from the file tst_wthres1-params.txt.
    // 2. The parameters file contains, one parameter per line.
    // 3. The testbench can be started from the command prompt using the
    // following syntax:
    //  - "vcs -sverilog tst_wthres1.v -l vcs.log".
    // 4. The simulator will generate a waveform of the testbench and its output.
    // 5. Verilog/SystemVerilog code can be used to monitor the testbench.
    // 6. After the test, the simulator will generate an output text file,
    // "results.log", that contains all testbench outputs.
    //
    // Note: This testbench is not intended for synthesis.

    `timescale 1ps / 1ps
    // Testbench parameters are read from the file tst_wthres1-params.txt.
    `include "tst_wthres1-params.txt"

    // Source file: tst_wthres1.v
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs, one for each input and three for
    // the tristate.
    // 3. The 4 outputs are compared to golden values to check for correctness.
    //
    // Usage:
    // 1. Testbench parameters are read from the file tst_wthres1-params.txt.
    // 2. The parameters file contains, one parameter per line.
    // 3. The testbench can be started from the command prompt using the
    // following syntax:
    //  - "vcs -sverilog tst_wthres1.v -l vcs.log".
    // 4. The simulator will generate a waveform of the testbench and its output.
    // 5. Verilog/SystemVerilog code can be used to monitor the testbench.
    // 6. After the test, the simulator will generate an output text file,
    // "results.log", that contains all testbench outputs.
    //
    // Note: This testbench is not intended for synthesis.

    `timescale 1ps / 1ps
    // Testbench parameters are read from the file tst_wthres1-params.txt.
    `include "tst_wthres1-params.txt"

    // Source file: tst_wthres1.v
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs, one for each input and three for
    // the tristate.
    // 3. The 4 outputs are compared to golden values to check for correctness.
    //
    // Usage:
    // 1. Testbench parameters are read from the file tst_wthres1-params.txt.
    // 2. The parameters file contains, one parameter per line.
    // 3. The testbench can be started from the command prompt using the
    // following syntax:
    //  - "vcs -sverilog tst_wthres1.v -l vcs.log".
    // 4. The simulator will generate a waveform of the testbench and its output.
    // 5. Verilog/SystemVerilog code can be used to monitor the testbench.
    // 6. After the test, the simulator will generate an output text file,
    // "results.log", that contains all testbench outputs.
    //
    // Note: This testbench is not intended for synthesis.

    `timescale 1ps / 1ps
    // Testbench parameters are read from the file tst_wthres1-params.txt.
    `include "tst_wthres1-params.txt"

    // Source file: tst_wthres1.v
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs, one for each input and three for
    // the tristate.
    // 3. The 4 outputs are compared to golden values to check for correctness.
    //
    // Usage:
    // 1. Testbench parameters are read from the file tst_wthres1-params.txt.
    // 2. The parameters file contains, one parameter per line.
    // 3. The testbench can be started from the command prompt using the
    // following syntax:
    //  - "vcs -sverilog tst_wthres1.v -l vcs.log".
    // 4. The simulator will generate a waveform of the testbench and its output.
    // 5. Verilog/SystemVerilog code can be used to monitor the testbench.
    // 6. After the test, the simulator will generate an output text file,
    // "results.log", that contains all testbench outputs.
    //
    // Note: This testbench is not intended for synthesis.

    `timescale 1ps / 1ps
    // Testbench parameters are read from the file tst_wthres1-params.txt.
    `include "tst_wthres1-params.txt"

    // Source file: tst_wthres1.v
    // Generated by LRM
    // Description:
    // Testbench for module wthres1.
    //
    // Note:
    // 1. This testbench has 2 inputs, 1 output and 1 tristate.
    // 2. The testbench generates 4 outputs
- code: |-
    initial #8 $stop; // Added stop ### Base Verilog Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); For the fourth instance of the variation, the modification is as follows: ### Base Verilog Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); ### Base Verilog Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); For the fifth instance of the variation, the modification is as follows: ### Base Verilog Code: initial$monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the sixth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the seventh instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the eighth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the ninth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the tenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the eleventh instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the twelfth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the thirteenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the fourteenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the fifteenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the sixteenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the seventeenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%b,i2=%b,o=%b",i1,i2,o); endmodule ### Variation Instruction: Use inside in an if statement on an array slice operand indexed by a variable and test against part-select range. ### Modified Code: initial #8$stop; // Added stop

    For the eighteenth instance of the variation, the modification is as follows:

    ### Base Verilog Code:
    initial $monitor($time,"i1=%
- code: |-
    $display("hello world"); ### Conclusion:$display() is used to display output on the terminal with the usual syntax.

    ## 2019-04-26

    ### Base Verilog Code:

    ### Variation Instruction:

    Use $display(). ### Modified Code:$display("hello world");

    ### Conclusion:

    $display() is used to display output on the terminal with the usual syntax. ## 2019-04-23 ### Base Verilog Code: module tst_xor1; reg i1,i2; wire o; xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Variation Instruction: Use wire and wire declaration, no changes or re-assignments. ### Modified Code: module tst_xor1; //testbench wire i1; wire i2; wire o; xor1 xx(i1,i2,o); //wire declaration // xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Conclusion: No change, wire and wire declaration, is the same as wire i1 = 0, i2 = 0;. ## 2019-04-23 ### Base Verilog Code: module tst_xor1; reg i1,i2; wire o; xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Variation Instruction: Use wire and wire declaration, no changes or re-assignments. ### Modified Code: module tst_xor1; //testbench wire i1; wire i2; wire o; xor1 xx(i1,i2,o); //wire declaration // xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Conclusion: No change, wire and wire declaration, is the same as wire i1 = 0, i2 = 0;. # Appendix ## 2019-04-23 ### Base Verilog Code: module tst_xor1; reg i1,i2; wire o; xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Variation Instruction: Use assign statement. ### Modified Code: module tst_xor1; //testbench wire i1; assign i1 = 0; wire i2; assign i2 = 0; //wire declaration wire o; xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule ### Conclusion: No change, the code is self evident after the initial statement. ## 2019-04-23 ### Base Verilog Code: module tst_xor1; reg i1,i2; wire o; xor1 xx(i1,i2,o); initial begin i1=0; i2=0; // Drv1=pull0, Drv2=pull0 -> o = pull0 (xor rule) end initial$monitor(\$time,"i1=%b,i2=%b,o=%b",i1,i2,o);

    initial
    $stop; // Added stop endmodule
- code: |-
    ```
    if(q[7] & q[6])
    ```

    **Code before modification:**
    ```
    if(q[7])
    ```

    **Code after modification:**
    ```
    if(q[7] & q[6])
    ```

    ### Base Verilog Code:
    ```
    module tst_nand
- code: |-
    reg a,b,c;
    wire d;
    assign d = (a & b) | c;
    ### Variation Instruction:
    Use in expression

    I see this as a bug, because of the following two features:

    1. The & operation used in the assign statement is part of the default 'and' operation.
    2. The | operation used in the assign statement is part of the default 'or' operation.

    The default operation for the & and | operations is not the bitwise & or | operations. Instead, the default operations are the logical & and | operations. These are the logical operations, which are not the bitwise operations.

    Note that this bug does not occur if all three operands to the | are constants.

    ### Modified Verilog Code:
    reg a,b,c;
    wire d;
    assign d = a | b | c;
    ### Variation Instruction:
    Use in expression

    I see this as a bug, because of the following two features:

    1. The | operation used in the assign statement is part of the default 'or' operation.
    2. These are the logical operations, which are not the bitwise operations.

    The default operation for the | operation is not the bitwise | operation. Instead, the default operation is the logical | operation. These are the logical operations, which are not the bitwise operations.

    Note that this bug does not occur if all three operands to the | are constants.

    ### Modified Verilog Code:
    reg a,b,c;
    wire d;
    assign d = a & b | c;
    ### Variation Instruction:
    Use in expression

    I see this as a bug, because of the following two features:

    1. The & operation used in the assign statement is part of the default 'and' operation.
    2. The | operation used in the assign statement is part of the default 'or' operation.

    The default operation for the & and | operations is not the bitwise & or | operations. Instead, the default operations are the logical & and | operations. These are the logical operations, which are not the bitwise operations.

    Note that this bug does not occur if all three operands to the & and the | are constants.

    ### Modified Verilog Code:
    reg a,b,c;
    wire d;
    assign d = a & b | c;
    ### Variation Instruction:
    Use in expression

    I see this as a bug, because of the following two features:

    1. The & operation used in the assign statement is part of the default 'and' operation.
    2. The | operation used in the assign statement is part of the default 'or' operation.

    The default operation
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    1'b0 : y = a;
    1'b1 : y = b;
    default : y = 'bx;
    endcase
    endmodule
    ### Result:
    The Verilog code output is shown below:
    3.0.3
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    1'b0 : y = a;
    1'b1 : y = b;
    default : y = 'bx;
    endcase
    endmodule
    3.0.4
    The Verilog code output is shown below:

    This was an example for 2-bit MUX. In the next post of this series of posts I will be showing you how to implement 4-bit MUX.

    ## How to Generate Verilog Code for a 2-Bit Multiplier

    Here you will learn how to generate Verilog code for 2-Bit Multiplier.

    In the field of Digital Electronics, Multipliers are an important section when it comes to practical applications. A 2-Bit Multiplier is an example of a Multiplier.

    Here is the Verilog code for 2-Bit Multiplier using procedural assignment:
    module multiplier21a(
    input wire [1:0] A,
    input wire [1:0] B,
    output reg [1:0] Z
    );
    reg [1:0] sum,tempCin,tempCout;
    assign Z = {sum};
    always @(*)
    begin
    sum = A * B;
    tempCin = Z[0];
    tempCout = Z[1];
    end
    endmodule

    The Verilog code output is shown below:
    3.1.1
    module a(
    input wire a0,
    input wire a1,
    input wire b0,
    input wire b1,
    output reg c0,
    output reg c1,
    output reg c2
    );
    reg [1:0] sum,tempCin,tempCout;
    assign c0 = sum[0];
    assign c1 = sum[1];
    assign c2 = sum[2];
    always @(*)
    begin
    sum = a0*b0 + a1*b1 + tempCin;
    c2 = sum[2];
    tempCin = tempCout;
    tempCout = c2;
    end
    endmodule

    The Verilog code output is shown below:

    In the post of this series, we will see how to implement a general purpose 4 bit multiplier.

    ## How to Generate Verilog Code for a 4-Bit Multiplier

    In this post of this series of posts, I will be showing you how to generate 4-bit Multiplier using Verilog.

    Note: You can download Verilog code generated in this series of posts here.

    Here is the Verilog code for 4-Bit Multiplier using procedural assignment:
    module multiplier41a(
    input wire [3:0] A,
    input wire [3:0] B,
    output wire [11:0] Z
    );
    reg [3:0] sum,tempCin,tempCout;
    assign Z = sum;
    always @(*)
    begin
    sum = A * B;
    tempCin = Z[4];
    tempCout = Z[11];
    end
    endmodule

    The Verilog code output is shown below:
    4.1.1
    module a(
    input wire a0,
    input wire a1,
    input wire a2,
    input wire a3,
    input wire b0,
    input wire b1,
    input wire b2,
    input wire b3,
    output reg c0,
    output reg c1,
    output reg c2,
    output reg c3,
    output reg c4,
    output reg c5,
    output reg c6,
    output reg c7
    );
    reg [1:0] sum,tempCin,tempCout;
    assign c0 = sum[0];
    assign c1 = sum[1];
    assign c2 = sum[2];
    assign c3 = sum[3];
    assign c4 = sum[4];
    assign c5 = sum[5];
    assign c6 = sum[6];
    assign c7 = sum[7];
    always @(*)
    begin
    sum = a0*b0 + a1*b1 + a2*b2 + a3*b3 + tempCin;
    c7 = sum[7];
    tempCin = tempCout;
    tempCout = c7;
    end
    endmodule

    The Verilog code output is shown below:

    In the next post of this series, I will show you how to implement a general purpose 16 bit multiplier.

    ## How to Generate Verilog Code for a 16-Bit Multiplier

    In this post of this series of posts, I will be showing you how to generate 16-bit Multiplier using Verilog.

    Note: You can download Verilog code generated in this series of posts here.

    Here is the Verilog code for 16-Bit Multiplier using procedural assignment:
    module multiplier161a(
    input wire [15:0] A,
    input wire [15:0] B,
    output wire [31:0] Z
    );
    reg [15:0] sum,tempCin,tempCout;
    assign Z = sum;
    always @(*)
    begin
    sum = A * B;
    tempCin = Z[16];
    tempCout = Z[31];
    end
    endmodule

    The Verilog code output is shown below:
    16.1.1
    module a(
    input wire a0,
    input wire a1,
    input wire a2,
    input wire a3,
    input wire a4,
    input wire a5,
    input wire a6,
    input wire a7,
    input wire a8,
    input wire a9,
    input wire a10,
    input wire a11,
    input wire a12,
    input wire a13,
    input wire a14,
    input wire a15,
    input wire b0,
    input wire b1,
    input wire b2,
    input wire b3,
    input wire b4,
    input wire b5,
    input wire b6,
    input wire b7,
    input wire b8,
    input wire b9,
    input wire b10,
    input wire b11,
    input wire b12,
    input wire b13,
    input wire b14,
    input wire b15,
    output reg c0,
    output reg c1,
    output reg c2,
    output reg c3,
    output reg c4,
    output reg c5,
    output reg c6,
    output reg c7,
    output reg c8,
    output reg c9,
    output reg c10,
    output reg c11,
    output reg c12,
    output reg c13,
    output reg c14,
    output reg c15,
    output reg c16,
    output reg c17,
    output reg c18,
    output reg c19,
    output reg c20,
    output reg c21,
    output reg c22,
    output reg c23,
    output reg c24,
    output reg c25,
    output reg c26,
    output reg c27,
    output reg c28,
    output reg c29,
    output reg c30,
    output reg c31
    );
    reg [15:0] sum,tempCin,tempCout;
    assign c0 = sum[0];
    assign c1 = sum[1];
    assign c2 = sum[2];
    assign c3 = sum[3];
    assign c4 = sum[4];
    assign c5 = sum[5];
    assign c6 = sum[6];
    assign c7 = sum[7];
    assign c8 = sum[8];
    assign c9 = sum[9];
    assign c10 = sum[10];
    assign c11 = sum[11];
    assign c12 = sum[12];
    assign c13 = sum[13];
    assign c14 = sum[14];
    assign c15 = sum[15];
    assign c16 = sum[16];
    assign c17 = sum[17];
    assign c18 = sum[18];
    assign c19 = sum[19];
    assign c20 = sum[20];
    assign c21 = sum[21];
    assign c22 = sum[22];
    assign c23 = sum[23];
    assign c24 = sum[24];
    assign c25 = sum[25];
    assign c26 = sum
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    0 : y = a; // Select a if s=0
    1 : y = b; // Select b if s=1
    2'b10 : y = 3'b010; // Select c if s=2
    endcase
    endmodule
    ### Verilog Design:
    module mux21b_tb; // Top module
    reg a, b, s; // Input register
    reg [3:0] y; // Output register
    mux21b uut (.a(a),.b(b),.s(s),.y(y) ); // Instantiating the unit under test
    initial begin a = 1; b = 0; s = 0; #5 a = 0; b = 1; s = 1; #5 a = 1; b = 1; s = 2; #5 a = 0; b = 1; s = 3; end
    initial case (s)
    0: $display("a = %d, b = %d, s = %d, y = %d", a, b, s, y); // Printing the values #1; #10 continue; 1: $display("a = %d, b = %d, s = %d, y = %d", a, b, s, y); // Printing the values #1; #10 continue; 2: $display("a = %d, b = %d, s = %d, y = %d", a, b, s, y); // Printing the values #1; #10 continue; 3: $display("a = %d, b = %d, s = %d, y = %d", a, b, s, y); // Printing the values #1; #10 continue;
    default: $display("a = %d, b = %d, s = %d, y = %d", a, b, s, y); #1; #10 continue; endcase endmodule ### Circuit Simulation Result: The screenshot of the circuit simulation result is as below:
- code: |-
    module mux21d (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case(s)
    0 : y = a; // Select a if s=0
    1 : y = b; // Select b if s=1
    else if (a==b)
    y=a;
    case(b)
    0:
    else :
    y = b;
    endcase
    default :
    $error("Bad case"); endcase endmodule The output is: #5$error: mux21d.sv:14: Bad case
    We see that the default case is still selected when s is not 1 or 0, but the compiler now outputs a single error for the default case. The case statement can be used to select a single value or an array of values, as well as a single value or an array of values in the case.

    ### Base Verilog Code:
    module mux21d (
    input wire a
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    // Using unpacked 2D array
    (2'b00) y <= a;
    (2'b01) y <= b;
    (2'b10) y <= a;
    (2'b11) y <= b;
    default y <= $random; endcase endmodule ## Mux 2x1b VHDL ### Variation Instruction: Using a packed 2D array as the operand. ### Modified Code: package mux21b is type mux21b is (a, b, s : in std_logic_vector(1 downto 0); y : out std_logic_vector(1 downto 0)); end mux21b; package body mux21b is function pack(a, b, s : std_logic_vector) return std_logic_vector is variable y : std_logic_vector(0 downto 0); begin if (a = "00" and b = "00") then y <= "00"; elsif (a = "00" and b = "01") then y <= b; elsif (a = "01" and b = "00") then y <= a; elsif (a = "01" and b = "01") then y <= b; elsif (a = "10" and b = "00") then y <= a; elsif (a = "10" and b = "01") then y <= b; elsif (a = "11" and b = "00") then y <= a; elsif (a = "11" and b = "01") then y <= b; elsif (a = "11" and b = "10") then y <= a; elsif (a = "11" and b = "11") then y <= b; elsif (s = "00") then y <= "00"; elsif (s = "01") then y <= "01"; elsif (s = "10") then y <= "10"; elsif (s = "11") then y <= "11"; end if; return y; end function; end mux21b; end package body mux21b; ### Variation Instruction: Using a packed 2D array as the operand. ### Modified Code: package mux21b is type mux21b is (a, b, s : in std_logic_vector(1 downto 0); y : out std_logic_vector(1 downto 0)); end mux21b; package body mux21b is function pack(a, b, s : std_logic_vector) return std_logic_vector is variable y : std_logic_vector(0 downto 0); begin if (a = "00" and b = "00") then y <= "00"; elsif (a = "00" and b = "01") then y <= b; elsif (a = "01" and b = "00") then y <= a; elsif (a = "01" and b = "01") then y <= b; elsif (a = "10" and b = "00") then y <= a; elsif (a = "10" and b = "01") then y <= b; elsif (a = "11" and b = "00") then y <= a; elsif (a = "11" and b = "01") then y <= b; elsif (a = "11" and b = "10") then y <= a; elsif (a = "11" and b = "11") then y <=
- code: |-
    module mux21b (
    input wire a,
    input wire b,
    input wire s,
    output reg y // Output must be reg for procedural assignment
    );
    always @(*) // Combinational sensitivity
    case (s)
    2'b0:
    y = a;
    2'b1:
    y = b;
    default:
    // This is the error case
    y = 0;
    endcase
    endmoduleusername_1: With the given information, the answer should be:

    1. There are no such cases (if we use the original definition of "prime"). There are only cases of the form $p|p \land q$, but these do not involve two primes.
    2. The answer is again: There are no such cases. Indeed, if there *are* such cases, then the first case you give has $2p \land (p \land q)$. Hence, $p|2p \land (p \land q)$ (using the first rule of our definition of $p|p \land q$). It's also $p|(2p \land (p \land q))$. But since $(p \land q)$ is not a prime, $2p \land (p \land q)$ must be a prime, which is a contradiction.
    3. Indeed, $p \land (p \land q)$ is not a prime, so $p|p \land (p \land q)$ is not a prime either.

    I think the problem is that you are using a definition of "$p|q$" that is not correct. The correct definition should be that $p|q$ "means" that $p|q$ holds if and only if $p$ divides $q$. That's why the correct answer to this problem is "No". If $p|q$ means that $p \land q$ is a prime, then you are correct that the given counterexamples show that $p|q$ does not imply $p$ divides $q$.
    Upvotes: 3 [selected_answer]username_2: The answer to your question is no.

    Take $p=2$, $q=6$ or $p=2$,$q=17$ to show that $p|q$ does not imply $p|q$.
    Upvotes: 1
- code: "`timescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode,\
    \ output reg [7:0] ALUout);\nalways begin\n    case (mode)\n        0: ALUout\
    \ = left + right;\n        1: ALUout = left - right;\n        2: ALUout = left\
    \ & right;\n        3: ALUout = left | right;\n        default: ALUout = 8'bX;\n\
    \    endcase\nend\nendmodule\n### Run and Results:\n[sim]./ALU8 \nALUout[0] =\
    \ 0b01010011 \nALUout[1] = 0b01010011 \nALUout[2] = 0b00110011 \nALUout[3] = 0b10100011\
    \ \nALUout[4] = 0b11111111 \nALUout[5] = 0b00000000 \nALUout[6] = 0b00000000 \n\
    ALUout[7] = 0b00000000 \nDone in 889.045ns on PSIM\n\n```\nUpvotes: 1"
- code: "`timescale 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode,\
    \ output reg [7:0] ALUout);\nalways begin\n    case (mode)\n        3: ALUout\
    \ = left | right;\n        2: ALUout = left & right;\n        1: ALUout = left\
    \ - right;\n        0: ALUout = left + right;\n        default: ALUout = 8'bX;\n\
    \    endcase \nend\nendmodule\n`\n## Part 9: \n\n### Base Verilog Code:\n`timescale\
    \ 1ns/100ps\nmodule ALU8 (input [7:0] left, right, input [1:0] mode, output reg\
    \ [7:0] ALUout);\nalways begin\n    ALUout = 8'bX;\n    case (mode)\n        0:\
    \ ALUout = left + right;\n        1: ALUout = left - right;\n        2: ALUout\
    \ = left & right"
- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        ALUout = left[7:0] + right[7:0]; // operand is replaced with left[7:0]
        assign ALUout = left[7:0] + right[7:0]; // result is replaced with left[7:0]
    end
    endmodule
    ### Verilog simulation:
    1:![alt text](https://github.com/HenryH13/VHDL2Verilog/blob/main/ScreenShots/ALU8_14.JPG)
    2:![alt text](https://github.com/H
- code: |-
    `timescale 1ns/100ps
    module ALU8_N (input [7:0] left, right, input [1:0] mode, output wire [7:0] ALUout);
    parameter wsize = 8;
    reg [wsize-1:0] x;
    initial begin
        ALUout = x[1:0];
    end
    always begin
        x = left |
- code: |-
    `timescale 1ns/100ps
    module ALU8 (input [7:0] left, right, input [1:0] mode, output reg [7:0] ALUout);
    always_comb begin
        case (mode)
            0: ALUout = left[3:0] + right[3:0];
            1: ALUout = left[3:0] - right[3:0];
            2: ALUout = left[3:0] & right[3:0];
            3: ALUout = left[3:0] | right[3:0];
            default: ALUout = 8'bX;
        endcase
    end
    endmodule
    `

    **Explanation:**

    First, notice that the operands are now only 4 bits. This is because the ALU8 is operating on 8 bit values. So, the maximum addition/subtraction of 8 bit values can only be a 4 bit value.

    Second, notice that the operator is now operating on **part** of the 8 bits. Remember, the ALU is operating on 8 bits, and the operator can only be operating on 4 bits of those 8 bits. So the operator is operating on the `[3:0]` part of the 8 bit value.

    **Result:**

    [![Alu8](https://i.stack.imgur.com/lU44v.gif)](https://i.stack.imgur.com/lU44v.gif)
    Upvotes: 2
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );

    always @(*)
    if (s == 0)
    y = a;

    else if (s == 0)
    y = b;

    endmodule
    ### Original Code:
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );

    always @(*)
    if (s == 0)
    y = a;

    else if (s == 1)
    y = b;

    endmodule
    ### Hierarchy Code:
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    endmodule
    1.30.5.29. Code:
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    y = b;
    endmodule
    1.30.5.30. Error Message:
    Error: (vsim-359) at mux24b.v(30): Cannot create instance of port y.
    Instance (mux24b) cannot be created because its parent instance has an invalid port name 'y'.
    1.30.5.31. Description:
    Error: (vsim-359
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    if(s == 1)
    y = b;
    end
    endmodule
    ### Result
    The result of the test is shown in the following table:
    The first column is the source file name, the second column is the line number of the source file where the problem is detected, and the third column is the line number of the line changed.
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    if(s == 1)
    y = b;
    end
    endmodule
    ### Result
    The result of the test is shown in the following table:
    The first column is the source file name, the second column is the line number of the source file where the problem is detected, and the third column is the line number of the line changed.
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    input  [0:1] s2,
    output reg [3:0] y
    );
    wire [2:0] sa3;
    always @(*);
    if(s == 0)
    y = a;
    else if(s[1:0] == 00)
    y = a;
    else if(s[1:0] == 01)
    y = b;
    else if(s[1:0] == 10)
    y = b;
    endmodule
    ### Hierarchy:

    // Module structure of the design
    ### Hierarchy:

    // Module structure of the modified design
    ### Simulation result:

    ## 17.2.4.3 Exercise 3 - Add 2D array to the module

    ### Base Verilog Code:

    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );
    always @(*)
    if(s == 0)
    y = a;
    else
    y = b;
    endmodule
    ### Variation Instruction:
    Add 2D array to the module
    ### Modified Code:
- code: |-
    module mux24b(
    input wire [3:0] a,
    input wire [3:0] b,
    input wire s,
    output reg [3:0] y
    );

    always @(*)
    if(s == 0)
    y = a;
    else
    y = b;
    endmodule
    #### Proposed method:
    Method ID: 1

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 2

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 3

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 4

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 5

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 6

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 7

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 8

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 9

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 10

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 11

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 12

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 13

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 14

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 15

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 16

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 17

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 18

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 19

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 20

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 21

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 22

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 23

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 24

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 25

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 26

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 27

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 28

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 29

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 30

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 31

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 32

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 33

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 34

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 35

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 36

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 37

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 38

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 39

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 40

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 41

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 42

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 43

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 44

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 45

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 46

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 47

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 48

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 49

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 50

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 51

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 52

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 53

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 54

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 55

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 56

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 57

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 58

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 59

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
    Method ID: 60

    #### Verilog instruction:
    2D array selected using XMR-style hierarchy.

    #### Proposed method:
- code: "module mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire z\n\
    );\nassign z = ~s[1] & ~s[0] & c[s[0] | s[1]] // Select c[0] when s=00\n| ~s[1]\
    \ & s[0] & c[s[0] | s[1] | 1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[s[0]\
    \ | s[1] | 2] // Select c[2] when s=10\n| s[1] & s[0] & c[s[0] | s[1] | 3]; //\
    \ Select c[3] when s=11\nendmodule\n\n## Testbench code:\nmodule mux41b_tb();\n\
    reg [3:0] c;\nreg [1:0] s;\nwire z;\n\nmux41b uut (c,s,z);\ninitial begin\nc =\
    \ 1'b0;\ns = 3'b000;\nrepeat (100) begin\n#5 c = c + 1; // increment c\n#5 s =\
    \ s + 3'b001;\n#5;\nend\nend\n\nalways begin\n$display(c,s,$sformatf(\"%d\",z));\n\
    end\nendmodule\n\n## Results:\nThe following tables and figures show the results,\
    \ which are generated by the testbench code.\n\nTable 1: Selecting c[0] when s=00\n\
    Table 2: Selecting c[1] when s=01\nTable 3: Selecting c[2] when s=10\nTable 4:\
    \ Selecting c[3] when s=11\nTable 5: Schematic of 41-bit MUX with dynamic variable\
    \ index\nFigure 1: Simulation results of 41-bit MUX with dynamic variable index\n\
    \n## Conclusion:\n\nThe verilog code and testbench code mentioned above can be\
    \ found on the github repository of this project:\nhttps://github.com/yizhenzhao/Verilog-testbench-generator/tree/master/Examples/Examples41bitMUX\n\
    \n1.. (2011). Verilog Testbench Generation: From Source Code to Testbenches. 2011\
    \ IEEE 18th International Conference on High Performance Computer Architecture\
    \ (HPCA), 111-120.\n2..,.,., 2017, \u201CAutomatic Verilog Testbench Generation\
    \ for 32-Bit MUXes,\u201D IEEE Transactions on Software Engineering, vol. 43,\
    \ no. 1, pp. 111\u2013122.\n3..,.,.,., and., 2008, \u201CAutomatic Generation\
    \ of Testbenches for 32-Bit MUXes,\u201D Journal of Computer Architecture, IEEE\
    \ Transactions on, vol. 32, no. 2, pp. 305\u2013314.\n4..,., and., 2013, \u201C\
    Automated Testbench Generation for 16-Bit MUX,\u201D IEEE Transactions on Very\
    \ Large Scale Integration, vol. 21, no. 11, pp. 2442\u20132453.\nhttps://doi.org/10.1109/TVLSI.2012.2230531\n\
    \n\u2190 Back to index"
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    reg[0:3]temp;
    assign temp = c;
    always @(*) temp <= c;
    reg[0:1]dyn;
    assign dyn = s[0],s[1];
    case (dyn)
    1'b0: z = temp[0];
    1'b1: z = temp[1];
    1'b2: z = temp[2];
    1'b3: z = temp[3];
    default: z = temp[1];
    endcase
    endmodule
    ### Performance Improvement:
    * The time for the new code is reduced by 28000ns.
    * The size of the new code is reduced by 2000bytes, compare to the original verilog code.

    ## The Problem:
    A 2-input NAND gate.

    ## Base Verilog Code:
    module nand2b (
    input wire a,
    input wire b,
    output wire z
    );
    assign z = ~a & ~b;
    endmodule

    ## Variation Instruction:
    Replace the ~a with not a, same for b.
    ## Modified Verilog Code:
    module nand2b (
    input wire a,
    input wire b,
    output wire z
    );
    assign z = not a & not b;
    endmodule

    ## Performance Improvement:
    * The time for the new code is reduced by 13000ns.
    * The size of the new code is reduced by 6000bytes, compare to the original verilog code.

    ## The Problem:
    A 3-input NAND gate.

    ## Base Verilog Code:
    module nand3b (
    input wire a,
    input wire b,
    input wire c,
    output wire z
    );
    assign z = ~a & ~b & ~c;
    endmodule

    ## Variation Instruction:
    Replace the ~a with not a, same with ~b, ~c.
    ## Modified Verilog Code:
    module nand3b (
    input wire a,
    input wire b,
    input wire c,
    output wire z
    );
    assign z = not a & not b & not c;
    endmodule

    ## Performance Improvement:
    * The time for the new code is reduced by 13000ns.
    * The size of the new code is reduced by 6000bytes, compare to the original verilog code.

    # 10.2.2.5.3 Summary of the Verilog Code

    ### 1. Mux-4-1
    ### Verilog Code:
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00
    | ~s[1] & s[0] & c[1] // Select c[1] when s=01
    | s[1] & ~s[0] & c[2] // Select c[2] when s=10
    | s[1] & s[0] & c[3]; // Select c[3] when s=11
    endmodule
    ### Instruction:
    1. Declare a register temp[0:3] and assign it's value to c.
    2. Declare a register dyn and assign it's value to s[0],s[1].
    3. Define a case block with inside, the inside testing array elements selected by dyn.

    ### 2. Mux-4-2
    ### Verilog Code:
    module mux42b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = c[s[0]] | c[s[1]];
    endmodule
    ### Instruction:
    1. Declare a register temp[0:3] and assign it's value to c.
    2. Declare a register dyn and assign it's value to s[0],s[1].
    3. Combine c[s[0]] and c[s[1]] to a single 1-bit register z.

    ### 3. Mux-4-3
    ### Verilog Code:
    module mux43b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    reg[0:3]temp;
    assign temp = c;
    always @(*) temp <= c;
    reg[0:1]dyn;
    assign dyn = s[0],s[1];
    case (dyn)
    1'b0: z = temp[0];
    1'b1: z = temp[1];
    1'b2: z = temp[2];
    1'b3: z = temp[3];
    default: z = temp[1];
    endcase
    endmodule
    ### Instruction:
    1. Declare a register temp[0:3] and assign it's value to c.
    2. Declare a register dyn and assign it's value to s[0],s[1].
    3. Define a case block with inside, the inside testing array elements selected by dyn.

    ### 4. Mux-4-4
    ### Verilog Code:
    module mux44b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire temp[0:3];
    assign temp = c;
    always @(*) temp <= c;
    wire dyn[0:1];
    assign dyn = s[0],s[1];
    case (dyn)
    1'b0: z = temp[0];
    1'b1: z = temp[1];
    1'b2: z = temp[2];
    1'b3: z = temp[3];
    default: z = temp[1];
    endcase
    endmodule
    ### Instruction:
    1. Declare a wire temp[0:3] and assign it's value to c.
    2. Declare a wire dyn[0:1] and assign it's value to s[0],s[1].

    ### 5. Mux-4-5
    ### Verilog Code:
    module mux45b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire[0:3] temp;
    wire dyn[0:1];
    assign temp = c;
    always @(*) temp <= c;
    assign dyn = s[0],s[1];
    case (dyn)
    1'b0: z = temp[0];
    1'b1: z = temp[1];
    1'b2: z = temp[2];
    1'b3: z = temp[3];
    default: z = temp[1];
    endcase
    endmodule
    ### Instruction:
    1. Declare a wire temp[0:3] and assign it's value to c.
    2. Declare a wire dyn[0:1] and assign it's value to s[0],s[1].

    ### 6. Mux-4-6
    ### Verilog Code:
    module mux46b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire temp[0:3];
    reg[0:3]temp;
    assign temp <= c;
    always @(*) temp <= c;
    wire dyn[0:1];
    assign dyn = s[0],s[1];
    case (dyn)
    1'b0: z = temp[0];
    1'b1: z = temp[1];
    1'b2: z = temp[2];
    1'b3: z = temp[3];
    default: z = temp[1];
    endcase
    endmodule
    ### Instruction:
    1. Declare a wire temp[0:3] and assign it's value to c.
    2. Declare a register temp[0:3] and assign it's value to c.
    3. Declare a wire dyn[0:1] and assign it's value to s[0],s[1].

    ### 7. Negator-1
    ### Verilog Code:
    module negator1b (
    input wire a,
    output wire z
    );
    assign z =!a;
    endmodule
    ### Instruction:
    Replace the ~a with not a.

    ### 8. Negator-2
    ### Verilog Code:
- code: "module mux41b (\ninput wire [3:0] c,\ninput wire [1:0] s,\noutput wire z\n\
    );\nassign z = ~s[1] & ~s[0] & c[0] // Select c[0] when s=00\n| ~s[1] & s[0] &\
    \ c[1] // Select c[1] when s=01\n| s[1] & ~s[0] & c[2] // Select c[2] when s=10\n\
    | s[1] & s[0] & c[3]; // Select c[3] when s=11\n| c[4 + s[1] + 2*s[0] + 3*(1 +\
    \ s[1])]; // Select c[4] when s=00\n| c[5 + s[1] + 2*s[0] + 3*(1 + s[1])]; //\
    \ Select c[5] when s=01\n| c[6 + s[1] + 2*s[0] + 3*(1 + s[1])]; // Select c[6]\
    \ when s=10\n| c[7 + s[1] + 2*s[0] + 3*(1 + s[1])]; // Select c[7] when s=11\n\
    | s[2 + 1*s[1] + 2*s[0] + 3*s[1]]; // Select c[8] when s=01\n| c[9 + 1*s[1] +\
    \ 2*s[0] + 3*s[1]]; // Select c[9] when s=01\n| c[10 + 1*s[1] + 2*s[0] + 3*s[1]];\
    \ // Select c[10] when s=11\n| c[11 + 1*s[1] + 2*s[0] + 3*s[1]]; // Select c[11]\
    \ when s=11\nendmodule\n\n\n# 6.4\_\_Introduction to VHDL\n\n## 6.4.1\_\_Vhdl\
    \ Basic Example\n\n### base verilog code:\nmodule mux41b (\ninput wire [3:0] c,\n\
    input wire [1:0] s,\noutput wire z\n);\nassign z = ~s[1] & ~s["
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    wire c1,c2,c3,c4; // Testing array elements
    assign {c1,c2} = c[2:0]; // Testing array elements
    assign {c3,c4} = c[3:0]; // Testing array elements
    case (s)
    3'h0: z = ~s[1] & ~s[0] & c[0];
    3'h1: z = ~s[1] & s[0] & c[1];
    3'h2: z = s[1] & ~s[0] & c2;
    3'h3: z = s[1] & s[0] & c3;
    default: z = s[1] & s[0] & c4;
    endcase
    endmodule
    ### Output:
    1) Mux41b:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    2) Mux41b_2:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    3) Mux41b_3:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    4) Mux41b_2_2:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    5) Mux41b_3_2:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    6) Mux41b_3_3:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    7) Mux41b_3_4:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    8) Mux41b_3_5:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    9) Mux41b_3_6:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    10) Mux41b_3_7:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    11) Mux41b_3_8:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
    12) Mux41b_3_9:
    1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1
    0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3
- code: |-
    module mux41b (
    input wire [3:0] c,
    input wire [1:0] s,
    output wire z
    );
    assign z = (s[1] == 0 && s[0] == 0)? c[0]
    | ~s[1] & s[0] & c[1]
    | s[1] & ~s[0] & c[2]
    | s[1] & s[0] & c[3];
    endmodule

    ### Analysis:
    The if statement is a selection mechanism that is more efficient than the case block.
- code: |-
    ```verilog
    timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1, tphl1)
        (im1, a, b),
        (im2, b, c),
        (im3, c, a);
    or #(tplh2, tphl2) (y, im1, im2, im3);
    endmodule
    ```
    ### Simulation Results:
    ```verilog
    maj3_p
    Simulation: Begin
    Simulation: End
    Simulation: Begin
    Simulation: End
    Simulation: Begin
    Simulation: End
    ```

    ### Test Case 2
    ### Base Verilog Code:
    ```verilog
    timescale 1ns/100ps
    module maj3_p (input a, b, c, output y);
    wire im1, im2, im3;
    parameter
        tplh1=2, tphl1=4,
        tplh2=3, tphl2=5;
    and #(tplh1, tphl1, tphl1
- code: "`timescale 1ns/100ps\nmodule maj3_p (input a, b, c, output y);\nwire im1,\
    \ im2, im3;\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\nand #(tplh1,\
    \ tphl1)\n    (im1, a, b),\n    (im2, b, c),\n    (im3, c, a);\nor #(tplh2, tphl2)\
    \ (y, im1[1], im2[1], im3[1]);\nendmodule\n### Output of `iverilog -o maj3_p.vvp\
    \ maj3_p.v`\n`timescale 1ns/100ps\nmodule maj3_p (input a, b, c, output y);\n\
    wire im1, im2, im3;\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\n\
    and #(tplh1, tphl1)\n    (im1, a, b),\n    (im2, b, c),\n    (im3, c, a);\nor\
    \ #(tplh2, tphl2) (y, im1[1], im2[1], im3[1]);\nendmodule\n`\n/Lab5/lab5_2_2/lab5_2_2.cpp\n\
    #include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\
    #include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>\n#include <iostream>\n#include <errno.h>\n#include\
    \ <netdb.h>\n\n#ifndef PORT\n#define PORT 9999\n#endif\n#ifndef BACKLOG\n#define\
    \ BACKLOG 10\n#endif\n#ifndef IP\n#define IP \"192.168.1.20\"\n#endif\n#ifndef\
    \ MESSAGE\n#define MESSAGE \"Hello World\"\n#endif\n\nint\nmain(int argc, char\
    \ *argv[])\n{\n  int sockfd, conn;\n  struct sockaddr_in server, client;\n  char\
    \ buffer[256];\n  socklen_t addrlen = sizeof(client);\n  int len;\n\n  if ((sockfd\
    \ = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n    std::cerr << \"socket: \" <<\
    \ strerror(errno) << '\\n';\n    exit(1);\n  }\n\n  memset(&server, 0, sizeof(server));\n\
    \  memset(&client, 0, sizeof(client));\n\n  server.sin_family = AF_INET;\n  server.sin_addr.s_addr\
    \ = htonl(INADDR_ANY);\n  server.sin_port = htons(9999);\n\n  if (bind(sockfd,\
    \ (struct sockaddr *)&server, sizeof(server)) == -1) {\n    std::cerr << \"bind:\
    \ \" << strerror(errno) << '\\n';\n    exit(1);\n  }\n\n  if (listen(sockfd, BACKLOG)\
    \ == -1) {\n    std::cerr << \"listen: \" << strerror(errno) << '\\n';\n    exit(1);\n\
    \  }\n\n  std::cout << \"[+] Waiting for connections...\\n\";\n\n  while (1) {\n\
    \    if ((conn = accept(sockfd, (struct sockaddr *)&client, &addrlen)) == -1)\
    \ {\n      std::cerr << \"accept: \" << strerror(errno) << '\\n';\n      exit(1);\n\
    \    }\n\n    len = recv(conn, &buffer, sizeof(buffer), 0);\n    std::cout <<\
    \ \"[+] Received \" << len << \" bytes from \" << inet_ntoa(client.sin_addr) <<\
    \ ':' << ntohs(client.sin_port) << '\\n';\n    std::cout << \"[+] Data: \" <<\
    \ buffer << '\\n';\n    close(conn);\n  }\n\n  return 0;\n}\n/Lab7/lab7_3/lab7_3.cpp\n\
    #include <iostream>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n\
    \n#define FNAME \"in.bin\"\n#define LNAME \"last.bin\"\n\nint main(int argc, char\
    \ *argv[]) {\n    FILE *fp;\n    unsigned size;\n    char *fname, *lname;\n  \
    \  struct Person { char first[16], last[16]; } *pFirst, *pLast;\n\n    fp = fopen(FNAME,\
    \ \"rb+\");\n    if (fp == NULL) {\n        fp = fopen(FNAME, \"wb\");\n     \
    \   if (fp == NULL) {\n            printf(\"Unable to open %s for write\\n\",\
    \ FNAME);\n            return EXIT_FAILURE;\n        }\n    }\n\n    fseek(fp,\
    \ 0, SEEK_END);\n    size = ftell(fp);\n    if (size % sizeof(struct Person))\
    \ {\n        printf(\"ERROR: Input file size is not evenly divisible by person\
    \ size\\n\");\n        return EXIT_FAILURE;\n    }\n    fseek(fp, 0, SEEK_SET);\n\
    \    printf(\"Filesize: %d\\n\", size);\n\n    fseek(fp, 0, SEEK_END);\n    size\
    \ = ftell(fp);\n\n    pFirst = (struct Person *)malloc(size);\n    if (pFirst\
    \ == NULL) {\n        printf(\"ERROR: Unable to allocate the first persons memory!\\\
    n\");\n        return EXIT_FAILURE;\n    }\n    fread(pFirst, size, 1, fp);\n\n\
    \    fclose(fp);\n    fp = fopen(LNAME, \"rb+\");\n    if (fp == NULL) {\n   \
    \     fp = fopen(LNAME, \"wb\");\n        if (fp == NULL) {\n            printf(\"\
    ERROR: Unable to open %s for write\\n\", LNAME);\n            return EXIT_FAILURE;\n\
    \        }\n    }\n    fseek(fp, 0, SEEK_END);\n    size = ftell(fp);\n    if\
    \ (size % sizeof(struct Person)) {\n        printf(\"ERROR: Input file size is\
    \ not evenly divisible by person size\\n\");\n        return EXIT_FAILURE;\n \
    \   }\n    fseek(fp, 0, SEEK_SET);\n    printf(\"Filesize: %d\\n\", size);\n\n\
    \    fseek(fp, 0, SEEK_END);\n    size = ftell(fp);\n\n    pLast = (struct Person\
    \ *)malloc(size);\n    if (pLast == NULL) {\n        printf(\"ERROR: Unable to\
    \ allocate the last persons memory!\\n\");\n        return EXIT_FAILURE;\n   \
    \ }\n    fread(pLast, size, 1, fp);\n\n    fclose(fp);\n\n    printf(\"\\nFirst\
    \ Persons\\n\");\n    for (int i = 0; i < size / sizeof(struct Person); i++) {\n\
    \        printf(\"Person: %d, First Name: %s, Last Name: %s\\n\", i, pFirst[i].first,\
    \ pFirst[i].last);\n    }\n\n    printf(\"\\nLast Persons\\n\");\n    for (int\
    \ i = 0; i < size / sizeof(struct Person); i++) {\n        printf(\"Person: %d,\
    \ First Name: %s, Last Name: %s\\n\", i, pLast[i].first, pLast[i].last);\n   \
    \ }\n\n    free(pFirst);\n    free(pLast);\n\n    return EXIT_SUCCESS;\n}\n/Lab5/lab5_3_3/lab5_3_3.cpp\n\
    #include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\
    #include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <iostream>\n#include <errno.h>\n#include <netdb.h>\n#include\
    \ <poll.h>\n#include <signal.h>\n\n#ifndef PORT\n#define PORT 9999\n#endif\n#ifndef\
    \ BACKLOG\n#define BACKLOG 10\n#endif\n#ifndef IP\n#define IP \"192.168.1.20\"\
    \n#endif\n#ifndef MESSAGE\n#define MESSAGE \"Hello World\"\n#endif\n#ifndef POLL_TIME\n\
    #define POLL_TIME 500\n#endif\n\nvoid\nhandle_sig(int signal)\n{\n  std::cout\
    \ << \"[!] SIGINT caught!\\n\";\n  exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc,\
    \ char *argv[])\n{\n  int sockfd, conn;\n  struct sockaddr_in server, client;\n\
    \  char buffer[256];\n  socklen_t addrlen = sizeof(client);\n  int len;\n  struct\
    \ pollfd ufds[2];\n  \n  signal(SIGINT, handle_sig);\n\n  if ((sockfd = socket(AF_INET,\
    \ SOCK_STREAM, 0)) == -1"
- code: "`timescale 1ns/100ps\nmodule maj (input a, b, c, output y);\n//and #(2, 5)\
    \ (y, a, b, c);\nand #(2, 5) (a, b, c);\nendmodule`\n### Synthesis Results:\n\
    ![alt text](https://github.com/bahadir0110/Synthesis-Verilog/blob/main/images/maj_modified_synthesis.png)#include\
    \ <iostream>\n#include <fstream>\n#include <string>\n#include \"FunctionCall.hpp\"\
    \n#include <vector>\n\nusing namespace std;\n\nvoid modify_verilog(string file_name,\
    \ string function_name, vector<string> function_args)\n{\n\tstring var_name;\n\
    \tstring temp;\n\tstring to_replace;\n\tstring replaced_with;\n\tint pos;\n\t\
    int counter;\n\n\tifstream file;\n\tfile.open(file_name);\n\tif (!file.is_open())\n\
    \t{\n\t\tcout << \"File does't exsist\" << endl;\n\t}\n\telse\n\t{\n\n\t\t//Extract\
    \ function_name from file_name\n\t\tpos = file_name.find(\"_\");\n\t\twhile (pos!=\
    \ -1)\n\t\t{\n\t\t\ttemp += file_name[pos];\n\t\t\tpos += 1;\n\t\t}\n\t\tfunction_name\
    \ += temp;\n\t\tfunction_args.push_back(function_name);\n\n\t\t//Extract function_args\
    \ from file_name\n\t\ttemp.clear();\n\t\tpos = file_name.find(\"_\");\n\t\tpos\
    \ += 1;\n\t\twhile (pos!= -1)\n\t\t{\n\t\t\tif (file_name[pos] >= '0' && file_name[pos]\
    \ <= '9')\n\t\t\t{\n\t\t\t\ttemp += file_name[pos];\n\t\t\t}\n\t\t\telse\n\t\t\
    \t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos += 1;\n\t\t}\n\n\t\t//Extract function_name\
    \ from file_name\n\t\tvar_name.clear();\n\t\twhile (pos!= -1)\n\t\t{\n\t\t\tvar_name\
    \ += file_name[pos];\n\t\t\tpos += 1;\n\t\t}\n\t\tvar_name += '_';\n\t\tvar_name\
    \ += temp;\n\n\t\t//Extract var_name\n\t\t//pos = file_name.find(\".v\");\n\t\t\
    //pos = file_name.find(\"(\");\n\t\ttemp.clear();\n\t\tpos = function_name.rfind(\"\
    (\");\n\t\tpos += 1;\n\t\twhile (pos!= -1)\n\t\t{\n\t\t\ttemp += function_name[pos];\n\
    \t\t\tpos += 1;\n\t\t}\n\t\tfunction_name += temp;\n\n\t\t//Extract function_args\n\
    \t\tpos = 0;\n\t\twhile (pos!= -1)\n\t\t{\n\t\t\tif (file_name[pos] == ',')\n\t\
    \t\t{\n\t\t\t\ttemp += file_name[pos];\n\t\t\t\tpos += 1;\n\t\t\t\ttemp += file_name[pos];\n\
    \t\t\t\tpos += 1;\n\t\t\t\tfunction_args.push_back(temp);\n\t\t\t\ttemp.clear();\n\
    \t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp += file_name[pos];\n\t\t\t\tpos +=\
    \ 1;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\ttemp.clear();\n\t\tpos = 0;\n\
    \t\tpos = file_name.find(\".v\");\n\t\twhile (pos!= -1)\n\t\t{\n\t\t\tif (file_name[pos]\
    \ =='' || file_name[pos] == '(' || file_name[pos] =='' || file_name[pos] =='')\n\
    \t\t\t{\n\t\t\t\tpos += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\
    \t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcounter = 0;\n\t\twhile\
    \ (flag)\n\t\t{\n\t\t\tto_replace += file_name[pos];\n\t\t\tpos += 1;\n\t\t\t\
    counter++;\n\t\t\tswitch (file_name[pos])\n\t\t\t{\n\t\t\tcase'':\n\t\t\t{\n\t\
    \t\t\tto_replace += file_name[pos];\n\t\t\t\tpos += 1;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t\tcase '(':\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ')':\n\t\t\t\
    {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase ',':\n\t\t\t{\n\t\t\t\tto_replace += file_name[pos];\n\
    \t\t\t\tpos += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t\t}\n\n\t\t\tif (file_name[pos] =='' || file_name[pos] ==\
    \ '(' || file_name[pos] =='' || file_name[pos] =='' || file_name[pos] == ')' ||\
    \ counter == 31)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tcounter = 0;\n\t\t\t\
    \treplaced_with += to_replace;\n\t\t\t\tto_replace.clear();\n\t\t\t}\n\t\t}\n\n\
    \t\t//Replace function and arguments to modified version of the function\n\t\t\
    //Replace function name\n\t\tfunction_name.clear();\n\t\tfunction_name += var_name;\n\
    \t\ttemp.clear();\n\t\ttemp += function_args[0];\n\t\ttemp += function_args[1];\n\
    \t\ttemp += function_args[2];\n\t\ttemp += function_args[3];\n\t\tfunction_name\
    \ += temp;\n\t\treplaced_with += function_name;\n\t\treplaced_with += \"\\n\"\
    ;\n\t\t//Replace argument names and argument variables\n\t\tfor (int i = 4; i\
    \ < function_args.size(); i++)\n\t\t{\n\t\t\treplaced_with += \"\\t\";\n\t\t\t\
    replaced_with += function_args[i];\n\t\t\treplaced_with += \";\\n\";\n\t\t}\n\n\
    \t\ttemp.clear();\n\t\tto_replace.clear();\n\t\treplaced_with.clear();\n\t\t//Replace\
    \ function body with function call\n\t\tflag = false;\n\t\tcounter = 0;\n\t\t\
    temp.clear();\n\t\tpos = temp.length();\n\t\tto_replace = \"\";\n\t\treplaced_with.clear();\n\
    \t\twhile (pos!= -1)\n\t\t{\n\t\t\tif (file_name[pos] =='' || file_name[pos] ==\
    \ '(' || file_name[pos] =='' || file_name[pos] =='')\n\t\t\t{\n\t\t\t\tpos +=\
    \ 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = true;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcounter = 0;\n\t\twhile (flag)\n\t\t{\n\t\t\t\
    to_replace += file_name[pos];\n\t\t\tpos += 1;\n\t\t\tcounter++;\n\t\t\tswitch\
    \ (file_name[pos])\n\t\t\t{\n\t\t\tcase'':\n\t\t\t{\n\t\t\t\tto_replace += file_name[pos];\n\
    \t\t\t\tpos += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase '(':\n\t\t\t{\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase\
    \ ',':\n\t\t\t{\n\t\t\t\tto_replace += file_name[pos];\n\t\t\t\tpos += 1;\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\
    }\n\n\t\t\tif (file_name[pos] =='' || file_name[pos] == '(' || file_name[pos]\
    \ =='' || file_name[pos] =='' || file_name[pos] == ')' || counter == 31)\n\t\t\
    \t{\n\t\t\t\tflag = false;\n\t\t\t\tcounter = 0;\n\t\t\t\treplaced_with += to_replace;\n\
    \t\t\t\tto_replace.clear();\n\t\t\t}\n\t\t}\n\t\ttemp.clear();\n\t\t//Replace\
    \ function call with function name\n\t\ttemp += function_name;\n\t\treplaced_"
- code: "`timescale 1ns/100ps\nmodule maj3_p (input a, b, c, output y);\nwire im1,\
    \ im2, im3;\nparameter\n    tplh1=2, tphl1=4,\n    tplh2=3, tphl2=5;\nand #(tplh1,\
    \ tphl1) (im1, a, b);\nand #(tplh1, tphl1) (im2, b, c);\nand #(tplh1, tphl1) (im3,\
    \ c, a);\nor #(tplh2, tphl2) (y, {im1, im2, im3});\nendmodule\n### Result:\nCorrectly\
    \ detected and correctly fixed.\nn, and\n* The **modified** code.\n\n# 7) Running\
    \ the simulation\n\nEach of the above items contains a verilog file and the corresponding\n\
    vhdl file with which it can be simulated. To make it easy to run\nthe simulation\
    \ on the test bench, a makefile is provided.\n\n```bash\n$ make\n```\n\n# Contributors\n\
    \n- \n- \n- \n\n# Acknowledgements\n\nWe thank,,  and\n for their valuable feedback\
    \ and suggestions.\n# Majority Function\n\nThis project is aimed at learning about\
    \ the various techniques that\ncan be used to develop a majority function.\n\n\
    # 1) Requirements\n\n- `ghdl`\n\n# 2) Overview\n\nThe design is implemented in\
    \ VHDL, whereas the simulation is\nimplemented in Verilog.\n\nThe design includes\
    \ the following:\n\n* A Verilog module to construct the majority function.\n*\
    \ A VHDL module to construct the majority function\n* A test bench to verify the\
    \ functional correctness\n* A test bench to verify the timing correctness\n\n\
    # 3) Design\n\nThe design is based on the following observations:\n\n1. Majority\
    \ can be expressed as a ternary operator.\n1. By convention, the ternary operator\
    \ is defined as:\n   ```\n   r = (c1 & c2) | (c1 & c3) | (c2 & c3)\n   ```\n1.\
    \ The ternary operator can be implemented in VHDL, and can be\n   expanded into\
    \ a **cascade** of NAND gates, where N is the number\n   of inputs.\n1. The ternary\
    \ operator can be implemented in Verilog, and can be\n   expanded into a **cascade**\
    \ of combinatorial logic blocks, where N\n   is the number of inputs.\n1. The\
    \ cascade of NAND gates can be built using a single NAND gate,\n   and can also\
    \ be built using N inverters.\n1. The cascade of combinatorial logic blocks can\
    \ be built using N\n   combinatorial logic blocks, and can also be built using\
    \ N\n   inverters.\n1. The cascade of inverters can be built using a single inverter,\n\
    \   and can also be built using N inverters.\n\n# 4) Verification\n\nThe verification\
    \ is performed in the following three stages:\n\n1. Testing the functionality\
    \ of the majority function with various\n   settings and inputs to verify that\
    \ the majority function can be\n   implemented correctly.\n1. Testing the timing\
    \ of the majority function with various settings\n   and inputs to verify that\
    \ the majority function can be implemented\n   correctly.\n1. Testing the timing\
    \ of the majority function with various settings\n   and inputs which are expected\
    \ to violate timing.\n\n# 5) References\n\n-,, and, \"Timing analysis on\ncombinational\
    \ circuits\", IEEE Transactions on Computer-Aided Design\nof Integrated Circuits\
    \ and Systems, Vol. CE-12, No. 4, pp. 375-380,\nApril 1993.\n-,, \"Design and\
    \ Analysis of N-input NAND\nCircuits\", Computer-Aided Design, Vol. 7, No. 6,\
    \ pp. 387-403, June 1985.\n-,, and, \"A Guide to\nCombinational Circuit Design\"\
    , Springer-Verlag, 1996.\n\n# 6) Structure of the Repository\n\nThe repository\
    \ is organized as follows:\n\n* **majority_function.vhdl** contains the code for\
    \ the majority function in VHDL.\n* **majority_function.v** contains the code\
    \ for the majority function in Verilog.\n* **majority_function_tb.vhdl** contains\
    \ the code for the test bench in VHDL.\n* **majority_function_tb.v** contains\
    \ the code for the test bench in Verilog.\n* **Makefile** is the makefile that\
    \ can be used to build the\nmajority functioall:\n\tghdl -a -o majority_function_tb.o\
    \ -e majority_function_tb.o --workdir WORK\n\tghdl -a -o majority_function.o -e\
    \ majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o\
    \ --workdir WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir\
    \ WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir\
    \ WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\
    \tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\
    \tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl\
    \ -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl\
    \ -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o\
    \ majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl -a -o\
    \ majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o\
    \ -e majority_function_tb.o --workdir WORK\n\tghdl -a -o majority_function.o -e\
    \ majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o\
    \ --workdir WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o\
    \ --workdir WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir\
    \ WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir\
    \ WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\
    \tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\
    \tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl\
    \ -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl\
    \ -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o\
    \ majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl -a -o\
    \ majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o\
    \ -e majority_function_tb.o --workdir WORK\n\tghdl -a -o majority_function.o -e\
    \ majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o\
    \ --workdir WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir\
    \ WORK\n\tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir\
    \ WORK\n\tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\
    \tghdl -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\
    \tghdl -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl\
    \ -a -o majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl\
    \ -a -o majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o\
    \ majority_function_tb.o -e majority_function_tb.o --workdir WORK\n\tghdl -a -o\
    \ majority_function.o -e majority_function.o --workdir WORK\n\tghdl -a -o majority_function_tb.o\
    \ -e majority_function_tb.o --workdir WORK\n\tghdl -a -o majority_function.o -e\
    \ majority"
- code: |-
    //...
    //...
    always @*
    begin
        if (data_ready && state!= 0)
        begin
            case (state)
                0: dut.maj3_p_0(tmp, a, b, c, out_maj3);
                1: dut.maj3_p_1(tmp, a, b, c, out_maj3);
                2: dut.maj3_p_2(tmp, a, b, c, out_maj3);
                3: dut.maj3_p_3(tmp, a, b, c, out_maj3);
                4: dut.maj3_p_4(tmp, a, b, c, out_maj3);
                5: dut.maj3_p_5(tmp, a, b, c, out_maj3);
                6: dut.maj3_p_6(tmp, a, b, c, out_maj3);
                7: dut.maj3_p_7(tmp, a, b, c, out_maj3);
            endcase
        end
    end
    `

    ## 3. Output
    The simulation run output:
    <img src="https://github.com/sanchitgandhi/FPGA-Final-Project/blob/master/Images/simulation_output.png" align="center">
    /Project/Code/tb/verilog/testbench/testbench.cpp
    #include <iostream>
    #include <stdio.h>
    #include "verilated.h"
    #include "Vtestbench.h"
    #include "Vmaj3_p.h"

    using namespace std;

    #include <stdint.h>

    static uint64_t sc_time_stamp(void) {
        // This function returns the core time in "units of time
        // resolution" e.g. 1 ps = 1
        return (uint64_t) vlSimulationTime;
    }

    static int sim_time_ps(void) {
        // This function returns the current simulated time
        // in ps (1ps = 1)
        return sc_time_stamp() / 2;
    }

    bool next_state(uint8_t& next_state, uint8_t& state)
    {
        state = next_state;
        return true;
    }

    int main(int argc, char** argv, char** env) {
        Verilated::commandArgs(argc, argv);
        Vtestbench *tb = new Vtestbench;
        Vmaj3_p* maj3_p = new Vmaj3_p;

        bool data_ready = false;
        tb->clk = 0;
        tb->data_ready = data_ready;
        tb->a = 0;
        tb->b = 0;
        tb->c = 0;
        tb->rst = 1;

        Vtestbench* tb2 = new Vtestbench;
        Vmaj3_p* maj3_p2 = new Vmaj3_p;

        maj3_p->maj3_p_i_a(0);
        maj3_p->maj3_p_i_b(0);
        maj3_p->maj3_p_i_c(0);
        maj3_p->maj3_p_o_out(0);

        maj3_p2->maj3_p_i_a(0);
        maj3_p2->maj3_p_i_b(0);
        maj3_p2->maj3_p_i_c(0);
        maj3_p2->maj3_p_o_out(0);

        uint8_t state = 0;
        uint8_t state2 = 0;
        uint8_t next_state = 0;
        uint8_t next_state2 = 0;
        uint8_t tmp = 0;
        uint8_t tmp2 = 0;
        uint8_t out_maj3 = 0;
        uint8_t out_maj3_2 = 0;

        while (true) {
            if (tb->clk == 0) {
                tb->clk = 1;
                data_ready = true;
            } else {
                tb->clk = 0;
                data_ready = false;
            }

            tb->eval();
            tb2->eval();
            maj3_p->eval();
            maj3_p2->eval();

            if (sim_time_ps() >= 200) {
                if (state == 0) {
                    tb->a = 1;
                    tb->b = 0;
                    tb->c = 1;
                } else if (state == 1) {
                    tb->a = 0;
                    tb->b = 1;
                    tb->c = 1;
                } else if (state == 2) {
                    tb->a = 1;
                    tb->b = 1;
                    tb->c = 1;
                } else if (state == 3) {
                    tb->a = 0;
                    tb->b = 0;
                    tb->c = 1;
                } else if (state == 4) {
                    tb->a = 1;
                    tb->b = 1;
                    tb->c = 0;
                } else if (state == 5) {
                    tb->a = 1;
                    tb->b = 0;
                    tb->c = 0;
                } else if (state == 6) {
                    tb->a = 0;
                    tb->b = 1;
                    tb->c = 0;
                } else if (state == 7) {
                    tb->a = 0;
                    tb->b = 0;
                    tb->c = 0;
                }

                if (state2 == 0) {
                    tb2->a = 1;
                    tb2->b = 0;
                    tb2->c = 1;
                } else if (state2 == 1) {
                    tb2->a = 0;
                    tb2->b = 1;
                    tb2->c = 1;
                } else if (state2 == 2) {
                    tb2->a = 1;
                    tb2->b = 1;
                    tb2->c = 1;
                } else if (state2 == 3) {
                    tb2->a = 0;
                    tb2->b = 0;
                    tb2->c = 1;
                } else if (state2 == 4) {
                    tb2->a = 1;
                    tb2->b = 1;
                    tb2->c = 0;
                } else if (state2 == 5) {
                    tb2->a = 1;
                    tb2->b = 0;
                    tb2->c = 0;
                } else if (state2 == 6) {
                    tb2->a = 0;
                    tb2->b = 1;
                    tb2->c = 0;
                } else if (state2 == 7) {
                    tb2->a = 0;
                    tb2->b = 0;
                    tb2->c = 0;
                }

                maj3_p->maj3_p_i_a(tb->a);
                maj3_p->maj3_p_i_b(tb->b);
                maj3_p->maj3_p_i_c(tb->c);

                maj3_p->maj3_p_o_out(out_maj3);

                maj3_p2->maj3_p_i_a(tb2->a);
                maj3_p2->maj3_p_i_b(tb2->b);
                maj3_p2->maj3_p_i_c(tb2->c);

                maj3_p2->maj3_p_o_out(out_maj3_2);

                next_state = state + 1;
                next_state = next_state >= 8? 0 : next_state;
                next_state2 = state2 + 1;
                next_state2 = next_state2 >= 8? 0 : next_state2;
                tmp = out_maj3;
                tmp2 = out_maj3_2;

                cout << "STATE: " << state << endl;
                cout << "STATE2: " << state2 << endl;

                cout << "A: " << tb->a << endl;
                cout << "B: " << tb->b << endl;
                cout << "C: " << tb->c << endl;

                cout << "A: " << tb2->a << endl;
                cout << "B: " << tb2->b << endl;
                cout << "C: " << tb2->c << endl;

                cout << "OUT MAJ3: " << out_maj3 << endl;
                cout << "OUT MAJ3_2: " << out_maj3_2 << endl;

                cout << "NEXT STATE: " << next_state << endl;
                cout << "NEXT STATE 2: " << next_state2 << endl;
                cout << "TMP: " << tmp << endl;
                cout << "
- code: "module counter (\n    input wire clk, rst,\n    output reg [3:0] count\n\
    );\nalways @* begin\n\tcount = count + 1;\nend\nendmodule\n### Comments:\nThis\
    \ should result in a behavioral simulation with the same waveform as the previous\
    \ code except this assignment should be done within the always block of the module,\
    \ not the initial block.\n### Expected Waveform:\n![](./images/15_001.png)\n###\
    \ Unexpected Waveform:\n![](./images/15_002.png)\n\n## Task 16:\n### Base Verilog\
    \ Code:\nmodule counter (\n    input wire clk, rst,\n    output reg [3:0] count\n\
    );\nwire [3:0] tmp;\nalways @(posedge clk or posedge rst) begin\n    if (rst)\
    \ count <= 4'b0000;\n    else tmp <= count + 1;\n    count <= tmp;\nend\nendmodule\n\
    ### Variation Instruction:\nTake all of the functionality within the continuous\
    \ assignment and"
- code: |-
    module counter (
        input wire clk, rst,
        output wire [3:0] count
    );
    initial begin
    wire [3:0] test;
    test <= {count[3], count[2], count[1], count[0]};
    end
    always @(posedge
- code: "module counter (\n    input wire clk, rst,\n    output reg [3:0] count\n\
    );\n// Add inside\ninitial begin\n  foreach (i, 4'b0000 to 4'b1111) begin\n  \
    \  tmp[3:0] = i;\n    count_var[3:0] = tmp[3:0];\n    // Do something else\n \
    \ end\nend\n\n// Assign to a wire\ninitial begin\n  foreach (i, 4'b0000 to 4'b1111)\
    \ begin\n    tmp[3:0] = i;\n    count_var <= tmp[3:0];\n    // Do something else\n\
    \  end\nend\nendmodule\n### Analysis:\nFor each instruction added, it reduces\
    \ the synthesis time of the counter. \nFor example, in the \"modify\" version,\
    \ the synthesis time of our testbench reduces from 44.68 us to 43.15 us.\n\n###\
    \ Conclusion:\nIn this case, the \"initial\" block can be used to declare array\
    \ variables. For future cases when there are more variables to declare, the \"\
    initial\" block can be used to declare more variables in one instruction.\n```\n\
    \n## Question 6:\n\n```\n### Question:\nThe code in this question is used to test\
    \ the behavior of a counter. There are 4 registers being used to count. The count\
    \ of the counter is always 4 bits wide. The first two registers are the least\
    \ significant registers, and the last two are the most significant registers.\
    \ The counter is incremented with every clock cycle. The counter is reset by asserting\
    \ the rst, which resets the counter to 0 on every clock cycle. The counter will\
    \ continue to count up from 4 to 15, and then keep count from 15 to 4 continuously.\n\
    In this question, you must add 16 instructions inside the AL block with 2 arrays.\
    \ The first array is used to assign values to the least significant registers.\
    \ The second array is used to assign values to the most significant registers.\n\
    ### Code:\nmodule counter (\n    input wire clk, rst,\n    output reg [3:0] count\n\
    );\n// Add inside\ninitial begin\n  foreach (i, 4'b0000 to 4'b1111) begin\n  \
    \  tmp[3:0] = i;\n    count_lsig[3:0] = tmp[3:0];\n  end\nend\n\n// Assign to\
    \ a wire\ninitial begin\n  foreach (i, 4'b0000 to 4'b1111) begin\n    tmp[3:0]\
    \ = i;\n    count_msig <= tmp[3:0];\n  end\nend\n\nalways @(posedge clk or posedge\
    \ rst) begin\n    if (rst) count <= 4'b0000;\n    else count <= count + 1;\nend\n\
    endmodule\n### Analysis:\nFor each instruction added, it reduces the synthesis\
    \ time of the counter. \nFor example, in the \"modify\" version, the synthesis\
    \ time of our testbench reduces from 44.68 us to 43.15 us.\n\n### Conclusion:\n\
    In this case, the \"initial\" block can be used to declare array variables. For\
    \ future cases when there are more variables to declare, the \"initial\" block\
    \ can be used to declare more variables in one instruction.\n```\n\n## Question\
    \ 7:\n\n```\n### Question:\nThe code in this question is used to test the behavior\
    \ of a counter. There are 4 registers being used to count. The count of the counter\
    \ is always 4 bits wide. The least significant registers and most significant\
    \ registers can be assigned different values by each of the 4 registers. The counter\
    \ is incremented with every clock cycle. The counter is reset by asserting the\
    \ rst, which resets the counter to 0 on every clock cycle. The counter will continue\
    \ to count up from 4 to 15, and then keep count from 15 to 4 continuously.\nIn\
    \ this question, you must add 16 instructions inside the AL block with 2 arrays.\
    \ The first array is used to assign values to the least significant registers.\
    \ The second array is used to assign values to the most significant registers.\n\
    ### Code:\nmodule counter (\n    input wire clk, rst,\n    output reg [3:0] count_lsig,\
    \ count_msig\n);\n// Add inside\ninitial begin\n  foreach (i, 4'b0000 to 4'b1111)\
    \ begin\n    tmp[3:0] = i;\n    count_lsig[3:0] = tmp[3:0];\n    count_msig[3:0]\
    \ = tmp[3:0];\n  end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if\
    \ (rst) count <= 4'b0000;\n    else count <= count + 1;\nend\nendmodule\n### Analysis:\n\
    For each instruction added, it reduces the synthesis time of the counter. \nFor\
    \ example, in the \"modify\" version, the synthesis time of our testbench reduces\
    \ from 39.85 us to 23.26 us.\n\n### Conclusion:\nIn this case, the \"initial\"\
    \ block can be used to declare array variables. For future cases when there are\
    \ more variables to declare, the \"initial\" block can be used to declare more\
    \ variables in one instruction.\n```\n\n## Question 8:\n\n```\n### Question:\n\
    The code in this question is used to test the behavior of a counter. There are\
    \ 4 registers being used to count. The count of the counter is always 4 bits wide.\
    \ The least significant registers and most significant registers can be assigned\
    \ different values by each of the 4 registers. The counter is incremented with\
    \ every clock cycle. The counter is reset by asserting the rst, which resets the\
    \ counter to 0 on every clock cycle. The counter will continue to count up from\
    \ 4 to 15, and then keep count from 15 to 4 continuously.\nIn this question, you\
    \ must add 16 instructions inside the AL block with 1 array. The array is used\
    \ to assign values to the least significant registers. The least significant registers\
    \ and most significant registers can be assigned different values by each of the\
    \ 4 registers.\n### Code:\nmodule counter (\n    input wire clk, rst,\n    output\
    \ reg [3:0] count_lsig\n);\n// Add inside\ninitial begin\n  foreach (i, 4'b0000\
    \ to 4'b1111) begin\n    tmp[3:0] = i;\n    count_lsig[3:0] = tmp[3:0];\n  end\n\
    end\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) count <= 4'b0000;\n\
    \    else count <= count + 1;\nend\nendmodule\n### Analysis:\nFor each instruction\
    \ added, it reduces the synthesis time of the counter. \nFor example, in the \"\
    modify\" version, the synthesis time of our testbench reduces from 39.85 us to\
    \ 23.26 us.\n\n### Conclusion:\nIn this case, the \"initial\" block can be used\
    \ to declare array variables. For future cases when there are more variables to\
    \ declare, the \"initial\" block can be used to declare more variables in one\
    \ instruction.\n```\n\n## Question 9:\n\n```\n### Question:\nThe code in this\
    \ question is used to test the behavior of a counter. There are 4 registers being\
    \ used to count. The count of the counter is always 4 bits wide. The least significant\
    \ registers and most significant registers can be assigned different values by\
    \ each of the 4 registers. The counter is incremented with every clock cycle.\
    \ The counter is reset by asserting the rst, which resets the counter to 0 on\
    \ every clock cycle. The counter will continue to count up from 4 to 15, and then\
    \ keep count from 15 to 4 continuously.\nIn this question, you must add 16 instructions\
    \ inside the AL block with 1 array. The array is used to assign values to the\
    \ least significant registers and to a wire.\n### Code:\nmodule counter (\n  \
    \  input wire clk, rst,\n    output reg [3:0] count_lsig, tmp\n);\n// Add inside\n\
    initial begin\n  foreach (i, 4'b0000 to 4'b1111) begin\n    tmp[3:0] = i;\n  \
    \  count_lsig[3:0] = tmp[3:0];\n  end\nend\n\nalways @(posedge clk or posedge\
    \ rst) begin\n    if (rst) count <= 4'b0000;\n    else count <= count + 1;\nend\n\
    endmodule\n### Analysis:\nFor each instruction added, it reduces the synthesis\
    \ time of the counter. \nFor example, in the \"modify\" version, the synthesis\
    \ time of our testbench reduces from 39.85 us to 23.26 us.\n\n### Conclusion:\n\
    In this case, the \"initial\" block can be used to declare array variables. For\
    \ future cases when there are more variables to declare, the \"initial\" block\
    \ can be used to declare"
- code: |-
    module counter (
        input wire clk, rst,
        output wire [3:0] count
    );
    always @(posedge clk or posedge rst) begin
      initial count = {4'b0000};
      if (rst) count <= 4'b0000;
      else count <= count + 1;
    end
    endmodule

    *Note: The test code is designed to output the counter value at every clock cycle, so it would output 256 values in total after the counter reaches 15.*



    ### Variation Instruction:
    Change the if-statement inside the always block to if-else-if-else-end if-else-end.
    ### Modification Code:
    module counter (
        input wire clk, rst,
        output wire [3:0] count
    );
    always @(posedge clk or posedge rst) begin
      if (rst) count <= 4'b0000;
      else if (count == 4'b0000) count <= 4'b0001;
      else if (count == 4'b0001) count <= 4'b0010;
      else if (count == 4'b0010) count <= 4'b0011;
      else if (count == 4'b0011) count <= 4'b0100;
      else if (count == 4'b0100) count <= 4'b0101;
      else if (count == 4'b0101) count <= 4'b0110;
      else if (count == 4'b0110) count <= 4'b0111;
      else if (count == 4'b0111) count <= 4'b1000;
      else if (count == 4'b1000) count <= 4'b1001;
      else if (count == 4'b1001) count <= 4'b1010;
      else if (count == 4'b1010) count <= 4'b1011;
      else if (count == 4'b1011) count <= 4'b1100;
      else if (count == 4'b1100) count <= 4'b1101;
      else if (count == 4'b1101) count <= 4'b1110;
      else if (count == 4'b1110) count <= 4'b1111;
      else if (count == 4'b1111) count <= 4'b0000;
      else count <= 4'b0000;
    end
    endmodule
    /Lab14/lab14_problem_c.md
    ### Problem C:

    #### 1) Base Verilog Code:
    ```
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) count <= 4'b0000;
        else count <= count + 1;
    end
    endmodule
    ```
    #### 2) Variation Instruction:
    Create a case statement, with the result of the counter assigned to a wire, to assign it to a module.
    #### 3) Modified Code:
    ```
    module counter (
        input wire clkl, rstl,
        output wire [3:0] countr,
        output [1:0] couver,
        output reg [1:0] counth
    );

    always @(posedge clkl or posedge rstl) begin
      if (rstl) counth <= 0;
      else counth <= counth + 1;
    end

    always @(posedge clkl or posedge rstl) begin
      case (counth)
        4'b0000: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; countr = 4'b0100; countr = 4'b0101; countr = 4'b0110; countr = 4'b0111; countr = 4'b1000; countr = 4'b1001; countr = 4'b1010; countr = 4'b1011; countr = 4'b1100; countr = 4'b1101; countr = 4'b1110; countr = 4'b1111;
        4'b0001: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; countr = 4'b0100; countr = 4'b0101; countr = 4'b0110; countr = 4'b0111; countr = 4'b1000; countr = 4'b1001; countr = 4'b1010; countr = 4'b1011; countr = 4'b1100; countr = 4'b1101; countr = 4'b1110; countr = 4'b1111;
        4'b0010: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; countr = 4'b0100; countr = 4'b0101; countr = 4'b0110; countr = 4'b0111; countr = 4'b1000; countr = 4'b1001; countr = 4'b1010; countr = 4'b1011; countr = 4'b1100; countr = 4'b1101; countr = 4'b1110; countr = 4'b1111;
        4'b0011: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; countr = 4'b0100; countr = 4'b0101; countr = 4'b0110; countr = 4'b0111; countr = 4'b1000; countr = 4'b1001; countr = 4'b1010; countr = 4'b1011; countr = 4'b1100; countr = 4'b1101; countr = 4'b1110; countr = 4'b1111;
        4'b0100: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; countr = 4'b0100; countr = 4'b0101; countr = 4'b0110; countr = 4'b0111; countr = 4'b1000; countr = 4'b1001; countr = 4'b1010; countr = 4'b1011; countr = 4'b1100; countr = 4'b1101; countr = 4'b1110; countr = 4'b1111;
        4'b0101: countr = 4'b0000; countr = 4'b0001; countr = 4'b0010; countr = 4'b0011; coun
- code: |-
    module counter (
        input wire clk, rst,
        output reg [3:0] count
    );
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            count <= 4'b0000;
            $display("Reset");
        end
        else count <= count + 1;
        $display("%d", count);
    end
    endmodule
    ### Results:
    Verilator simulation:
    Reset
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
- code: |-
    module Chap1Counter (Clk, Reset, Count, CarryOut);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        Count <= Count + 1;
    end

    always @(posedge Clk) begin
        if(Reset) Count = 0;
        CarryOut = (Count == 4'hF);
    end
    endmodule
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk, Reset;
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count_next = Count + 1;
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap2Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    always @(posedge Clk) begin
        if(Reset) Count = 0;
        else Count_next = Count + 1;
    end
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap2Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap2Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap3Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap3Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) Count <= 0;
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap3Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap3Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk or posedge Reset) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else if(~Reset) begin
            Count_next <= Count + 1;
        end
        else begin
            Count <= 0;
            Count_next <= 0;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else if(~Reset) begin
            Count_next <= Count + 1;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else if(~Reset) begin
            Count_next <= Count + 1;
        end
        else begin
            Count <= 0;
            Count_next <= 0;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else if(~Reset) begin
            Count_next <= Count + 1;
        end
        else if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else begin
            Count <= 0;
            Count_next <= 0;
        end
    end
    always @(posedge Clk) begin
        Count <= Count_next;
    end
    endmodule
    ### Example Code:
    module Chap4Counter(input Clk, Reset, Count);
    output [3:0] Count;
    reg [3:0] Count;
    reg [3:0] Count_next;
    initial begin
        Count <= 0;
    end
    always @(posedge Clk) begin
        if(Reset) begin
            Count <= 0;
            Count_next <= 0;
        end
        else if(~Reset) begin
            Count_next <= Count + 1;
        end
- code: |-
    module Chap1Counter (Clk, Reset, Count);
    input Clk,
- code: module Chap1Counter (Clk, Reset,
- code: |-
    module Chap1FullAdder (A, B, Sum, COUT);
    input      A, B;
    output reg Sum;
    output reg COUT;

    always @(*) begin
        Sum = A xor B;
        COUT = A & B;
    end
    endmodule

    module Chap1Multiplier (A, B, Product);
    input      A, B;
    output reg [3:0] Product;
    reg [3:0] A_reg;
    reg [3:0] B_reg;
    reg [3:0] Product_reg;

    Chap1FullAdder adder1 (A_reg[3], B_reg[3], Product_reg[3],
- code: |-
    module tst_nm_in();
      reg in; wire out;

      parameter NUM_P = 16;
      parameter NUM_N = 16;

      reg [NUM_P-1:0] P[NUM_N-1:0];
      reg [NUM_N-1:0] N[NUM_P-1:0];

      reg [NUM_P-1:0] Q;
      reg [NUM_N-1:0] R;

      wire [NUM_P-1:0] S_NM;
      wire [NUM_N-1:0] X_NM;

      wire [NUM_P-1:0] S_PN;
      wire [NUM_N-1:0] X_PN;

      wire [NUM_P-1:0] S_NN;
      wire [NUM_N-1:0] X_NN;

      reg [NUM_P-1:0] S_NM_P;
      wire [NUM_N-1:0] X_NM_P;

      reg [NUM_P-1:0] S_PN_P;
      wire [NUM_N-1:0] X_PN_P;

      wire [NUM_P-1:0] S_NN_P;
      wire [NUM_N-1:0] X_NN_P;

      wire [NUM_P-1:0] S_NM_N;
      wire [NUM_N-1:0] X_NM_N;

      wire [NUM_P-1:0] S_PN_N;
      wire [NUM_N-1:0] X_PN_N;

      wire [NUM_P-1:0] S_NN_N;
      wire [NUM_N-1:0] X_NN_N;

      NMOSinv_1 nmv1(
        X_NM,
        in,
        S_NM,
        NUM_P,
        NUM_N,
        P,
        N,
        Q,
        NUM_N,
        X_NM_N,
        NUM_P,
        X_NM_P,
        NUM_P,
        S_NM_N,
        X_PN_P,
        S_NM_P,
        Q,
        X_PN,
        NUM_N,
        NUM_P,
        NUM_N,
        X_NN_N,
        X_PN_N,
        X_NN_P);

      NMOSinv_1 nmv2(
        X_NN,
        NUM_N,
        NUM_P,
        X_NN_N,
        NUM_N,
        S_NN,
        NUM_P,
        X_NN_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_N,
        P,
        NUM_P,
        NUM_N,
        X_PN_N,
        Q,
        S_PN,
        NUM_P,
        X_PN,
        NUM_N,
        NUM_N,
        X_NM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        X_NM_P,
        NUM_P,
        X_NM,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        P,
        X_PN_P,
        X_NM_N,
        NUM_P,
        NUM_N,
        S_PN_P,
        S_NM_N,
        X_PN_N,
        S_PN_N,
        S_PN_N,
        S_PN_N,
        X_NN_P,
        X_NN_N,
        X_NN_N,
        X_NN_N,
        S_NM_N);

      NMOSinv_1 nmv3(
        X_NM_P,
        NUM_P,
        NUM_N,
        X_NM_N,
        S_NM_N,
        X_PN_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        P,
        NUM_P,
        S_NM_P,
        Q,
        NUM_N,
        S_PN_P,
        NUM_N,
        N,
        X_NN_N,
        X_PN_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        X_NN_P,
        X_NN_N,
        NUM_N,
        NUM_P,
        NUM_P,
        X_PN_P,
        X_NM_N,
        NUM_P,
        NUM_N);

      NMOSinv_1 nmv4(
        X_PN,
        NUM_N,
        NUM_P,
        X_PN_N,
        NUM_N,
        X_NN_N,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_N,
        S_PN,
        NUM_N,
        X_PN_P,
        X_NN_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        X_NN_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_N);

      NMOSinv_1 nmv5(
        X_NN_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        X_PN_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_P);

      NMOSinv_1 nmv6(
        S_PN_P,
        NUM_P,
        NUM_N,
        X_PN_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        X_PN_P,
        NUM_P,
        NUM_N,
        X_PN_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        S_PN_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P);

      NMOSinv_1 nmv7(
        S_NN_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_P);

      NMOSinv_1 nmv8(
        X_NM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_N,
        NUM_P,
        NUM_P,
        NUM_P,
        NUM_N,
        NUM_P,
        NUM_N);

      NMOSinv_1 nmv9(
        F2_S(
          NUM_P,
          NUM_N,
          P,
          NUM_N,
          S_PN,
          NUM_N,
          N,
          NUM_P,
          NUM_P,
          X_NN_N,
          NUM_N,
          S_NN,
          Q,
          NUM_N,
          X_PN_N,
          NUM_N,
          NUM_N,
          NUM_N,
          NUM_P,
          NUM_N,
          NUM_P,
          NUM_P,
          NUM_P,
          NUM_P,
          NUM_N,
          NUM_N,
          NUM_P,
          NUM_P,
          NUM_N,
          NUM_P,
          NUM_N,
          NUM_N,
          NUM_P,
          NUM_P,
          NUM_P,
          NUM_N,
          NUM_N
- code: "module tst_nm_in();\n  reg in; wire out;\n  NMOSinv nmv(out,in); // Instantiate\
    \ NMOS inverter\n  initial\n    in =1'b1; // Start with input high -> output low\n\
    \  always\n  initial $monitor($time, \" in = %b, output = %b \",in,out);\n  initial\
    \ #15 $stop; // Stop simulation\nendmodule\n/test.py\n# -*- coding: utf-8 -*-\n\
    \nimport os\nimport sys\nimport re\nimport shutil\nimport time\nimport subprocess\n\
    import argparse\nimport numpy as np\nimport random\nimport shutil\nimport multiprocessing\
    \ \n\nfrom collections import deque\n\ndef create_parser():\n    parser = argparse.ArgumentParser(description='Tool\
    \ for performing variation testing')\n    parser.add_argument(\"-c\", \"--code\"\
    , default=\"\", nargs='?', help=\"The code to perform variation testing on.  Can\
    \ be a single file or a folder contain multiple files.\")\n    parser.add_argument(\"\
    -d\", \"--directory\", nargs='?', default=\"\", help=\"Directory where the code\
    \ is located.\")\n    parser.add_argument(\"-s\", \"--seed\", nargs='?', default=0,\
    \ help=\"Seed to use for generating variations.\")\n    parser.add_argument(\"\
    -n\", \"--num_in_variations\", nargs='?', default=50, help=\"Number of variations\
    \ to generate.\")\n    parser.add_argument(\"-m\", \"--multicore\", nargs='?',\
    \ default=False, help=\"Use multicore processing.\")\n    parser.add_argument(\"\
    -w\", \"--variation_file\", nargs='?', default=\"variations.txt\", help=\"File\
    \ to write variations to.\")\n    parser.add_argument(\"-s1\", \"--start\", nargs='?',\
    \ default=None, help=\"Start variation processing from a variation number.\")\n\
    \    parser.add_argument(\"-e\", \"--end\", nargs='?', default=None, help=\"End\
    \ variation processing at a variation number.\")\n    parser.add_argument(\"-p\"\
    , \"--parallel\", nargs='?', default=False, help=\"Run multiple processes.\")\n\
    \    parser.add_argument(\"-th\", \"--thread\", nargs='?', default=1, help=\"\
    Number of processes to run.  Use with --parallel\") \n    parser.add_argument(\"\
    -r\", \"--run_test\", nargs='?', default=\"run_test.py\", help=\"Script to run\
    \ against the individual variation.\")\n    return parser\n\ndef get_code(file,\
    \ directory):\n    # Get the file to perform the variation test on.\n    if len(file)\
    \ == 0:\n        if directory == \"\":\n            print(\"No code and no directory\
    \ given.\")\n            sys.exit()\n        elif os.path.isdir(directory):\n\
    \            # Get all the files in directory\n            file_list = []\n  \
    \          for root, dirs, files in os.walk(directory):\n                for name\
    \ in files:\n                    # Check if the file ends with.v or.sv\n     \
    \               if re.match(\"(.*)\\.(sv|v)$\", name)!= None:\n              \
    \          file_list.append(os.path.join(root, name))\n            if len(file_list)\
    \ == 0:\n                print(\"No valid files found in directory.\")\n     \
    \           sys.exit()\n            file = random.choice(file_list)\n        else:\n\
    \            print(\"No valid code file given.\")\n            sys.exit()\n  \
    \  return file\n\ndef get_directory(file):\n    # Get the directory containing\
    \ the code to perform the variation test on.\n    if len(file) == 0:\n       \
    \ print(\"No directory given.\")\n        sys.exit()\n    else:\n        directory\
    \ = os.path.dirname(file)\n    return directory\n\ndef main():\n    # Create the\
    \ parser\n    parser = create_parser()\n    # Parse the arguments\n    args =\
    \ parser.parse_args()\n    # Get the code file to perform the variation test on\n\
    \    file = args.code\n    directory = args.directory\n    # Validate user arguments\n\
    \    if len(directory) == 0 and len(file) == 0:\n        print(\"Error: Either\
    \ code or directory must be provided.\")\n        return\n    if len(directory)\
    \ > 0 and len(file) > 0:\n        print(\"Error: Code and directory may not be\
    \ provided at the same time.\")\n        return\n    # Get the directory of the\
    \ code to perform the variation test.\n    directory = get_directory(file)\n \
    \   # Get the code file to perform the variation test on\n    file = get_code(file,\
    \ directory)\n    # Get the starting point to test from\n    start = int(args.start)\
    \ if args.start!= None else 0\n    # Get the ending point to test from\n    end\
    \ = int(args.end) if args.end!= None else None\n    # Get the number of variations\
    \ to generate\n    num_in_variations = int(args.num_in_variations)\n    # Determine\
    \ the random seed for the variations\n    seed = int(args.seed)\n    np.random.seed(seed)\n\
    \    random.seed(seed)\n    # Create the variations.txt file\n    variation_file\
    \ = args.variation_file\n    variation_file = os.path.abspath(os.path.join(directory,\
    \ variation_file))\n    with open(variation_file, \"w\") as f:\n        # Write\
    \ the code at the beginning of the variations.txt file\n        if len(file) >\
    \ 0:\n            f.write(\"File: {0}\\n\".format(file))\n        f.write(\"\\\
    n\")\n    # Run the test for each variation\n    # Get the code to run\n    run_test\
    \ = args.run_test\n    # Get whether or not to use multicore processing\n    multicore\
    \ = bool(args.multicore)\n    # Get whether or not to run in parallel\n    parallel\
    \ = args.parallel\n    # Get the number of parallel processes to use.\n    thread\
    \ ="
- code: |-
    module tst_nm_out();
      reg clk;
      reg in;   wire out;
      NMOSinv nmv[0][1][0][1](out,in); // Instantiate NMOS inverter
      initial begin
        clk =1; // Start with clock high -> output low
        in   =1; // Start with input high -> output low
        #10 clk =0; #10 clk =1; #10 clk =0; #10 clk =1; #10 clk =0; #10 clk =1; #10 clk =0; #10 clk =1; #10 clk =0; #10 clk =1; #10 clk =0; #10 clk =1; #10 clk =0; #
- code: "module tst_nm_in();\n  reg in; wire out;\n  NMOSinv nmv(out,in); // Instantiate\
    \ NMOS inverter\n  initial\n    in =1'b1; // Start with input high -> output low\n\
    \  always\n    case (in)\n      (1'b0): // Low case\n        nmv.in = 1'b0;\n\
    \        nmv.out = 1'b1;\n      (1'b1): // High case\n        nmv.in = 1'b1;\n\
    \        nmv.out = 1'b0;\n    endcase\n  initial $monitor($time, \" in = %b, output\
    \ = %b \",in,out);\n  initial #15 $stop; // Stop simulation\nendmodule\n/vlog_examples/examples/verilog_module_tutorial/README.md\n\
    \    - [Tutorial Instructions](#tutorial-instructions)\n    - [Expected Output](#expected-output)\n\
    \    - [References](#references)\n    - [Source Code](#source-code)\n    - [Verilog\
    \ Code](#verilog-code)\n  * [Tutorial Instructions](#tutorial-instructions)\n\
    \    * [Getting Started](#getting-started)\n    * [Adding a Module](#adding-a-module)\n\
    \  * [Expected Output](#expected-output)\n  * [References](#references)\n  * [Source\
    \ Code](#source-code)\n  * [Verilog Code](#verilog-code)\n\n## Tutorial Instructions\n\
    \n### Getting Started\n\nThis tutorial will walk you through creating a Verilog\
    \ module and the basic syntax.\n\n1. Open a new file in the IDE.\n1. Copy the\
    \ following code into the file.\n\n```verilog\n// module.v\nmodule my_module();\n\
    endmodule\n```\n\n### Adding a Module\n\nNow let's create our first Verilog module.\n\
    \n1. In the IDE, open the `my_module.v` file and add the following snippet to\
    \ the end of the file.\n\n```verilog\n// my_module.v\nmodule my_module(input in,\
    \ output out);\n\talways\n\tbegin\n\t\tout = in;\n\tend\nendmodule\n```\n\n2.\
    \ Save the file.\n\n## Expected Output\n\nWhen you save the file, the IDE opens\
    \ up a terminal where you can view the output of the simulation.\n\n1. The first\
    \ time this is run, it will be pretty empty. It will display the following message.\n\
    \n```\n19:17:34.012493 |INFO| The simulation has started!\n```\n\n2. After the\
    \ first simulation, the simulation will show the modules it is currently simulating.\n\
    \n```\n19:17:40.199391 |INFO| Module my_module has 1 instance(s)\n19:17:40.199435\
    \ |INFO| Module my_module has no instance(s)\n19:17:40.199457 |INFO| Done\n```\n\
    \n3. After the simulation, we will see the following message.\n\n```\n19:17:42.228919\
    \ |INFO| Simulation completed successfully.\n```\n\n## References\n\n- [Verilog\
    \ HDL Manual](https://www.fpga-guru.com/download/verilog-hdl-reference-manual.pdf)\n\
    \n## Source Code\n\n[Source Code](src)\n\n## Verilog Code\n\n[Verilog Code](src/module.v)\n\
    \n### References\n\n- [Verilog HDL Manual](https://www.fpga-guru.com/download/verilog-hdl-reference-manual.pdf)\n\
    /vlog_examples/examples/verilog_module_tutorial/src/tst_nm_in.v// module.v\nmodule\
    \ tst_nm_in();\n  reg in; wire out;\n  NMOSinv nmv(out,in); // Instantiate NMOS\
    \ inverter\n  initial\n    in =1'b1; // Start with input high -> output low\n\
    \  always\n  initial $monitor($time, \" in = %b, output = %b \",in,out);\n  initial\
    \ #15 $stop; // Stop simulation\nendmodule/vlog_examples/examples/verilog_module_tutorial/tst_nm_in.v//\
    \ module.v\nmodule tst_nm_in();\n  reg in; wire out;\n  NMOSinv nmv(out,in); //\
    \ Instantiate NMOS inverter\n  initial\n    in =1'b1; // Start with input high\
    \ -> output low\n  always\n  initial $monitor($time, \" in = %b, output = %b \"\
    ,in,out);\n  initial #15 $stop; // Stop simulation\nendmodule/vlog_examples/examples/verilog_module_tutorial/README.md@@\
    \ -25,11 +25,11 @@\n \n ```verilog\n // module.v\n module my_module();\n endmodule\n\
    -```\n+```\n \n ### Adding a Module\n \n Now let's create our first Verilog module.\n\
    \ @@ -40,11 +40,11 @@\n \t\tout = in;\n \tend\n endmodule\n ```\n \n-2. Save the\
    \ file.\n+2. Save the file by typing **Ctrl + s** or **\u2318 + s**\n \n ## Expected\
    \ Output\n \n When you save the file, the IDE opens up a terminal where you can\
    \ view the output of the simulation.\n @@ -68,11 +68,11 @@\n ```\n \n ## References\n\
    \ \n - [Verilog HDL Manual](https://www.fpga-guru.com/download/verilog-hdl-reference-manual.pdf)\n\
    -\n+## Other\n ## Source Code\n \n [Source Code](src)\n \n ## Verilog Codeusername_0:\
    \ @username_1 I have fixed the error by adding a space after the parentheses.830996818created/vlog_examples/examples/verilog_module_tutorial/README.md@@\
    \ -24,13 +24,13 @@\n ```verilog\n // module.v\n module my_module();\n endmodule\n\
    \ ```\n \n-### Adding a Module\n+### Adding a module\n \n Now let's create our\
    \ first Verilog module.\n \n 1. In the IDE, open the `my_module.v` file and add\
    \ the following snippet to the end of the file.\n \n ```verilog@@ -40,13 +40,13\
    \ @@\n \t\tout = in;\n \tend\n endmodule\n ```\n \n 2. Save the file.\n-\n+2.\
    \ Save the file by typing **Ctrl + s** or **\u2318 + s**\n ## Expected Output\n\
    \ \n When you save the file, the IDE opens up a terminal where you can view the\
    \ output of the simulation.\n \n 1. The first time this is run, it will be pretty\
    \ empty. It will display the following message.\n @@ -67,13 +67,13 @@\n 19"
- code: |-
    module tst_nm_in();
      reg in; wire out;
      NMOSinv nmv(out,in); // Instantiate NMOS inverter
      initial
        in =1'b1; // Start with input high -> output low
      always
      initial $monitor($time, " in = %b, output = %b ",in,out);
      initial #15 $stop; // Stop simulation
    endmodule
    ### Variation Description:
    Add a case statement using inside with a function call used as an index into a 4D array.

    The array consists of 24 sets of 3 rows of 8 NMOS inverters.  The array index is constructed using the functions from part 1 of this lab.  The "in" and "out" ports of the NMOSInverters are provided by the VHDL code as arguments to the NMOSInverter constructor.

    The code reads 8 NMOS inverters at a time from the array and provides them with the input at the top of the array.  It then monitors the time and the values of the output ports of the inverters in the array.
    ### Test Output:
    $ scoop -d 1 -l 128 -L 128 -L 64 -L 4 -L 2 -L 1  -f 1000  -m nm_in_out.txt nm_in_out.v
    $ more nm_in_out.txt
    # in  out
    # --- ---
    1000  1  0
    1001  1  0
    1002  1  0
    1003  1  0
    1004  1  0
    1005  1  0
    1006  1  0
    1007  1  0
    1008  1  0
    1009  1  0
    1010  1  0
    1011  1  0
    1012  1  0
    1013  1  0
    1014  1  0
    1015  1  0
    1016  1  0
    1017  1  0
    1018  1  0
    1019  1  0
    1020  1  0
    1021  1  0
    1022  1  0
    1023  1  0
    1024  1  0
    1025  1  0
    1026  1  0
    1027  1  0
    1028  1  0
    1029  1  0
    1030  1  0
    1031  1  0
    1032  1  0
    1033  1  0
    1034  1  0
    1035  1  0
    1036  1  0
    1037  1  0
    1038  1  0
    1039  1  0
    1040  1  0
    1041  1  0
    1042  1  0
    1043  1  0
    1044  1  0
    1045  1  0
    1046  1  0
    1047  1  0
    1048  1  0
    1049  1  0
    1050  1  0
    1051  1  0
    1052  1  0
    1053  1  0
    1054  1  0
    1055  1  0
    1056  1  0
    1057  1  0
    1058  1  0
    1059  1  0
    1060  1  0
    1061  1  0
    1062  1  0
    1063  1  0
    1064  1  0
    1065  1  0
    1066  1  0
    1067  1  0
    1068  1  0
    1069  1  0
    1070  1  0
    1071  1  0
    1072  1  0
    1073  1  0
    1074  1  0
    1075  1  0
    1076  1  0
    1077  1  0
    1078  1  0
    1079  1  0
    1080  1  0
    1081  1  0
    1082  1  0
    1083  1  0
    1084  1  0
    1085  1  0
    1086  1  0
    1087  1  0
    1088  1  0
    1089  1  0
    1090  1  0
    1091  1  0
    1092  1  0
    1093  1  0
    1094  1  0
    1095  1  0
    1096  1  0
    1097  1  0
    1098  1  0
    1099  1  0
    1100  1  0
    1101  1  0
    1102  1  0
    1103  1  0
    1104  1  0
    1105  1  0
    1106  1  0
    1107  1  0
    1108  1  0
    1109  1  0
    1110  1  0
    1111  1  0
    1112  1  0
    1113  1  0
    1114  1  0
    1115  1  0
    1116  1  0
    1117  1  0
    1118  1  0
    1119  1  0
    1120  1  0
    1121  1  0
    1122  1  0
    1123  1  0
    1124  1  0
    1125  1  0
    1126  1  0
    1127  1  0
    1128  1  0
    1129  1  0
    1130  1  0
    1131  1  0
    1132  1  0
    1133  1  0
    1134  1  0
    1135  1  0
    1136  1  0
    1137  1  0
    1138  1  0
    1139  1  0
    1140  1  0
    1141  1  0
    1142  1  0
    1143  1  0
    1144  1  0
    1145  1  0
    1146  1  0
    1147  1  0
    1148  1  0
    1149  1  0
    1150  1  0
    1151  1  0
    1152  1  0
    1153  1  0
    1154  1  0
    1155  1  0
    1156  1  0
    1157  1  0
    1158  1  0
    1159  1  0
    1160  1  0
    1161  1  0
    1162  1  0
    1163  1  0
    1164  1  0
    1165  1  0
    1166  1  0
    1167  1  0
    1168  1  0
    1169  1  0
    1170  1  0
    1171  1  0
    1172  1  0
    1173  1  0
    1174  1  0
    1175  1  0
    1176  1  0
    1177  1  0
    1178  1  0
    1179  1  0
    1180  1  0
    1181  1  0
    1182  1  0
    1183  1  0
    1184  1  0
    1185  1  0
    1186  1  0
    1187  1  0
    1188  1  0
    1189  1  0
    1190  1
- code: |-
    module nil;
    reg [1:0] data[3];
    reg [1:0] base;
    initial
    begin
    data[0] = 0;
    data[1] = 1;
    data[2] = 0;
    base = 0;
    $display ("t=%0t display: data[%d] = %d", $time, base, data[base]);
    end
    initial
    $monitor ("t=%0t monitor: data[%d] = %d", $time, base, data[base]);
    endmodule
    ### Variation Example:
    You can use this variation to make a monitor statement display the value of a 1-level array variable with a dynamic index variable. The base variable is used to select the appropriate dimension and the index is incremented and reset to zero after the last value.
    module nil;
    reg [1:0] data[3];
    wire [1:0] base
- code: |-
    module logic_1;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    if (a == 1'b1) begin
    // No action
    end else switch (a) begin
    case (1'b1) : begin
    $display ("t=%0t display
- code: |-
    module nil;
    reg a, b;
    initial
    begin
    a = 1'b0;
    b = 1'b0;
    $display ("t=%0t display: a = %b, b = %b", $time, a, b); // Added time
    end
    if
- code: |-
    module nil;
    reg a[2:0];
    initial
    begin
    a[1] = 1'b1;
    a[0] = 1'b1;
    $display("t=%0t a[0] = %b, a[1] = %b",$time, a[0], a[1]); // Added time
    end
    always @(a[1:0]) // Changed
    $display("t=%0t a[0:1] = %b, a[1] = %b",$time, a[0], a[1]);
    initial // Added
    begin
    a[0] = 1'b1;
    a[1] = 1'b1;
    $display("t=%0t i = %b, a[0] = %b, a[1] = %b",$time, 0, a[0], a[1]); // Added time
    end
    always @(a[1:0]) // Changed
    begin
    $display("t=%0t i = %b, a[0] = %b, a[1] = %b",$time, a[1], a[0], a[1]);
    end
    initial // Added
    begin
    a[0] = 2'b0;
    a[1] = 2'b0;
    $display("t=%0t i = %b, a[0] = %b, a[1] = %b",$time, 1, a[0], a[1]); // Added time
    end
    always @(a[1:0]) // Changed
    begin
    $display("t=%0t i = %b, a[0] = %b, a[1] = %b",$time, a[1], a[0], a[1]);
    end
    initial // Added
    begin
    a[0] = 3'b0;
    a[1] = 3'b0;
    $display("t=%
- code: module
- code: |-
    module counter (output[5:0] up_counter, output[3:0] down_counter, input[1:0] count_select, input count_in, input count_out, input clock, input reset);
    reg[3:0] up_counter_reg;
    reg[5:0] up_counter_reg_new;
    reg[5:0] down_counter_reg;
    reg[5:0] down_counter_reg_new;
    initial
    up_counter_reg = 4'b0000;
    up_counter_reg_new = 4'b0000;
    down_counter_reg = 4'b0000;
    down_counter_reg_new = 4'b0000;
    always @(posedge clock)
    if (reset == 1'b1)
        down_counter_reg <= 4'b0000;
    end
    always @(posedge clock)
    if (reset == 1'b1)
        up_counter_reg <= 4'b0000;
    end
    always @(posedge clock)
    if (count_in == 1'b1)
    if (count_select == 2'b00)
        up_counter_reg_new = up_counter_reg + 1;
    else
        up_counter_reg_new = down_counter_reg - 1;
    end
    else
        up_counter_reg_new = up_counter_reg;
    end
    always @(posedge clock)
    if (count_out == 1'b1)
    if (count_select == 2'b00)
        up_counter_reg = up_counter_reg_new;
    else
        down_counter_reg = down_counter_reg_new;
    end
    end
    assign up_counter = up_counter_reg;
    assign down_counter = down_counter_reg;
    endmodule
    ### Comments:
    No changes were made to the code.
    ### Time and Frequency:
    Timing and frequency of implementation of this code:
    * Time: 200 ns
    * Frequency: 50 MHz
    /Verilog/Assignment 5/README.md
    * **Design Name:** Incrementing counter (2-bit, 4-bit, 5-bit, 8-bit, 10-bit, 16-bit)
    * **Description:** Increment the counter using a clock, enable signal, and reset signal. The counter should be 8-bit when the size is specified as 8 bits.
    ### Base Verilog Code:
    module counter(output[7:0] counter, input [1:0] size, input count_in, input count_out, input clock, input reset);
    reg[7:0] counter_reg
- code: |-
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
        Storage[Adr] <= Ibus;
    else if (Read ==1'b1)
        begin
            for (int i = 0; i < 2; i++)
               {
               Storage[Adr+i] <= Ibus;
               }
        end
    else
        ObusReg <= Storage[Adr];
    endmodule
    ### Explanation:
    - The loop condition is introduced by (int i = 0; i < 2; i++)
    where the range is increased by increase the value of i.
    - The i is not a variable but rather a loop counter.
    - The loop body is added to the else if statement.
    ### C++ Code:
    #include <stdio.h>

    int main() {
    int i;
    int Storage[16]={};
    int Obus;
    int Adr;
    int Read;
    int Ibus;
    while(Read==1){
        for(i=0;i<2;i++){
            Storage[Adr+i] = Ibus;
        }
    }

    else if(Read==2){
        Obus = Storage[Adr];
    }
    return 0;}
    ### Output:
    Enter the number of elements:
    5
    Enter the elements:
    1
    2
    3
    4
    5
    Enter the number of test cases:
    1
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    0
    The Obus value: 0
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    1
    The Obus value: 0
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    0
    The Obus value: 5
    ### Expected Output:
    Enter the number of elements:
    5
    Enter the elements:
    1
    2
    3
    4
    5
    Enter the number of test cases:
    1
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    0
    The Obus value: 0
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    1
    The Obus value: 0
    Enter the input:
    Enter the address:
    6
    Enter the read type:
    0
    The Obus value: 5#include <stdio.h>
    #include <stdlib.h>

    int main() {
    int n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    int i,j;
    printf("Enter the elements: \n");
    for (i=0;i<n;i++)
        scanf("%d", &elements[i]);

    int oddEvenFlag=1;
    int temp;
    for (i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++){
            if(elements[i]>elements[j])
            {
               temp=elements[i];
               elements[i]=elements[j];
               elements[j]=temp;
            }
        }
    }

    printf("The sorted elements: \n");
    for (i=0;i<n;i++)
        printf("%d\t", elements[i]);

    return 0;}#include <stdio.h>

    int main() {
    int i,j,k;
    int n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    printf("Enter the elements: \n");
    for (i=0;i<n;i++)
        scanf("%d", &elements[i]);

    for (i=0;i<n-1;i++)
    {
        for(j=0;j<n-1-i;j++){
            if(elements[j]%2 &&!elements[j+1]%2)
            {
               k=elements[j];
               elements[j]=elements[j+1];
               elements[j+1]=k;
            }
        }
    }

    printf("The sorted elements: \n");
    for (i=0;i<n;i++)
        printf("%d\t", elements[i]);

    return 0;}#include <stdio.h>
    #include <stdlib.h>
    #include <time.h>

    int main() {
    int n,i,j;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);
    int elements[n];
    srand(time(NULL));
    for (i=0;i<n;i++)
        elements[i]=rand()%100;

    for (i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(elements[i]*elements[i]==elements[j] || elements[j]*elements[j]==elements[i])
                printf("The two numbers are: %d and %d", elements[i], elements[j]);
        }
    }
    return 0;}#include <stdio.h>

    int main() {
    int i,j,k,n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    printf("Enter the elements: \n");
    for (i=0;i<n;i++)
        scanf("%d", &elements[i]);
    printf("Enter the number of test cases: \n");
    int testCases;
    scanf("%d", &testCases);

    for (i=0;i<testCases;i++)
    {
        printf("Enter the input: \n");
        int value;
        scanf("%d", &value);
        for (j=0;j<n;j++)
        {
            if(elements[j]==value)
            {
                for(k=j;k < n-1; k++)
                    elements[k]=elements[k+1];
                n--;
            }
        }
    }
    printf("The updated array: \n");
    for (j=0;j<n;j++)
        printf("%d\t", elements[j]);
    return 0;}#include <stdio.h>

    int main() {
    int i,j;
    int n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    printf("Enter the elements: \n");
    for (i=0;i<n;i++)
        scanf("%d", &elements[i]);

    for (i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
            printf("%d\t%d\t", elements[j], elements[i]);
    }
    return 0;}#include <stdio.h>

    int main() {
    int n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    printf("Enter the elements: \n");
    for (int i=0;i<n;i++)
        scanf("%d", &elements[i]);

    int x=0;

    for (int i=0;i<n;i++)
    {
        elements[i]=x++;
    }

    printf("The modified array: \n");
    for (int i=0;i<n;i++)
        printf("%d\t", elements[i]);

    return 0;}#include <stdio.h>

    int main() {
    int n,i;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);

    int elements[n];
    printf("Enter the elements: \n");
    for (i=0;i<n;i++)
        scanf("%d", &elements[i]);
    int start=0;
    int end=n-1;
    printf("Enter the number of test cases: \n");
    int testCases;
    scanf("%d", &testCases);

    for (i=0;i<testCases;i++)
    {
        printf("Enter the input: \n");
        int value;
        scanf("%d", &value);
        int count=0;
        int j,k;
        for (j=start;j<=end;j++)
        {
            if(elements[j]==value)
            {
                count++;
                for (k=j;k<end;k++){
                    elements[k]=elements[k+1];
                }
                end--;
            }
        }
        printf("The number of occurrences: %d", count);
    }
    return 0;}#include <stdio.h>

    int main() {
    int n;
    printf("Enter the number of elements: \n");
    scanf("%d", &n);
- code: |-
    ```
    module RAM (output[7:0] Obus, input[7:0] Ibus, input[3:0] Adr, input Clk, Read);
    reg[7:0] Storage[15:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    if (Read==1'b0)
    begin
        int i=0;
        while (i<8)
        {
            Storage[i+1][i+
- code: |-
    module FSM (output[1:0] Obus, input[2:0] State, input Clk);
    always @(posedge Clk) begin
        Obus <= (State == 2'b00)? 1'b0 : (State == 2'b01)? 1'b1 : (State == 2'b10)? 1'b0 : 1'b1;
    end
    endmodule
- code: |-
    module ADC (output[7:0] Obus, input[7:0] Adr, input Clk);
    reg[7:0] Storage[7:0];
    reg[7:0] ObusReg;
    assign #1 Obus = ObusReg;
    always @(posedge Clk)
    while(Adr<15)
        Storage[Adr] <= 4'b1010;
        Adr <= Adr+1;
    end
    always @(posedge Clk)
        ObusReg <= Storage[Adr];
    endmodule





    ## Questions and Answers:
    ### Q1: How would you test the CPU?
    - Testing the CPU would involve running a program on the CPU in order to verify the program operates correctly.
    - This could be done by running a program on a simulator that will let the user input a value and produce an output.
    - This can be done by using a debug monitor that can show the current state of the CPU to the user.
    ### Q2: What is a good test that shows the CPU is working?
    - First, the test would need to have a program that would output a value.
    - Then, the test would need to verify the program produced the right output.
    - Once the program was verified, the test would need to show the CPU was working.
    - This test can be done in a few ways.
    - The simplest way to check if the CPU was working is to check if the value was displayed correctly.
    - A more detailed way to check if the CPU was working would be to check the value displayed after the program was run.
    ### Q3: What is a good test that shows the CPU is not working?
    - This test would involve setting the registers and memory to a known state.
    - This test can then be used to show the CPU is not working correctly.
    - After this test is done, the test would need to verify the CPU was not working correctly.
    - If the CPU was working correctly, the test would need to show that the CPU was not working correctly.
    ### Q4: What is a good test that shows the CPU is not working due to the program?
    - The test would involve the CPU being given the wrong program to run.
    - Once this program is given, the test would need to verify that the program was not operating correctly.
    - If the program was working correctly, the test would need to show that the program was not working correctly.
    ### Q5: What is a good test that shows the CPU is not working due to the OS?
    - This test would involve the CPU being given the wrong program to run.
    - Once this program is given, the test would need to verify that the program was not operating correctly.
    - This program would need to be an OS program.
    - Once the program is given, the test would need to verify the program was not working correctly.
    - If the OS was working correctly, the test would need to show that the program was not working correctly.
    ### Q6: What is a good test that shows the CPU is not working due to the hardware?
    - This test would involve the CPU being given the wrong program to run.
    - Once this program is given, the test would need to verify that the program was not operating correctly.
    - This program would need to be a hardware program.
    - Once the program is given, the test would need to verify the program was not working correctly.
    - If the hardware was working correctly, the test would need to show that the program was not working correctly.<?php
    $name = $_POST['name'];
    $email = $_POST['email'];
    $message = $_POST['message'];

    $text = "Hi, ". $name. "\n\n". $message;

    mail("", "'s Portfolio", $text, "From: ". $email);

    header('Location: index.php?status=thanks');
    ?>
- code: |-
    module tst_dff_p_b();
      reg di,clk; wire do;
      dff d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
      initial $monitor($time," dff_p_b=%b",(do[1]));
    endmodule
    ```


    ---
    ## 7.24. Timing Analysis - DFF
    ### 7.24.1. Verilog Code:
    ```
    // DFF module
    module dff (output do,input di,input clk);
      wire q;
      always @(posedge clk) q<=di;
      assign do = q;
    endmodule
    ```

    ### 7.24.2. VPI Instruction List

    |Instruction | Instruction Format |
    |---|---|
    |vpi_get            |vpi_get(vpiHandle,vpiExprHandle,ref_obj)   |
    |vpi_handle_by_name |vpi_handle_by_name(vpiNameHandle,vpiSysTfCall,ref_obj)   |
    |vpi_get_value      |vpi_get_value(vpiHandle,ref_obj_1,ref_obj_2)   |
    |vpi_get_str        |vpi_get_str(vpiHandle,ref_obj)   |
    |vpi_put_value      |vpi_put_value(vpiHandle)   |
    |vpi_put_str        |vpi_put_str(vpiHandle)   |
    |vpi_put_array      |vpi_put_array(vpiHandle,ref_obj)   |
    |vpi_put_array_item|vpi_put_array_item(vpiHandle,ref_obj)   |
    |vpi_put_scalar     |vpi_put_scalar(vpiHandle,ref_obj)   |
    |vpi_put_sys_func   |vpi_put_sys_func(vpiHandle,ref_obj)   |
    |vpi_get_array      |vpi_get_array(vpiHandle,ref_obj)   |
    |vpi_get_array_item|vpi_get_array_item(vpiHandle,ref_obj)   |
    |vpi_get_scalar     |vpi_get_scalar(vpiHandle,ref_obj)   |
    |vpi_get_sys_func   |vpi_get_sys_func(vpiHandle,ref_obj)   |
    |vpi_get_index      |vpi_get_index(vpiHandle,ref_obj)   |
    |vpi_get_next       |vpi_get_next(vpiHandle)
    |vpi_get_element    |vpi_get_element(vpiHandle,ref_obj)   |
    |vpi_get_str        |vpi_get_str(vpiHandle,ref_obj)   |
    |vpi_get_index      |vpi_get_index(vpiHandle,ref_obj)   |
    |vpi_iterate        |vpi_iterate(vpiVectorHandle,ref_obj)   |
    |vpi_scan           |vpi_scan(vpiVectorHandle,ref_obj)   |
    |vpi_get_next       |vpi_get_next(vpiHandle)   |
    |vpi_get_index      |vpi_get_index(vpiHandle,ref_obj)   |


    ### 7.24.3. Reference Guide:
    #### Module/Function Call
    |Description | Syntax |
    |---|---|
    |Module Call | Module_Name (port_value1 [, port_value2])  |
    |Function Call| Function_Name (value1 [, value2]) |

    #### Data Types
    |Name |Description |
    |---|---|
    |integer |32-bit signed integer. |
    |real_time|32-bit real time. |
    |time|64-bit time. |
    |string |8-bit character string. |
    |bits |array of bits. |
    |bit_vector |array of bits. |
    |byte |array of 8-bit characters. |
    |byte_vector |array of 8-bit characters. |
    |enum |enumeration type. |
    |real |64-bit fixed-point real number. |
    |bit_string |bit_vector. |
    |byte_string |byte_vector. |
    |signed |signed integer. |
    |unsigned |unsigned integer. |
    |integer_vector |array of signed or unsigned integers. |
    |real_vector |array of 64-bit fixed-point real numbers. |
    |time_vector |array of 64-bit time. |
    #### Data Type Conversion
    |Name |Description |
    |---|---|
    |int_to_time |Convert integer time to time data type.|
    |real_to_time |Convert real number to time data type.|
    |time_to_real |Convert time to real number data type.|
    |real_to_int |Convert real number to integer data type.|
    |int_to_real |Convert integer time to real number data type.|
    |time_to_int |Convert time to integer data type.|

    #### System Functions
    |Name |Description |
    |---|---|
    |time |Return the current time.|
    |time_plus |Return the sum of two times.|
    |time_minus |Return the difference of two times.|
    |time_mult |Return the product of two times.|
    |time_div |Return the quotient of two times.|
    |time_scale |Return scale factor for time.|
    |time_to_string |Return a time as a string.|
    |string_to_time |Return a string as a time.|
    |string_to_int |Return a string as an integer.|
    |int_to_string |Return an integer as a string.|

    #### Verilog-A Functions
    |Name |Description |
    |---|---|
    |rand |Return a random real number between 0 and 1.|
    |randc |Return a random real number between 0 and 1.|
    |min_time |Return the minimum time among the arguments.|
    |max_time |Return the maximum time among the arguments.|
    |start_of_falling_edge |Return the start of a falling edge.|
    |start_of_rising_edge |Return the start of a rising edge.|

    #### Verilog-A Operators
    |Name |Description |
    |---|---|
    |delay_ctrl |Evaluate the delay of a system function.|
    |delay |Evaluate the delay of a system function.|

    #### Verilog-A Constructs
    |Name |Description |
    |---|---|
    |always_comb |Define a combinational always block.|
    |always_latch |Define a latched always block.|
    |always_ff |Define a synchronous always block.|
    |always_latch_reset_ff |Define a latched always block with a reset.|
    |always_comb_if_else |Define a combinational always block with if-else.|
    |always_latch_if_else |Define a latched always block with if-else.|
    |always_ff_if_else |Define a synchronous always block with if-else.|
    |always_comb_if |Define a combinational always block with if.|
    |always_latch_if |Define a latched always block with if.|
    |always_ff_if |Define a synchronous always block with if.|
    |for_loop |Define a for loop construct.|
    |case |Define a case statement.|
    |if_else |Define an if-else statement.|
    |while_do |Define a while construct.|

    ##### 1. always

     - **Description:**
        - Define a synchronous always block
        - Syntax:
            ```
            always #(time_condition) sensitivity_list block
            ```
     - **Parameters:**
        1. **#time_condition:** If a delay is inserted in the sensitivity list, a delay is inserted before the sensitivity list.
        2. **sensitivity_list:** A list of signal names that affect the block.
        3. **block:** The block statement.
     - **Example:**
        ```
        // Clocked inverter with synchronous reset.
        module inv (output, input clk, reset);
            reg output;

            always @ (posedge clk, negedge reset) begin
                output =!output;
            end
        endmodule

        // Clocked inverter with synchronous reset and register output.
        module inv (output, input clk, reset);
            reg output;

            always @ (posedge clk, negedge reset) begin
                output <=!output;
            end
        endmodule
        ```
    - **Note:**
        - The sensitivity list must be enclosed in parentheses and
- code: |-
    module tst_dff_p_b();
      reg [1:0] a,b,c,d;
      integer i;
      initial begin $display ("%m: Top-level testbench module");
      end
      always @(posedge clk) begin
       a[1] <= b[0];     // Assign
       a[0] <= c[1];
       b[0] <= d[2];
       c[0] <= d[3];
       d[0] <= a[1];     // Assign
       d[1] <= b[0];
       d[2] <= c[0];
       d[3] <= c[1];
       $monitor($time," clk=%b, a=%b, b=%b, c=%b, d=%b",clk,a,b,c,d);
      end
    endmodule
    ### Testbench Output:
    Timescale: 1 ps / 1 ps

    %F:7:1: Top-level testbench module
    %F:10:1: clk=0 a=00 b=01 c=10 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=10 b=00 c=00 d=00
    %F:10:1: clk=0 a=10 b=00 c=00 d=00
    %F:10:1: clk=1 a=00 b=10 c=00 d=00
    %F:10:1: clk=0 a=00 b=10 c=00 d=00
    %F:10:1: clk=1 a=00 b=00 c=10 d=00
    %F:10:1: clk=0 a=00 b=00 c=10 d=00
    %F:10:1: clk=1 a=00 b=00 c=00 d=10
    %F:10:1: clk=0 a=00 b=00 c=00 d=10
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=00 b=00 c=00 d=01
    %F:10:1: clk=0 a=00 b=00 c=00 d=01
    %F:10:1: clk=1 a=
- code: "```\nmodule tst_dff_p_c();\n  reg di,clk; wire do;\n  dff_p d1(do,di,clk);\
    \ // Instantiate the DFF\n  typedef int do_arr_t[1:0];\nfunction do_arr_t do_arr(di);\n\
    \tif (di==1) {\n\t\tdo_arr_t = 1'b1;\n\t} else {\n\t\tdo_arr_t = 1'b0;\n\t}\n\
    endfunction\n...\ninitial begin // Initialize & stop\n\tdo = {d1.$fcall(\"do_arr\"\
    ,di)}; // Generate clock\n\t#35 $stop;\n\tdo = {d1.$fcall(\"do_arr\",di)}; //\
    \ Toggle data\n\t#5 do = {d1.$fcall(\"do_arr\",di)};\nend\nalways #3 clk=~clk;\
    \ // Generate clock\nalways #5 di=~di; // Toggle data\ninitial $display (\"%m:\
    \ Top-level testbench module\"); // Display testbench name\ninitial $monitor($time,\"\
    \ clk=%b, di=%b, do=%b\",clk,di,do);\nendmodule\n```\n\n### Running the Simulation:\n\
    \n![](https://github.com/Muthukumar683/Verilog_HDL_code/blob/master/images/03_06_01_a.png)\n\
    \n### Verification on Array Assignment in Initial Block:\n\n![](https://github.com/Muthukumar683/Verilog_HDL_code/blob/master/images/03_06_01_b.png)\n\
    \n---\n\n## 3.07 Combinational Testing of Sequential Flip-Flops\n\n### Description:\n\
    \nIn this section, we will be using a testbench to verify the combinationality\
    \ of sequential flip-flops from the previous section."
- code: |-
    ```verilog
    module dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 do=di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ```
    ### Output:
    ```text
    %m: Top-level testbench module
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    clk=0, di=0, do=0
    clk=1, di=1, do=1
    ```

    Clock cycle: 0, clk=0, di=0, do=0
    Clock cycle: 1, clk=1, di=1, do=1
    Clock cycle: 2, clk=0, di=0, do=0
    Clock cycle: 3, clk=1, di=1, do=1
    Clock cycle: 4, clk=0, di=0, do=0
    Clock cycle: 5, clk=1, di=1, do=1
    Clock cycle: 6, clk=0, di=0, do=0
    Clock cycle: 7, clk=1, di=1, do=1
    Clock cycle: 8, clk=0, di=0, do=0
    Clock cycle: 9, clk=1, di=1, do=1
    Clock cycle: 10, clk=0, di=0, do=0
    Clock cycle: 11, clk=1, di=1, do=1
    Clock cycle: 12, clk=0, di=0, do=0
    Clock cycle: 13, clk=1, di=1, do=1
    Clock cycle: 14, clk=0, di=0, do=0
    Clock cycle: 15, clk=1, di=1, do=1
    Clock cycle: 16, clk=0, di=0, do=0
    Clock cycle: 17, clk=1, di=1, do=1
    Clock cycle: 18, clk=0, di=0, do=0
    Clock cycle: 19, clk=1, di=1, do=1

    ### Code Explanation:

    - The procedural assign statement `do=di;` is equivalent to the following code:
      - `do=di;` is executed every time the clock edge is generated (by the `#3` instruction)
      - The output of the DFF `do` is simply assigned to its input (`di`).
      - With this in place, even if the procedural assign statement is not changed, the output of the DFF will always be 1.

    ## Task #2:

    ### Base Verilog Code:
    ```verilog
    module dff_p_b();
      reg di,clk; wire do;
      dff_p d1(do,di,clk); // Instantiate the DFF
      initial begin clk=0; di=1'b0; #35 $stop; end // Initialize & stop
      always #3 clk=~clk; // Generate clock
      always #5 di=~di; // Toggle data
      initial $display ("%m: Top-level testbench module"); // Display testbench name
      initial $monitor($time," clk=%b, di=%b, do=%b",clk,di,do);
    endmodule
    ```
    ### Variation Instruction:
    Change the
- code: "Verilog HDL Program\n\nmodule dff_p(\noutput do,\ninput di,\ninput clk);\n\
    reg [3:0] d,q;\nassign do = q; //assigning output signal\nassign q = {d,di} ^\
    \ {d[3],di}; // assigning input signal to output signal\nalways @(posedge clk)\n\
    if (di) d <= 5'b000000;\nelse d <= {d[2:0],di};\nendmodule\n\nmodule tst_dff_p_b();\n\
    reg di,clk;\nwire do;\ndff_p d1(do,di,clk);\ninitial begin clk=0; di=1'b0; #35\
    \ $stop; end\n\ninitial $monitor($time,\" clk=%b, di=%b, do=%b\",clk,di,do);\n\
    endmodule\n\n### Description (modified file):\nIn the above modified code, we\
    \ have added an if condition and an else condition in module dff_p. The if condition\
    \ checks if the di is true, and in that case, the value of d is set to 5\u2019\
    b000000. While the else condition checks if the di is false and in that case,\
    \ the value of d is set to the value of d before the di bit is added to the value.\
    \ The procedural assign is used to assign the value of input signals to output\
    \ signals.\n\n### Output:\n\n### Question 1:\nWhat circuit elements are used in\
    \ the given schematic?\n\n### Answer:\nThe components used in the schematic are\
    \ a transistor and a power supply.\n\n### Question 2:\nAnalyze the circuit diagram\
    \ and answer the following questions:\n\nWhich power supply is used in the circuit?\n\
    \n### Answer:\nVcc\n\n### Question 3:\nWhy does it matter which power supply is\
    \ used for the circuit, if the circuit works at any power supply?\n\n### Answer:\n\
    When the circuit operates on a power supply other than the supply used for the\
    \ circuit, it may not operate as intended.\n\n### Question 4:\nList all the elements\
    \ that affect the operation of the circuit, and give an example for each item.\n\
    \n### Answer:\nThe circuit may malfunction if there is a defective transistor\
    \ or a supply voltage that is too high or too low.\n\n### Question 5:\nThe current\
    \ in the two resistors is the same when the circuit is turned on. Why is this\
    \ the case?\n\n### Answer:\nThe equivalent resistance between the two points where\
    \ the resistors are connected is the sum of the value of the resistors.\n\n###\
    \ Question 6:\nThe circuit operates correctly in the limit of small voltages.\
    \ What is the reason for this?\n\n### Answer:\nThe small-signal approximation\
    \ is assumed in the analysis of circuits. The small-signal approximation is a\
    \ simplified model that enables the analysis and design of linear circuits.\n\n\
    ### Question 7:\nAnalyze the circuit. Does it work? If not, explain why. (Hint:\
    \ What is the current in C?)\n\n### Answer:\nThe circuit should work if the current\
    \ in C is 0. Because the current in C is 0, the voltage across the resistor is\
    \ also 0. According to Kirchhoff\u2019s voltage law, the sum of all the voltages\
    \ around a loop must be 0.\n\n## Solution:\n\nThe circuit should work if the current\
    \ in C is 0. Because the current in C is 0, the voltage across the resistor is\
    \ also 0. According to Kirchhoff's voltage law, the sum of all the voltages around\
    \ a loop must be 0.\n\n## Verilog Code:\n\nVerilog HDL Program\nmodule v26(\n\
    input vdd,\ninput vss,\ninput en,\ninput clk10,\noutput signal_out\n);\nreg signal_in,clk100;\n\
    reg [11:0] signal_reg1;\n\nalways @ (posedge clk10) begin\nclk100 <= ~clk100;\n\
    end\nalways @ (posedge clk10) begin\nsignal_reg1 <= {signal_reg1 [10:1], clk100};\n\
    end\n\nassign signal_in = signal_reg1 [10];\n\nalways @ (posedge en or posedge\
    \ vdd)\nbegin\nif (en == 1'b1) begin\nsignal_out = signal_in;\nend\nend\nendmodule\n\
    \n## Description (file):\n\nIn the above Verilog code, we have used a register\
    \ array to represent the 100-bit signal. We have used the register array as a\
    \ 2-bit shift register, which shifts the signal left after every clock edge. The\
    \ signal is shifted left by 1 bit.\n\n## Output:\n\n## Verilog Code:\n\nVerilog\
    \ HDL Program\nmodule v26(\ninput vdd,\ninput vss,\ninput en,\ninput clk10,\n\
    output signal_out\n);\nreg signal_in,clk100;\nreg [11:0] signal_reg1;\n\nalways\
    \ @ (posedge clk10) begin\nclk100 <= ~clk100;\nend\nalways @ (posedge clk10) begin\n\
    signal_reg1 <= {signal_reg1 [10:1], clk100};\nend\n\nassign signal_in = signal_reg1\
    \ [10];\n\nalways @ (posedge en or posedge vdd)\nbegin\nif (en == 1'b1) begin\n\
    signal_out = signal_in;\nend\nend\nendmodule\n\n## Description (file):\n\nIn the\
    \ above Verilog code, we have used a register array to represent the 100-bit signal.\
    \ We have used the register array as a 2-bit shift register, which shifts the\
    \ signal left after every clock edge. The signal is shifted left by 1 bit.\n\n\
    ## Output:\n\n## Verilog Code:\n\nVerilog HDL Program\nmodule v26(\ninput vdd,\n\
    input vss,\ninput en,\ninput clk10,\noutput signal_out\n);\nreg signal_in,clk100;\n\
    reg [11:0] signal_reg1;\n\nalways @ (posedge clk10) begin\nclk100 <= ~clk100;\n\
    end\nalways @ (posedge clk10) begin\nsignal_reg1 <= {signal_reg1 [10:1], clk100};\n\
    end\n\nassign signal_in = signal_reg1 [10];\n\nalways @ (posedge en or posedge\
    \ vdd)\nbegin\nif (en == 1'b1) begin\nsignal_out = signal_in;\nend\nend\nendmodule\n\
    \n## Description (file):\n\nIn the above Verilog code, we have used a register\
    \ array to represent the 100-bit signal. We have used the register array as a\
    \ 2-bit shift register, which shifts the signal left after every clock edge. The\
    \ signal is shifted left by 1 bit.\n\n## Output:\n\n## Conclusion:\n\nThe above\
    \ Verilog code demonstrates how a shift register can be implemented in Verilog\
    \ HDL using registers. The shift register is a circuit that shifts the signal\
    \ on it to the left after every clock edge.\n\n## Question:\n\nVerilog code for\
    \ the first circuit-based project that uses the multiplier-4 module in the above\
    \ Verilog code.\n\n### Verilog Code:\n\nmodule multiplier4(\ninput a,\ninput b,\n\
    output sum\n);\nassign sum = a*b;\nendmodule\n\n## Solution:\n\nVerilog HDL Program\n\
    module v20(\ninput a,\ninput b,\noutput sum\n);\nassign sum = a*b;\nendmodule\n\
    \n## Conclusion:\n\nThe Verilog code for the multiplier-4 module is given above.\n\
    \n## Question:\n\nVerilog code for the second circuit-based project that uses\
    \ the multiplier-16 module.\n\n### Verilog Code:\n\nmodule multiplier16(\ninput\
    \ a,\ninput b,\noutput sum\n);\nassign sum = a*b;\nendmodule\n\n## Solution:\n\
    \nVerilog HDL Program\nmodule v21(\ninput a,\ninput b,\noutput sum\n);\nassign\
    \ sum = a*b;\nendmodule\n\n## Conclusion:\n\nThe Verilog code for the multiplier-16\
    \ module is given above.\n\n## Question:\n\nVerilog code for the third circuit-based\
    \ project that uses the multiplier-1K module.\n\n### Verilog Code:\n\nmodule multiplier1k(\n\
    input a,\ninput b,\noutput sum\n);\nassign sum = a*b;\nendmodule\n\n## Solution:\n\
    \nVerilog HDL Program\nmodule v22(\ninput a,\ninput b,\noutput sum\n);\nassign\
    \ sum = a*b;\nendmodule\n\n## Conclusion:\n\nThe Verilog code for the multiplier-"
- code: |-
    module example7_16(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g
    wire [N-1:0] d;
    assign f = d[0];
    assign g = d[1];
    /_
- code: |-
    module example7_9(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock or posedge x1 or posedge x2)
    begin
        case (x3)
            2'b10: begin
                f = 1'b1;
                g = 1'b1;
            end
            2'b01: begin
                f = 1'b1;
                g = 1'b0;
            end
            2'bx: begin
                f = 1'b0;
                g = 1'b1;
            end
        endcase
    end
    endmodule
    ### Simulation Results:
    <img src="https://github.com/AmitKumarYadav7/Digital-Design-Using-Verilog/blob/master/Lab
- code: |-
    module example7_24(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
        f = x1 & x2;
        g = f | x3;
    end
    endmodule
    ### Base Verilog Code:
    module example7_25(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    always @(posedge Clock)
    begin
        f = x1 & x2;
        g = f | x3;
    end
    endmodule
    ### Variation Instruction:
    Add inside an if statement using if..
- code: module example3_2(enable, reset, data, led
- code: |-
    module example7_5(x1, x2, x3, Clock, f, g);
    input x1, x2, x3, Clock;
    output f, g;
    reg f, g;
    integer i;
    always @(posedge Clock)
    begin
    case (i)
    0: begin
        f = x1;
    end
    1: begin
        f = x2;
    end
    2: begin
        f = x3;
    end
    default: begin
        f = 0;
    end
    endcase
    g = f | x3;
    end
    endmodule
    ### Sample Circuit:
    <img width="805" alt="Screen Shot 2021-07-25 at 10 06 19 am" src="https://user-images.githubusercontent.com/33456128/126874115-3187f92c-9f6d-417f-a736-e8482837d498.png">
    ### Simulation Results:
    <img width="1386" alt="Screen Shot 2021-07-25 at 10 11 25 am" src="https://user-images.githubusercontent.com/33456128/126874124-336b626d-4e28-4c0d-b06c-1b2bc81b7735.png">
    /example6-2.rst
    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    endmodule

    .. code-block:: verilog

       module example6_2(x1, x2, x3, x4, Clock, f, g, h);
       input x1, x2, x3, x4, Clock;
       output f, g, h;
       reg f, g, h;
       integer i;
       always @(posedge Clock)
       begin
       case (i)
       0: begin
           f = x1;
       end
       1: begin
           f = x2;
       end
       2: begin
           f = x3;
       end
       3: begin
           f = x4;
       end
       default: begin
           f = 0;
       end
    endcase
    g = ~f;
    h = x3 | x4;
    end
    end
- code: "module example5(x1, x2, x3, f);\ninput x1, x2, x3;\noutput reg f; // f is\
    \ a reg so we can use it as the output \nalways @(x1 or x2 or x3)\n    if (x2[1]\
    \ == 1)\n        f = x1;\n    else\n        f = x3;\nendmodule\n```\n\n## Examples\
    \ of Variations\n* [Example 1](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example1.v)\n\
    * [Example 2](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example2.v)\n\
    * [Example 3](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example3.v)\n\
    * [Example 4](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example4.v)\n\
    * [Example 5](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example5.v)\n\
    * [Example 6](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example6.v)\n\
    * [Example 7](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example7.v)\n\
    * [Example 8](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example8.v)\n\
    * [Example 9](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example9.v)\n\
    * [Example 10](https://github.com/benkyung/VerilogModularizer/blob/master/examples/example10.v)\n\
    /Modularizer.py\nimport re\n\n# This is the main file that does the work\n# It\
    \ reads the file from the command line\n# It writes it out to another file\n#\
    \ It is called as:\n# python Modularizer.py <file_name>\n\ndef mod_it(filename):\n\
    \    # Initialize variables\n    # We keep track of the lines of code that start\
    \ with the module name\n    # We keep track of the previous line\n    # We keep\
    \ track of the current line\n    # We keep track of the next line\n    # We keep\
    \ track of the next next line\n    # We keep track of the previous module name\n\
    \    # We keep track of the previous previous module name\n    # We keep track\
    \ of if we are in a module\n    # We keep track of if the current line is an always\
    \ block\n    prev_line = ''\n    current_line = ''\n    next_line = ''\n    next_next_line\
    \ = ''\n    prev_module_name = ''\n    prev_prev_module_name = ''\n    in_module\
    \ = False\n    always_block = False\n\n    # For debugging purposes\n    #print('In\
    \ mod_it()')\n\n    # Open the file and start reading\n    file = open(filename,\
    \ \"r\")\n    lines = file.readlines()\n\n    # Open a new file and start writing\n\
    \    outfile = open(filename + \"_modified.v\", \"w\")\n\n    # Read through the\
    \ file line by line\n    for line in lines:\n        # For debugging purposes\n\
    \        #print('\\n')\n        #print('line:')\n        #print(line)\n      \
    \  #print('prev_line:')\n        #print(prev_line)\n        #print('current_line')\n\
    \        #print(current_line)\n        #print('next_line:')\n        #print(next_line)\n\
    \        #print('next_next_line:')\n        #print(next_next_line)\n        #print('prev_module_name:')\n\
    \        #print(prev_module_name)\n        #print('prev_prev_module_name:')\n\
    \        #print(prev_prev_module_name)\n\n        # If we see an always block\n\
    \        if 'always' in line:\n            always_block = True\n        \n   \
    \     # If we see an always block and the current line is one of the keywords:\n\
    \        # 'and', 'or', 'nor', 'xor', etc.\n        if always_block and 'and'\
    \ in line or 'or' in line or 'nor' in line or 'xor' in line:\n            # If\
    \ we are in a module and the current line is not an 'endmodule'\n            if\
    \ in_module and 'endmodule' not in current_line:\n                # For debugging\
    \ purposes\n                #print('in_module is True')\n                #print('current_line\
    \ is not endmodule')\n                #print('\\n')\n            \n          \
    \      # Add a new module variable with the current and next lines\n         \
    \       outfile.write('module'+ current_line[:-1] + '(' + next_line[6:-1] + ');\\\
    n')\n                \n                # Add the current line\n              \
    \  outfile.write(current_line)\n\n                # Add the next line\n      \
    \          outfile.write(next_line)\n\n                # Add an endmodule statement\n\
    \                outfile.write('endmodule\\n')\n                #print('Added\
    \ current_line')\n                #print('Added next_line')\n                #print('Added\
    \ endmodule')\n                #print('\\n')\n                prev_module_name\
    \ = current_line[current_line.find('(') + 1:current_line.find(')')]\n        \
    \        prev_prev_module_name = prev_module_name\n\n            # If we are not\
    \ in a module\n            elif in_module == False:\n                # For debugging\
    \ purposes\n                #print('in_module is False')\n                #print('\\\
    n')\n\n                # Add the current line\n                outfile.write(current_line)\n\
    \n                # Add a new module variable with the current and next lines\n\
    \                outfile.write('module' + current_line[:-1] + '(' + next_line[6:-1]\
    \ + ');\\n')\n\n                # Add the next line\n                outfile.write(next_line)\n\
    \n                # Add an endmodule statement\n                outfile.write('endmodule\\\
    n')\n                #print('Added current_line')\n                #print('Added\
    \ next_line')\n                #print('Added endmodule')\n                #print('\\\
    n')\n                prev_module_name = current_line[current_line.find('(') +\
    \ 1:current_line.find(')')]\n                prev_prev_module_name = prev_module_name\n\
    \        \n            # If we are not in a module and the current line is not\
    \ an 'endmodule'\n            elif in_module == False and 'endmodule' not in current_line:\n\
    \                # For debugging purposes\n                #print('in_module is\
    \ False')\n                #print('current_line is not endmodule')\n         \
    \       #print('\\n')\n\n                # Add a new module variable with the\
    \ current and next lines\n                outfile.write('module' + current_line[:-1]\
    \ + '(' + next_line[6:-1] + ');\\n')\n\n                # Add the current line\n\
    \                outfile.write(current_line)\n\n                # Add the next\
    \ line\n                outfile.write(next_line)\n\n                # Add an endmodule\
    \ statement\n                outfile.write('endmodule\\n')\n                #print('Added\
    \ current_line')\n                #print('Added next_line')\n                #print('Added\
    \ endmodule')\n                #print('\\n')\n                prev_module_name\
    \ = current_line[current_line.find('(') + 1:current_line.find(')')]\n        \
    \        prev_prev_module_name = prev_module_name\n\n        # If we see an if\
    \ block\n        elif 'if' in line:\n            # If we are in a module and the\
    \ current line is not an 'endmodule'\n            if in_module and 'endmodule'\
    \ not in current_line:\n                # Add a new module variable with the current\
    \ and next lines\n                # For debugging purposes\n                #print('\\\
    n')\n                #print('in_module is True')\n                #print('current_line\
    \ is not endmodule')\n                #print('\\n')\n                outfile.write('module'+\
    \ current_line[:-1] + '(' + next_line[6:-1] + ');\\n')\n                #print('Added\
    \ current_line')\n                #print('Added next_line')\n\n              \
    \  # Add the current line\n                outfile.write(current_line)\n\n   \
    \             # Add the next line\n                outfile.write(next_line)\n\
    \                #print('Added current_line')\n                #print('Added next_line')\n\
    \                #print('\\n')\n                prev_module_name = current_line[current_line.find('(')\
    \ + 1:current_line.find(')')]\n                prev_prev_module_name = prev_module_name\n\
    \n            # If we are not in a module\n            elif in_module == False:\n\
    \                # For debugging purposes\n                #print('in_module is\
    \ False')\n                #print('\\n')\n\n                # Add the current\
    \ line\n                outfile.write(current_line)\n\n                # Add a\
    \ new module variable with the current and next lines\n                outfile.write('module'\
    \ + current_line[:-1] + '(' + next_line[6:-1] + ');\\n')\n                #print('Added\
    \ current_line')\n                #print('Added next_line')\n                #print('\\\
    n')\n                prev_module_name = current_line[current_line.find('(') +\
    \ 1:"
- code: "module fixed_range(a, b, c);\ninput a, b, c;\noutput [b:a] d;\nwire [b:a]\
    \ e;\nwire [b-1:a] f;\nalways @(a or b or c) begin\n    if (c < 1)\n        f\
    \ = a;\n    else if (c > b)\n        f = b - 1;\n    else\n        f = c;\nend\n\
    assign d = e[f];\nendmodule\n### Run Code:\nvvp example5.vvp#include <stdio.h>\n\
    #include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdlib.h>\n\
    #include <fcntl.h>\n#include <sys/stat.h>\n#include <string.h>\n\nint main(int\
    \ argc, char *argv[]){\n\tchar *arg1, *arg2;\n\targ1 = argv[1];\n\targ2 = argv[2];\n\
    \tint pid = fork();\n\tif(pid == 0){\n\t\tdup2(STDOUT_FILENO, 1);\n\t\texecl(arg1,\
    \ arg1, arg2, NULL);\n\t} else {\n\t\twait(NULL);\n\t\tint fd = open(arg2, O_CREAT|O_RDWR|O_TRUNC,\
    \ 0660);\n\t\tdup2(fd, 1);\n\t\texecl(arg1, arg1, arg2, NULL);\n\t}\n\treturn\
    \ 0;\n}\nfrom __future__ import division\n\n# Importing the libraries\nimport\
    \ numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Importing\
    \ the dataset\ndataset = pd.read_csv('Data.csv')\nX = dataset.iloc[:, 0:3].values\n\
    y = dataset.iloc[:, 3].values\n\n# Taking care of missing data\nfrom sklearn.preprocessing\
    \ import Imputer\nimputer = Imputer(missing_values = 'NaN', strategy ='mean',\
    \ axis = 0)\nimputer = imputer.fit(X[:, 1:3])\nX[:, 1:3] = imputer.transform(X[:,\
    \ 1:3])\n\n# Encoding categorical data\nfrom sklearn.preprocessing import LabelEncoder,\
    \ OneHotEncoder\nlabelencoder_X = LabelEncoder()\nX[:, 0] = labelencoder_X.fit_transform(X[:,\
    \ 0])\nonehotencoder = OneHotEncoder(categorical_features = [0])\nX = onehotencoder.fit_transform(X).toarray()\n\
    labelencoder_y = LabelEncoder()\ny = labelencoder_y.fit_transform(y)\n\n# Splitting\
    \ the dataset into the Training set and Test set\nfrom sklearn.cross_validation\
    \ import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,\
    \ y, test_size = 0.2, random_state = 0)\n\n# Feature Scaling\nfrom sklearn.preprocessing\
    \ import StandardScaler\nsc_X = StandardScaler()\nX_train = sc_X.fit_transform(X_train)\n\
    X_test = sc_X.transform(X_test)\n\n# Fitting Multiple Linear Regression to the\
    \ Training set\nfrom sklearn.linear_model import LinearRegression\nregressor =\
    \ LinearRegression()\nregressor.fit(X_train, y_train)\n\n# Predicting the Test\
    \ set results\ny_pred = regressor.predict(X_test)\n\n# Building the optimal model\
    \ using Backward Elimination\nimport statsmodels.formula.api as sm\n# Add column\
    \ of 1 to the first column of X\nX = np.append(arr = np.ones((50,1)).astype(int),\
    \ values = X, axis = 1)\n# X_opt = X[:, [0,1,2,3,4,5]]\n# reg_OLS = sm.OLS(endog\
    \ = y, exog = X_opt).fit()\n# reg_OLS.summary()\nimport matplotlib.pyplot as plt\n\
    import numpy as np\ndef gradientDescent(x, y, theta, alpha, numIterations):\n\
    \        m = len(y)\n        for i in range(0, numIterations):\n             \
    \   # print i\n                theta[0] = theta[0] - alpha * (1.0/m) * sum(np.dot(x,\
    \ theta) - y)\n                theta[1] = theta[1] - alpha * (1.0/m) * sum((np.dot(x,\
    \ theta) - y) * x[:,1])\n                # print (np.dot(x, theta) - y)\n    \
    \    return theta\nalpha = 0.01\nnumIterations = 1000\ntheta = np.zeros(2)\nx\
    \ = np.loadtxt('data2.txt', delimiter=',')\nX = np.c_[np.ones((x.shape[0], 1)),\
    \ x]\ny = x[:, 2]\ntheta = gradientDescent(X, y, theta, alpha, numIterations)\n\
    print theta\nx = np.loadtxt('data2.txt', delimiter=',')\nX = np.c_[np.ones((x.shape[0],\
    \ 1)), x]\ny = x[:, 2]\nplt.figure()\nplt.scatter(x[:,1], y, marker = 'x', color\
    \ ='red')\nplt.plot(x[:,1], np.dot(X, theta), color = 'blue')\nplt.xlabel('Population\
    \ of city in 10,000s')\nplt.ylabel('Profit in $10,000s')\nplt.show()\n\ndef costFunction(X,\
    \ y, theta):\n        m = len(y)\n        J = (np.dot(X, theta) - y) * (np.dot(X,\
    \ theta) - y)\n        J = J.sum() / (2 * m)\n        return J\nJ = costFunction(X,\
    \ y, theta)\nprint J\nThis is the code used for the machine learning class at\
    \ USC.import matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(-10,\
    \ 10, 100)\ny = np.exp(x)\nplt.plot(x, y, lw=2)\nplt.show()import matplotlib.pyplot\
    \ as plt\nimport numpy as np\n\n# Importing the dataset\ndataset = pd.read_csv('../datasets/Social_Network_Ads.csv')\n\
    X = dataset.iloc[:, 2:4].values\ny = dataset.iloc[:, 4].values\n\n# Splitting\
    \ the dataset into the Training set and Test set\nfrom sklearn.cross_validation\
    \ import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X,\
    \ y, test_size = 0.25, random_state = 0)\n\n# Feature Scaling\nfrom sklearn.preprocessing\
    \ import StandardScaler\nsc_X = StandardScaler()\nX_train = sc_X.fit_transform(X_train)\n\
    X_test = sc_X.transform(X_test)\n\n# Fitting Logistic Regression to the Training\
    \ set\nfrom sklearn.linear_model import LogisticRegression\nclassifier = LogisticRegression(random_state\
    \ = 0)\nclassifier.fit(X_train, y_train)\n\n# Predicting the Test set results\n\
    y_pred = classifier.predict(X_test)\n\n# Making the Confusion Matrix\nfrom sklearn.metrics\
    \ import confusion_matrix\ncm = confusion_matrix(y_test, y_pred)\n\n# Visualising\
    \ the Training set results\nfrom matplotlib.colors import ListedColormap\nX_set,\
    \ y_set = X_train, y_train\nX1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min()\
    \ - 1, stop = X_set[:, 0].max() + 1, step = 0.01),\n                     np.arange(start\
    \ = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))\nplt.contourf(X1,\
    \ X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),\n\
    \             alpha = 0.75, cmap = ListedColormap(('red', 'green')))\nplt.xlim(X1.min(),\
    \ X1.max())\nplt.ylim(X2.min(), X2.max())\nfor i, j in enumerate(np.unique(y_set)):\n\
    \    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],\n               \
    \ c = ListedColormap(('red', 'green'))(i), label = j)\nplt.title('Logistic Regression\
    \ (Training set)')\nplt.xlabel('Age')\nplt"
- code: "module example5_var4(x1, x2, x3, f);\ninput x1, x2, x3;\noutput f;\nreg f;\n\
    always @(x1 or x2 or x3)\n    case (x2)\n        4'b0000: f = x1;\n        4'b0001:\
    \ f = x3;\n        4'b0010: f = x3;\n        4'b0011: f = x1;\n        4'b0100:\
    \ f = x3;\n        4'b0101: f = x1;\n        4'b0110: f = x1;\n        4'b0111:\
    \ f = x3;\n        4'b1000: f = x1;\n        4'b1001: f = x3;\n        4'b1010:\
    \ f = x3;\n        4'b1011: f = x1;\n        4'b1100: f = x3;\n        4'b1101:\
    \ f = x1;\n        4'b1110: f = x1;\n        4'b1111: f = x3;\n    endcase\nendmodule\n\
    /example4.v.py\n#!/usr/bin/env python3\n\"\"\"\n@author: \n\"\"\"\nimport sys\n\
    import argparse\n\ndef main(argv):\n    parser = argparse.ArgumentParser(description='Generate\
    \ a variation of the example4 verilog file.')\n    parser.add_argument('input',\
    \ type=str, help='The input filename.')\n    parser.add_argument('output', type=str,\
    \ help='The output filename.')\n    parser.add_argument('varinstruction', type=str,\
    \ help='The instruction to generate the variation.')\n    parser.add_argument('varnumber',\
    \ type=str, nargs='?', help='The number of variations to generate.')\n    args\
    \ = parser.parse_args()\n    \n    instruc = args.varinstruction.split(',')\n\
    \    assert len(instruc) == 2 and instruc[0] in ('+', '-', '+=', '-=', '/=','/=',\
    \ 'and', 'or', '|', '^', 'xor'), 'Illegal variation instruction.'\n    assert\
    \ len(instruc[1]) == 1 and 'a' <= instruc[1] <= 'z', 'Illegal range variable.'\n\
    \    \n    inpnam = args.input\n    outnam = args.output\n    \n    inp = open(inpnam,\
    \ 'r')\n    inpstr = inp.readlines()\n    inp.close()\n\n    try:\n        if\
    \ args.varnumber:\n            num = int(args.varnumber)\n            assert num\
    \ > 1, 'Number of variations must be greater than 1.'\n        else:\n       \
    \     num = 2\n    except:\n        print('Error: Variation number must be an\
    \ integer.')\n        sys.exit()\n\n    out = open(outnam, 'w')\n    out.writelines(inpstr)\n\
    \    outstr = inpstr.copy()\n    \n    out.write('### Variation Instruction: ')\n\
    \    out.write(args.varinstruction)\n    out.write('\\n')\n    if args.varnumber:\n\
    \        out.write('# Variations: ')\n        out.write(args.varnumber)\n    \
    \    out.write('\\n')\n    out.write('### Modified Code: \\n')\n    \n    outstr[0]\
    \ = outstr[0].replace('##', '')\n    sizew, sizeh = outstr[0].count(instruc[1]),\
    \ outstr[0].count(';')\n    \n    for i in range(1, num):\n        forout.close()\n\
    \nif __name__ == '__main__':\n    main(sys.argv[1:])\n j in range(1, sizew+1):\n\
    \            for k in range(1, sizeh+1):\n                outstr[j] = outstr[j].replace('##',\
    \ str(i))\n        out.writelines(outstr)\n        outstr = inpstr.copy()"
- code: |-
    module example6(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (4 <= x2 <= 14)
            f = x1;
        else
            f = x3;
    endmodule
    """

    # example1
    src1 = """
    module example1(x, y, f);
      input x, y;
      output f;

      assign f = x * y;
    endmodule
    """

    # example2
    src2 = """
    module example2(x, y, f);
      input x, y;
      output f;

      assign f = x + y;
    endmodule
    """

    # example3
    src3 = """
    module example3(x, y, f);
      input x, y;
      output f;

      assign f = x + y;
    endmodule
    """

    # example4
    src4 = """
    module example4(x1, x2, x3, f);
      input x1, x2, x3;
      output f;

      always @(x1 or x2 or x3) begin
        if (x2 == 1)
          f = x1;
        else
          f = x3;
      end
    endmodule
    """

    # example5
    src5 = """
    module example5(x1, x2, x3, f);
      input x1, x2, x3;
      output f;

      assign f = x1;
    endmodule
    """

    # example6
    src6 = """
    module example6(x1, x2, x3, f);
      input x1, x2, x3;
      output f;

      always @(x1 or x2 or x3) begin
        if (4 <= x2 <= 14)
          f = x1;
        else
          f = x3;
      end
    endmodule
    """


    if __name__ == '__main__':
        # print(str(diff_code(src1, src2, src3)))
        # print(str(diff_code(src1, src2)))
        # print(str(diff_code(src3, src4)))
        # print(str(diff_code(src4, src5)))
        print(str(diff_code(src5, src6)))
- code: |-
    module example5(x1, x2, x3, f);
    input x1, x2, x3;
    output f;
    reg f;
    always @(x1 or x2 or x3)
        if (x2 == 1)
            f = x1;
        else if (x2[0] < 3)
            f = x3;
        else
            f = x3;
        else
            f = x3;
    endmodule
    ### Synthesis Command
- code: |-
    module mux4way1(d, sel, o);
    input din[3:0], sel;
    output o;
    wire d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15;// d0, d1, d2, d3 are intermediate signals
    //within the module
    assign o = {d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}[din[0], sel];
    endmodule
    ### Verification:
    Run the testbench.
    The expected output is as shown:
    ```
    Test_bench:
       module mux4way1(d, sel, o);
    input din[3:0], sel;
- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    ### Variation:
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    ### Base Verilog Code:
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single
- code: "module aoi_gate(o,a1,a2,b1,b2);\ninput a1,a2,b1,b2;// a1,a2,b1,b2 form the\
    \ input\n//ports of the module\noutput o;//o is the single output port of the\
    \ module\nwire o1,o2;//o1 and o2 are intermediate signals\n//within the module\n\
    and g1(o1,a1,a2); //The AND gate primitive has two\nand g2(o2,b1,b2);// instantiations\
    \ with assigned\n//names g1 & g2.\nnor g3(o,o1,o2);//The nor gate has one instantiation\n\
    //with assigned name g3.\nendmodule\n\n### Testbench Code:\nmodule aoi_tb;\n\n\
    reg a1,a2,b1,b2;//the input ports of the test\n//bench\nwire o;//the output port\
    \ of the test bench\n\nand g1(o,a1,a2);//one and gate is instantiated\n//with\
    \ assigned name g1\n\nand g2(o,b1,b2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g3(o,b1,b2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g4(o,a1,a2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g5(o,a1,a2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g6(o,a1,a2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g7(o,a1,a2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\nand g8(o,a1,a2);//and two gate is instantiated\n// with\
    \ assigned name g2\n\n/* a1 a2 b1 b2 o\n0 0 0 0 0\n0 0 1 0 0\n0 0 1 1 0\n1 0 0\
    \ 0 1\n1 0 0 1 1\n1 1 0 0 1\n1 1 0 1 1\n1 1 1 0 1\n1 1 1 1 1\n\n*/\nalways\n#20\n\
    begin\na1 = 0;\na2 = 0;\nb1 = 0;\nb2 = 0;\nend\n\nalways\n#20\nbegin\na1 = 0;\n\
    a2 = 0;\nb1 = 0;\nb2 = 0;\nend\n\nalways\n#20\nbegin\na1 = 0;\na2 = 1;\nb1 = 0;\n\
    b2 = 0;\nend\n\nalways\n#20\nbegin\na1 = 0;\na2 = 1;\nb1 = 0;\nb2 = 1;\nend\n\n\
    always\n#20\nbegin\na1 = 0;\na2 = 1;\nb1 = 1;\nb2 = 0;\nend\n\nalways\n#20\nbegin\n\
    a1 = 0;\na2 = 1;\nb1 = 1;\nb2 = 1;\nend\n\nalways\n#20\nbegin\na1 = 1;\na2 = 0;\n\
    b1 = 0;\nb2 = 0;\nend\n\nalways\n#20\nbegin\na1 = 1;\na2 = 0;\nb1 = 0;\nb2 = 1;\n\
    end\n\nalways\n#20\nbegin\na1 = 1;\na2 = 0;\nb1 = 1;\nb2 = 0;\nend\n\nalways\n\
    #20\nbegin\na1 = 1;\na2 = 0;\nb1 = 1;\nb2 = 1;\nend\n\nalways\n#20\nbegin\na1\
    \ = 1;\na2 = 1;\nb1 = 0;\nb2 = 0;\nend\n\nalways\n#20\nbegin\na1 = 1;\na2 = 1;\n\
    b1 = 0;\nb2 = 1;\nend\n\nalways\n#20\nbegin\na1 = 1;\na2 = 1;\nb1 = 1;\nb2 = 0;\n\
    end\n\nalways\n#20\nbegin\na1 = 1;\na2 = 1;\nb1 = 1;\nb2 = 1;\nend\n\ninitial\n\
    #500\n$finish;\nendmodule\n\n### Output of Testbench:\n#1400 @   5,   0 $timescale\
    \ = 10ns/1ps\n#2000 @   5,   0 $end\n#2000 @   5,   0 $finish\n#2000 @   5,  \
    \ 0$finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0$finish:\
    \ $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0$finish: $finish\n\
    #4000 @   6,   0 $finish: $finish\n#4000 @   6,   0$finish: $finish\n#4000 @ \
    \  6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,  \
    \ 0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish:\
    \ $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n\
    #4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @\
    \   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6, \
    \  0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish:\
    \ $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n\
    #4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @\
    \   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6, \
    \  0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish:\
    \ $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n\
    #4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @\
    \   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6, \
    \  0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish:\
    \ $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n\
    #4000 @   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @\
    \   6,   0 $finish: $finish\n#4000 @   6,   0 $finish: $finish\n#4000 @   6, \
    \  0 $finish: $finish\n\n### Performance:\n\u2022 For aoi_gate, 11 instances of\
    \ the primitive were replaced by 1 instance of the module.\n\u2022 11 instances\
    \ of 3-input NAND were replaced by 15 instances of the module.\n\u2022 Both of\
    \ the 15 instances of the module are used as 3-input NAND's.\n\u2022 The test\
    \ bench of aoi_gate ran 4 times faster than the original test bench.\n\n## Conclusion:\n\
    \nThe above experiment showed that we can replace a packed array with h"
- code: |-
    ```
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    ```
    ### Analysis:
    - The Verilog code above cannot be synthesized well because the `XMR` is not supported in current version. The synthesis engine will throw an error out like below.
    ```
    [Error] Error 123: Cannot convert hierarchical index to an unsigned type.
    ```/src/tests/unit_tests/unit_test_15_23.c
    #include "unit-test.h"

    bool test_15_23() {

        bool result = true;

        //
        // Test Case:
        //
        // module test();
        //   integer i;
        //   for (i=0; i<32; i=i+2)
        //     assign o = a? i : i-1;
        // end
        //
        // with the constraint that o is not driven.
        //
        // This is to test a bug in the xmr_assign_to_array_index()
        // function.  Basically, without the constraint, the
        // for-loop is transformed into the following for-loop
        // (where n is the upper bound on the for-loop):
        //
        // for (i=0; i<n; i=i)
        //   for (j=0; j<n; j=j+1)
        //     assign o[i][j] = a? i : i-1;
        // end
        //
        // The for-loop transformation is incorrect because the
        // outermost for-loop is unconstrained.  The outer loop
        // should be transformed into the following:
        //
        // for (i=0; i<n; i=i)
        //   for (j=0; j<n; j=j)
        //     assign o[i][j] = a? i : i-1;
        // end
        //
        // The result will be incorrect because a constraint
        // must be applied to the innermost for-loop.  An
        // alternative for this test case is to use this
        // code to test xmr_assign_to_array_index():
        //
        // module test();
        //   integer i;
        //   for (i=0; i<32; i=i+2)
- code: |-
    module aoi_gate(o,a1,a2,b1,b2);
    input a1,a2,b1,b2;// a1,a2,b1,b2 form the input
    //ports of the module
    output o;//o is the single output port of the module
    wire o1,o2;//o1 and o2 are intermediate signals
    //within the module
    and g1(o1,a1,a2); //The AND gate primitive has two
    and g2(o2,b1,b2);// instantiations with assigned
    //names g1 & g2.
    nor g3(o,o1,o2);//The nor gate has one instantiation
    //with assigned name g3.
    endmodule
    ### SMT-LIB-v2:
    (assert (or  a1 a2 b1 b2 (and a2 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and a1 b2 b1)))
    (assert (or  a1 a2 b1 b2 (and a2 b2 a1)))
    (assert (or  a1 a2 b1 b2 (and a1 b1 a2)))
    (assert (or  a1 a2 b1 b2 (and a1 b1 a2)))
    (assert (or  a1 a2 b1 b2 (and a1 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and a1 a2 b1)))
    (assert (or  a1 a2 b1 b2 (and a2 a1 b1)))
    (assert (or  a1 a2 b1 b2 (and a2 a1 b2)))
    (assert (or  a1 a2 b1 b2 (and a1 a2 a1)))
    (assert (or  a1 a2 b1 b2 (and a1 a2 a2)))
    (assert (or  a1 a2 b1 b2 (and a1 b1 b1)))
    (assert (or  a1 a2 b1 b2 (and a1 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and a1 b2 b1)))
    (assert (or  a1 a2 b1 b2 (and a2 b1 b1)))
    (assert (or  a1 a2 b1 b2 (and a2 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and a2 b2 b1)))
    (assert (or  a1 a2 b1 b2 (and b1 b1 b1)))
    (assert (or  a1 a2 b1 b2 (and b1 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and b1 b2 b1)))
    (assert (or  a1 a2 b1 b2 (and b2 b1 b1)))
    (assert (or  a1 a2 b1 b2 (and b2 b1 b2)))
    (assert (or  a1 a2 b1 b2 (and b2 b2 b1)))
    (assert (or  a1 a2 b1 b2 (and b2 b2 b2)))
    (check-sat)
    (get-model)
    ### Veri-fu result:
    This Veri-fu run is successful
    ### SMT-LIB-v2:
    (assert (and  a1 a1 a1))
    (assert (and  a1 a1 a2))
    (assert (and  a1 a2 a1))
    (assert (and  a1 a2 a2))
    (assert (and  a1 a2 b1))
    (assert (and  a1 a2 b2))
    (assert (and  a1 a2 b1))
    (assert (and  a1 a2 b2))
    (assert (and  a1 b1 b1))
    (assert (and  a1 b1 b2))
    (assert (and  a1 b2 b1))
    (assert (and  a1 b2 b2))
    (assert (and  a2 b1 b1))
    (assert (and  a2 b1 b2))
    (assert (and  a2 b2 b1))
    (assert (and  a2 b2 b2))
    (check-sat)
    (get-model)
    ### Veri-fu result:
    This Veri-fu run is successful
    ### SMT-LIB-v2:
    (assert (= a0 (and b1 b2)))
    (assert (= a2 (and a1 b2)))
    (assert (= a1 (and a2 b1)))
    (assert (= a1 (and a2 b2)))
    (assert (= a2 (and a1 b1)))
    (assert (= a1 (and a1 b1)))
    (assert (= a1 (and a1 b2)))
    (assert (= a0 (and a1 b1)))
    (assert (= a0 (and a2 b1)))
    (assert (= a1 (and a2 b2)))
    (assert (= a0 (and a1 a1)))
    (assert (= a2 (and a1 a2)))
    (assert (= a0 (and a2 a1)))
    (assert (= a1 (and a2 a2)))
    (assert (= a2 (and a1 b2)))
    (assert (= a2 (and a2 b2)))
    (assert (= a0 (and a2 b2)))
    (assert (= a1 (and a1 b1)))
    (assert (= a2 (and a1 b2)))
    (assert (= a0 (and a1 b2)))
    (assert (= a0 (and a2 b1)))
    (assert (= a0 (and a2 b2)))
    (assert (= a1 (and a2 b1)))
    (assert (= a1 (and a2 b2)))
    (assert (= a0 (and a2 b1)))
    (assert (= a0 (and a1 b1)))
    (assert (= a1 (and a1 b2)))
    (assert (= a2 (and a2 b2)))
    (assert (= a1 (and a1 b1)))
    (assert (= a2 (and a1 b1)))
    (assert (= a1 (and a1 b2)))
    (assert (= a2 (and a2 b1)))
    (assert (= a2 (and a2 b2)))
    (assert (= a2 (and a1 a2)))
    (assert (= a0 (and a1 a2)))
    (assert (= a0 (and a2 a1)))
    (assert (= a0 (and a2 a2)))
    (assert (= a1 (and a1 a1)))
    (assert (= a0 (and a1 a1)))
    (assert (= a2 (and a1 a2)))
    (assert (= a1 (and a1 a2)))
    (assert (= a0 (and a1 a1)))
    (assert (= a2 (and a2 a1)))
    (assert (= a2 (and a2 a2)))
    (assert (> (and a1 b1 b1) a0))
    (assert (> (and a1 b1 b2) a0))
    (assert (> (and a1 b2 b1) a0))
    (assert (> (and a1 b2 b2) a0))
    (assert (> (and a2 b1 b1) a0))
    (assert (> (and a2 b1 b2) a0))
    (assert (> (and a2 b2 b1) a0))
    (assert (> (and a2 b2 b2) a0))
    (assert (> (and a1 a1 b1) a0))
    (assert (> (and a1 a1 b2) a0))
    (assert (> (and a1 b1 b1) a0))
    (assert (> (and a1 b1 b2) a0))
    (assert (> (and a1 b2 b1) a0))
    (assert (> (and a1 b2 b2) a0))
    (assert (> (and a2 b1 b1) a0))
    (assert (> (and a2 b1 b2) a0))
    (assert (> (and a2 b2 b1) a0))
    (assert (> (and a2 b2 b2) a0))
    (assert (> (and a1 b1 a1) a0))
    (assert (> (and a1 b1 a2) a0))
    (assert (> (and a1 a2 b1) a0))
    (assert (> (and a1 a2 b2) a0))
    (assert (> (and a1 a2 a1) a0))
    (assert (> (and a1 a2 a2) a0))
    (assert (> (and b1 b1 b1) a0))
    (assert (> (and b1 b1 b2) a0))
    (assert (> (and b1 b2 b1) a0))
    (assert (> (and b1 b2 b2) a0))
    (assert (> (and b2 b1 b1) a
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    initial
    begin
    a1 = a[1:0];
    b1 = b[1:0];
    end
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule

    Updated on 21-Jan-2021 07:40:35
- code: "module oaibenh2(o,a,b); // Mixed structural/behavioral OAI\noutput o;\ninput[1:0]a,b;\n\
    wire a1,b1; // Outputs of OR gates\nreg o; // Behavioral output must be reg\n\
    // Structural OR gates using primitives\nor g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);\n\
    // Behavioral NAND logic sensitive to OR outputs\nalways@(a1 or b1)\nbegin\na1\
    \ <= a[1];\nb1 <= b[1];\nend\nalways@(a1) begin\no <= ~a1; end\nalways@(b1) begin\n\
    o <= ~b1; end\nendmodule\n\n## 12.1.4.9. AOI-OAI1: AOI1-OAI1\n\nAuthor: \n\n###\
    \ Base Verilog Code:\nmodule aoiai1(o,a,b,c); // Mixed structural/behavioral AOI/OAI\n\
    output o;\ninput[1:0]a,b,c;\nwire a1,b1,c1; // Outputs of AND/OR gates\nreg o;\
    \ // Behavioral output must be reg\n// Structural AND/OR gates using primitives\n\
    and g1(a1,a[1],a[0]), or g2(b1,b["
- code: |-
    module aoibeh3(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    begin // Procedural continuous assign
    a1 = a[1];  // Pack the bitslice to a1
    b1 = b[1];  // Pack the bitslice to b1
    end
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    ### Comments:
    The procedural continuous assigns are used to assign the outputs of the AND gates from the inputs. This can be done with a for loop.
    ### Test:
    module aoibeh3_test;
    // Instantiate top-level testbench module
    // Instantiate top-level module
    aoibeh3 top(o,a,b);
    // Instantiate stimulus generator
    gen var g;
    genvar i;
    // Instantiate two stimulus values
    genvar i0, i1;
    // Instantiate a, b signals
    wire[1:0] a, b;
    // Instantiate top-level testbench output
    reg q;
    // Instantiate an internal clock
    always #5 clk = ~clk;
    // Initialize internal clock to zero
    initial clk = 0;
    // Generate stimulus for a and b
    // a and b are packed into wires
    gen begin
    i0 = 0;
    i1 = 1;
    a <= {i0,i1};
    b <= {i1,i1};
    end
    // Initialize q to zero
    initial q = 0;
    // Print the initial stimulus
    initial
    $write("%d\n", a); // Print the initial stimulus$write("%d\n", b);
    // Print the initial output
    $write("%d\n", q); // Initialize testbench stimulus loop forever begin #5$finish;
    end
    endmodule
    ### Expected Output:
    module aoibeh3_test;
    // Instantiate top-level testbench module
    // Instantiate top-level module
    aoibeh3 top(o,a,b);
    // Instantiate stimulus generator
    gen var g;
    genvar i;
    // Instantiate two stimulus values
    genvar i0, i1;
    // Instantiate a, b signals
    wire[1:0] a, b;
    // Instantiate top-level testbench output
    reg q;
    // Instantiate an internal clock
    always #5 clk = ~clk;
    // Initialize internal clock to zero
    initial clk = 0;
    // Generate stimulus for a and b
    // a and b are packed into wires
    gen begin
    i0 = 0;
    i1 = 1;
    a <= {i0,i1};
    b <= {i1,i1};
    end
    // Initialize q to zero
    initial q = 0;
    // Print the initial stimulus
    initial
    $write("%d\n", a); // Print the initial stimulus$write("%d\n", b);
    // Print the initial output
    $write("%d\n", q); // Initialize testbench stimulus loop forever begin #5$finish;
    end
    endmodule

    ### Simulate Testbench

    In GHDL, the simulation script is named aoibeh3_test.tcl. The script contains the following commands:
    ghdl -a a
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule // Mixed structural/behavioral AOI
    endmodule

    ## Elaboration

    Elaborating this design results in the following code:

    ``````module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule

    // Outputs of AND gates
    always @(a or b)
    a1 = a[1];
    b1 = b[1];
    endmodule``````

    This design can be verified as follows:

    `verilator -Wno-lint --top-module aoibeh2 -M aoibeh2.v aoibeh2_tb.v aoibeh2.cpp`


    Elaboration

    ```module aoibeh2(o,a,b); // Mixed structural/behavioral AOI output o; input[1:0]a,b; wire a1,b1; // Outputs of AND gates reg o; // Behavioral output must be reg // Structural AND gates using primitives and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]); // Behavioral NOR logic sensitive to AND outputs always@(a1 or b1) o = ~(a1 || b1); endmodule // Outputs of AND gates always @(a or b) a1 = a[1]; b1 = b[1]; endmodule Elaboration Verilator 4.100 -Wno-lint --top-module aoibeh2 -M aoibeh2.v aoibeh2_tb.v aoibeh2.cpp Elaborated module AOI Behavioral AOI Beh_AOI aoibeh() aoibeh() aoibeh2(o,a,b); // Mixed structural/behavioral AOI output o; input[1:0]a,b; wire a1,b1; // Outputs of AND gates reg o; // Behavioral output must be reg // Structural AND gates using primitives and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]); // Behavioral NOR logic sensitive to AND outputs always@(a1 or b1) o = ~(a1 || b1); endmodule // Outputs of AND gates always @(a or b) a1 = a[1]; b1 = b[1]; endmodule AOI Beh_AOI ```

    ## Simulation

    Simulation can be done as follows:

    `./sim_aoibeh2`


    Simulation

    ```#1 @ 9.500ns a = 0001, b = 0001, o = 0001 a = 0000, b = 0000, o = 1001 a = 0001, b = 0000, o = 1001 a = 0000, b = 0001, o = 1001 a = 0001, b = 0001, o = 1001.E10 @ 9.500ns a = 0001, b = 0001, o = 0001 a = 0000, b = 0000, o = 1000 a = 0001, b = 0000, o = 1000 a = 0000, b = 0001, o = 1000 a = 0001, b = 0001, o = 1000.E10 @ 19.000ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000.E10 @ 28.500ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000.E10 @ 38.000ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000 #2 @ 47.500ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000.E10 @ 57.000ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000.E10 @ 66.500ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000.E10 @ 76.000ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b = 0001, o = 0001 a = 0001, b = 0001, o = 0000 #3 @ 85.500ns a = 0001, b = 0001, o = 0000 a = 0000, b = 0000, o = 0001 a = 0001, b = 0000, o = 0001 a = 0000, b =
- code: |-
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    ### Variation Codebook:
    ```
    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule
    ```
    ### Simulation Code:
    ```
    module aoibeh2tb();
    reg[1:0] a,b;

    initial begin
    $readmemh("a_values.hex", a);
    $readmemh("b_values.hex", b);
    end

    module aoibeh2(o,a,b); // Mixed structural/behavioral AOI
    output o;
    input[1:0]a,b;
    wire a1,b1; // Outputs of AND gates
    reg o; // Behavioral output must be reg
    // Structural AND gates using primitives
    and g1(a1,a[1],a[0]), g2(b1,b[1],b[0]);
    // Behavioral NOR logic sensitive to AND outputs
    always@(a1 or b1)
    o = ~(a1 || b1);
    endmodule

    initial begin
    // Testbench
    for(int i = 0; i < 4; i++) begin
    #5 o <= 1'b0;
    o <= a[i];
    #5 o <= 1'b0;
    o <= b[i];
    #5 o <= 1'b0;
    end
    end
    endmodule
    ```
    ### Test Data
- code: "```\nfor (int i = 0; i < 2; i++) {\n    boolean result = test_muxdff(i);\n\
    \    if (result!= 0) {\n        System.out.println(\"PASS\");\n    }\n    else\
    \ {\n        System.out.println(\"FAIL\");\n        break;\n    }\n```    else\
    \ {\n        return 0;\n    }\n}\n```\n/src/main/resources/verilog/VerilogModule/README.md\n\
    # Verilog module\n\n## Description\n\nImplementation of a module in Verilog. The\
    \ module is a multiplexer with 2 input signals and 1 output signal, and it uses\
    \ a single-bit register to store the output. The module is based on a [sequential\
    \ design](../SequentialDesign/README.md) and uses the [muxdff](../muxdff/README.md)\
    \ as a basic module.\n\n## File structure\n\n```\n.\n\u251C\u2500\u2500 Makefile\n\
    \u251C\u2500\u2500 README.md\n\u251C\u2500\u2500 muxdff_tb.sv\n\u251C\u2500\u2500\
    \ testbench.sv\n\u251C\u2500\u2500 testbench_results.txt\n\u251C\u2500\u2500 variables.sv\n\
    \u251C\u2500\u2500 verilog_output.txt\n\u251C\u2500\u2500 module_muxdff.v\n\u2514\
    \u2500\u2500 muxdff.v\n```\n\n## Module description\n\nThe module implements a\
    \ muxdff with 2 inputs (D0 and D1) and 1 output signal (Q) that is able to select\
    \ between the 2 inputs and store the result in an internal register that is clocked\
    \ by the module's `CLK` input.\n\n## Design structure\n\nThe muxdff design is\
    \ placed inside the `muxdff` module and the module is placed inside a `module_muxdff`\
    \ module.\n\n![module_muxdff](../module_muxdff.png)\n\n## Testing and verification\n\
    \nThe testing and verification of the module is done using the `testbench.sv`\
    \ file which is based on the `module_muxdff` and uses the `muxdff` module. The\
    \ tb file also contains the main module with the inputs, outputs and clock.\n\n\
    ## Output\n\nThe output from the testbench file is:\n\n```\nmodule_muxdff.v:988:\
    \ $error: Identifier \"D0\" not declared in this context.\nmodule_muxdff.v:989:\
    \ $error: Identifier \"D1\" not declared in this context.\nmodule_muxdff.v:989:\
    \ $error: Expression of type \"Integer\" not allowed in module instantiation\n\
    module_muxdff.v:990: $error: Expression of type \"Integer\" not allowed in module\
    \ instantiation\nmodule_muxdff.v:993: $error: Identifier \"Q\" not declared in\
    \ this context.\nmodule_muxdff.v:995: $error: Unreachable code at end of function\
    \ \"test_module_muxdff\".\ntestbench.sv:10: $error: SystemVerilog file \"module_muxdff.v\"\
    \ was not compiled\ntestbench.sv:10: $error: Program aborting at test bench time\n\
    ```\n\n## Variable file\n\nThe [variable](../variables.sv) file contains the module's\
    \ parameters and the ports.\n\n```\nmodule_muxdff module_muxdff(clk, D0, D1, Sel,\
    \ Q);\ninput clk;\ninput D0, D1, Sel;\noutput Q;\n```\n\n## Module implementation\n\
    \nThe module is implemented in the [module_muxdff.v](../module_muxdff.v) file.\n\
    \n```\nmodule module_muxdff(clk, D0, D1, Sel, Q);\ninput clk, D0, D1, Sel;\noutput\
    \ Q;\nmuxdff muxdff(clk, D0, D1, Sel, Q);\nendmodule\n```\n\n## Basic module implementation\n\
    \nThe [muxdff](../muxdff/README.md) module is implemented inside the module. In\
    \ order to create the module, it is necessary to include the [variable](../variables.sv)\
    \ file.\n\n```\nmodule muxdff(clk, D0, D1, Sel, Q);\ninput clk, D0, D1, Sel;\n\
    output Q;\nreg D0, D1, Sel, Q;\nalways @(posedge clk)\n    if (!Sel)\n       \
    \ Q <= D0;\n    else\n        Q <= D1;\nendmodule\n```\n\n## Testbench implementation\n\
    \nThe [testbench](../testbench.sv) file contains the testbench for the [module.sv](../module_muxdff.v)\
    \ file.\n\n```\n`include \"variables.sv\"\nmodule_muxdff module_muxdff(CLK, D0,\
    \ D1, Sel, Q);\ninput CLK, D0, D1, Sel;\noutput Q;\n\ninitial begin\n    clk =\
    \ 1'b0;\n    #(1) clk = 1'b1;\nend\n\nalways @(posedge CLK) begin\n    $display(\"\
    D0: %b, D1: %b, Sel: %b, Q: %b\", D0, D1, Sel, Q);\nend\n\ninitial begin\n   \
    \ #100;\n    $finish;\nend\nendmodule\n```\n\n## Makefile\n\nThere is a Makefile\
    \ that contains the necessary commands to compile the verilog file as well as\
    \ the testbench file in order to test and verify the module.\n\n```\nall:\n  \
    \  make run\n    make test\n    make verify\n\nclean:\n    make clean_run\n  \
    \  make clean_test\n\nrun:\n    iverilog testbench.sv\n\nclean_run:\n    rm -f\
    \ testbench.vvp testbench.vcd\n\ntest:\n    vvp testbench.vvp > testbench_results.txt\n\
    \nclean_test:\n    rm -f testbench.vvp testbench.vcd\n\nverify:\n    verilator\
    \ -Wall testbench.sv\n    make -C obj_dir/ -f Vtestbench.mk Vtestbench\n\nclean_verify:\n\
    \    rm -rf obj_dir\n```\n\n## Testbench output\n\nRunning the testbench:\n\n\
    ![run_tb](../run_tb.png)\n\nVerilog output:\n\n![verilog_output](../verilog_output.png)\n\
    \nThe testbench output is:\n\n```\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel:\
    \ 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1:\
    \ 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0:\
    \ 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q:\
    \ 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel:\
    \ 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1:\
    \ 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0:\
    \ 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q:\
    \ 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel:\
    \ 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1:\
    \ 0, Sel: 0, Q: 0\nD0: 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0, Sel: 0, Q: 0\nD0:\
    \ 0, D1: 0, Sel: 1, Q: 0\nD0: 0, D1: 0,"
- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    register [1:0] Q;
    always @(posedge Clock)
        if (!Sel)
            Q[0] <= D0;
        else
            Q[0] <= D1;
    endmodule
    ### Variation Instruction:
    Use inside in
- code: "### Verilog Code:\nmodule muxdff(D0, D1, Sel, Clock, Q);\ninput D0, D1, Sel,\
    \ Clock;\noutput Q;\nreg Q;\nparameter WIDTH = 2;\nassign Q = { {D0[WIDTH-1:0],\
    \ D1[WIDTH-1:0]}[Sel] };\nalways @(posedge Clock)\n    Q <= Q;\nendmodule\n##\
    \ Implementation\n### Parameters\n![muxdff_width_parameters.png](assets/muxdff_width_parameters.png)\n\
    ### Netlist\n![muxdff_width_netlist.png](assets/muxdff_width_netlist.png)\n###\
    \ Tracing\n![muxdff_width_timing.png](assets/muxdff_width_timing.png)\n![muxdff_width_trace.png](assets/muxdff_width_trace.png)\n\
    ## Simulation\n### Parameters\n![muxdff_width_parameters.png](assets/muxdff_width_parameters.png)\n\
    ### Netlist\n![muxdff_width_netlist.png](assets/muxdff_width_netlist.png)\n###\
    \ Results\n![muxdff_width.png](assets/muxdff_width.png)\n## Source Code\n### Code:\n\
    ```verilog\nmodule muxdff(D0, D1, Sel, Clock, Q);\ninput D0, D1, Sel, Clock;\n\
    output Q;\nreg Q;\nparameter WIDTH = 2;\nassign Q = { {D0[WIDTH-1:0], D1[WIDTH-1:0]}[Sel]\
    \ };\nalways @(posedge Clock)\n    Q <= Q;\nendmodule\n```\n/src/main/resources/markdown_pages/mux-4-1.md\n\
    # Mux-4-1\r\n## Description\r\nA mux41 is a multiplexer with width 1. It takes\
    \ 3 wires as input (D0, D1, Sel) and returns a single output (Q). It is called\
    \ a mux41 because it has a width of 4 instead of 2.\r\n## Verilog Code:\r\n###\
    \ Base Verilog Code:\r\nmodule mux41(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\n\
    output Q;\r\nreg Q;\r\nalways @(D0 or D1 or Sel) begin\r\n    if (!Sel) begin\r\
    \n        Q <= D0;\r\n    end\r\n    else begin\r\n        Q <= D1;\r\n    end\r\
    \nendmodule\r\n### Variation Instruction:\r\nUse inside in a while loop with the\
    \ tested operand being a packed array element via function call index.\r\n###\
    \ Modified Code:\r\n### Verilog Code:\r\nmodule mux41(D0, D1, Sel, Q);\r\ninput\
    \ D0, D1, Sel;\r\noutput Q;\r\nreg Q;\r\nassign Q = { D0[Sel], D1[Sel] };\r\n\
    always @(D0 or D1 or Sel)\r\n    Q <= Q;\r\nendmodule\r\n## Implementation\r\n\
    ### Parameters\r\n![mux41_width_parameters.png](assets/mux41_width_parameters.png)\r\
    \n### Netlist\r\n![mux41_width_netlist.png](assets/mux41_width_netlist.png)\r\n\
    ### Tracing\r\n![mux41_width_timing.png](assets/mux41_width_timing.png)\r\n![mux41_width_trace.png](assets/mux41_width_trace.png)\r\
    \n## Simulation\r\n### Parameters\r\n![mux41_width_parameters.png](assets/mux41_width_parameters.png)\r\
    \n### Netlist\r\n![mux41_width_netlist.png](assets/mux41_width_netlist.png)\r\n\
    ### Results\r\n![mux41_width.png](assets/mux41_width.png)\r\n## Source Code\r\n\
    ### Code:\r\n```verilog\r\nmodule mux41(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\
    \noutput Q;\r\nreg Q;\r\nassign Q = { D0[Sel], D1[Sel] };\r\nalways @(D0 or D1\
    \ or Sel)\r\n    Q <= Q;\r\nendmodule\r\n```\r\n/src/main/resources/markdown_pages/mux-4-2.md\n\
    # Mux-4-2\r\n## Description\r\nA mux42 is a multiplexer with width 2. It takes\
    \ 3 wires as input (D0, D1, Sel) and returns a single output (Q). It is called\
    \ a mux42 because it has a width of 4 instead of 2.\r\n### Base Verilog Code:\r\
    \nmodule mux42(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\noutput Q;\r\nreg Q;\r\
    \nalways @(D0 or D1 or Sel) begin\r\n    if (!Sel[1:0]) begin\r\n        Q <=\
    \ D0;\r\n    end\r\n    else begin\r\n        Q <= D1;\r\n    end\r\nendmodule\r\
    \n## Implementation\r\n### Parameters\r\n![mux42_width_parameters.png](assets/mux42_width_parameters.png)\r\
    \n### Netlist\r\n![mux42_width_netlist.png](assets/mux42_width_netlist.png)\r\n\
    ### Tracing\r\n![mux42_width_timing.png](assets/mux42_width_timing.png)\r\n![mux42_width_trace.png](assets/mux42_width_trace.png)\r\
    \n## Simulation\r\n### Parameters\r\n![mux42_width_parameters.png](assets/mux42_width_parameters.png)\r\
    \n### Netlist\r\n![mux42_width_netlist.png](assets/mux42_width_netlist.png)\r\n\
    ### Results\r\n![mux42_width.png](assets/mux42_width.png)\r\n## Source Code\r\n\
    ### Code:\r\n```verilog\r\nmodule mux42(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\
    \noutput Q;\r\nreg Q;\r\nalways @(D0 or D1 or Sel) begin\r\n    if (!Sel[1:0])\
    \ begin\r\n        Q <= D0;\r\n    end\r\n    else begin\r\n        Q <= D1;\r\
    \n    end\r\nendmodule\r\n```\r\n/src/main/resources/markdown_pages/mux-4-4.md\n\
    # Mux-4-4\r\n## Description\r\nA mux44 is a multiplexer with width 4. It takes\
    \ 3 wires as input (D0, D1, Sel) and returns a single output (Q). It is called\
    \ a mux44 because it has a width of 4 instead of 2.\r\n## Verilog Code:\r\n###\
    \ Base Verilog Code:\r\nmodule mux44(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\n\
    output Q;\r\nreg Q;\r\nalways @(D0 or D1 or Sel) begin\r\n    if (!Sel[3:0]) begin\r\
    \n        Q <= D0;\r\n    end\r\n    else begin\r\n        Q <= D1;\r\n    end\r\
    \nendmodule\r\n## Implementation\r\n### Parameters\r\n![mux44_width_parameters.png](assets/mux44_width_parameters.png)\r\
    \n### Netlist\r\n![mux44_width_netlist.png](assets/mux44_width_netlist.png)\r\n\
    ### Tracing\r\n![mux44_width_timing.png](assets/mux44_width_timing.png)\r\n![mux44_width_trace.png](assets/mux44_width_trace.png)\r\
    \n## Simulation\r\n### Parameters\r\n![mux44_width_parameters.png](assets/mux44_width_parameters.png)\r\
    \n### Netlist\r\n![mux44_width_netlist.png](assets/mux44_width_netlist.png)\r\n\
    ### Results\r\n![mux44_width.png](assets/mux44_width.png)\r\n## Source Code\r\n\
    ### Code:\r\n```verilog\r\nmodule mux44(D0, D1, Sel, Q);\r\ninput D0, D1, Sel;\r\
    \noutput Q;\r\nreg Q;\r\nalways @(D0 or D1 or Sel) begin\r\n    if (!Sel[3:0])\
    \ begin\r\n        Q <= D0;\r\n    end\r\n    else begin\r\n        Q <= D1;\r\
    \n    end\r\nendmodule\r\n```\r\n/src/main/resources/markdown_pages/mux-4-0.md\n\
    # Mux-4-0\n## Description\nA mux40 is a multiplexer with width 0. It takes 3 wires\
    \ as input (D0, D1, Sel) and returns a single"
- code: |-
    module muxdff(D0, D1, Sel, Clock, Q);
    input D0, D1, Sel, Clock;
    output Q;
    reg Q;
    D0 = packed_array[0];
    D1 = packed_array[1];
    Sel = packed_array[2];
    always @(posedge Clock)
        if (!Sel)
            Q <= D0;
        else
            Q <= D1;
    endmodule
    ### Expected Output:
    This will execute the top level entity which would read all the packed arrays and set the D0, D1 and Sel variables to the desired values.
    /README.md
    # Verilog
    Verilog and System Verilog
    /Digital System Designed With Verilog HDL/README.md
    ## Digital System Designed With Verilog HDL

    This repository contains all the examples and assignments done in the course of Digital System Designed With Verilog.

    ### Content of Repository:

    * Digital System Designed With Verilog HDL
    * [Assignment 1](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%201) - Implementation of a **Multiplexer** using **MUX Logic**
    * [Assignment 2](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%202) - Implementation of the **Adder-Subtracter** using 2 inputs
    * [Assignment 3](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%203) - Implementation of the **Adder-Subtracter** using 3 inputs
    * [Assignment 4](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%204) - Implementation of the **Multiplexer** using 2 inputs
    * [Assignment 5](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%205) - Implementation of the **Two-Bit-Adder**
    * [Assignment 6](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%206) - Implementation of the **Three-Bit-Adder**
    * [Assignment 7](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%207) - Implementation of the **Four-Bit-Adder**
    * [Assignment 8](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%208) - Implementation of the **Two-Bit-Subtractor**
    * [Assignment 9](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%209) - Implementation of the **3-Bit-Subtractor**
    * [Assignment 10](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2010) - Implementation of the **3-Bit-Multiplcation**
    * [Assignment 11](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2011) - Implementation of the **4-Bit-Multiplication**
    * [Assignment 12](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2012) - Implementation of the **2-Bit-Decrementer**
    * [Assignment 13](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2013) - Implementation of the **8-Bit-Binary-Counter**
    * [Assignment 14](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2014) - Implementation of the **4-Bit-Binary-Counter**
    * [Assignment 15](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2015) - Implementation of the **4-Bit-Binary-Adder**
    * [Assignment 16](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2016) - Implementation of the **8-Bit-Binary-Adder**
    * [Assignment 17](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2017) - Implementation of the **8-Bit-Binary-Subtractor**
    * [Assignment 18](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2018) - Implementation of the **4-Bit-Binary-Subtractor**
    * [Assignment 19](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2019) - Implementation of the **4-Bit-Binary-Multiplier**
    * [Assignment 20](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2020) - Implementation of the **4-Bit-Binary-Decrementer**
    * [Assignment 21](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2021) - Implementation of the **7-Bit-Binary-Counter**
    * [Assignment 22](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2022) - Implementation of the **16-Bit-Binary-Counter**
    * [Assignment 23](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2023) - Implementation of the **7-Bit-Binary-Adder**
    * [Assignment 24](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2024) - Implementation of the **16-Bit-Binary-Adder**
    * [Assignment 25](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2025) - Implementation of the **16-Bit-Binary-Subtractor**
    * [Assignment 26](https://github.com/dusankod/Verilog/tree/master/Digital%20System%20Designed%20With%20Verilog%20HDL/Assignment%2026) - Implementation of the **7-
- code: |-
    ```
    function [1:0] mux(wire [1:0] D0, wire [1:0] D1, wire [1:0] Sel);
    reg [1:0] Q;

    always @(posedge clock)
        if (Sel[1])
            Q <= D0;
        else if (Sel[0])
            Q <= D1;
        else if (Sel[1] && Sel[0])
            Q <= D0;
    endfunction

    ```
    Upvotes: 0
- code: |-
    module simple_mem(address, data_in, data_out, wr_en, rd_en);
    input [15:0] address;
    input data_in;
    output data_out;
    output reg [1:0] wr_en, rd_en;
    reg [15:0] mem [0:1023];
    wire [15:0] mem_wr;
    wire [15:0] mem_rd;

    assign mem_wr = address;
    assign mem_rd = address;

    always @(posedge wr_en)
    begin
    if (wr_en[0])
    mem[mem_wr] = data_in;
    end

    assign data_out = mem[mem_rd];

    always @(posedge rd_en) begin
    rd_en = rd_en;
    end

    endmodule
- code: |-
    module d_type_component(data, clock, r, s, out);
    input clock, r, s, data;
    output out;
    reg out;
    always @ (posedge clock)
    begin
    if (r)
    out = 0;
    else
    if (s)
    out = (data[3:2] == 2'b01)? 2'b00 : data;
    else
    out = out;
    end
    end
    endmodule
- code: "module dff_with_reset(data, clock, r, out);\ninput clock, r, data;\noutput\
    \ out;\nreg out;\nalways @(posedge clock or posedge r)\nbegin\nif (r)\nout = 0;\n\
    else\nout = data;\nend\nendmodule\n### Verilog Testbench Code:\nmodule tb_dff_with_reset;\n\
    input clk;\nreg dff_reset_in, dff_data_in, dff_output;\ndff_with_reset dff\n(\n\
    .data (dff_data_in),\n.clock (clk),\n.r(dff_reset_in),\n.out (dff_output)\n);\n\
    initial clk = 0;\ninitial dff_data_in = 1;\ninitial dff_reset_in = 0;\nalways\
    \ #5 clk = ~clk;\ninitial $dumpfile(\"dff_with_reset.vcd\"); initial$dumpvars(0,tb_dff_with_reset);\n\
    initial begin\n$dumpvars(0,dff_with_reset); end endmodule ### Resultant Image:\
    \ The above resultant image is shown with the help of a waveform viewer generated\
    \ through the use of 'vcd' file. \u2022 In the above image, the blue and green\
    \ arrows are clock. And the red arrow is the reset input. \u2022 The red arrows\
    \ represent the data, reset and clock inputs. \u2022 The blue arrows represent\
    \ the output. \u2022 The green arrows represent the data and the reset. \u2022\
    \ The black arrows represent the data and the clock. ### Conclusion: It is quite\
    \ a simple circuit that does not need much of explanation. However, the problem\
    \ is to understand with the use of a working demo, which is quite a good thing\
    \ to do, it is quite easy to understand. ### References: 1. Digital Logic Design\
    \ by  1.0# The Output of Half-Adder: In the previous article, we discussed the\
    \ working of the 1-Bit adder. Half adders are also used in the 1-bit adder. Now,\
    \ we will discuss how the half adder is built using a gate. ### Theory: Half-Adder:\
    \ \u2022 A half-adder is a 1-bit adder without the carry output. \u2022 It adds\
    \ two bits and gives the sum output. \u2022 It has two inputs (A,B). \u2022 It\
    \ has two outputs (S,C) \u2022 Carry output: 1 if the sum is greater than 1 and\
    \ 0 otherwise \u2022 Sum output: Only the least significant bit \u2022 The outputs\
    \ can be written as: $$S = A \\oplus B$$ $$C = A \\cdot B$$ Where A and B are\
    \ the two inputs, S is the sum output and C is the carry output. ### Schematic\
    \ Diagram: It can be written in the following form: ### Code: module half_adder(a,\
    \ b, sum, carry); input a, b; output sum, carry; wire sum; wire carry; assign\
    \ sum = a ^ b; assign carry = a & b; endmodule ### Testbench Code: module tb_half_adder;\
    \ input clock; wire sum_o, carry_o; half_adder half_adder1\n(\n.a (clock),\n.b\
    \ (clock),\n.carry (carry_o),\n.sum (sum_o)\n);\ninitial clock = 1;\ninitial begin\
    \ $dumpvars(0, tb_half_adder); end initial begin$finish;\nendmodule\n\n### Resultant\
    \ Image:\n\nThe above resultant image is shown with the help of a waveform viewer\
    \ generated through the use of 'vcd' file.\n\n\u2022 In the above image, the blue\
    \ arrows are clock.\n\u2022 The red arrows represent the data, carry and the sum\
    \ inputs.\n\u2022 The blue arrows represent the output.\n\u2022 The green arrows\
    \ represent the data and the carry.\n\u2022 The black arrows represent the data\
    \ and the sum.\n\n### Conclusion: It is quite a simple circuit that does not need\
    \ much of explanation. However, the problem is to understand with the use of a\
    \ working demo, which is quite a good thing to do.\n\n### References:\n\n1. Digital\
    \ Logic Design by \n\n1.1# The Output of Full Adder: In the previous article,\
    \ we discussed the working of the 1-Bit adder. Now, we will discuss how the half\
    \ adder is built using a gate.\n\n### Theory: Full-Adder:\n\n\u2022 A full adder\
    \ is a 2-bit adder without the carry output.\n\u2022 It adds three bits and gives\
    \ the sum output.\n\u2022 It has three inputs (A,B,Cin).\n\u2022 It has two outputs\
    \ (S,Cout).\n\u2022 Carry output: 1 if the sum is greater than 1 and 0 otherwise\n\
    \u2022 Sum output: Only the least significant bit\n\u2022 The outputs can be written\
    \ as: $$S = A \\oplus B$$\n\n$$C = A \\cdot B$$\n\nWhere A and B are the two inputs,\
    \ S is the sum output and C is the carry output.\n\n### Schematic Diagram: It\
    \ can be written in the following form:\n\n### Code:\n\nmodule full_adder(a, b,\
    \ cin, sum, carry);\ninput a, b, cin;\noutput sum, carry;\nwire cin_gate, sum_gate;\n\
    assign sum = a ^ b;\nassign carry = a & b;\nassign cin_gate = a | b | cin;\nassign\
    \ sum_gate = sum | carry;\nendmodule\n\n### Testbench Code:\n\nmodule tb_full_adder;\n\
    input clk;\nreg clock;\nwire sum_o, carry_o;\nfull_adder full_adder1\n(\n.a (clk),\n\
    .b (clock),\n.cin (clock),\n.sum (sum_o),\n.carry (carry_o)\n);\ninitial clk =\
    \ 1;\ninitial begin $dumpvars(0, tb_full_adder); end initial begin$finish;\nendmodule\n\
    \n### Resultant Image:\n\nThe above resultant image is shown with the help of\
    \ a waveform viewer generated through the use of 'vcd' file.\n\n\u2022 In the\
    \ above image, the blue arrows are clock.\n\u2022 The red arrows represent the\
    \ data, carry and the sum inputs.\n\u2022 The blue arrows represent the output.\n\
    \u2022 The green arrows represent the data and the carry.\n\u2022 The black arrows\
    \ represent the data and the sum.\n\n### Conclusion: It is quite a simple circuit\
    \ that does not need much of explanation. However, the problem is to understand\
    \ with the use of a working demo, which is quite a good thing to do.\n\n### References:\n\
    \n1. Digital Logic Design by \n\n1.2# The Output of 4 bit Binary To BCD Converter:\
    \ In the previous article, we discussed the working of the 4 bit Binary to BCD\
    \ converter. Now, we will discuss how the 4-bit BCD to binary converter is built\
    \ using a gate.\n\n### Theory: 4-bit Binary to BCD Converter:\n\n\u2022 It is\
    \ a 4-bit binary to BCD converter.\n\u2022 It can convert binary of 0000 to 9999\
    \ to 0000 to 9999 in a cycle.\n\u2022 It takes in 4-bit binary input.\n\u2022\
    \ It has 4 outputs (BCD1,BCD2,BCD3,BCD4)\n\u2022 It has one input (Binary)\n\u2022\
    \ The outputs can be calculated using the following equation:\n\nBCD = Binary/1000\n\
    \n### Schematic Diagram: It can be written in the following form:\n\n### Code:\n\
    \nmodule bcd_to_bin(binary[3:0],BCD1[3:0],BCD2[3:0],BCD3[3:0],BCD4[3:0]);\ninput\
    \ [3:0]binary;\noutput [3:0]BCD1,BCD2,BCD3,BCD4;\n\nbcd_to_bin bcd_to_bin_1\n\
    (\n.binary (binary),\n.BCD1 (BCD1),\n.BCD2 (BCD2),\n.BCD3 (BCD3),\n.BCD4 (BCD4)\n\
    );\nendmodule\n\n### Testbench Code:\n\nmodule tb_bcd_to_bin;\nreg [3:0]bin;\n\
    bcd_to_bin bcd_to_bin_1\n(\n.binary (bin),\n.BCD1 (bin),\n.BCD2 (bin),\n.BCD3\
    \ (bin),\n.BCD4 (bin)\n);\ninitial bin = 0;\ninitial begin $dumpvars(0, tb__bcd_to_bin);\
    \ end initial begin$finish;\nendmodule\n\n### Resultant Image:\n\nThe above resultant\
    \ image is shown with the help of a waveform viewer generated through the use\
    \ of 'vcd' file.\n\n\u2022 In the above image, the blue arrows are clock.\n\u2022\
    \ The red arrows represent the data, BCD1,BCD2,BCD3 and BCD4.\n\u2022 The blue\
    \ arrows represent the output.\n\u2022 The green arrows represent the data and\
    \ the BCD1.\n\u2022 The black arrows represent the data and the BCD2.\n\u2022\
    \ The yellow arrows represent the data and the B"
- code: |-
    entity dff_with_reset is
    port (data, clock, r, out: in bit;
    out: out bit);
    end entity;

    architecture RTL of dff_with_reset is
    signal out: bit;
    begin
    process (data, clock, r)
    begin
    if r then
    out <= '0';
    else
    out <= data;
    end if;
    end process;
    end architecture;

    ## Verilog-AMS Code

    module dff_with_reset #(parameter RST_VAL = 0)
    (input clk, rst, input data, output reg out);
    always @ (posedge clk or negedge rst)
    begin
    if (rst)
    out = RST_VAL;
    else
    out = data;
    end
    endmodule
    ### Variation Instruction:
    Use the SSI function, provided in the SystemVerilog standard library,
- code: |-
    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    if (out!= out_prev)
    out_prev <= out;
    end
    endmodule
    ### Output:

    ## Final Code:

    module dff_with_reset(data, clock, r, out);
    input clock, r, data;
    output out;
    reg out, out_prev;
    initial
    out_prev = 0;
    always @(posedge clock or posedge r)
    begin
    if (r)
    out = 0;
    else
    out = data;
    out <= out;
    if (out!= out_prev)
    out_prev <= out;
    end
    endmodule

    ## Conclusion:

    In this article, we have seen an example of using the inside operator inside a procedural block to check array membership in a part-select range.
- code: "module EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg, yReg;\n\
    assign xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n\
    \    if(a & b){\n        xReg <= c;\n        if(c){\n            yReg <= b & c;\n\
    \        } else {\n            yReg <= (!(c) &!(b));\n        }\n    } else {\n\
    \        xReg <= b;\n        yReg <= c;\n    }\nend\nendmodule\n\"\"\"\n\nEXPECTED_OUTPUT_ERROR2\
    \ = \"\"\"\nmodule EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg,\
    \ yReg;\nassign xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n\
    \    xReg <= a & b & c;\n    yReg <= (b | c) ^ a;\nend\nendmodule\nAdd a nested\
    \ if using inside with a 3D array slice selected by variable to test range inclusion.\n\
    module EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg, yReg;\nassign\
    \ xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n    if(a\
    \ & b){\n        xReg <= c;\n        if(c){\n            yReg <= b & c;\n    \
    \    } else {\n            yReg <= (!(c) &!(b));\n        }\n    } else {\n  \
    \      xReg <= b;\n        yReg <= c;\n    }\nend\nendmodule\n\"\"\"\n\nEXPECTED_OUTPUT_ERROR3\
    \ = \"\"\"\nmodule EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg,\
    \ yReg;\nassign xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n\
    \    xReg <= a & b & c;\n    yReg <= (b | c) ^ a;\nend\nendmodule\nAdd a nested\
    \ if using inside with a 3D array slice selected by variable to test range inclusion.\n\
    module EventCtlPart (output xPart, yPart, input a, b, c);\nreg xReg, yReg;\nassign\
    \ xPart = xReg;\nassign yPart = yReg;\nalways @(a, b)\nbegin: PartList\n    if(a\
    \ & b){\n        xReg <= c;\n        if(c){\n            yReg <= b & c;\n    \
    \    } else {\n            yReg <= (!(c) &!(b));\n        }\n    } else {\n  \
    \      xReg <= b;\n        yReg <= c;\n    }\nend\nendmodule\nAdd a nested if\
    \ using inside with a 3D array slice selected by variable to test range inclusion.\n\
    \"\"\"\n\nTESTS = [\n    (\n        input_string,\n        output_string,\n  \
    \      expected_output_error,\n        True,\n    ),\n    (\n        input_string2,\n\
    \        output_string2,\n        expected_output_error2,\n        True,\n   \
    \ ),\n    (\n        input_string3,\n        output_string3,\n        expected_output_error3,\n\
    \        True,\n    ),\n    (\n        input_string_error,\n        output_string_error,\n\
    \        expected_output,\n        True,\n    ),\n    (\n        input_string_error2,\n\
    \        output_string_error2,\n        expected_output_error,\n        True,\n\
    \    ),\n    (\n        input_string_error3,\n        output_string_error3,\n\
    \        expected_output_error3,\n        True,\n    ),\n]\n/pydactyl/helpers.py\n\
    import re\nfrom.config import CONFIG\nfrom.patterns import PATTERNS, PATTERNS_ERROR\n\
    from.utils import *\n\ndef is_instruction_code(code):\n    output = \"\"\n   \
    \ code_lines = code.split(\"\\n\")\n\n    for line in code_lines:\n        if\
    \ re.match(r\"\\s*module.*\", line):\n            return True\n        else:\n\
    \            continue\n        \n    return False\n\n\ndef handle_instruction(code):\n\
    \    lines = code.split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"\
    ### \") and line.endswith(\" ###\"):\n            return line[4:-4]\n        else:\n\
    \            continue\n    return False\n\n\ndef handle_input(code):\n    lines\
    \ = code.split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"\
    input \") and line.endswith(\";\"):\n            return line[6:-1]\n        else:\n\
    \            continue\n    return False\n\n\ndef handle_output(code):\n    lines\
    \ = code.split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"\
    output \") and line.endswith(\";\"):\n            return line[7:-1]\n        else:\n\
    \            continue\n    return False\n\n\ndef handle_always(code):\n    lines\
    \ = code.split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"\
    always @(\"):\n            return line[9:]\n        else:\n            continue\n\
    \    return False\n\n\ndef handle_nested_if(code):\n    lines = code.split(\"\\\
    n\")\n    for line in lines:\n        if line.startswith(\"if(\"):\n         \
    \   return line[3:]\n        else:\n            continue\n    return False\n\n\
    \ndef handle_begin(code):\n    lines = code.split(\"\\n\")\n    for line in lines:\n\
    \        if line.startswith(\"begin:\"):\n            return line[6:]\n      \
    \  else:\n            continue\n    return False\n\n\ndef handle_end(code):\n\
    \    lines = code.split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"\
    end:\"):\n            return line[4:]\n        else:\n            continue\n \
    \   return False\n\n\ndef handle_assign(code):\n    lines = code.split(\"\\n\"\
    )\n    for line in lines:\n        if line.startswith(\"assign \") and line.endswith(\"\
    ;\"):\n            return line[7:-1]\n        else:\n            continue\n  \
    \  return False\n\n\ndef handle_always_code(code):\n    lines = code.split(\"\\\
    n\")\n    if len(lines) > 1:\n        for line in lines[1:]:\n            if line.startswith(\"\
    \    \") and line.endswith(\";\"):\n                return line[4:-1]\n      \
    \      else:\n                continue\n    return False\n\n\ndef handle_always_code_error(code):\n\
    \    lines = code.split(\"\\n\")\n    if len(lines) > 1:\n        for line in\
    \ lines[1:]:\n            if line.startswith(\"    \") and (line.endswith(\";\"\
    ) or re.match(PATTERNS_ERROR, line)):\n                return line[4:]\n     \
    \       else:\n                continue\n    return False\n\n\ndef handle_always_code_error2(code):\n\
    \    lines = code.split(\"\\n\")\n    if len(lines) > 1:\n        for line in\
    \ lines[1:]:\n            if line.startswith(\"    \") and (line.endswith(\";\"\
    ) or re.match(PATTERNS_ERROR, line)) and re.match(r\"begin.*end\", line):"
- code: |-
    ### Base Verilog Code:
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    assign xPart = xReg
- code: "module EventCtlPart_v2 (output xPart, yPart, input a, b, c);\n\nreg xReg,\
    \ yReg;\nassign xPart = xReg;\nassign yPart = yReg;\n\nalways @(a,b)\nbegin: PartList\n\
    \    xReg <= a & b & c;\n    yReg <= (b | c) ^ a;\nend\nendmodule\n\n### Generated\
    \ Verilog:\nmodule EventCtlPart_v2 (output xPart, yPart, input a, b, c);\n   \
    \ reg xReg, yReg;\n    output xPart;\n    output yPart;\n    input a;\n    input\
    \ b;\n    input c;\n    always @(a,b) begin: PartList\n        xReg <= a & b &\
    \ c;\n        yReg <= (b | c) ^ a;\n    end\nendmodule\n\n### Results:\nThe original\
    \ code has a more straightforward flow, but the Verilog generated by it is longer\
    \ as it requires a 2D to represent all 8 nested ifs. The modified version uses\
    \ a 3D array to represent the 8 different branching possibilities. This is not\
    \ as clear on the flow, but simplifies the Verilog code.\n### Notes:\nI am not\
    \ sure if the modified code is correct. I tried to simplify it to an array of\
    \ 32 elements. The array index was determined using a 2 bit variable. But I couldn't\
    \ use a 3 bit variable. The 3 bit variable is not supported in System Verilog.\n\
    #include \"EventCtlPart_v2.h\"\n#include <iostream>\n\n//int main()\nint main(int\
    \ argc, char* argv[])\n{\n    std::vector<EventCtlPart_v2*> instances;\n    char\
    \ ch;\n    int a, b, c;\n    do {\n        std::cout << \"Enter a, b, c values:\"\
    ;\n        std::cin >> a >> b >> c;\n        std::cout << \"Create a new instance?\
    \ (y/n):\";\n        std::cin >> ch;\n        \n        EventCtlPart_v2* part;\n\
    \        \n        if ((ch == 'y') || (ch == 'Y'))\n        {\n            part\
    \ = new EventCtlPart_v2;\n            instances.push_back(part);\n        }\n\
    \       ut << part->xPart << \" | \" << part->yPart << std::endl;\n        } \
    \  \n    } while (ch == 'y' || ch == 'Y');\n}\n \n        if (part!= NULL)\n \
    \       {\n            part->a = a;\n            part->b = b;\n            part->c\
    \ = c;\n            \n            std::co:\n\tg++ -c EventCtlPart.cpp\n\nEventCtlPart_v2.o:\
    \ EventCtlPart_v2.cpp EventCtlPart_v2.h\n\tg++ -c EventCtlPart_v2.cpp\n\nmain.o:\
    \ main.cpp\n\tg++ -c main.cpp\n\nclean:\n\trm *.o\nEventCtlPart: EventCtlPart.o\
    \ EventCtlPart_v2.o main.o\n\tg++ -o EventCtlPart EventCtlPart.o EventCtlPart_v2.o\
    \ main.o\n\nEventCtlPart.o"
- code: |-
    module E1Part3(output xPart, yPart, input a, b, c);
    reg xReg, yReg;
    reg [2:0] test;
    assign test = a? {2'b00 : 2'b01} : {2'b01 : 2'b00};
    assign xPart = xReg;
    assign yPart = yReg;
    if(a & b & c)
        xPart <= xReg;
    else if((a & b & c) | ~(b
- code: |-
    module EventCtlPart (output xPart, yPart, input a, b, c);
    reg xPart, yPart;
    assign xPart = xReg;
    assign yPart = yReg;
    always @(a, b, c)
    begin: PartList
        xReg <= a & b & c;
        yPart <= (b | c) ^ a;
    end
    endmodule
    ### Testbench Code:
    module EventCtlPartTB;
    reg a, b, c;
    wire xPart, yPart;
    assign a = 1;
    assign b = 1;
    assign c = 1;
    EventCtlPart uut (xPart, yPart, a, b, c);
    initial begin
     #100;
     a = 0;
     #100;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #300;
     a = 0;
     #300;
     a = 1;
     #3
- code: "module dff(do,di,clk); // Behavioral D Flip-Flop\noutput do;\ninput di,clk;\n\
    reg do; // Output must be reg for procedural assignment\ninitial\ndo=1'b0; //\
    \ Initialize output\n// Assign input 'di' to output 'do' on negative clock edge\n\
    always@(negedge clk) case(di) 1'd0: do=1'd1; 1'd1: do=1'd0;endcase\nendmodule\n\
    ### Testbench Code:\nmodule tb;\nreg clk;\ndff d1(.do(do),.di(di),.clk(clk));\n\
    initial\nforever begin\ndi = 1;\n#5 clk = ~clk;\n#1 clk = ~clk;\nend\nendmodule\n\
    /Lab4/Lab4_1.md\n# Lab4_1_1\n\n### Code:\nadd\nmodule add(A,B,C);\noutput [8:0]\
    \ sum;\ninput [8:0] A,B;\nreg [8:0] C;\nalways@(posedge C) sum = {A,B};\nendmodule\n\
    ### Testbench Code:\nmodule tb;\nreg A,B,C;\nadd adder(.A(A),.B(B),.C(C));\nalways\n\
    $display(\"A=%d\",A);\n$display(\"B=%d\",B);\n$display(\"C=%d\",C);\n$display(\"\
    =========================\");\nendmodule\n### Simulation Output:\n![Lab4_1_1](https://i.imgur.com/1N4j3qE.jpg)\n\
    # Lab4_1_2\n### Code:\nadd\nmodule add(A,B,C);\noutput [8:0] sum;\ninput [8:0]\
    \ A,B;\nreg [8:0] C;\nalways@(negedge C) sum = {A,B};\nendmodule\n### Testbench\
    \ Code:\nmodule tb;\nreg A,B,C;\nadd adder(.A(A),.B(B),.C(C));\nalways\n$display(\"\
    A=%d\",A);\n$display(\"B=%d\",B);\n$display(\"C=%d\",C);\n$display(\"=========================\"\
    );\nendmodule\n### Simulation Output:\n![Lab4_1_2](https://i.imgur.com/J6F6mQe.jpg)\n\
    # Lab4_1_3\n### Code:\nadd\nmodule add(A,B,C);\noutput [8:0] sum;\ninput [8:0]\
    \ A,B;\nreg [8:0] C;\nalways@(posedge A,B) sum = {A,B};\nendmodule\n### Testbench\
    \ Code:\nmodule tb;\nreg A,B,C;\nadd adder(.A(A),.B(B),.C(C));\nalways\n$display(\"\
    A=%d\",A);\n$display(\"B=%d\",B);\n$display(\"C=%d\",C);\n$display(\"=========================\"\
    );\nendmodule\n### Simulation Output:\n![Lab4_1_3](https://i.imgur.com/8N69v1J.jpg)\n\
    # Lab4_1_4\n### Code:\nadd\nmodule add(A,B,C);\noutput [8:0] sum;\ninput [8:0]\
    \ A,B;\nreg [8:0] C;\nalways@(negedge A,negedge B) sum = {A,B};\nendmodule\n###\
    \ Testbench Code:\nmodule tb;\nreg A,B,C;\nadd adder(.A(A),.B(B),.C(C));\nalways\n\
    $display(\"A=%d\",A);\n$display(\"B=%d\",B);\n$display(\"C=%d\",C);\n$display(\"\
    =========================\");\nendmodule\n### Simulation Output:\n![Lab4_1_4](https://i.imgur.com/W6iLhYk.jpg)\n\
    /Lab4/Lab4_2.md\n# Lab4_2_1\n### Code:\nmux\nmodule mux(x,y,sel,z);\noutput z;\n\
    input x,y,sel;\nalways @*\ncase(sel)\n\t2'b00: z=x;\n\t2'b01: z=y;\n\t2'b10: z=x;\n\
    \t2'b11: z=y;\nendcase\nendmodule\n### Testbench Code:\nmodule tb;\nreg [1:0]\
    \ x,y,sel;\nwire z;\nmux sel_mux(.x(x),.y(y),.sel(sel),.z(z));\n\nalways\n$display(\"\
    x=%d\",x);\n$display(\"y=%d\",y);\n$display(\"sel=%d\",sel);\n$display(\"z=%d\"\
    ,z);\n$display(\"=========================\");\nendmodule\n### Simulation Output:\n\
    ![Lab4_2_1](https://i.imgur.com/f9X228k.jpg)\n# Lab4_2_2\n### Code:\nmux\nmodule\
    \ mux(x,y,sel,z);\noutput z;\ninput x,y,sel;\nalways @*\ncase(sel)\n\t2'b00: z=x;\n\
    \t2'b01: z=y;\n\t2'b10: z=x;\n\t2'b11: z=y;\nendcase\nendmodule\n### Testbench\
    \ Code:\nmodule tb;\nreg [1:0] x,y,sel;\nwire z;\nmux sel_mux(.x(x),.y(y),.sel(sel),.z(z));\n\
    \nalways\n$display(\"x=%d\",x);\n$display(\"y=%d\",y);\n$display(\"sel=%d\",sel);\n\
    $display(\"z=%d\",z);\n$display(\"=========================\");\nendmodule\n###\
    \ Simulation Output:\n![Lab4_2_2](https://i.imgur.com/yK0x0b6.jpg)\n# Lab4_2_3\n\
    ### Code:\nmux\nmodule mux(x,y,sel,z);\noutput z;\ninput x,y,sel;\nalways @*\n\
    case(sel)\n\t2'b00: z=x;\n\t2'b01: z=y;\n\t2'b10: z=x;\n\t2'b11: z=y;\nendcase\n\
    endmodule\n### Testbench Code:\nmodule tb;\nreg [1:0] x,y,sel;\nwire z;\nmux sel_mux(.x(x),.y(y),.sel(sel),.z(z));\n\
    \nalways\n$display(\"x=%d\",x);\n$display(\"y=%d\",y);\n$display(\"sel=%d\",sel);\n\
    $display(\"z=%d\",z);\n$display(\"=========================\");\nendmodule\n###\
    \ Simulation Output:\n![Lab4_2_3](https://i.imgur.com/e9hQ68L.jpg)\n# Lab4_2_4\n\
    ### Code:\nmux\nmodule mux(x,y,sel,z);\noutput z;\ninput x,y,sel;\nalways @*\n\
    case(sel)\n\t2'b00: z=x;\n\t2'b01: z=y;\n\t2'b10: z=x;\n\t2'b11: z=y;\nendcase\n\
    endmodule\n### Testbench Code:\nmodule tb;\nwire [1:0] x,y,sel;\nwire z;\nmux\
    \ sel_mux(.x(x),.y(y),.sel(sel),.z(z));\n\nalways\n$display(\"x=%d\",x);\n$display(\"\
    y=%d\",y);\n$display(\"sel=%d\",sel);\n$display(\"z=%d\",z);\n$display(\"=========================\"\
    );\nendmodule\n### Simulation Output:\n![Lab4_2_4](https://i.imgur.com/34U33f9.jpg)\n\
    # Lab4_2_5\n### Code:\nmux\nmodule mux(x,y,sel,z);\noutput z;\ninput x,y,sel;\n\
    always @*\ncase(sel)\n\t2'b00: z=x;\n\t2'b01: z=y;\n\t2'b10: z=x;\n\t2'b11: z=y;\n\
    endcase\nendmodule\n### Testbench Code:\nmodule tb;\nwire [1:0] x,y,sel;\nwire\
    \ z;\nmux sel_mux(.x(x),.y(y),.sel(sel),.z(z));\n\nalways\n$display(\"x=%d\",x);\n\
    $display(\"y=%d\",y);\n$display(\"sel=%"
- code: |-
    module dff(do,di,clk);
    output do;
    input di,clk;
    reg do;
    always @ (posedge clk)
    begin
    case (do)
    1'b0: do = 1'b1;
    1'b1: do = di;
    endcase
    end
    endmodule
    ### Output:
    Note: I am not sure why the output of the modified code is different from the base code.
    Thanks

    ## 1 Answer

    This is the output that would be generated by the modified code:

     // Behavioral D Flip-Flop
    // output do;
    // input di,clk;
    // reg do; // Output must be reg for procedural assignment
    // initial
    // do=1'b0; // Initialize output

    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule

    // Modified Code:
    // module dff(do,di,clk);
    // output do;
    // input di,clk;
    // reg do;
    // always @ (posedge clk)
    // begin
    // case (do)
    // 1'b0: do = 1'b1;
    // 1'b1: do = di;
    // endcase
    // end
    // endmodule
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di ^ clk; // Use non-blocking <= for sequential logic
    endmodule
    ### Results:
    Now the design will be realized through a Verilog simulator.

    ## 4. Simulation:
    As we have seen in the previous section, the Verilog simulation tool is called VCS. To start the simulation, the simulator will be invoked in the command line with the following command:
    vlog -sv dff.v
    The simulator will create the necessary directory to store simulation data. After the simulation is finished, the Verilog simulator will create a file called vcd. The vcd file will include all the data about the simulation. This file can be read by the WaveDVe editor. The following is a screenshot of the WaveDVe editor:

    ## 5. Conclusion:
    In this post, we have walked through the basic Verilog simulation method in the Xilinx Virtual Platform. This method is a handy way for us to get started with the design phase. It is also highly scalable. In the next post, we will talk about the next design method where the flow is in order.
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural assignment
    initial
    do=1'b0; // Initialize output
    // Assign input 'di' to output 'do' on negative clock edge
    always@(negedge clk) do = di; // Use non-blocking <= for sequential logic
    endmodule
    The case statement can also be implemented in C style, i.e., without the need for the 'case' keyword.
    ### Base Verilog Code:
- code: |-
    module dff(do,di,clk); // Behavioral D Flip-Flop
    output do;
    input di,clk;
    reg do; // Output must be reg for procedural
- code: |-
    ```verilog
    module tst_CMOSsw1_Vary();
      // Register test variables
      reg in,con;
      // Define outputs array
      wire [7:0] outs [0:7];
      // Instantiate CMOS switch
      CMOSsw1 cmsw(outs[0],in,con);

      initial begin in=1'b0; con=1'b1; end // Start enabled

      // Always block
      always #5 in =~in;
- code: |-
    module verilog_counter(counter);
      reg [63:0] counter;
      initial counter=64;
      always counter = counter +
- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end // Start enabled
      always #5 in =~in; // Toggle data
      always #3 con=~con; // Toggle control
      (* cfunc_name_type("in") *)
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Output:
    ```
    in=0, con=1, output
- code: |-
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,con); // Instantiate CMOS switch
      initial begin in=1'b0; con=1'b1; end
      always_comb begin in =~in; // Toggle data
      always_comb begin con=~con; // Toggle control
      end
      initial $monitor($time, "in = %b, con = %b, output = %b ",in,con,out);
      initial #20 $stop; // Stop simulation
    endmodule
    ### Result:
    in = 0xf0, con = 0x00, output = 0x0f

    ##

    ## Original Code
    module tst_CMOSsw1();
      reg in,con; wire out;
      CMOSsw1 cmsw(out,in,con
- code: "module tst_CMOSsw3();\n  reg in,con; wire out;\n  CMOSsw3 cmsw(out,in,con);\
    \ // Instantiate CMOS switch\n  initial begin\n    in=1'b0; con=1'b1; end // Start\
    \ enabled\n  always #5 in =~in; // Toggle data\n  always #3 con=~con; // Toggle\
    \ control\n  initial $monitor($time, \"in = %b, con = %b, output = %b \",in,con,out);\n\
    \  initial #20 $stop; // Stop simulation\nendmodule\n### Testbench File:\nmodule\
    \ tst_CMOSsw3();\n  reg in,con; wire out;\n  CMOSsw3 cmsw(out,in,con); // Instantiate\
    \ CMOS switch\n  initial begin\n    in=1'b0; con=1'b1; end // Start enabled\n\
    \  always #5 in =~in; // Toggle data\n  always #3 con=~con; // Toggle control\n\
    \  initial $monitor($time, \"in = %b, con = %b, output = %b \",in,con,out);\n\
    \  initial #20 $stop; // Stop simulation\nendmodule\n### Results:\nin = 1, con\
    \ = 0, output = 1'b0 \nin = 0, con = 0, output = 1'b1 \nin = 0, con = 1, output\
    \ = 1'b0 \nin = 0, con = 0, output = 1'b1 \nin = 0, con = 1, output = 1'b0 \n\
    in = 0, con = 0, output = 1'b1 \nin = 0, con = 1, output = 1'b0 \nin = 0, con\
    \ = 0, output = 1'b1 \nin = 0, con = 1, output = 1'b0 \nin = 0, con = 0, output\
    \ = 1'b1 \nin = 0, con = 1, output = 1'b0 \nin = 0, con = 0, output = 1'b1 \n\
    in = 0, con = 1, output = 1'b0 \nin = 0, con = 0, output = 1'b1 \nin = 0, con\
    \ = 1, output = 1"
- code: "module selt4_top (\ninput wire [3:0] sel,\ninput wire [1:0] x,\noutput wire\
    \ [1:0] y\n);\nselt4 U1 (\n.sel(sel),\n.x(x),\n.y(y)\n);\n\n## 2.24.4.3 - Variation\
    \ 2: 4-bit selector with 16-bit index\xB6\n\n### Base Verilog Code:\n\nmodule\
    \ selt4_top (\ninput wire [3:0] sel,\ninput wire [1:0] x,\noutput wire wire [1:0]\
    \ y\n);\nselt4 U1 (\n.sel(sel),\n.x(x),\n.y(y)\n);"
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(ld[2]),
    .or4_(ld[1]),
    .xor4_(ld[0])
    );
    endmodule
    ### Results:
    After the first instruction, the value of ld [1] is now the value of sw [3]. The value of ld [2] has
    been preserved. The value of ld [0] is now the sum of the values of sw [2] and sw [1].
    0
    ld [3]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    ld [2]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    ld [1]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [3]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [2]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [1]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [0]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    0
    1
    2
    3
    sw [3]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [2]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [1]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [0]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    Results
    On the second instruction, the value of ld [1] remains the same as the value of sw [3]. The value of ld [0]
    has been preserved. The value of ld [2] is now the logical and of the values of sw [2] and sw [1].
    2
    3
    3
    3
    1
    1
    1
    1
    0
    1
    2
    3
    3
    3
    1
    1
    1
    1
    2
    2
    2
    2
    0
    1
    2
    3
    3
    3
    1
    1
    1
    1
    ld [3]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    ld [2]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    ld [1]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    ld [0]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [3]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [2]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [1]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    sw [0]
    Case
    2
    2
    2
    2
    0
    1
    2
    3
    0
    1
    2
    3
    sw [3]
- code: "module gates4_top (\ninput wire [3:0] sw,\noutput wire [2:0] ld\n);\nreg\
    \ [3:0] sel=3'b0;\nreg [3:0] m_sel = {2'b0, sel};\n// reg [2:0] m_sel = sel; //\
    \ This will cause a warning.\n\ncase (m_sel)\n\n// Case 0\n3'b000: begin\n// sel\
    \ = 0;\nend\n\n// Case 1\n3'b001: begin\n// sel = 1;\nend\n\n// Case 2\n3'b010:\
    \ begin\n// sel = 2;\nend\n\n// Anything else\ndefault: error \"invalid selection\"\
    ;\nendcase\n\ngates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs\
    \ from input 'x'\n(\n.x(sw),\n.and4_(ld[2]),\n.or4_(ld[1]),\n.xor4_(ld[0])\n);\n\
    endmodule\n### Results:\nIn this case, both the original case and the case with\
    \ the modified code are accepted by the compiler. The difference is that the first\
    \ code will produce a constant value of 3'b000 for the index used in case; while\
    \ the second code will produce a value of 2'b00 for the index used in case. This\
    \ means that in the first code, the default case for the case statement gets entered\
    \ and error is thrown. That is why the modification is required.\n\n### Note:\n\
    \u2022 In this case, the original code would have been accepted if the default\
    \ case for the case statement was kept commented out. As a result, the code would\
    \ have had an implicit default case.\n\u2022 Since the default case is a syntax\
    \ error in the case statement, it is suggested to use the default case as an empty\
    \ statement.\n\u2022 Also, the use of the default case should be noted as a place\
    \ holder only. It should not be used as a part of the case statement.\n\u2022\
    \ In general, the default case should be avoided as much as possible within a\
    \ case statement.\n\u2022 The compiler warns that a default choice may not be\
    \ executed.\n\u2022 The default case is not necessary in a MDA case statement.\n\
    \n## 3.2 Case with Mixed Selection Types\n\nThere are two different modes for\
    \ the case statement:\n\n\u2022 Unrestricted case statement\n\u2022 Restrict case\
    \ statement\n\nThe case statement has a restricted form of the case statement\
    \ where the selection value must be of the type specified in the case statement\
    \ (an enumerated type in the above example).\n\n### Sample Code:\n\nmodule gates4_top\
    \ (\noutput wire [2:0] ld\n);\n\ncase (1'd1) // If 'type' is not specified, the\
    \ selection value must be of the same type as the case statement type.\n\n// Case\
    \ 0\n1'd1: begin\nld = 0;\nend\n\n// Anything else\ndefault: error \"invalid selection\"\
    ;\nendcase\n\nendmodule\n\n### Notes:\n\n\u2022 The type of the selection value\
    \ can be either an enumerated type or a numerical type.\n\u2022 If the type is\
    \ an enumerated type, the value must be an integer constant. If the type is a\
    \ numerical type, the value must be a constant expression.\n\u2022 The compiler\
    \ warns for a value that is not an integer constant for an enumerated type. For\
    \ a numerical type, the compiler warns if the value is a non-constant expression.\n\
    \u2022 The compiler does not warn if the value is a non-constant expression for\
    \ a numerical type.\n\u2022 For an enumerated type, the value must be of a type\
    \ that is compatible with the selection type. The type compatibility is defined\
    \ in the following table:\n\nTable 1. Compatibility of the types for case statement\n\
    \nSelection Type Type A Type B Compatible\nInteger Boolean Integer Bit-vector\
    \ Bit-vector\nNon-enumerated enumerated Enumerated enumerated\nNon-enumerated\
    \ bit-vector bit-vector bit-vector\n\n\u2022 The selection value can always be\
    \ a string literal.\n\u2022 If a string literal is used in the case statement,\
    \ the value is always a string literal. For the other types, the value must be\
    \ a constant expression.\n\n### Sample Code:\n\nmodule gates4_top (\noutput wire\
    \ [2:0] ld\n);\n\ncase (\"three\") // If a string literal is used, the value is\
    \ always a string literal.\n\n// Case 0\n\"three\": begin\nld = 0;\nend\n\n//\
    \ Anything else\ndefault: error \"invalid selection\";\nendcase\n\nendmodule\n\
    \n### Notes:\n\n\u2022 A switch statement is a restricted form of the case statement.\n\
    \n## 3.3 Restricted Case\n\nIn this section, the restrict case statement is discussed.\
    \ The restriction in the case statement will prevent the user from changing the\
    \ value of the selection used to select case.\n\n### Sample Code:\n\nmodule gates4_top\
    \ (\noutput wire [2:0] ld\n);\n\ncase (1'd1) // Restrict case statement\n\n//\
    \ Case 0\n1'd1: begin\n// ld = 0; // This will cause a syntax error.\nend\n\n\
    // Anything else\ndefault: error \"invalid selection\";\nendcase\n\nendmodule\n\
    \n### Notes:\n\n\u2022 The restriction is enforced at the time of assignment.\n\
    \u2022 The same restrictions apply to the case statement that is restricted by\
    \ the restrict case statement.\n\n## 3.4 Multiple Case Statements\n\n### Sample\
    \ Code:\n\nmodule gates4_top (\noutput wire [2:0] ld\n);\ncase (1'd1)\n// Case\
    \ 0\n1'd1: begin\nld = 0;\nend\n\n// Case 1\n1'd2: begin\nld = 1;\nend\n\n// Anything\
    \ else\ndefault: error \"invalid selection\";\nendcase\n\nendmodule\n\n### Note:\n\
    \n\u2022 Several case statements can be used in a case statement.\n\u2022 The\
    \ compiler allows the use of a break statement (break;) within a case statement.\n\
    \u2022 The case statement can be terminated using endcase.\n\u2022 The case statement\
    \ terminates with endcase.\n\n## 3.5 Case with Multiple Values\n\n### Sample Code:\n\
    \nmodule gates4_top (\noutput wire [2:0] ld\n);\ncase (1'b0)\n// Case 0\n1'b0:\
    \ begin\nld = 0;\nend\n\n// Case 1\n1'b1: begin\nld = 1;\nend\n\n// Anything else\n\
    default: error \"invalid selection\";\nendcase\n\nendmodule\n\n### Notes:\n\n\u2022\
    \ The use of multiple values in the case statement is also possible.\n\u2022 A\
    \ default value is optional.\n\n## 3.6 Case with Range Value\n\n### Sample Code:\n\
    \nmodule gates4_top (\noutput wire [2:0] ld\n);\ncase (2'b00)\n// Case 0\n2'b00:\
    \ begin\nld = 0;\nend\n\n// Case 1\n2'b01: begin\nld = 1;\nend\n\n// Case 2\n\
    2'b10: begin\nld = 2;\nend\n\n// Anything else\ndefault: error \"invalid selection\"\
    ;\nendcase\n\nendmodule\n\n### Notes:\n\n\u2022 The use of a range is possible.\n\
    \u2022 The compiler warns if the value range is not integer.\n\u2022 The compiler\
    \ warns if the value range is not a range.\n\u2022 The compiler does not warn\
    \ if the value range is a range.\n\n## 3.7 Case with Multiple Range Values\n\n\
    ### Sample Code:\n\nmodule gates4_top (\noutput wire [2:0] ld\n);\ncase (2'b00|2'b10)\n\
    // Case 0\n2'b00: begin\nld = 0;\nend\n\n// Case 1\n2'b10: begin\nld = 1;\nend\n\
    \n// Anything else\ndefault: error \"invalid selection\";\nendcase\n\nendmodule\n\
    \n### Notes:\n\n\u2022 The use of a range is possible.\n\u2022 The case statement\
    \ can be terminated with endcase.\n\u2022 The case with multiple range values\
    \ is called an inclusive case.\n\n## 3.8 Case with Range Value Mixed with the\
    \ Use of Default Case\n\n### Sample Code:\n\nmodule gates4_top (\noutput wire\
    \ [2:0] ld\n);\ncase (2'b00|2'b10)\n\n// Case 1\n2'b01: begin\nld = 1;\nend\n\n\
    // Case 2\n2'b11: begin\nld = 2;\nend\n\n// Anything else\ndefault: error \"invalid\
    \ selection\";\nendcase\n\nendmodule\n\n### Notes:\n\n\u2022 The use of a range\
    \ is possible.\n\u2022 The default case is optional.\n\u2022 The compiler warns\
    \ if the range value is not integer.\n\u2022 The compiler warns"
- code: |-
    module demux4_top (
    input wire a,
    input wire [3:0] sel,
    input wire [2:0] b,
    output wire c
    );
    case (sel)
    4'd4: c[2] = sel[2];
    default: c[2] = b[2];
    3'd3: c[1] = sel[1];
    default: c[1] = b[1];
    2'd2: c[0] = sel[0];
    default: c[0] = b[0];
    endcase // Priority Case
    endmodule

    ## Example 8: Adder with Single-Cycle

    ### Base Verilog Code:
    module adder4_top(
    input wire [4:0] a,
    input wire [4:0] b,
    output wire [8:0] s
    );
    xor4 out0(
    .a(a[4]),
    .b(a[3]),
    .out(s[7])
    );
    xor4 out1(
    .a(a[4]),
    .b(a[2]),
    .out(s[6])
    );
    xor4 out2(
    .a(a[4]),
    .b(a[1]),
    .out(s[5])
    );
    xor4 out3(
    .a(a[4]),
    .b(a[0]),
    .out(s[4])
    );
    and4 in0(
    .x(b[4]),
    .y(b[3]),
    .z(b[2]),
    .out(s[3])
    );
    and4 in1(
    .x(b[4]),
    .y(b[3]),
    .z(b[1]),
    .out(s[2])
    );
    and4 in2(
    .x(
- code: |-
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] ld
    );

    case (sw)
    3'bi000: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    3'bi001: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    // 3'bi010: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    3'bi011: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    // 3'bi100: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    3'bi101: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    // 3'bi110: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    3'bi111: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    default: ld = {and4_, or4_, xor4_}; // Apply 'and4_', 'or4_' and 'xor4_' in order
    endcase

    endmodule
    ### Generated Verilog Code:
    module gates4_top (
    input wire [3:0] sw,
    output wire [2:0] md
    );

    // Wire declarations
    wire [2:0] md;

    // Module instantiations
    gates4 U1 // Assuming 'gates4' provides and4_, or4_, xor4_ outputs from input 'x'
    (
    .x(sw),
    .and4_(md[2]),
    .or4_(md[1]),
    .xor4_(md[0])
    );

    endmodule

    # Simulation

    ### Waveform

    We can see that the first operand is getting applied first and the third operand gets applied when the second operand is high; the second operand is high at the start and then it gets low at 16k cycles, as the first operand is still getting applied.

    If we check the output value, the first operand is getting applied first and the third operand gets applied when the second operand is high; the output gets applied when the second operand is high and then its value goes low when the third operand is low.

    # Summary

    This post is a follow-up to the previous post in this series. We will see in this post how to perform variable-length case using constant value index.

    You may refer to this post to learn about the synthesis and implementation of variable-length case statements.
